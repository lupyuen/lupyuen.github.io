# LoRa SX1262 on Apache NuttX OS

ðŸ“ _22 Dec 2021_

![PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)... Sniffed wirelessly with Airspy R2 Software Defined Radio (right)](https://lupyuen.github.io/images/sx1262-title.jpg)

_PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)... Sniffed wirelessly with Airspy R2 Software Defined Radio (right)_

__LoRa__ is an awesome wireless technology for IoT that will transmit __small packets over super long distances__...

[(Up to 5 km or 3 miles in urban areas... 15 km or 10 miles in rural areas!)](https://lora-developers.semtech.com/documentation/tech-papers-and-guides/lora-and-lorawan/)

Let's port LoRa to [__Apache NuttX OS!__](https://lupyuen.github.io/articles/nuttx)

[(More about LoRa)](https://makezine.com/2021/05/24/go-long-with-lora-radio/)

_Doesn't NuttX support LoRa already?_

Yep NuttX has a standalone LoRa Driver for __Semtech SX1276 Transceiver__ (Radio Transmitter + Receiver)...

-   [__NuttX SX127x Driver__](https://github.com/apache/nuttx/tree/master/drivers/wireless/lpwan/sx127x)

-   [__NuttX SX127x Demo__](https://github.com/apache/nuttx-apps/tree/master/examples/sx127x_demo)

(That doesn't work with LoRaWAN yet)

Today we build a NuttX Driver for the (newer) [__Semtech SX1262 Transceiver__](https://www.semtech.com/products/wireless-rf/lora-core/sx1262)...

-   [__SX1262 Library__](https://github.com/lupyuen/lora-sx1262/tree/lorawan)

-   [__SX1262 Test App__](https://github.com/lupyuen/nuttx-apps/tree/master/examples/sx1262_test)

Our LoRa SX1262 Driver shall be tested on Bouffalo Lab's [__BL602 and BL604 RISC-V SoCs__](https://lupyuen.github.io/articles/pinecone).

(It will probably run on __ESP32__, since we're calling standard NuttX Interfaces)

Eventually our LoRa SX1262 Driver will support the __LoRaWAN Wireless Protocol__.

_How useful is LoRaWAN? Will we be using it?_

Our LoRa SX1262 Driver will work perfectly fine for unsecured __Point-to-Point Wireless Communication__.

But if we need to __relay data packets__ securely to a Local Area Network or to the internet, we need __LoRaWAN__.

[(More about LoRaWAN)](https://makezine.com/2021/05/24/go-long-with-lora-radio/)

# Small Steps

_So today we'll build the NuttX Drivers for LoRa SX1262 and LoRaWAN?_

Not quite. Implementing LoRa AND LoRaWAN is a complex endeavour.

Thus we break the implementation into small steps...

-   Today we do the __SX1262 Library__ (top right)

-   And we test with our __LoRa App__ (top left)

![Porting LoRaWAN to NuttX OS](https://lupyuen.github.io/images/sx1262-library.jpg)

-   In the next article we'll do the __LoRaWAN Library__ and test with our __LoRaWAN App__

-   Eventually we shall wrap the SX1262 and LoRaWAN Libraries as __NuttX Drivers__

    (Because that's the proper design for NuttX)

## LoRaWAN Support

_Why is LoRaWAN so complex?_

LoRaWAN works __slightly differently across the world regions__, to comply with Local Wireless Regulations: Radio Frequency, Maximum Airtime (Duty Cycle), [Listen Before Talk](https://lupyuen.github.io/articles/lorawan#appendix-lora-carrier-sensing), ...

Thus we should port __Semtech's LoRaWAN Stack__ to NuttX with __minimal changes__, in case of future updates. (Like for new regions)

This also means that we should port __Semtech's SX1262 Driver__ to NuttX as-is, because of the dependencies between the LoRaWAN Stack and the SX1262 Driver.

## LoRa SX1262 Library

_Where did the LoRa SX1262 code come from?_

Our LoRa SX1262 Library originated from __Semtech's Reference Implementation__ of SX1262 Driver (29 Mar 2021)...

-   [__LoRaMac-node/radio/sx126x__](https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x)

Which we ported to __Linux__ and __BL602 IoT SDK__...

-   [__lupyuen/lora-sx1262 (lorawan branch)__](https://github.com/lupyuen/lora-sx1262/tree/lorawan)

And we're porting now to __NuttX__.

(Because porting Linux code to NuttX is straightforward)

_How did we create the LoRa SX1262 Library?_

We followed the steps below to create __"nuttx/libs/libsx1262"__ by cloning a NuttX Library...

-   [__"Create a NuttX Library"__](https://lupyuen.github.io/articles/sx1262#appendix-create-a-nuttx-library)

Then we replaced the "libsx1262" folder by a __Git Submodule__ that contains our LoRa SX1262 code... 

```bash
cd nuttx/nuttx/libs
rm -r libsx1262
git rm -r libsx1262
git submodule add --branch nuttx https://github.com/lupyuen/lora-sx1262 libsx1262
```

Note that we're using the older __"nuttx"__ branch of the "lora_sx1262" repo, which [__doesn't use GPIO Interface and NimBLE Porting Layer__](https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library). (And doesn't support LoRaWAN)

## Library vs Driver

_NuttX Libraries vs Drivers... What's the difference?_

Our LoRa SX1262 code is initially packaged as a __NuttX Library__ (instead of NuttX Driver) because...

-   NuttX Libraries are __easier to code and troubleshoot__

-   NuttX Libraries may be called by __NuttX Apps AND NuttX Drivers__

    (So we can test our library with a NuttX App)

Eventually our LoRa SX1262 code shall be packaged as a __NuttX Driver__...

-   Our code shall run inside NuttX OS, which means...

-   Our driver needs to expose an __ioctl()__ interface to NuttX Apps

    (Which will be cumbersome to code)

Check out the __ioctl()__ interface for the existing SX1276 Driver in NuttX: [__sx127x.c__](https://github.com/apache/nuttx/blob/master/drivers/wireless/lpwan/sx127x/sx127x.c#L954-L1162)

![SPI Test Driver](https://lupyuen.github.io/images/spi2-plan2.jpg)

_But how will our library access the NuttX SPI Interface?_

The NuttX SPI Interface is accessible by NuttX Drivers, but not NuttX Apps.

Thankfully in the previous article we have created an __SPI Test Driver "/dev/spitest0"__ that exposes the SPI Interface to NuttX Apps (pic above)...

-   [__"SPI on Apache NuttX OS"__](https://lupyuen.github.io/articles/spi2)

For now we'll call this SPI Test Driver in our LoRa SX1262 Library.

![Inside PineDio Stack BL604](https://lupyuen.github.io/images/spi2-pinedio1.jpg)

# Connect SX1262 Transceiver

Our code has been configured for [__PineDio Stack BL604__](https://lupyuen.github.io/articles/pinedio2) and its onboard SX1262 Transceiver. (Pic above)

Based on this schematic for PineDio Stack BL604 (version 2)...

> ![SX1262 Interface on PineDio Stack](https://lupyuen.github.io/images/spi2-pinedio3.png)

We have configured the following __BL604 Pin Definitions__ in [board.h](https://github.com/lupyuen/nuttx/blob/sx1262/boards/risc-v/bl602/bl602evb/include/board.h#L42-L95)

SX1262 | BL604 Pin | NuttX Pin
:-------: | :---------: | :---------
__MOSI__ | GPIO 13 | BOARD_SPI_MOSI
__MISO__ | GPIO 0  | BOARD_SPI_MISO
__SCK__  | GPIO 11 | BOARD_SPI_CLK
__CS__   | GPIO 15 | BOARD_GPIO_OUT1
__BUSY__ | GPIO 10 | BOARD_GPIO_IN1
__DIO1__ | GPIO 19 | BOARD_GPIO_INT1
__NRESET__ | GPIO 18 | Not assigned yet

```c
/* Busy Pin for PineDio SX1262 */

#define BOARD_GPIO_IN1    (GPIO_INPUT | GPIO_FLOAT | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN10)

/* SPI Chip Select for PineDio SX1262 */

#define BOARD_GPIO_OUT1   (GPIO_OUTPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN15)

/* GPIO Interrupt (DIO1) for PineDio SX1262 */

#define BOARD_GPIO_INT1   (GPIO_INPUT | GPIO_PULLUP | \
                            GPIO_FUNC_SWGPIO | GPIO_PIN19)

/* SPI Configuration: Chip Select is unused because we control via GPIO instead */

#define BOARD_SPI_CS   (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN8)  /* Unused */
#define BOARD_SPI_MOSI (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN13)
#define BOARD_SPI_MISO (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN0)
#define BOARD_SPI_CLK  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_SPI | GPIO_PIN11)
```

[(Which pins can be used? See this)](https://lupyuen.github.io/articles/expander#pin-functions)

GPIO Output __BOARD_GPIO_OUT1__ becomes our __SPI Chip Select__. [(See this)](https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio)

__BOARD_GPIO_IN1__ (Busy Pin) and __BOARD_GPIO_INT1__ (DIO1) will be used for LoRaWAN in the next article.

__For BL602:__ Connect SX1262 to [these pins](https://lupyuen.github.io/articles/spi2#connect-sx1262). Copy the BL602 Pin Definitions from [board.h](https://github.com/lupyuen/nuttx/blob/spi_test/boards/risc-v/bl602/bl602evb/include/board.h#L36-L92) to...

```text
boards/risc-v/bl602/bl602evb/include/board.h
```

__For ESP32:__ Connect SX1262 to [these pins](https://lupyuen.github.io/articles/spi2#connect-sx1262)

Before testing, remember to connect the __LoRa Antenna__... 

(So we don't fry the SX1262 Transceiver as we charge up the Power Amplifier)

![PineDio Stack BL604 with Antenna](https://lupyuen.github.io/images/spi2-pinedio10a.jpg)

_What are these SX1262 pins: DIO1, BUSY and NRESET?_

__DIO1__ is used by SX1262 to signal that a LoRa Packet has been received.

__BUSY__ is tells us if SX1262 is busy.

__NRESET__ is toggled to reset the SX1262 module.

Although our SX1262 Library doesn't use these pins, it works somewhat OK for sending and receiving LoRa Messages.

(We'll learn why in a while)

![Reading SX1262 Registers](https://lupyuen.github.io/images/sx1262-read2.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171)

# Read SX1262 Registers

_What's the simplest way to test our SX1262 Library?_

To test whether our SX1262 Library is sending SPI Commands correctly to the SX1262 Transceiver, we can read the __SX1262 Registers__.

Here's how: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L155-L171)

```c
/// Main Function
int main(int argc, FAR char *argv[]) {
  //  Read SX1262 registers 0x00 to 0x0F
  read_registers();
  return 0;
}

/// Read SX1262 registers
static void read_registers(void) {
  //  Init the SPI port
  SX126xIoInit();

  //  Read and print the first 16 registers: 0 to 15
  for (uint16_t addr = 0; addr < 0x10; addr++) {
    //  Read the register
    uint8_t val = SX126xReadRegister(addr);

    //  Print the register value
    printf("Register 0x%02x = 0x%02x\n", addr, val);
  }
}
```

[(__SX126xIoInit__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94)

In our Test App we call __read_registers__ and __SX126xReadRegister__ to read a bunch of SX1262 Registers. (`0x00` to `0x0F`)

In our SX1262 Library, __SX126xReadRegister__ calls __SX126xReadRegisters__ and __sx126x_read_register__ to read each register: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L286-L299)

```c
/// Read an SX1262 Register at the specified address
uint8_t SX126xReadRegister(uint16_t address) {
  //  Read one register and return the value
  uint8_t data;
  SX126xReadRegisters(address, &data, 1);
  return data;
}

/// Read one or more SX1262 Registers at the specified address.
/// `size` is the number of registers to read.
void SX126xReadRegisters(uint16_t address, uint8_t *buffer, uint16_t size) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady();

  //  Read the SX1262 registers
  int rc = sx126x_read_register(NULL, address, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy();
}
```

(We'll see __SX126xCheckDeviceReady__ and __SX126xWaitOnBusy__ in a while)

__sx126x_read_register__ reads a register by sending the Read Register Command to SX1262 over SPI: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L556-L565)

```c
/// Send a Read Register Command to SX1262 over SPI
/// and return the results in `buffer`. `size` is the
/// number of registers to read.
static int sx126x_read_register(const void* context, const uint16_t address, uint8_t* buffer, const uint8_t size) {
  //  Reserve 4 bytes for our SX1262 Command Buffer
  uint8_t buf[SX126X_SIZE_READ_REGISTER] = { 0 };

  //  Init the SX1262 Command Buffer
  buf[0] = RADIO_READ_REGISTER;       //  Command ID (0x1D)
  buf[1] = (uint8_t) (address >> 8);  //  MSB of Register ID
  buf[2] = (uint8_t) (address >> 0);  //  LSB of Register ID
  buf[3] = 0;                         //  Unused

  //  Transmit the Command Buffer over SPI 
  //  and receive the Result Buffer
  int status = sx126x_hal_read( 
    context,  //  Context (unsued)
    buf,      //  Command Buffer
    SX126X_SIZE_READ_REGISTER,  //  Command Buffer Size: 4 bytes
    buffer,   //  Result Buffer
    size,     //  Result Buffer Size
    NULL      //  Status not required
  );
  return status;
}
```

(More about __sx126x_hal_read__ later)

This transmits the following __Read Register Command__ to SX1262...

```text
1d 00 08 00 00 
```

(`0x1D` is the Command ID, `0x08` is the Register ID)

SX1262 responds with...

```text
a2 a2 a2 a2 80 
```

The last byte is the __Register Value__: `0x80`

## Build the Firmware

Let's build the modified NuttX Firmware that contains our __LoRa SX1262 Library and Test App__...

1.  Install the build prerequisites...

    [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

1.  Download the modified source code...

    ```bash
    mkdir nuttx
    cd nuttx
    git clone --recursive --branch sx1262 https://github.com/lupyuen/nuttx nuttx
    git clone --recursive --branch sx1262 https://github.com/lupyuen/nuttx-apps apps
    ```

    Note that we're using the older __"sx1262"__ branches of the NuttX OS and NuttX Apps repos, which [__don't use GPIO Interface and NimBLE Porting Layer__](https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library). (And don't support LoRaWAN)

    [(__For PineDio Stack BL604:__ The SX1262 Library and Test App are already preinstalled)](https://lupyuen.github.io/articles/pinedio2#appendix-bundled-features)

1.  Edit [__apps/examples/sx1262_test_main.c__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L100-L101) and uncomment...

    ```c
    #define READ_REGISTERS
    ```

1.  Configure the build...

    ```bash
    cd nuttx

    ## For BL602: Configure the build for BL602
    ./tools/configure.sh bl602evb:nsh

    ## For PineDio Stack BL604: Configure the build for BL604
    ./tools/configure.sh bl602evb:pinedio

    ## For ESP32: Configure the build for ESP32.
    ## TODO: Change "esp32-devkitc" to our ESP32 board.
    ./tools/configure.sh esp32-devkitc:nsh

    ## Edit the Build Config
    make menuconfig 
    ```

1.  Enable the __GPIO Driver__ in menuconfig...

    [__"Enable GPIO Driver"__](https://lupyuen.github.io/articles/nuttx#enable-gpio-driver)

    ![Enable the GPIO Driver](https://lupyuen.github.io/images/nuttx-menu7a.png)

1.  Enable the __SPI Peripheral__ and __SPI Character Driver__...

    [__"Enable SPI"__](https://lupyuen.github.io/articles/spi2#enable-spi)

    ![Enable SPI](https://lupyuen.github.io/images/spi2-debug.jpg)

1.  Enable our __SPI Test Driver__ "/dev/spitest0"...

    [__"Enable SPI"__](https://lupyuen.github.io/articles/spi2#enable-spi)

    ![Select SPI Test Driver](https://lupyuen.github.io/images/spi2-newdriver6.png)

1.  Enable __GPIO and SPI Logging__ for easier troubleshooting...

    (Might be good to uncheck __"GPIO Informational Output"__ and __"SPI Informational Output"__)

    [__"Enable Logging"__](https://lupyuen.github.io/articles/spi2#enable-logging)

    ![Enable Logging](https://lupyuen.github.io/images/spi2-driver4.png)

1.  Enable our __SX1262 Library__...

    [__"Enable Library"__](https://lupyuen.github.io/articles/sx1262#enable-library)

    ![Enable Library](https://lupyuen.github.io/images/sx1262-clone7.png)

1.  Enable our __SX1262 Test App__...

    Check the box for __"Application Configuration"__ â†’ __"Examples"__ â†’ __"SX1262 Test"__

    ![Enable SX1262 Test App](https://lupyuen.github.io/images/sx1262-clone8.png)

1.  Save the configuration and exit menuconfig

    [(Here's the .config for BL602)](https://gist.github.com/lupyuen/ec97cff54064c9f9d7d1c700c035b777)

1.  __For ESP32:__ Edit [__esp32_bringup.c__](https://github.com/lupyuen/nuttx/blob/spi_test/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c#L118-L426) to register our SPI Test Driver [(See this)](https://lupyuen.github.io/articles/spi2#register-device-driver)

1.  Build, flash and run the NuttX Firmware on BL602 or ESP32...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx)

## Run the Firmware

Finally we run the NuttX Firmware and test our __LoRa SX1262 Library__...

1.  In the NuttX Shell, enter...

    ```bash
    ls /dev
    ```

    Our SPI Test Driver should appear as __"/dev/spitest0"__
    
    ![Our SPI Test Driver appears as "/dev/spitest0"](https://lupyuen.github.io/images/spi2-newdriver10.png)

1.  In the NuttX Shell, enter...

    ```bash
    sx1262_test
    ```

1.  We should see these __SX1262 Register Values__ (pic below)...

    ```text
    Register 0x00 = 0x00
    ...
    Register 0x08 = 0x80
    Register 0x09 = 0x00
    Register 0x0a = 0x01
    ```

    [(See the Output Log)](https://gist.github.com/lupyuen/1e732f5b1e0e4a80d1eb351ab3aadede)

    Our LoRa SX1262 Library talks OK to the SX1262 Transceiver!

    Note that the values above will change when we __transmit and receive LoRa Messages__. Let's do that now.

![Reading SX1262 Registers](https://lupyuen.github.io/images/sx1262-read5.jpg)

## Source Files

_We're seeing layers of code, like an onion? (Or Shrek)_

Yep our SX1262 Library is structured as __layers of Source Files__ because we hope to support three platforms...

1.  __NuttX__ (Just Completed)

1.  [__Linux__](https://lupyuen.github.io/articles/usb) (Completed: PineDio USB)

1.  [__BL602 IoT SDK__](https://lupyuen.github.io/articles/lorawan) (Completed)

The __Platform-Independent__ Source Files shared by all platforms are...

-   [__src/sx126x.c__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c)

    (Semtech's Driver for SX1262 Transceiver)

-   [__src/radio.c__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c)

    (Semtech's Radio Interface for LoRa Transceivers)

(We should minimise changes to the above files, because they will be called by Semtech's LoRaWAN Driver)

The __Platform-Specific__ Source Files for NuttX are...

-   [__src/sx126x-nuttx.c__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c)

    (NuttX Interface for SX1262)

The Source Files are called like this...

__Test App__ â†’ __radio.c__ â†’ __sx126x.c__ â†’ __sx126x-nuttx.c__

# LoRa Parameters

Before we transmit and receive LoRa Messages, let's talk about the __LoRa Parameters__.

Check this doc to find out which __LoRa Frequency__ we should use for our region...

-  [__LoRa Frequencies by Country__](https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html)

We set the __LoRa Frequency__ in our SX1262 Test App like so: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L45)

```c
/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923
```

Change __USE_BAND_923__ to __USE_BAND_433__, __780__, __868__ or __915__.

[(See the complete list)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L33-L45)

Below are the other __LoRa Parameters__: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L47-L66)

```c
/// LoRa Parameters
#define LORAPING_TX_OUTPUT_POWER            14        /* dBm */

#define LORAPING_BANDWIDTH                  0         /* [0: 125 kHz, */
                                                      /*  1: 250 kHz, */
                                                      /*  2: 500 kHz, */
                                                      /*  3: Reserved] */
#define LORAPING_SPREADING_FACTOR           7         /* [SF7..SF12] */
#define LORAPING_CODINGRATE                 1         /* [1: 4/5, */
                                                      /*  2: 4/6, */
                                                      /*  3: 4/7, */
                                                      /*  4: 4/8] */
#define LORAPING_PREAMBLE_LENGTH            8         /* Same for Tx and Rx */
#define LORAPING_SYMBOL_TIMEOUT             5         /* Symbols */
#define LORAPING_FIX_LENGTH_PAYLOAD_ON      false
#define LORAPING_IQ_INVERSION_ON            false

#define LORAPING_TX_TIMEOUT_MS              3000    /* ms */
#define LORAPING_RX_TIMEOUT_MS              10000    /* ms */
#define LORAPING_BUFFER_SIZE                64      /* LoRa message size */
```

[(More about LoRa Parameters)](https://www.thethingsnetwork.org/docs/lorawan/spreading-factors/)

During testing, these should __match the LoRa Parameters__ used by the LoRa Transmitter / Receiver.

In a while we'll use [__RAKwireless WisBlock__](https://lupyuen.github.io/articles/wisblock) (pic below) to test our SX1262 Library. 

Below are the __LoRa Transmitter and Receiver__ programs (Arduino) that we'll run on WisBlock...

-   [__wisblock-lora-transmitter__](https://github.com/lupyuen/wisblock-lora-transmitter)

    [(LoRa Parameters for Transmitter)](https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54)

-   [__wisblock-lora-receiver__](https://github.com/lupyuen/wisblock-lora-receiver)

    [(LoRa Parameters for Receiver)](https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56)

The LoRa Parameters above should match the ones in our SX1262 Test App for NuttX.

_Are there practical limits on the LoRa Parameters?_

Yes we need to comply with the __Local Regulations__ on the usage of [__ISM Radio Bands__](https://en.wikipedia.org/wiki/ISM_radio_band): FCC, ETSI, ...

-   [__"Regional Parameters"__](https://www.thethingsnetwork.org/docs/lorawan/regional-parameters/)

(Blasting LoRa Messages non-stop is no-no!)

![RAKwireless WisBlock LPWAN Module mounted on WisBlock Base Board](https://lupyuen.github.io/images/wisblock-title.jpg)

## Initialise LoRa SX1262

Let's watch how the LoRa Parameters are used to __initialise the SX1262 Transceiver__.

The __init_driver__ function in our Test App takes the LoRa Parameters and initialises LoRa SX1262 like so: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227)

```c
/// Command to initialise the LoRa Driver.
/// Assume that create_task has been called to init the Event Queue.
static void init_driver(char *buf, int len, int argc, char **argv) {
  //  Set the LoRa Callback Functions
  RadioEvents_t radio_events;
  memset(&radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
  radio_events.TxDone    = on_tx_done;     //  Packet has been transmitted
  radio_events.RxDone    = on_rx_done;     //  Packet has been received
  radio_events.TxTimeout = on_tx_timeout;  //  Transmit Timeout
  radio_events.RxTimeout = on_rx_timeout;  //  Receive Timeout
  radio_events.RxError   = on_rx_error;    //  Receive Error
```

Here we set the __Callback Functions__ that will be called when a LoRa Message has been transmitted or received, also when we encounter a transmit / receive timeout or error.

(We'll see the Callback Functions in a while)

Next we call our SX1262 Library to initialise the LoRa Transceiver and set the __LoRa Frequency__...

```c
  //  Init the SPI Port and the LoRa Transceiver
  Radio.Init(&radio_events);

  //  Set the LoRa Frequency
  Radio.SetChannel(RF_FREQUENCY);
```

Then we set the __LoRa Transmit Parameters__...

```c
  //  Configure the LoRa Transceiver for transmitting messages
  Radio.SetTxConfig(
    MODEM_LORA,
    LORAPING_TX_OUTPUT_POWER,
    0,        //  Frequency deviation: Unused with LoRa
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    LORAPING_TX_TIMEOUT_MS
  );
```

Finally we set the __LoRa Receive Parameters__...

```c
  //  Configure the LoRa Transceiver for receiving messages
  Radio.SetRxConfig(
    MODEM_LORA,
    LORAPING_BANDWIDTH,
    LORAPING_SPREADING_FACTOR,
    LORAPING_CODINGRATE,
    0,        //  AFC bandwidth: Unused with LoRa
    LORAPING_PREAMBLE_LENGTH,
    LORAPING_SYMBOL_TIMEOUT,
    LORAPING_FIX_LENGTH_PAYLOAD_ON,
    0,        //  Fixed payload length: N/A
    true,     //  CRC enabled
    0,        //  Frequency hopping disabled
    0,        //  Hop period: N/A
    LORAPING_IQ_INVERSION_ON,
    true      //  Continuous receive mode
  );    
}
```

The __Radio__ functions are Platform-Independent, defined in our SX1262 Library: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c)

-   [__RadioInit:__](https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module) Init LoRa SX1262

    [(__RadioInit__ is explained here)](https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module)

-   [__RadioSetChannel:__](https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency) Set LoRa Frequency

    [(__RadioSetChannel__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiosetchannel-set-lora-frequency)

-   [__RadioSetTxConfig:__](https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration) Set LoRa Transmit Configuration

    [(__RadioSetTxConfig__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiosettxconfig-set-transmit-configuration)

-   [__RadioSetRxConfig:__](https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration) Set LoRa Receive Configuration

    [(__RadioSetRxConfig__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiosetrxconfig-set-receive-configuration)

(The __Radio__ functions will also be called when we implement LoRaWAN)

![Transmitting a LoRa Message](https://lupyuen.github.io/images/sx1262-send.jpg)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253)

# Transmit LoRa Message

Now we're ready to __transmit a LoRa Message__ in our SX1262 Test App! Here's how: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L110-L121)

```c
/// Main Function
int main(void) {
  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);

  //  Send a LoRa message
  send_message();
  return 0;
}
```

We begin by calling __init_driver__ in our Test App to set the LoRa Parameters and the Callback Functions.

(We've seen __init_driver__ in the previous section)

To transmit a LoRa Message, __send_message__ calls __send_once__: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L229-L235)

```c
/// Send a LoRa message. Assume that SX1262 driver has been initialised.
static void send_message(void) {
  //  Send the "PING" message
  send_once(1);
}
```

__send_once__ prepares a 64-byte LoRa Message containing the string "`PING`": [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253)

```c
/// We send a "PING" message and expect a "PONG" response
const uint8_t loraping_ping_msg[] = "PING";
const uint8_t loraping_pong_msg[] = "PONG";

/// 64-byte buffer for our LoRa message
static uint8_t loraping_buffer[LORAPING_BUFFER_SIZE];

/// Send a LoRa message. If is_ping is 0, send "PONG". Otherwise send "PING".
static void send_once(int is_ping) {
  //  Copy the "PING" or "PONG" message 
  //  to the transmit buffer
  if (is_ping) {
    memcpy(loraping_buffer, loraping_ping_msg, 4);
  } else {
    memcpy(loraping_buffer, loraping_pong_msg, 4);
  }
```

Then we __pad the 64-byte message__ with values 0, 1, 2, ...

```c
  //  Fill up the remaining space in the 
  //  transmit buffer (64 bytes) with values 
  //  0, 1, 2, ...
  for (int i = 4; i < sizeof loraping_buffer; i++) {
    loraping_buffer[i] = i - 4;
  }
```

And we call our SX1262 Library to __transmit the LoRa Message__...

```c
  //  We send the transmit buffer (64 bytes)
  Radio.Send(loraping_buffer, sizeof loraping_buffer);
}
```

[(__RadioSend__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message)

When the LoRa Message has been transmitted, the SX1262 Library calls our Callback Function __on_tx_done__ defined in [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L267-L280)

```c
/// Callback Function that is called when our LoRa message has been transmitted
static void on_tx_done(void) {
  //  Log the success status
  loraping_stats.tx_success++;

  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();
}
```

[(__RadioSleep__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiosleep-switch-to-sleep-mode)

Here we log the number of packets transmitted, and put LoRa SX1262 into __low power, sleep mode__.

Note: __on_tx_done__ won't actually be called in our current driver, because we haven't implemented Multithreading. (More about this later)

To handle Transmit Timeout Errors, we define the Callback Function __on_tx_timeout__: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L314-L326)

```c
/// Callback Function that is called when our LoRa message couldn't be transmitted due to timeout
static void on_tx_timeout(void) {
  //  Switch the LoRa Transceiver to 
  //  low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.tx_timeout++;
}
```

## Run the Firmware

Let's test our SX1262 Library and __transmit a LoRa Message__...

1.  Assume that we have downloaded and configured our NuttX code...

    [__"Build the Firmware"__](https://lupyuen.github.io/articles/sx1262#build-the-firmware)

1.  Edit [__apps/examples/sx1262_test_main.c__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L116-L117) and uncomment...

    ```c
    #define SEND_MESSAGE
    ```

1.  Also edit [__sx1262_test_main.c__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66) and set the __LoRa Parameters__. (As explained earlier)

1.  Build, flash and run the NuttX Firmware on BL602 or ESP32...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx)

1.  Switch over to __RAKwireless WisBlock__ and run our __LoRa Receiver__...

    [__wisblock-lora-receiver__](https://github.com/lupyuen/wisblock-lora-receiver)

    Check that the __LoRa Parameters__ are correct...

    [__LoRa Parameters for WisBlock Receiver__](https://github.com/lupyuen/wisblock-lora-receiver/blob/main/src/main.cpp#L37-L56)

1.  In the NuttX Shell, enter...

    ```bash
    sx1262_test
    ```

1.  We should see our SX1262 Library transmitting a 64-byte __LoRa Message__...

    ```text
    send_message
    RadioSend: size=64
    50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
    ```

    [("`PING`" followed by 0, 1, 2, ...)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253)

    [(See the Output Log)](https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668)

1.  On WisBlock we should see the same 64-byte __LoRa Message__ received by WisBlock...

    ```text
    LoRaP2P Rx Test
    Starting Radio.Rx
    OnRxDone: Timestamp=18, RssiValue=-28 dBm, SnrValue=13, 
    Data=50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
    ```

    Our SX1262 Library has successfully transmitted a 64-byte LoRa Message to RAKwireless WisBlock!

![Our SX1262 Library transmits a LoRa Message to RAKwireless WisBlock](https://lupyuen.github.io/images/sx1262-send2.jpg)

In case of problems, try troubleshooting with a Software Defined Radio like Airspy R2...

![PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)... Sniffed wirelessly with Airspy R2 Software Defined Radio (right)](https://lupyuen.github.io/images/sx1262-title.jpg)

## Spectrum Analysis with SDR

_What if nothing appears in our LoRa Receiver?_

Use a __Spectrum Analyser__ (like a __Software Defined Radio__) to sniff the airwaves and check whether our LoRa Message is transmitted...

1.  At the right __Radio Frequency__

    (923 MHz below)

1.  With __sufficient power__

    (Red stripe below)

![Spectrum Analysis of LoRa Message with SDR](https://lupyuen.github.io/images/sx1262-sdr.jpg)

LoRa Messages have a characteristic criss-cross shape: __LoRa Chirp__. (Like above)

More about LoRa Chirps and Software Defined Radio...

-   [__"Visualise LoRa with Software Defined Radio"__](https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio)

![Receiving a LoRa Message](https://lupyuen.github.io/images/sx1262-receive.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L262)

# Receive LoRa Message

Watch the (turn)tables turn as we __receive a LoRa Message__ with our SX1262 Library! This is how we do it: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L107-L137)

```c
/// Main Function
int main(void) {
  //  TODO: Create a Background Thread 
  //  to handle LoRa Events
  create_task();
```

We start by creating a __Background Thread__ to handle LoRa Events in our Test App.

(__create_task__ doesn't do anything because we haven't implemented Multithreading. More about this later)

Next we set the __LoRa Parameters__ and the __Callback Functions__...

```c
  //  Init SX1262 driver
  init_driver();

  //  TODO: Do we need to wait?
  sleep(1);
```

(Yep the same __init_driver__ we've seen earlier)

For the next __10 seconds__ we poll and handle LoRa Events (like Message Received)...

```c
  //  Handle LoRa events for the next 10 seconds
  for (int i = 0; i < 10; i++) {
    //  Prepare to receive a LoRa message
    receive_message();

    //  Process the received LoRa message, if any
    RadioOnDioIrq(NULL);
    
    //  Sleep for 1 second
    usleep(1000 * 1000);
  }
  return 0;
}
```

(Polling isn't efficient, we'll discuss the enhancements later)

We call __receive_message__ to get SX1262 ready to receive a single LoRa Message.

Then we call __RadioOnDioIrq__ (from our SX1262 Library) to handle the Message Received Event. (If any)

[(__RadioOnDioIrq__ is explained here)](https://lupyuen.github.io/articles/sx1262#radioondioirq)

__receive_message__ is defined in our Test App: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L255-L262)

```c
/// Receive a LoRa message. Assume that SX1262 driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(void) {
  //  Receive a LoRa message within the timeout period
  Radio.Rx(LORAPING_RX_TIMEOUT_MS);
}
```

This code calls __RadioRx__ (from our SX1262 Library) to prep SX1262 to receive a single LoRa Message.

[(__RadioRx__ is explained here)](https://lupyuen.github.io/articles/sx1262#radiorx-receive-message)

When our SX1262 Library receives a LoRa Message, it calls our Callback Function __on_rx_done__ defined in our Test App: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L282-L312)

```c
/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
  uint8_t *payload,  //  Buffer containing received LoRa message
  uint16_t size,     //  Size of the LoRa message
  int16_t rssi,      //  Signal strength
  int8_t snr) {      //  Signal To Noise ratio

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the signal strength, signal to noise ratio
  loraping_rxinfo_rxed(rssi, snr);
```

__on_rx_done__ switches the LoRa Transceiver to low power, sleep mode and logs the received packet.

Next we __copy the received packet__ into a buffer...

```c
  //  Copy the received packet
  if (size > sizeof loraping_buffer) {
    size = sizeof loraping_buffer;
  }
  loraping_rx_size = size;
  memcpy(loraping_buffer, payload, size);
```

Finally we __dump the buffer__ containing the received packet...

```c
  //  Dump the contents of the received packet
  for (int i = 0; i < loraping_rx_size; i++) {
    printf("%02x ", loraping_buffer[i]);
  }
  puts("");
}
```

_What happens when we don't receive a packet in 10 seconds? (LORAPING_RX_TIMEOUT_MS)_

Our SX1262 Library calls our Callback Function __on_rx_timeout__ defined in our Test App: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L328-L341)

```c
/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();

  //  Log the timeout
  loraping_stats.rx_timeout++;
}
```

We switch the LoRa Transceiver into sleep mode and log the timeout.

Note: __on_rx_timeout__ won't actually be called in our current driver, because we haven't implemented Multithreading. (More about this later)

To handle Receive Errors, we define the Callback Function __on_rx_error__ in our Test App: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L343-L355)

```c
/// Callback Function that is called when we couldn't receive a LoRa message due to error
static void on_rx_error(void) {
  //  Log the error
  loraping_stats.rx_error++;

  //  Switch the LoRa Transceiver to low power, sleep mode
  Radio.Sleep();
}
```

## Run the Firmware

Let's test our SX1262 Library and __receive a LoRa Message__...

1.  Assume that we have downloaded and configured our NuttX code...

    [__"Build the Firmware"__](https://lupyuen.github.io/articles/sx1262#build-the-firmware)

1.  Edit [__apps/examples/sx1262_test_main.c__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L123-L124) and uncomment...

    ```c
    #define RECEIVE_MESSAGE
    ```

1.  Also edit [__sx1262_test_main.c__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L30-L66) and set the __LoRa Parameters__. (As explained earlier)

1.  Build, flash and run the NuttX Firmware on BL602 or ESP32...

    [__"Build, Flash and Run NuttX"__](https://lupyuen.github.io/articles/sx1262#appendix-build-flash-and-run-nuttx)

1.  Switch over to __RAKwireless WisBlock__ and run our __LoRa Transmitter__...

    [__wisblock-lora-transmitter__](https://github.com/lupyuen/wisblock-lora-transmitter)

    Check that the __LoRa Parameters__ are correct...

    [__LoRa Parameters for WisBlock Transmitter__](https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L38-L54)

1.  WisBlock transmits a 64-byte __LoRa Message__ every 5 seconds...

    ```text
    LoRap2p Tx Test
    send: 48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
    OnTxDone
    ```

    [("`Hello`" followed by 0, 1, 2, ...)](https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144)

1.  In the NuttX Shell, enter...

    ```bash
    sx1262_test
    ```

1.  On NuttX we should see the same 64-byte __LoRa Message__...

    ```text
    IRQ_RX_DONE
    48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a
    IRQ_PREAMBLE_DETECTED
    IRQ_HEADER_VALID
    receive_message
    ```

    [(See the Output Log)](https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b)

    Congratulations our SX1262 Library has successfully received the 64-byte LoRa Message from RAKwireless WisBlock!

![Our SX1262 Library receives a LoRa Message from RAKwireless WisBlock](https://lupyuen.github.io/images/sx1262-receive2.jpg)

# SPI Interface

_Porting the SX1262 Library from Linux to NuttX... Was it difficult?_

Not at all! NuttX works much like Linux because of its [__POSIX Compliance__](https://lupyuen.github.io/articles/nuttx).

Most of the porting effort [(14 minutes!)](https://lupyuen.github.io/images/sx1262-git.png) was spent on...

1.  __SPI Interface__

1.  __GPIO Interface__

Because the interfaces work differently on NuttX vs Linux.

Let's dive into the SPI Interface: How we initialise the interface and transfer data over SPI.

![SPI Test Driver](https://lupyuen.github.io/images/spi2-plan2.jpg)

## Initialise SPI

In the previous article we have created an __SPI Test Driver "/dev/spitest0"__ that exposes the SPI Interface to NuttX Apps (pic above)...

-   [__"SPI on Apache NuttX OS"__](https://lupyuen.github.io/articles/spi2)

Our SX1262 Library opens the SPI Test Driver to __initialise the SPI Bus__ like so: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L782-L804)

```c
/// SPI Bus
static int spi = 0;

/// Chip Select Pin (GPIO Output)
static int cs = 0;

/// Init the SPI Bus and Chip Select Pin. Return 0 on success.
static int init_spi(void) {
  //  Open the SPI Bus (SPI Test Driver).
  //  Defaults to "/dev/spitest0"
  spi = open(SPI_DEVPATH, O_RDWR);
  assert(spi > 0);

  //  Open GPIO Output for SPI Chip Select.
  //  Defaults to "/dev/gpio1"
  cs = open(CS_DEVPATH, O_RDWR);
  assert(cs > 0);

  //  Get SPI Chip Select Pin Type
  enum gpio_pintype_e pintype;
  int ret = ioctl(cs, GPIOC_PINTYPE, (unsigned long)((uintptr_t)&pintype));
  assert(ret >= 0);

  //  Verify that SPI Chip Select is GPIO Output (not GPIO Input or GPIO Interrupt)
  assert(pintype == GPIO_OUTPUT_PIN);

  //  TODO: Set SPI Chip Select to High for all SPI Devices
  return 0;
}
```

[(__SPI_DEVPATH__ and __CS_DEVPATH__ are explained in the Appendix)](https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths)

__init_spi__ is called by [__SX126xIoInit__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94), which is called by [__RadioInit__](https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module) and [__init_driver__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L173-L227)

(We've seen __init_driver__ earlier in our Test App)

[(__RadioInit__ is explained here)](https://lupyuen.github.io/articles/sx1262#radioinit-initialise-lora-module)

_Where are SPI Mode and SPI Frequency defined?_

__SPI Mode__ and __SPI Frequency__ are defined in the SPI Test Driver...

-   [__"Configure SPI"__](https://lupyuen.github.io/articles/spi2#configure-spi)

_Why did we use GPIO Output?_

We're controlling the __SPI Chip Select Pin__ (/dev/gpio1) ourselves via GPIO Output, as explained below...

-   [__"Control Chip Select with GPIO"__](https://lupyuen.github.io/articles/spi2#control-chip-select-with-gpio)

More about GPIO Output in the next section.

![Initialise SPI](https://lupyuen.github.io/images/sx1262-driver2a.png)

[(Source)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L782-L804)

## Transfer SPI

To __transfer SPI Data__ to SX1262 via our SPI Test Driver, we do this: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L806-L832)

```c
/// Blocking call to transmit and receive buffers on SPI. Return 0 on success.
static int transfer_spi(const uint8_t *tx_buf, uint8_t *rx_buf, uint16_t len) {
  assert(spi > 0);
  assert(cs  > 0);
  assert(len > 0);
  assert(len <= SPI_BUFFER_SIZE);
  _info("spi tx: "); for (int i = 0; i < len; i++) { _info("%02x ", tx_buf[i]); } _info("\n");

  //  Set SPI Chip Select to Low
  int ret = ioctl(cs, GPIOC_WRITE, 0);
  assert(ret >= 0);

  //  Transmit data over SPI
  int bytes_written = write(spi, tx_buf, len);
  assert(bytes_written == len);

  //  Receive SPI response
  int bytes_read = read(spi, rx_buf, len);
  assert(bytes_read == len);

  //  Set SPI Chip Select to High
  ret = ioctl(cs, GPIOC_WRITE, 1);
  assert(ret >= 0);

  _info("spi rx: "); for (int i = 0; i < len; i++) { _info("%02x ", rx_buf[i]); } _info("\n");
  return 0;
}
```

Note that we control __SPI Chip Select__ ourselves with GPIO Output. The code above is explained in...

-   [__"GPIO Output as Chip Select"__](https://lupyuen.github.io/articles/spi2#gpio-output-as-chip-select)

Let's watch how __transfer_spi__ is called by our SX1262 Library to transmit and receive LoRa Messages.

![Transfer SPI](https://lupyuen.github.io/images/sx1262-driver3.jpg)

[(Source)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L806-L832)

## Transmit Message

Later as we walk through the __sending of a LoRa Message__ [(__RadioSend__)](https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message), we'll learn that our SX1262 Driver calls this function to transfer the LoRa Message to SX1262: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L567-L573)

```c
static int sx126x_write_buffer(const void* context, const uint8_t offset, const uint8_t* buffer, const uint8_t size) {
  //  Prepare the Write Buffer Command (2 bytes)
  uint8_t buf[SX126X_SIZE_WRITE_BUFFER] = { 0 };
  buf[0] = RADIO_WRITE_BUFFER;  //  Write Buffer Command: 0x0E
  buf[1] = offset;              //  Write Buffer Offset

  //  Transfer the Write Buffer Command to SX1262 over SPI
  return sx126x_hal_write(
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_WRITE_BUFFER,  //  Command Buffer Size (2 bytes)
    buffer,   //  Write Data Buffer
    size      //  Write Data Buffer Size
  );
}
```

[(__sx126x_write_buffer__ is called by __RadioSend__)](https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message)

In code above we prepare a __SX1262 Write Buffer Command__ (`0x0E 0x00`) and pass the Command Buffer (plus Data Buffer) to __sx126x_hal_write__.

(Data Buffer contains the 64-byte __LoRa Message__ to be transmitted)

Note that __Write Buffer Offset is always 0__, because of [__SX126xSetPayload__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L144-L147) and [__SX126xWriteBuffer__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L301-L307).

[(__SX126xSetPayload__ and __SX126xWriteBuffer__ are explained here)](https://lupyuen.github.io/articles/sx1262#radiosend-transmit-message)

__sx126x_hal_write__ calls __transfer_spi__ to transfer the Command Buffer and Data Buffer over SPI: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L606-L643)

```c
/**
 * Radio data transfer - write
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be transmitted
 * @param [in] data_length      Buffer size to be transmitted
 *
 * @returns Operation status
 */
static int sx126x_hal_write( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  const uint8_t* data, const uint16_t data_length ) {
  printf("sx126x_hal_write: command_length=%d, data_length=%d\n", command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len > 0);
  assert(len <= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&spi_tx_buf, 0, len);
  memset(&spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&spi_tx_buf, command, command_length);

  //  Copy data bytes to SPI Transmit Buffer
  memcpy(&spi_tx_buf[command_length], data, data_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);
  return 0;
}
```

(We've seen __transfer_spi__ in the previous section)

_What are spi_tx_buf and spi_rx_buf?_

They are the internal __1024-byte buffers for SPI Transfers__: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L588-L601)

```c
/// Max size of SPI transfers
#define SPI_BUFFER_SIZE 1024

/// SPI Transmit Buffer
static uint8_t spi_tx_buf[SPI_BUFFER_SIZE];

/// SPI Receive Buffer
static uint8_t spi_rx_buf[SPI_BUFFER_SIZE];
```

## Receive Message

Later as we inspect the code that __receives LoRa Messages__, we'll see that our SX1262 Library calls this function when a __Receive Done Event__ is triggered: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L575-L583)

```c
static int sx126x_read_buffer(const void* context, const uint8_t offset, uint8_t* buffer, const uint8_t size) {
  //  Prepare the Read Buffer Command (3 bytes)
  uint8_t buf[SX126X_SIZE_READ_BUFFER] = { 0 };
  buf[0] = RADIO_READ_BUFFER;  //  Read Buffer Command: 0x1E
  buf[1] = offset;             //  Read Buffer Offset
  buf[2] = 0;                  //  NOP

  //  Transfer the Read Buffer Command to SX1262 over SPI
  int status = sx126x_hal_read( 
    context,  //  Context
    buf,      //  Command Buffer
    SX126X_SIZE_READ_BUFFER,  //  Command Buffer Size (3 bytes)
    buffer,   //  Read Data Buffer
    size,     //  Read Data Buffer Size
    NULL      //  Ignore the status
  );
  return status;
}
```

[(__sx126x_read_buffer__ is called by the __Receive Done Event__)](https://lupyuen.github.io/articles/sx1262#receive-done)

In this code we prepare a __SX1262 Read Buffer Command__ (`0x1E 0x00 0x00`) and pass the Command Buffer (plus Data Buffer) to __sx126x_hal_read__.

(Data Buffer will contain the received 64-byte __LoRa Message__)

Note that __Read Buffer Offset is always 0__, because of [__SX126xGetPayload__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L149-L160) and [__SX126xReadBuffer__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L309-L315).

[(__SX126xGetPayload__ and __SX126xReadBuffer__ are explained here)](https://lupyuen.github.io/articles/sx1262#receive-done)

__sx126x_hal_read__ calls __transfer_spi__ to transfer the Command Buffer over SPI: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L645-L689)

```c
/**
 * Radio data transfer - read
 *
 * @remark Shall be implemented by the user
 *
 * @param [in] context          Radio implementation parameters
 * @param [in] command          Pointer to the buffer to be transmitted
 * @param [in] command_length   Buffer size to be transmitted
 * @param [in] data             Pointer to the buffer to be received
 * @param [in] data_length      Buffer size to be received
 * @param [out] status          If not null, return the second SPI byte received as status
 *
 * @returns Operation status
 */
static int sx126x_hal_read( 
  const void* context, const uint8_t* command, const uint16_t command_length,
  uint8_t* data, const uint16_t data_length, uint8_t *status ) {
  printf("sx126x_hal_read: command_length=%d, data_length=%d\n", command_length, data_length);

  //  Total length is command + data length
  uint16_t len = command_length + data_length;
  assert(len > 0);
  assert(len <= SPI_BUFFER_SIZE);

  //  Clear the SPI Transmit and Receive buffers
  memset(&spi_tx_buf, 0, len);
  memset(&spi_rx_buf, 0, len);

  //  Copy command bytes to SPI Transmit Buffer
  memcpy(&spi_tx_buf, command, command_length);

  //  Transmit and receive the SPI buffers
  int rc = transfer_spi(spi_tx_buf, spi_rx_buf, len);
  assert(rc == 0);

  //  Copy SPI Receive buffer to data buffer
  memcpy(data, &spi_rx_buf[command_length], data_length);

  //  Return the second SPI byte received as status
  if (status != NULL) {
    assert(len >= 2);
    *status = spi_rx_buf[1];
  }
  return 0;
}
```

And returns the __Data Buffer__ received from SX1262 over SPI.

## SPI In Action

We've talked about [__sx126x_write_buffer__](https://lupyuen.github.io/articles/sx1262#transmit-message) and [__sx126x_read_buffer__](https://lupyuen.github.io/articles/sx1262#receive-message), let's watch them in action as we __transmit and receive__ 64-byte LoRa Messages.

To transmit a LoRa Message, [__sx126x_write_buffer__](https://lupyuen.github.io/articles/sx1262#transmit-message) sends the __WriteBuffer Command__ to SX1262 over SPI...

1.  __WriteBuffer Command:__ `0x0E`

1.  __WriteBuffer Offset:__ `0x00`

1.  __WriteBuffer Data:__ Transfer 64 bytes

This copies the __entire 64-byte LoRa Message__ into the SX1262 Transmit Buffer as a __single (huge) chunk__.

This appears in the [__Transmit Log__](https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668) as...

```text
sx126x_hal_write: 
  command_length=2, 
  data_length=64
spi tx: 
  0e 00 
  50 49 4e 47 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b
spi rx: 
  a2 a2 
  a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2
```

The __64-byte LoRa Message__ transmitted appears in the __SPI Transmit Log__ above: `50 49 4e 47...`

[("`50 49 4e 47...`" is "`PING`" followed by 0, 1, 2, ...)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L237-L253)

To receive a LoRa Message, [__sx126x_read_buffer__](https://lupyuen.github.io/articles/sx1262#receive-message) sends this __ReadBuffer Command__ to SX1262 over SPI...

1.  __ReadBuffer Command:__ `0x1E`

1.  __ReadBuffer Offset:__ `0x00`

1.  __ReadBuffer NOP:__ `0x00`

1.  __ReadBuffer Data:__ Transfer 64 bytes

Which appears in the [__Receive Log__](https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b) as...

```text
sx126x_hal_read: 
  command_length=3, 
  data_length=64
spi tx: 
  1e 00 00 
  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
spi rx: 
  d2 d2 d2 
  48 65 6c 6c 6f 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 
```

The __64-byte LoRa Message__ received appears in the __SPI Receive Log__ above: `48 65 6c 6c 6f...`

[("`48 65 6c 6c 6f...`" is "`Hello`" followed by 0, 1, 2, ...)](https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L120-L144)

# GPIO Interface

_Besides SPI, what Interfaces do we need to control the SX1262 Transceiver?_

Our SX1262 Library needs a __GPIO Interface__ to control these __SX1262 Pins__...

-   __BUSY__ at /dev/gpio0: GPIO Input that tells us whether SX1262 is busy

    (BUSY is High when SX1262 is busy)

-   __Chip Select__ at /dev/gpio1: Select or deselect SX1262 on the SPI Bus

    (Chip Select is Low when SX1262 is selected)

-   __DIO1__ at /dev/gpio2: GPIO Interrupt used by SX1262 to signal that a LoRa Packet has been transmitted or received

    (DIO1 shifts from Low to High when that happens)

-   __NRESET__: GPIO Output that is toggled to reset the SX1262 module

    (NRESET is not implemented yet. To reset SX1262, we power cycle the board. [See this](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L163-L183))

    [(We might implement NRESET with a GPIO Expander)](https://lupyuen.github.io/articles/pinedio2#gpio-expander)

[(__PineDio Stack BL604__ uses different GPIO Names, see the Appendix)](https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths)

Let's look at the implementation of the GPIO Interface for the __new SX1262 Library that will support LoRaWAN__.

[(See this for the old SX1262 Library)](https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library)

## Initialise GPIO

This function is called to initialise the GPIO Pins when our app starts: [__SX126xIoInit__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L75-L94)

```c
/// Initialise GPIO Pins and SPI Port. Called by SX126xIoIrqInit.
/// Note: This is different from the Reference Implementation,
/// which initialises the GPIO Pins and SPI Port at startup.
void SX126xIoInit( void ) {
  //  Init the Event Queue if not initialised. 
  //  TimerInit is called before SX126xIoInit, 
  //  so the Event Queue should already be initialised.
  init_event_queue();

  //  Init GPIO Pins. Event Queue must be initialised before this.
  int rc = init_gpio();
  assert(rc == 0);

  //  Init SPI Bus
  rc = init_spi();
  assert(rc == 0);
}
```

(We'll see __init_event_queue__ in the next chapter)

(We've seen __init_spi__ earlier)

__init_gpio__ initialises the GPIO Pins like so: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L725-L780)

```c
/// SX1262 Busy Pin (GPIO Input)
static int busy = 0;

/// SX1262 DIO1 Pin (GPIO Interrupt)
static int dio1 = 0;

/// Init the GPIO Pins. Return 0 on success.
static int init_gpio(void) {
  //  Open GPIO Input for SX1262 Busy Pin.
  //  Defaults to "/dev/gpio0"
  busy = open(BUSY_DEVPATH, O_RDWR);
  assert(busy > 0);
```

[(__BUSY_DEVPATH__ is explained in the Appendix)](https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths)

We begin by opening the GPIO Input for the __Busy Pin__ "/dev/gpio0".

We fetch the __GPIO Pin Type__ and verify that it's GPIO Input...

```c
  //  Get SX1262 Busy Pin Type
  enum gpio_pintype_e pintype;
  int ret = ioctl(  //  Execute a GPIO Command...
    busy,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &pintype)  //  Returned Pin Type
  );
  assert(ret >= 0);

  //  Verify that SX1262 Busy Pin is GPIO Input (not GPIO Output or GPIO Interrupt)
  assert(pintype == GPIO_INPUT_PIN);  //  No pullup / pulldown
```

Next we open the GPIO Interrupt for the __DIO1 Pin__ "/dev/gpio2".

```c
  //  Open GPIO Interrupt for SX1262 DIO1 Pin
  //  Defaults to "/dev/gpio2"
  dio1 = open(DIO1_DEVPATH, O_RDWR);
  assert(dio1 > 0);
```

[(__DIO1_DEVPATH__ is explained in the Appendix)](https://lupyuen.github.io/articles/sx1262#appendix-spi-and-gpio-device-paths)

We fetch the __GPIO Pin Type__ and verify that it's GPIO Interrupt...

```c
  //  Get SX1262 DIO1 Pin Type
  ret = ioctl(      //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &pintype)  //  Returned Pin Type
  );
  assert(ret >= 0);
  printf("DIO1 pintype before=%d\n", pintype);

  //  Verify that SX1262 DIO1 Pin is GPIO Interrupt (not GPIO Input or GPIO Output)
  assert(pintype == GPIO_INTERRUPT_PIN);
```

Remember that __DIO1 shifts from Low to High__ when a LoRa Packet has been transmitted or received.

Thus we configure NuttX to trigger a __GPIO Interrupt on Rising Edge__...

```c
  //  Change DIO1 Pin to Trigger GPIO Interrupt on Rising Edge
  //  TODO: Crashes at ioexpander/gpio.c (line 544) because change failed apparently
  puts("init_gpio: change DIO1 to Trigger GPIO Interrupt on Rising Edge");
  ret = ioctl(         //  Execute a GPIO Command...
    dio1,              //  GPIO Descriptor
    GPIOC_SETPINTYPE,  //  Set GPIO Pin Type
    (unsigned long) GPIO_INTERRUPT_RISING_PIN  //  Requested Pin Type
  );
  assert(ret >= 0);
```

[(This crashes NuttX with an Assertion Failure, so we have __disabled the assertion__)](https://lupyuen.github.io/articles/sx1262#appendix-gpio-pin-type-issue)

We fetch the __GPIO Pin Type__ and verify that it's GPIO Interrupt Triggered on Rising Edge...

```c
  //  Get SX1262 DIO1 Pin Type again
  ret = ioctl(      //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_PINTYPE,  //  Get GPIO Pin Type
    (unsigned long)((uintptr_t) &pintype)  //  Returned Pin Type
  );
  assert(ret >= 0);
  printf("DIO1 pintype after=%d\n", pintype);

  //  Verify that SX1262 DIO1 Pin is GPIO Interrupt on Rising Edge
  //  TODO: This fails because the Pin Type remains as GPIO_INTERRUPT_PIN
  //  assert(pintype == GPIO_INTERRUPT_RISING_PIN);  //  Trigger interrupt on rising edge

  //  Omitted: Start the Background Thread to process DIO1 interrupts
  ...
```

(But there's a quirk in NuttX so we have disabled the assertion)

In the next section we'll create a __Background Thread__ to handle the GPIO Interrupt.

_Why do we verify the GPIO Pin Types? (Input / Output / Interrupt)_

The GPIO Pin Names look awfully similar: __/dev/gpio0__, __gpio1__, __gpio2__, ...

It's easy to __mix up the GPIO Pins.__ Hence we verify the GPIO Pin Types to be sure that we got the right pin.

![Initialise GPIO](https://lupyuen.github.io/images/lorawan3-gpio2.png)

## Start DIO1 Thread

In the rest of __init_gpio__ we create a __Background Thread__ to handle GPIO Interrupts from DIO1: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L725-L780)

```c
/// Init the GPIO Pins. Return 0 on success.
static int init_gpio(void) {
  //  Omitted: Open GPIO Input for SX1262 Busy Pin
  //  Omitted: Open GPIO Interrupt for SX1262 DIO1 Pin
  //  Omitted: Change DIO1 Pin to Trigger GPIO Interrupt on Rising Edge
  ...
  //  Init the Background Thread Attributes
  static pthread_attr_t attr;
  ret = pthread_attr_init(&attr);
  assert(ret == 0);
```

After we have initialised the Thread Attributes, we __create the Background Thread__...

```c
  //  Start the Background Thread to process DIO1 interrupts
  static pthread_t thread;
  ret = pthread_create(  //  Create a Background Thread
    &thread,             //  Returned Thread
    &attr,               //  Thread Attributes
    process_dio1,        //  Function that will be executed by the thread
    0                    //  Argument to pass to the thread
  );
  assert(ret == 0);
```

Let's look inside __process_dio1__, the function that will be executed by the thread.

![Handle DIO1 Interrupt](https://lupyuen.github.io/images/lorawan3-gpio3.png)

## Handle DIO1 Interrupt

We have created a __Background Thread__ that will handle __GPIO Interrupts from DIO1__.  (Whenever a LoRa Packet is transmitted or received)

The thread shall do this...

1.  Define a __NuttX Signal__ that will be signalled on GPIO Interrupt

1.  __Wait for the GPIO Interrupt (Signal)__ to be triggered by DIO1

1.  __Add an Event__ to the Event Queue

1.  Repeat forever

(Event Queue comes from NimBLE Porting Layer, explained in the next chapter)

Below is the code for our __Background Thread__: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L834-L896)

```c
/// Handle DIO1 Interrupt by adding to Event Queue
void *process_dio1(void *arg) {
  assert(dio1 > 0);

  //  Define the DIO1 Interrupt Event
  static struct ble_npl_event ev;
  ble_npl_event_init(  //  Init the Event for...
    &ev,               //  Event
    RadioOnDioIrq,     //  Event Handler Function
    NULL               //  Argument to be passed to Event Handler
  );
```

The thread begins by defining the __DIO1 Interrupt Event__ that will be added to the Event Queue.

When the Event Loop receives this Event, it will call [__RadioOnDioIrq__](https://lupyuen.github.io/articles/sx1262#radioondioirq)
 to process the received packet.

Next we define the __NuttX Signal__ that will be signalled on GPIO Interrupt...

```c
  //  Define the signal
  #define SIG_DIO1 1
  struct sigevent notify;
  notify.sigev_notify = SIGEV_SIGNAL;
  notify.sigev_signo  = SIG_DIO1;
```

We __register the Signal__ that will be triggered on GPIO Interrupt...

```c
  //  Set up to receive signal from GPIO Interrupt (DIO1 rising edge)
  int ret = ioctl(   //  Execute a GPIO Command...
    dio1,            //  GPIO Descriptor
    GPIOC_REGISTER,  //  Register GPIO Interrupt
    (unsigned long) &notify  //  Signal to be notified on GPIO Interrupt
  );
  assert(ret >= 0);
```

Then we add the Signal to a __Signal Set__ (which we shall await later)...

```c
  //  Create an empty Signal Set
  sigset_t set;
  sigemptyset(&set);

  //  Add the signal to the Signal Set
  sigaddset(
    &set,     //  Signal Set
    SIG_DIO1  //  Signal to be added
  );
```

We loop forever. Inside the loop we __await the Signal Set__ for up to 60 seconds...

```c
  //  Loop forever waiting for the signal (DIO1 rising edge)
  for (;;) {

    //  Wait up to 60 seconds for the Signal Set
    struct timespec ts;
    ts.tv_sec  = 60;
    ts.tv_nsec = 0;
    ret = sigtimedwait(&set, NULL, &ts);
```

(We should probably wait forever)

If we were signalled (due to GPIO Interrupt), we __add our Event__ to the Event Queue...

```c
    //  Were we signalled?
    if (ret >= 0) {
      //  We were signalled. Add the DIO1 Interrupt Event to the Event Queue.
      puts("DIO1 add event");
      ble_npl_eventq_put(&event_queue, &ev);
```

(Which gets handled by the Event Loop in the next chapter)

If we __weren't signalled in 60 seconds__, everything is hunky dory, just try again...

```c
    } else {
      //  We were not signalled
      int errcode = errno;
      if (errcode == EAGAIN) { puts("DIO1 timeout"); }
      else { fprintf(stderr, "ERROR: Failed to wait signal %d: %d\n", SIG_DIO1, errcode); return NULL; }
    }
  }
```

Finally this loops back perpetually, awaiting the next GPIO Interrupt (Signal) or timeout.

That's it for the Background Thread! We don't do much here, we do all the work in the Event Loop.

(Which is probably safer for Multithreading)

![Handle DIO1 Interrupt](https://lupyuen.github.io/images/lorawan3-gpio4a.png)

## Read DIO1 State

Our SX1262 Library calls this function to read the __DIO1 Pin State__: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L349-L361)

```c
uint32_t SX126xGetDio1PinState( void ) {
  //  Return the value of DIO1 Pin
  assert(dio1 > 0);

  //  Read the GPIO Input
  bool invalue;
  int ret = ioctl(  //  Execute a GPIO Command...
    dio1,           //  GPIO Descriptor
    GPIOC_READ,     //  Read GPIO Input
    (unsigned long)((uintptr_t) &invalue)  //  Returned Value
  );
  assert(ret >= 0);

  //  Return the value: 1 or 0
  return invalue ? 1 : 0;
}
```

![Check Busy State](https://lupyuen.github.io/images/lorawan3-gpio1.png)

## Check Busy State

The Busy Pin goes High when SX1262 is busy. We wait for SX1262 by reading the GPIO Input for the Busy Pin: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200)

```c
void SX126xWaitOnBusy( void ) {
  assert(busy > 0);

  //  Loop until Busy Pin is Low
  for (;;) {
    //  Read Busy Pin
    bool invalue;
    int ret = ioctl(  //  Execute a GPIO Command...
      busy,           //  GPIO Descriptor
      GPIOC_READ,     //  Read GPIO Pin
      (unsigned long)((uintptr_t) &invalue)  //  Returned value
    );
    assert(ret >= 0);

    //  Exit if Busy Pin is Low
    if (invalue == 0) { break; }
  }
}
```

(__SX126xWaitOnBusy__ is called by [__SX126xCheckDeviceReady__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142), which wakes up SX1262 before checking if SX1262 is busy)

Earlier we talked about the Event Queue, let's dive into the NimBLE Porting Layer.

![Multithreading with NimBLE Porting Layer](https://lupyuen.github.io/images/sx1262-handler.jpg)

# Multithreading with NimBLE Porting Layer

Our SX1262 Library was designed for __Multithreading__ by calling the open-source __NimBLE Porting Layer__...

-   [__"Multitask with NimBLE Porting Layer"__](https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer)

To transmit and receive LoRa Messages without polling we need __Timers and Event Queues__. Which are provided by NimBLE Porting Layer.

_Have we used NimBLE Porting Layer on other platforms?_

Yep we used NimBLE Porting Layer in the __LoRa SX1262 and SX1276 Drivers__ for BL602 IoT SDK...

-   [__"PineCone BL602 RISC-V Board Receives LoRa Packets"__](https://lupyuen.github.io/articles/lora2)

NimBLE Porting Layer [__compiles on NuttX__](https://github.com/apache/mynewt-nimble/tree/master/porting/npl/nuttx) as well...

-   [__lupyuen/nimble-porting-nuttx__](https://github.com/lupyuen/nimble-porting-nuttx)

Note that NimBLE Porting Layer needs __POSIX Timers and Message Queues__ (plus more) to work on NuttX...

-   [__"POSIX Timers and Message Queues"__](https://lupyuen.github.io/articles/lorawan3#appendix-posix-timers-and-message-queues)

_How will we receive LoRa Messages with GPIO Interrupts?_

According to the pic above...

1.  When SX1262 receives a LoRa Message, it triggers a __GPIO Interrupt__ on Pin DIO1

1.  In the previous chapter we started a __Background Thread__ that waits for GPIO Interrupts and __adds a DIO1 Interrupt Event__ to our Event Queue

1.  In our NuttX App, the __Foreground Thread__ runs an __Event Loop__ that handles every Event in our Event Queue

1.  When the Event Loop receives the DIO1 Interrupt Event, it calls [__RadioOnDioIrq__](https://lupyuen.github.io/articles/sx1262#radioondioirq)
 to process the received LoRa Message

Let's look at the implementation of NimBLE Porting Layer for the __new SX1262 Library that will support LoRaWAN__.

[(See this for the old SX1262 Library)](https://lupyuen.github.io/articles/sx1262#appendix-previous-sx1262-library)

## Event Queue

_What Events will be added to our Event Queue?_

Our Event Queue will have __two types of Events__...

1.  __GPIO Interrupt__: Triggered via DIO1 when SX1262 has transmitted or received a LoRa Message

1.  __Timer Events__: All Timers for LoRa and LoRaWAN will insert Events into our Event Queue upon timeout

All Events are handled __First In First Out__ by our Event Loop.

_How do we create the Event Queue?_

Our SX1262 Library __creates the Event Queue__ by calling NimBLE Porting Layer: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L901-L916)

```c
/// Event Queue containing Events to be processed. Exposed to NuttX App for Event Loop.
struct ble_npl_eventq event_queue;

/// True if Event Queue has been initialised
static bool is_event_queue_initialised = false;

/// Init the Event Queue
static void init_event_queue(void) {

  //  Init only once
  if (is_event_queue_initialised) { return; }
  is_event_queue_initialised = true;

  //  Init the Event Queue by calling NimBLE Porting Layer
  ble_npl_eventq_init(&event_queue);
}
```

![Handling LoRaWAN Events with NimBLE Porting Layer](https://lupyuen.github.io/images/lorawan3-npl1.png)

## Event Loop

Let's look at the __Event Loop__ that handles the LoRa and LoRaWAN Events in our Event Queue: [lorawan_test_main.c](https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c#L611-L655)

```c
/// Event Loop that dequeues Events from the Event Queue and processes the Events
static void handle_event_queue(void *arg) {

  //  Loop forever handling Events from the Event Queue
  for (;;) {

    //  Get the next Event from the Event Queue
    struct ble_npl_event *ev = ble_npl_eventq_get(
      &event_queue,         //  Event Queue
      BLE_NPL_TIME_FOREVER  //  No Timeout (Wait forever for event)
    );
```

This code runs in the __Foreground Thread__ of our NuttX App.

Here we loop forever, __waiting for Events__ from the Event Queue.

When we receive an Event, we __remove the Event__ from the Event Queue...

```c
    //  If no Event due to timeout, wait for next Event.
    //  Should never happen since we wait forever for an Event.
    if (ev == NULL) { printf("."); continue; }

    //  Remove the Event from the Event Queue
    ble_npl_eventq_remove(&event_queue, ev);
```

We call the __Event Handler Function__ that was registered with the Event...

```c
    //  Trigger the Event Handler Function
    ble_npl_event_run(ev);
```

-   For DIO1 Interrupts: We call [__RadioOnDioIrq__](https://lupyuen.github.io/articles/sx1262#radioondioirq) to handle the packet transmitted / received notification

-   For Timer Events: We call the __Timeout Function__ defined in the Timer

The rest of the Event Loop handles LoRaWAN Events. We'll cover this in the next article...

-   [__"LoRaWAN on Apache NuttX OS"__](https://lupyuen.github.io/articles/lorawan3)

```c
    //  For LoRaWAN: Processes the LoRaMac events
    LmHandlerProcess( );

    //  For LoRaWAN: If we have joined the network, do the uplink
    if (!LmHandlerIsBusy( )) {
      UplinkProcess( );
    }

    //  For LoRaWAN: Handle Low Power Mode
    CRITICAL_SECTION_BEGIN( );
    if( IsMacProcessPending == 1 ) {
      //  Clear flag and prevent MCU to go into low power modes.
      IsMacProcessPending = 0;
    } else {
      //  The MCU wakes up through events
      //  TODO: BoardLowPowerHandler( );
    }
    CRITICAL_SECTION_END( );
  }
}
```

And we loop back perpetually, waiting for Events and handling them.

That's how we handle LoRa and LoRaWAN Events with NimBLE Porting Layer!

![Porting LoRaWAN to NuttX OS](https://lupyuen.github.io/images/sx1262-library5.jpg)

# What's Next

In our next article we'll move on to __LoRaWAN!__ We'll port Semtech's __Reference LoRaWAN Stack__ to NuttX...

-   [__"LoRaWAN on Apache NuttX OS"__](https://lupyuen.github.io/articles/lorawan3)

_We're porting plenty of code to NuttX: LoRa, LoRaWAN and NimBLE Porting Layer. Do we expect any problems?_

Yep we might have issues keeping our LoRaWAN Stack in sync with Semtech's version.  [(But we shall minimise the changes)](https://lupyuen.github.io/articles/sx1262#notes)

We have started porting the [__Rust Embedded HAL__](https://lupyuen.github.io/articles/nuttx#rust-on-nuttx) to NuttX. Here's what we've done...

-   [__"Rust on Apache NuttX OS"__](https://lupyuen.github.io/articles/rust2)

-   [__"Rust talks I2C on Apache NuttX RTOS"__](https://lupyuen.github.io/articles/rusti2c)

Now LoRa works on Rust too...

-   [__"Transmit LoRa Message (in Rust)"__](https://lupyuen.github.io/articles/rust2#transmit-lora-message)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [Sponsor me a coffee](https://github.com/sponsors/lupyuen)

-   [Discuss this article on Reddit](https://www.reddit.com/r/embedded_oc/comments/rluiw0/lora_sx1262_on_apache_nuttx_os/)

-   [Read "The RISC-V BL602 / BL604 Book"](https://lupyuen.github.io/articles/book)

-   [Check out my articles](https://lupyuen.github.io)

-   [RSS Feed](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[`lupyuen.github.io/src/sx1262.md`](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sx1262.md)

# Notes

1.  This article is the expanded version of [this Twitter Thread](https://twitter.com/MisterTechBlog/status/1471179698268893188)

1.  We're __porting plenty of code__ to NuttX: LoRa, LoRaWAN and NimBLE Porting Layer. Do we expect any problems?

    -   If we implement LoRa and LoRaWAN as __NuttX Drivers__, we'll have to scrub the code to comply with the [__NuttX Coding Conventions__](https://nuttx.apache.org/docs/latest/contributing/coding_style.html).

        This makes it __harder to update__ the LoRaWAN Driver when there are changes in the LoRaWAN Spec. (Like for a new LoRaWAN Region)

        [(Here's an example)](https://lupyuen.github.io/articles/lorawan#appendix-lora-carrier-sensing)

    -   Alternatively we may implement LoRa and LoRaWAN as __External Libraries__, similar to [__NimBLE for NuttX__](https://github.com/lupyuen/nuttx-apps/tree/master/wireless/bluetooth/nimble).

        (The [__Makefile__](https://github.com/lupyuen/nuttx-apps/blob/master/wireless/bluetooth/nimble/Makefile#L33) downloads the External Library during build)

        But then we won't get a proper NuttX Driver that exposes the ioctl() interface to NuttX Apps.

    Conundrum. Lemme know your thoughts!

1.  How do other Embedded Operating Systems implement LoRaWAN?

    -   __Mynewt__ embeds a [__Partial Copy__](https://github.com/apache/mynewt-core/tree/master/net/lora/node) of Semtech's LoRaWAN Stack into its source tree.

    -   __Zephyr__ maintains a [__Complete Fork__](https://github.com/zephyrproject-rtos/loramac-node) of the entire LoRaWAN Repo by Semtech. Which gets embedded during the Zephyr build.

    We're adopting the Zephyr approach to __keep our LoRaWAN Stack in sync__ with Semtech's.

1.  We have already ported LoRaWAN to __BL602 IoT SDK__ [(see this)](https://lupyuen.github.io/articles/lorawan), why are we porting again to NuttX?

    Regrettably BL602 IoT SDK has been revamped (without warning) to the __new "hosal" HAL__ [(see this)](https://twitter.com/MisterTechBlog/status/1456259223323508748), and the LoRaWAN Stack will __no longer work__ on the revamped BL602 IoT SDK.

    For easier maintenance, we shall __code our BL602 and BL604 projects with Apache NuttX OS__ instead.

    (Which won't get revamped overnight!)

1.  Will NuttX become the official OS for PineDio Stack BL604 when it goes on sale?

    It might! But first let's get LoRaWAN (and ST7789) running on PineDio Stack.

# Appendix: SPI and GPIO Device Paths

[__PineDio Stack BL604__](https://lupyuen.github.io/articles/pinedio2) uses the __GPIO Expander__, which assigns meaningful names to GPIO Pins...

-   [__"NuttX GPIO Expander for PineDio Stack BL604"__](https://lupyuen.github.io/articles/expander)

For PineDio Stack we changed the definition of __`DIO1_DEVPATH`__ to "__/dev/gpio19__" in Kconfig / menuconfig...

```text
CONFIG_LIBSX1262_SPI_DEVPATH="/dev/spitest0"
CONFIG_LIBSX1262_CS_DEVPATH="/dev/gpio15"
CONFIG_LIBSX1262_BUSY_DEVPATH="/dev/gpio10"
CONFIG_LIBSX1262_DIO1_DEVPATH="/dev/gpio19"
```

[(Source)](https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/configs/pinedio/defconfig#L1141-L1144)

(Note also the changes to __SPI_DEVPATH__, __CS_DEVPATH__ and __BUSY_DEVPATH__)

For backward compatibility with BL602 (which doesn't use GPIO Expander), we default __`DIO1_DEVPATH`__ to "__/dev/gpio2__" if __`DIO1_DEVPATH`__ isn't configured...

```c
//  Define the SPI Test Driver for SX1262. (Not the regular SPI Driver)

#ifdef CONFIG_LIBSX1262_SPI_DEVPATH
#define SPI_DEVPATH CONFIG_LIBSX1262_SPI_DEVPATH
#else
#define SPI_DEVPATH "/dev/spitest0"
#endif  //  CONFIG_LIBSX1262_SPI_DEVPATH

//  Define the GPIOs for SX1262 Chip Select (Output), Busy (Input) and DIO1 (Interrupt)

#ifdef CONFIG_LIBSX1262_CS_DEVPATH
#define CS_DEVPATH CONFIG_LIBSX1262_CS_DEVPATH
#else
#define CS_DEVPATH "/dev/gpio1"
#endif  //  CONFIG_LIBSX1262_CS_DEVPATH

#ifdef CONFIG_LIBSX1262_BUSY_DEVPATH
#define BUSY_DEVPATH CONFIG_LIBSX1262_BUSY_DEVPATH
#else
#define BUSY_DEVPATH "/dev/gpio0"
#endif  //  CONFIG_LIBSX1262_BUSY_DEVPATH

#ifdef CONFIG_LIBSX1262_DIO1_DEVPATH
#define DIO1_DEVPATH CONFIG_LIBSX1262_DIO1_DEVPATH
#else
#define DIO1_DEVPATH "/dev/gpio2"
#endif  //  CONFIG_LIBSX1262_DIO1_DEVPATH
```

[(Source)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L18-L44)

(Note also the defaults for __SPI_DEVPATH__, __CS_DEVPATH__ and __BUSY_DEVPATH__)

# Appendix: Create a NuttX Library

_(For BL602 and ESP32)_

This section explains the steps to create a __NuttX Library__ named __"libsx1262"__.

(Change "libsx1262" to the desired name of our library)

1.  Browse to the [__"nuttx/libs"__](https://github.com/lupyuen/nuttx/tree/newlibrary/libs) folder

1.  Copy the __"libdsp"__ subfolder and paste it as __"libsx1262"__

    ![Copy the "libdsp" subfolder and paste it as "libsx1262"](https://lupyuen.github.io/images/sx1262-clone1.png)

    [(Source)](https://github.com/lupyuen/nuttx/commit/6596edd6eb47547f41f647e6da1e08d33faacf4f#diff-739a304e183a900711f6497e6544a814ef5367da89ccedad067fc1a3f0814b41)

1.  Inside the __"libsx1262"__ folder, delete all source files except __"lib_misc.c"__

1.  Edit __"Makefile"__. Remove all "CSRCS" lines except...

    ```text
    CSRCS += lib_misc.c
    ```

    [(See Makefile)](https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/Makefile)

1.  Inside the __"libsx1262"__ folder, search and replace all __"libdsp"__ by __"libsx1262"__

    Be sure to __Preserve Case!__

    ![Change all "libdsp" to "libsx1262"](https://lupyuen.github.io/images/sx1262-clone2a.png)

    [(See changes)](https://github.com/lupyuen/nuttx/commit/9fe76d3bca389642e71ac405c8343b280384276d#diff-a9d844356942ef04a0efe9eac47f95390756485e2aec9cd4018831af2e8e9409)

    [(See libsx1262 folder)](https://github.com/lupyuen/nuttx/tree/newlibrary/libs/libsx1262)

1.  Edit the file __"Kconfig"__

    Update the section __"menuconfig LIBSX1262"__ as follows...

    ```text
    menuconfig LIBSX1262
        bool "Semtech SX1262 Library"
        default n
        ---help---
            Enable build for Semtech SX1262 functions    
    ```

    ![Update Kconfig](https://lupyuen.github.io/images/sx1262-clone4.png)

    [(Source)](https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/Kconfig)

1.  Edit the file __"lib_misc.c"__.  Remove all the code and add...

    ```c
    #include <stdio.h>  /* TODO: Fix this for kernel mode */
    #include <sx1262.h>

    void test_libsx1262(void)
    {
      puts("libsx1262 OK!");
    }
    ```

    We'll call this function in a while.

    [(See lib_misc.c)](https://github.com/lupyuen/nuttx/blob/newlibrary/libs/libsx1262/lib_misc.c)

1.  Browse to the [__"nuttx/include"__](https://github.com/lupyuen/nuttx/blob/newlibrary/include) folder

1.  Copy the file __"dsp.h"__ and paste it as __"sx1262.h"__

1.  Inside the file __"sx1262.h"__, search and replace all __"dsp"__ by __"sx1262"__

    Remember to __Preserve Case!__

    [(See sx1262.h)](https://github.com/lupyuen/nuttx/blob/newlibrary/include/sx1262.h)

1.  Edit the file __"sx1262.h"__, remove all Public Functions Prototypes and add...

    ```c
    void test_libsx1262(void);
    ```

    We'll test this function in a while.

    [(See sx1262.h)](https://github.com/lupyuen/nuttx/blob/master/include/sx1262.h)

## Update Makefiles and Kconfig

Next we update the Makefiles and Kconfig so that NuttX will build our library...

1.  Browse to the [__"nuttx/tools"__](https://github.com/lupyuen/nuttx/tree/newlibrary/tools) folder

1.  Edit the file __"Directories.mk"__

    After __"libdsp"__, insert this section...

    ```text
    ifeq ($(CONFIG_LIBSX1262),y)
    KERNDEPDIRS += libs$(DELIM)libsx1262
    else
    CLEANDIRS += libs$(DELIM)libsx1262
    endif
    ```

    As shown below...

    ![Update "Directories.mk"](https://lupyuen.github.io/images/sx1262-clone5.png)

    [(Source)](https://github.com/lupyuen/nuttx/commit/8bd31da9abccbcfdd1b9b1ccfd22bd41803ac7f8#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281)

1.  Edit the files __"FlatLibs.mk"__, __"KernelLibs.mk"__ and __"ProtectedLibs.mk"__

    After __"libopenamp"__, insert this section...

    ```text
    ifeq ($(CONFIG_LIBSX1262),y)
    NUTTXLIBS += staging$(DELIM)libsx1262$(LIBEXT)
    endif
    ```

    As shown below...

    ![Update Makefiles](https://lupyuen.github.io/images/sx1262-clone6.jpg)

    [(Source)](https://github.com/lupyuen/nuttx/commit/b381a99e7512d09d74db4da982826b5e40b2606a#diff-f9d35d43770d39092a663e665e82ae1d84a9e0da3d0d10c407acada6a40cd281)

1.  Edit the file __"LibTargets.mk"__

    After __"libdsp"__, insert this section...

    ```text
    libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT): pass2dep
        $(Q) $(MAKE) -C libs$(DELIM)libsx1262 libsx1262$(LIBEXT) EXTRAFLAGS="$(EXTRAFLAGS)"

    staging$(DELIM)libsx1262$(LIBEXT): libs$(DELIM)libsx1262$(DELIM)libsx1262$(LIBEXT)
        $(Q) $(call INSTALL_LIB,$<,$@)
    ```

    As shown in the pic above.

1.  Browse to the [__"nuttx"__](https://github.com/lupyuen/nuttx/tree/newlibrary) folder

1.  Edit the file __"Kconfig"__

    Inside the section __menu "Library Routines"__, add this line...

    ```text
    source "libs/libsx1262/Kconfig"
    ```

    ![Update Root Kconfig](https://lupyuen.github.io/images/sx1262-clone3a.png)

    [(Source)](https://github.com/lupyuen/nuttx/commit/6a18348842b5fcec6a9fe8672c0de380b889086c)

1.  Run the following...

    ```bash
    ## TODO: Change this to the path of our "nuttx" folder
    cd nuttx/nuttx

    ## Preserve the Build Config
    cp .config ../config

    ## Erase the Build Config
    make distclean

    ## For BL602: Configure the build for BL602
    ./tools/configure.sh bl602evb:nsh

    ## For PineDio Stack BL604: Configure the build for BL604
    ./tools/configure.sh bl602evb:pinedio

    ## For ESP32: Configure the build for ESP32.
    ## TODO: Change "esp32-devkitc" to our ESP32 board.
    ./tools/configure.sh esp32-devkitc:nsh

    ## Restore the Build Config
    cp ../config .config

    ## Edit the Build Config
    make menuconfig 
    ```

## Enable Library

We enable our library as follows...

1.  In __menuconfig__, select __"Library Routines"__

    Check the box for __"Semtech SX1262 Library"__

    ![Enable Library](https://lupyuen.github.io/images/sx1262-clone7.png)

1.  Hit __"Save"__ then __"OK"__ to save the NuttX Configuration to __".config"__

1.  Hit __"Exit"__ until __menuconfig__ quits

## Verify Library

To verify our library...

1.  We create a simple NuttX App: [__apps/examples/sx1262_test__](https://github.com/lupyuen/nuttx-apps/tree/newlibrary/examples/sx1262_test)

    ```c
    #include <nuttx/config.h>
    #include <stdio.h>
    #include <assert.h>
    #include <fcntl.h>
    #include <sx1262.h>

    int main(int argc, FAR char *argv[])
    {
      printf("Sx1262_test, World!!\n");

      /* Call SX1262 Library */
    
      test_libsx1262();

      return 0;
    }
    ```

    [(Source)](https://github.com/lupyuen/nuttx-apps/blob/newlibrary/examples/sx1262_test/sx1262_test_main.c)

1.  Build ("make"), flash and run the NuttX Firmware on BL602 or ESP32.

1.  In the NuttX Shell, enter...

    ```bash
    sx1262_test
    ```

1.  We should see the message...

    ```text
    libsx1262 OK!
    ```

    Congratulations our library is now running on NuttX!

    ![Our library runs OK](https://lupyuen.github.io/images/sx1262-library4.jpg)

# Appendix: Build, Flash and Run NuttX

_(For BL602 and ESP32)_

Below are the steps to build, flash and run NuttX on BL602 and ESP32.

The instructions below will work on __Linux (Ubuntu)__, __WSL (Ubuntu)__ and __macOS__.

[(Instructions for other platforms)](https://nuttx.apache.org/docs/latest/quickstart/install.html)

[(See this for Arch Linux)](https://popolon.org/gblog3/?p=1977&lang=en)

## Build NuttX

Follow these steps to build NuttX for BL602 or ESP32...

1.  Install the build prerequisites...

    [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

1.  Assume that we have downloaded and configured our NuttX code...

    [__"Build the Firmware"__](https://lupyuen.github.io/articles/sx1262#build-the-firmware)

1.  To build NuttX, enter this command...

    ```bash
    make
    ```

1.  We should see...

    ```text
    LD: nuttx
    CP: nuttx.hex
    CP: nuttx.bin
    ```

    [(See the complete log for BL602)](https://gist.github.com/lupyuen/8f725c278c25e209c1654469a2855746)

1.  __For WSL:__ Copy the __NuttX Firmware__ to the __c:\blflash__ directory in the Windows File System...

    ```bash
    ##  /mnt/c/blflash refers to c:\blflash in Windows
    mkdir /mnt/c/blflash
    cp nuttx.bin /mnt/c/blflash
    ```

    For WSL we need to run __blflash__ under plain old Windows CMD (not WSL) because it needs to access the COM port.

1.  In case of problems, refer to the __NuttX Docs__...

    [__"BL602 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/risc-v/bl602/index.html)

    [__"ESP32 NuttX"__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html)

    [__"Installing NuttX"__](https://nuttx.apache.org/docs/latest/quickstart/install.html)

> ![Building NuttX](https://lupyuen.github.io/images/nuttx-build2.png)

## Flash NuttX

__For ESP32:__ [__See instructions here__](https://nuttx.apache.org/docs/latest/platforms/xtensa/esp32/index.html#flashing) [(Also check out this article)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602:__ Follow these steps to install __blflash__...

1.  [__"Install rustup"__](https://lupyuen.github.io/articles/flash#install-rustup)

1.  [__"Download and build blflash"__](https://lupyuen.github.io/articles/flash#download-and-build-blflash)

We assume that our Firmware Binary File __nuttx.bin__ has been copied to the __blflash__ folder.

Set BL602 / BL604 to __Flashing Mode__ and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __High__ [(Like this)](https://lupyuen.github.io/images/pinedio-high.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`H` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperh.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Connect BL10 to the USB port

1.  Press and hold the __D8 Button (GPIO 8)__

1.  Press and release the __EN Button (Reset)__

1.  Release the D8 Button

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __3.3V__

1.  Reconnect the board to the USB port

Enter these commands to flash __nuttx.bin__ to BL602 / BL604 over UART...

```bash
## For Linux: Change "/dev/ttyUSB0" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/ttyUSB0 

## For macOS: Change "/dev/tty.usbserial-1410" to the BL602 / BL604 Serial Port
blflash flash nuttx.bin \
  --port /dev/tty.usbserial-1410 \
  --initial-baud-rate 230400 \
  --baud-rate 230400

## For Windows: Change "COM5" to the BL602 / BL604 Serial Port
blflash flash c:\blflash\nuttx.bin --port COM5
```

[(See the Output Log)](https://gist.github.com/lupyuen/9c0dbd75bb6b8e810939a36ffb5c399f)

For WSL: Do this under plain old Windows CMD (not WSL) because __blflash__ needs to access the COM port.

[(Flashing WiFi apps to BL602 / BL604? Remember to use __bl_rfbin__)](https://github.com/apache/nuttx/issues/4336)

[(More details on flashing firmware)](https://lupyuen.github.io/articles/flash#flash-the-firmware)

![Flashing NuttX](https://lupyuen.github.io/images/nuttx-flash2.png)

## Run NuttX

__For ESP32:__ Use Picocom to connect to ESP32 over UART...

```bash
picocom -b 115200 /dev/ttyUSB0
```

[(More about this)](https://popolon.org/gblog3/?p=1977&lang=en)

__For BL602:__ Set BL602 / BL604 to __Normal Mode__ (Non-Flashing) and restart the board...

__For PineDio Stack BL604:__

1.  Set the __GPIO 8 Jumper__ to __Low__ [(Like this)](https://lupyuen.github.io/images/pinedio-low.jpg)

1.  Disconnect the USB cable and reconnect

    Or use the Improvised Reset Button [(Here's how)](https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack)

__For PineCone BL602:__

1.  Set the __PineCone Jumper (IO 8)__ to the __`L` Position__ [(Like this)](https://lupyuen.github.io/images/pinecone-jumperl.jpg)

1.  Press the Reset Button

__For BL10:__

1.  Press and release the __EN Button (Reset)__

__For [Ai-Thinker Ai-WB2](https://docs.ai-thinker.com/en/wb2), Pinenut and MagicHome BL602:__

1.  Disconnect the board from the USB Port

1.  Connect __GPIO 8__ to __GND__

1.  Reconnect the board to the USB port

After restarting, connect to BL602 / BL604's UART Port at 2 Mbps like so...

__For Linux:__

```bash
screen /dev/ttyUSB0 2000000
```

__For macOS:__ Use CoolTerm ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__For Windows:__ Use `putty` ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

__Alternatively:__ Use the Web Serial Terminal ([See this](https://lupyuen.github.io/articles/flash#watch-the-firmware-run))

Press Enter to reveal the __NuttX Shell__...

```text
NuttShell (NSH) NuttX-10.2.0-RC0
nsh>
```

Congratulations NuttX is now running on BL602 / BL604!

[(More details on connecting to BL602 / BL604)](https://lupyuen.github.io/articles/flash#watch-the-firmware-run)

![Running NuttX](https://lupyuen.github.io/images/nuttx-boot2.png)

__macOS Tip:__ Here's the script I use to build, flash and run NuttX on macOS, all in a single step: [run.sh](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

![Script to build, flash and run NuttX on macOS](https://lupyuen.github.io/images/spi2-script.png)

[(Source)](https://gist.github.com/lupyuen/cc21385ecc66b5c02d15affd776a64af)

# Appendix: Radio Functions

In this section we explain the Platform-Independent __Radio Functions__ for Semtech SX1262 Transceiver: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c)

-   [__RadioInit:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L522-L559) Initialise LoRa SX1262

-   [__RadioSetChannel:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L599-L604) Set LoRa Frequency

-   [__RadioSetTxConfig:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L787-L908) Set LoRa Transmit Configuration

-   [__RadioSetRxConfig:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L660-L786) Set LoRa Receive Configuration

-   [__RadioSend:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1068-L1098) Transmit a LoRa Message

-   [__RadioRx:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1116-L1138) Receive one LoRa Message

-   [__RadioIrqProcess:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1313-L1460) Process Transmit and Receive Interrupts

-   [__RadioSleep:__](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1099-L1109) Switch SX1262 to low-power sleep mode

The code is nearly identical to [____Semtech's Reference Implementation____](https://github.com/Lora-net/LoRaMac-node/tree/master/src/radio/sx126x) of SX1262 Driver (29 Mar 2021).

(So it should work perfectly fine with Semtech's LoRaWAN Stack, as explained in the next article)

The Radio Functions will trigger the following __Callback Functions__ to handle __Radio Events__: [radio.h](https://github.com/lupyuen/lora-sx1262/blob/lorawan/include/radio.h#L54-L109)

-   [__TxDone:__](https://lupyuen.github.io/articles/sx1262#transmit-done) Transmit Done

-   [__RxDone:__](https://lupyuen.github.io/articles/sx1262#receive-done) Receive Done

-   [__RxError:__](https://lupyuen.github.io/articles/sx1262#receive-done) Receive Error

-   [__TxTimeout:__](https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout) Transmit Timeout

-   [__RxTimeout:__](https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout) Receive Timeout or Header Error

-   [__CadDone:__](https://lupyuen.github.io/articles/sx1262#cad-done) Channel Activity Detection Done

The Callback Functions are defined in our LoRa Test App.

(Also in the LoRaWAN Library, as explained in the next article)

## RadioInit: Initialise LoRa Module

__RadioInit__ initialises the LoRa SX1262 Module: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L522-L559)

```c
void RadioInit( RadioEvents_t *events ) {
  //  We copy the Event Callbacks from "events", because
  //  "events" may be stored on the stack
  assert(events != NULL);
  memcpy(&RadioEvents, events, sizeof(RadioEvents));
  //  Previously: RadioEvents = events;
```

The function begins by copying the list of __Radio Event Callbacks__...

-   [__TxDone:__](https://lupyuen.github.io/articles/sx1262#transmit-done) Called when a LoRa Message has been transmitted

-   [__RxDone:__](https://lupyuen.github.io/articles/sx1262#receive-done) Called when a LoRa Message has been received

-   [__TxTimeout:__](https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout) Called upon timeout when transmitting a LoRa Message

-   [__RxTimeout:__](https://lupyuen.github.io/articles/sx1262#transmit--receive-timeout)  Called upon timeout when receiving a LoRa Message

-   [__RxError:__](https://lupyuen.github.io/articles/sx1262#receive-done) Called when a LoRa Message has been received with CRC Error

This differs from the Semtech Reference Implementation, which copies the pointer to __RadioEvents_t__ instead of the entire __RadioEvents_t__.

(Which causes problems when __RadioEvents_t__ lives on the stack)

Next we __init the SPI and GPIO Ports__, wake up the LoRa Module, and init the TCXO Control and RF Switch Control.

```c
  //  Init SPI and GPIO Ports, wake up the LoRa Module,
  //  init TCXO Control and RF Switch Control.
  SX126xInit( RadioOnDioIrq );
```

[(__SX126xInit__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L112-L131)

[(__RadioOnDioIrq__ is explained here)](https://lupyuen.github.io/articles/sx1262#radioondioirq)

We set the LoRa Module to __Standby Mode__...

```c
  //  Set LoRa Module to standby mode
  SX126xSetStandby( STDBY_RC );
```

We set the __Power Regulation: LDO or DC-DC__...

```c
  //  TODO: Declare the power regulation used to power the device
  //  This command allows the user to specify if DC-DC or LDO is used for power regulation.
  //  Using only LDO implies that the Rx or Tx current is doubled

  //  #warning SX126x is set to LDO power regulator mode (instead of DC-DC)
  //  SX126xSetRegulatorMode( USE_LDO );   //  Use LDO

  //  #warning SX126x is set to DC-DC power regulator mode (instead of LDO)
  SX126xSetRegulatorMode( USE_DCDC );  //  Use DC-DC
```

[(__SX126xSetRegulatorMode__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L390-L393)

This depends on how our LoRa Module is wired for power.

For now we're using __DC-DC__ Power Regulation. (To be verified)

[(More about LDO vs DC-DC Power Regulation)](https://lupyuen.github.io/articles/lorawan#dc-dc-vs-ldo)

We set the __Base Addresses__ of the Read and Write Buffers to 0...

```c
  //  Set the base addresses of the Read and Write Buffers to 0
  SX126xSetBufferBaseAddress( 0x00, 0x00 );
```

[(__SX126xSetBufferBaseAddress__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L697-L704)

The Read and Write Buffers are accessed by [__sx126x_read_buffer__](https://lupyuen.github.io/articles/sx1262#receive-message) and [__sx126x_write_buffer__](https://lupyuen.github.io/articles/sx1262#transmit-message).

We set the __Transmit Power__ and the __Ramp Up Time__...

```c
  //  TODO: Set the correct transmit power and ramp up time
  SX126xSetTxParams( 22, RADIO_RAMP_3400_US );
  //  TODO: Previously: SX126xSetTxParams( 0, RADIO_RAMP_200_US );
```

[(__SX126xSetTxParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L528-L576)

__Ramp Up Time__ is the duration (in microseconds) we need to wait for SX1262's Power Amplifier to ramp up (charge up) to the configured Transmit Power.

For easier testing we have set the Transmit Power to __22 dBm__ (highest power) and Ramp Up Time to __3400 microseconds__ (longest duration).

(To give sufficient time for the Power Amplifier to ramp up to the highest Transmit Power)

After testing we should revert to the __Default Transmit Power__ (0) and __Ramp Up Time__ (200 microseconds).

[(More about the Transmit Power)](https://lupyuen.github.io/articles/lorawan#transmit-power)

[(Over Current Protection in __SX126xSetTxParams__)](https://lupyuen.github.io/articles/lorawan#over-current-protection)

We configure which __LoRa Events will trigger interrupts__ on each DIO Pin...

```c
  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
```

[(__SX126xSetDioIrqParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470)

(All LoRa Events will trigger interrupts on DIO1)

We define the SX1262 Registers that will be restored from __Retention Memory__ when waking up from Warm Start Mode...

```c
  //  Add registers to the retention list (4 is the maximum possible number)
  RadioAddRegisterToRetentionList( REG_RX_GAIN );
  RadioAddRegisterToRetentionList( REG_TX_MODULATION );
```

[(__RadioAddRegisterToRetentionList__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1167-L1195)

Finally we init the Timeout Timers (from NimBLE Porting Layer) for __Transmit Timeout__ and __Receive Timeout__...

```c
  //  Initialize driver timeout timers
  TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
  TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );

  //  Interrupt not fired yet
  IrqFired = false;
}
```

[(__TimerInit__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L384-L405)

## RadioSetChannel: Set LoRa Frequency

__RadioSetChannel__ sets the LoRa Frequency: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L599-L604)

```c
void RadioSetChannel( uint32_t freq ) {
  SX126xSetRfFrequency( freq );
}
```

__RadioSetChannel__ passes the LoRa Frequency (like `923000000` for 923 MHz) to __SX126xSetRfFrequency__.

__SX126xSetRfFrequency__ is defined as follows: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L497-L514)

```c
void SX126xSetRfFrequency( uint32_t frequency ) {
  uint8_t buf[4];
  if( ImageCalibrated == false ) {
    SX126xCalibrateImage( frequency );
    ImageCalibrated = true;
  }
  uint32_t freqInPllSteps = SX126xConvertFreqInHzToPllStep( frequency );
  buf[0] = ( uint8_t )( ( freqInPllSteps >> 24 ) & 0xFF );
  buf[1] = ( uint8_t )( ( freqInPllSteps >> 16 ) & 0xFF );
  buf[2] = ( uint8_t )( ( freqInPllSteps >> 8 ) & 0xFF );
  buf[3] = ( uint8_t )( freqInPllSteps & 0xFF );
  SX126xWriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
}
```

[(__SX126xCalibrateImage__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L408-L438)

[(__SX126xConvertFreqInHzToPllStep__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L812-L826)

[(__SX126xWriteCommand__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235)

## RadioSetTxConfig: Set Transmit Configuration

__RadioSetTxConfig__ sets the LoRa Transmit Configuration: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L787-L908)

```c
void RadioSetTxConfig( RadioModems_t modem, int8_t power, uint32_t fdev,
  uint32_t bandwidth, uint32_t datarate,
  uint8_t coderate, uint16_t preambleLen,
  bool fixLen, bool crcOn, bool freqHopOn,
  uint8_t hopPeriod, bool iqInverted, uint32_t timeout ) {

  //  LoRa Modulation or FSK Modulation?
  switch( modem ) {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...
```

Since we're using __LoRa Modulation__ instead of FSK Modulation, we skip the section on FSK Modulation.

We begin by populating the __Modulation Parameters__: Spreading Factor, Bandwidth and Coding Rate...

```c
    case MODEM_LORA:
      //  LoRa Modulation
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t ) datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth =  
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;
```

Depending on the LoRa Parameters, we optimise for __Low Data Rate__...

```c
      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) && ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }
```

Next we populate the __Packet Parameters__: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ...

```c
      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
        ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ) {
        if( preambleLen < 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;
```

We set the LoRa Module to __Standby Mode__ and configure it for __LoRa Modulation__ (or FSK Modulation)...

```c
      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
        ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
        ? MODEM_FSK 
        : MODEM_LORA
      );
```

[(__RadioStandby__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1111-L1115)

[(__RadioSetModem__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L576-L598)

We configure the LoRa Module with the __Modulation Parameters__ and __Packet Parameters__...

```c
      //  Configure Modulation Parameters
      SX126xSetModulationParams( &SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &SX126x.PacketParams );
      break;
  }
```

[(__SX126xSetModulationParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L578-L621)

[(__SX126xSetPacketParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680)

This is a Workaround for __Modulation Quality__ with __500 kHz Bandwidth__...

```c
  // WORKAROUND - Modulation Quality with 500 kHz LoRa Bandwidth, see DS_SX1261-2_V1.2 datasheet chapter 15.1
  if( ( modem == MODEM_LORA ) && ( SX126x.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) ) {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) & ~( 1 << 2 ) 
    );
  } else {
    SX126xWriteRegister( 
      REG_TX_MODULATION, 
      SX126xReadRegister( REG_TX_MODULATION ) | ( 1 << 2 ) 
    );
  }
  // WORKAROUND END
```

[(__SX126xWriteRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284)

[(__SX126xReadRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299)

We finish by setting the __Transmit Power__ and __Transmit Timeout__...

```c
  //  Set Transmit Power
  SX126xSetRfTxPower( power );

  //  Set Transmit Timeout
  TxTimeout = timeout;
}
```

__SX126xSetRfTxPower__ is defined in [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L317-L322)...

```c
void SX126xSetRfTxPower( int8_t power ) {
  //  TODO: Previously: SX126xSetTxParams( power, RADIO_RAMP_40_US );
  SX126xSetTxParams( power, RADIO_RAMP_3400_US );  //  TODO
}
```

For easier testing we have set the Ramp Up Time to __3400 microseconds__ (longest duration).

After testing we should revert to the __Default Ramp Up Time__ (40 microseconds).

## RadioSetRxConfig: Set Receive Configuration

__RadioSetRxConfig__ sets the LoRa Receive Configuration: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L660-L786)

```c
void RadioSetRxConfig( RadioModems_t modem, uint32_t bandwidth,
  uint32_t datarate, uint8_t coderate,
  uint32_t bandwidthAfc, uint16_t preambleLen,
  uint16_t symbTimeout, bool fixLen,
  uint8_t payloadLen,
  bool crcOn, bool freqHopOn, uint8_t hopPeriod,
  bool iqInverted, bool rxContinuous ) {

  //  Set Symbol Timeout
  RxContinuous = rxContinuous;
  if( rxContinuous == true ) {
    symbTimeout = 0;
  }

  //  Set Max Payload Length
  if( fixLen == true ) {
    MaxPayloadLength = payloadLen;
  }
  else {
    MaxPayloadLength = 0xFF;
  }
```

We begin by setting the __Symbol Timeout__ and __Max Payload Length__.

Since we're using __LoRa Modulation__ instead of FSK Modulation, we skip the section on FSK Modulation...

```c
  //  LoRa Modulation or FSK Modulation?
  switch( modem )
  {
    case MODEM_FSK:
      //  Omitted: FSK Modulation
      ...
```

We populate the __Modulation Parameters__: Spreading Factor, Bandwidth and Coding Rate...

```c
    case MODEM_LORA:
      //  LoRa Modulation
      SX126xSetStopRxTimerOnPreambleDetect( false );
      SX126x.ModulationParams.PacketType = 
        PACKET_TYPE_LORA;
      SX126x.ModulationParams.Params.LoRa.SpreadingFactor = 
        ( RadioLoRaSpreadingFactors_t )datarate;
      SX126x.ModulationParams.Params.LoRa.Bandwidth = 
        Bandwidths[bandwidth];
      SX126x.ModulationParams.Params.LoRa.CodingRate = 
        ( RadioLoRaCodingRates_t )coderate;
```

Depending on the LoRa Parameters, we optimise for __Low Data Rate__...

```c
      //  Optimise for Low Data Rate
      if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
      ( ( bandwidth == 1 ) && ( datarate == 12 ) ) ) {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
      } else {
        SX126x.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
      }
```

We populate the __Packet Parameters__: Preamble Length, Header Type, Payload Length, CRC Mode and Invert IQ...

```c
      //  Populate Packet Type
      SX126x.PacketParams.PacketType = PACKET_TYPE_LORA;

      //  Populate Preamble Length
      if( ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
          ( SX126x.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF6 ) ){
        if( preambleLen < 12 ) {
          SX126x.PacketParams.Params.LoRa.PreambleLength = 12;
        } else {
          SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
        }
      } else {
        SX126x.PacketParams.Params.LoRa.PreambleLength = preambleLen;
      }

      //  Populate Header Type, Payload Length, CRC Mode and Invert IQ
      SX126x.PacketParams.Params.LoRa.HeaderType = 
        ( RadioLoRaPacketLengthsMode_t )fixLen;
      SX126x.PacketParams.Params.LoRa.PayloadLength = 
        MaxPayloadLength;
      SX126x.PacketParams.Params.LoRa.CrcMode = 
        ( RadioLoRaCrcModes_t )crcOn;
      SX126x.PacketParams.Params.LoRa.InvertIQ = 
        ( RadioLoRaIQModes_t )iqInverted;
```

We set the LoRa Module to __Standby Mode__ and configure it for __LoRa Modulation__ (or FSK Modulation)...

```c
      //  Set LoRa Module to Standby Mode
      RadioStandby( );

      //  Configure LoRa Module for LoRa Modulation (or FSK Modulation)
      RadioSetModem( 
          ( SX126x.ModulationParams.PacketType == PACKET_TYPE_GFSK ) 
          ? MODEM_FSK 
          : MODEM_LORA 
      );
```

[(__RadioStandby__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1111-L1115)

[(__RadioSetModem__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L576-L598)

We configure the LoRa Module with the __Modulation Parameters__, __Packet Parameters__ and Symbol Timeout...

```c
      //  Configure Modulation Parameters
      SX126xSetModulationParams( &SX126x.ModulationParams );

      //  Configure Packet Parameters
      SX126xSetPacketParams( &SX126x.PacketParams );

      //  Configure Symbol Timeout
      SX126xSetLoRaSymbNumTimeout( symbTimeout );
```

[(__SX126xSetModulationParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L578-L621)

[(__SX126xSetPacketParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680)

[(__SX126xSetLoRaSymbNumTimeout__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L366-L388)

This is a Workaround that __optimises the Inverted IQ Operation__...

```c
      // WORKAROUND - Optimizing the Inverted IQ Operation, see DS_SX1261-2_V1.2 datasheet chapter 15.4
      if( SX126x.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED ) {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) & ~( 1 << 2 ) 
        );
      } else {
        SX126xWriteRegister( 
          REG_IQ_POLARITY, 
          SX126xReadRegister( REG_IQ_POLARITY ) | ( 1 << 2 ) 
        );
      }
      // WORKAROUND END
```

[(__SX126xWriteRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284)

[(__SX126xReadRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299)

We finish by setting the __Receive Timeout__ to No Timeout (always receiving)...

```c
      // Timeout Max, Timeout handled directly in SetRx function
      RxTimeout = 0xFFFF;
      break;
  }
}
```

## RadioSend: Transmit Message

__RadioSend__ transmits a LoRa Message: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1068-L1098)

```c
void RadioSend( uint8_t *buffer, uint8_t size ) {

  //  Set the DIO Interrupt Events:
  //  Transmit Done and Transmit Timeout
  //  will trigger interrupts on DIO1
  SX126xSetDioIrqParams( 
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Mask
    IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT,  //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
```

[(__SX126xSetDioIrqParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470)

We begin by configuring which __LoRa Events will trigger interrupts__ on each DIO Pin.

(Transmit Done and Transmit Timeout will trigger interrupts on DIO1)

Next we configure the __Packet Parameters__...

```c
  //  Populate the payload length
  if( SX126xGetPacketType( ) == PACKET_TYPE_LORA ) {
    SX126x.PacketParams.Params.LoRa.PayloadLength = size;
  } else {
    SX126x.PacketParams.Params.Gfsk.PayloadLength = size;
  }
  //  Configure the packet parameters
  SX126xSetPacketParams( &SX126x.PacketParams );
```

[(__SX126xGetPacketType__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L523-L526)

[(__SX126xSetPacketParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L623-L680)

We finish by sending the __Message Payload__ and starting the __Transmit Timer__...

```c
  //  Send message payload
  SX126xSendPayload( buffer, size, 0 );

  //  Start Transmit Timer
  TimerStart2( &TxTimeoutTimer, TxTimeout );
}
```

[(__TimerStart2__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L466-L491)

__SX126xSendPayload__ is defined below: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L162-L166)

```c
///  Send message payload
void SX126xSendPayload( uint8_t *payload, uint8_t size, uint32_t timeout ) {
  //  Copy message payload to Transmit Buffer
  SX126xSetPayload( payload, size );

  //  Transmit the buffer
  SX126xSetTx( timeout );
}
```

[(__SX126xSetTx__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L289-L299)

This code copies the Message Payload to the SX1262 __Transmit Buffer__ and transmits the message.

__SX126xSetPayload__ copies to the Transmit Buffer by calling __SX126xWriteBuffer__: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L144-L147)

```c
/// Copy message payload to Transmit Buffer
void SX126xSetPayload( uint8_t *payload, uint8_t size ) {
  //  Copy message payload to Transmit Buffer
  SX126xWriteBuffer( 0x00, payload, size );
}
```

__SX126xWriteBuffer__ wakes up the LoRa Module, writes to the Transmit Buffer and waits for the operation to be completed: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L283-L289)

```c
/// Copy message payload to Transmit Buffer
void SX126xWriteBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload to Transmit Buffer
  int rc = sx126x_write_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}
```

[(__SX126xCheckDeviceReady__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142)

[(__sx126x_write_buffer__ is explained here)](https://lupyuen.github.io/articles/sx1262#transmit-message)

[(__SX126xWaitOnBusy__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200)

When the LoRa Message is transmitted (successfully or unsuccessfully), the LoRa Module triggers a __DIO1 Interrupt__.

Our driver calls __RadioIrqProcess__ to process the interrupt. [(See this)](https://lupyuen.github.io/articles/sx1262#radioirqprocess-process-transmit-and-receive-interrupts)

## RadioRx: Receive Message

__RadioRx__ preps SX1262 to receive a single LoRa Message: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1116-L1138)

```c
void RadioRx( uint32_t timeout ) {

  //  Set the DIO Interrupt Events:
  //  All LoRa Events will trigger interrupts on DIO1
  SX126xSetDioIrqParams(
    IRQ_RADIO_ALL,   //  Interrupt Mask
    IRQ_RADIO_ALL,   //  Interrupt Events for DIO1
    IRQ_RADIO_NONE,  //  Interrupt Events for DIO2
    IRQ_RADIO_NONE   //  Interrupt Events for DIO3
  );
```

[(__SX126xSetDioIrqParams__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L457-L470)

We begin by configuring which __LoRa Events will trigger interrupts__ on each DIO Pin.

(All LoRa Events will trigger interrupts on DIO1)

We start the __Receive Timer__ to catch Receive Timeouts...

```c
  //  Start the Receive Timer
  if( timeout != 0 ) {
    TimerStart2( &RxTimeoutTimer, timeout );
  }
```

[(__TimerStart2__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L466-L491)

Now we begin to __receive a LoRa Message__ continuously, or until a timeout occurs...

```c
  if( RxContinuous == true ) {
    //  Receive continuously
    SX126xSetRx( 0xFFFFFF ); // Rx Continuous
  } else {
    //  Receive with timeout
    SX126xSetRx( RxTimeout << 6 );
  }
}
```

__SX126xSetRx__ enters Receive Mode like so: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L301-L313)

```c
void SX126xSetRx( uint32_t timeout ) {
  uint8_t buf[3];

  //  Remember we're in Receive Mode
  SX126xSetOperatingMode( MODE_RX );

  //  Configure Receive Gain
  SX126xWriteRegister( REG_RX_GAIN, 0x94 ); // default gain

  //  Enter Receive Mode
  buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
  buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
  buf[2] = ( uint8_t )( timeout & 0xFF );
  SX126xWriteCommand( RADIO_SET_RX, buf, 3 );
}
```

[(__SX126xSetOperatingMode__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161)

[(__SX126xWriteRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284)

[(__SX126xWriteCommand__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235)

When a LoRa Message is received (successfully or unsuccessfully), the LoRa Module triggers a __DIO1 Interrupt__.

Our driver calls __RadioIrqProcess__ to process the interrupt, which is explained next...

## RadioIrqProcess: Process Transmit and Receive Interrupts

__RadioIrqProcess__ processes the interrupts that are triggered when a LoRa Message is transmitted and received: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1313-L1460)

```c
/// Process Transmit and Receive Interrupts.
/// For BL602: Must be run in the Application
/// Task Context, not Interrupt Context because 
/// we will call printf and SPI Functions here.
void RadioIrqProcess( void ) {

  //  Remember and clear Interrupt Flag
  CRITICAL_SECTION_BEGIN( );
  const bool isIrqFired = IrqFired;
  IrqFired = false;
  CRITICAL_SECTION_END( );
```

[(Note: Critical Sections are not yet implemented)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/include/sx126x-board.h#L58-L60)

The function begins by copying the __Interrupt Flag__ and clearing the flag.

[(The Interrupt Flag is set by __RadioOnDioIrq__)](https://lupyuen.github.io/articles/sx1262#radioondioirq)

The rest of the function will run only if the __Interrupt Flag was originally set__...

```c
  //  IrqFired must be true to process interrupts
  if( isIrqFired == true ) {
    //  Get the Interrupt Status
    uint16_t irqRegs = SX126xGetIrqStatus( );

    //  Clear the Interrupt Status
    SX126xClearIrqStatus( irqRegs );
```

[(__SX126xGetIrqStatus__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L472-L478)

[(__SX126xClearIrqStatus__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L803-L810)

This code fetches the __Interrupt Status__ from the LoRa Module and clears the Interrupt Status.

If DIO1 is still High, we set the __Interrupt Flag__ for future processing...

```c
    //  Check if DIO1 pin is High. If it is the case revert IrqFired to true
    CRITICAL_SECTION_BEGIN( );
    if( SX126xGetDio1PinState( ) == 1 ) {
      IrqFired = true;
    }
    CRITICAL_SECTION_END( );
```

__Interrupt Status__ tells us which LoRa Events have just occurred. We handle the LoRa Events accordingly...

-   Transmit Done

-   Receive Done

-   CAD Done

-   Transmit / Receive Timeout

-   Preamble Detected

-   Sync Word Valid

-   Header Valid

-   Header Error

### Transmit Done

When the LoRa Module has transmitted a LoRa Message successfully, we stop the Transmit Timer and call the __Callback Function for Transmit Done__: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1339-L1349)

```c
    //  If a LoRa Message was transmitted successfully...
    if( ( irqRegs & IRQ_TX_DONE ) == IRQ_TX_DONE ) {

      //  Stop the Transmit Timer
      TimerStop( &TxTimeoutTimer );

      //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call the Callback Function for Transmit Done
      if( ( RadioEvents.TxDone != NULL ) ) {
        RadioEvents.TxDone( );
      }
    }
```

[(__TimerStop__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L407-L419)

[(__SX126xSetOperatingMode__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161)

__TxDone__ points to the __on_tx_done__ Callback Function that we've seen earlier.

### Receive Done

When the LoRa Module receives a LoRa Message, we stop the Receive Timer: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1351-L1389)

```c
    //  If a LoRa Message was received...
    if( ( irqRegs & IRQ_RX_DONE ) == IRQ_RX_DONE ) {

      //  Stop the Receive Timer
      TimerStop( &RxTimeoutTimer );
```

In case of CRC Error, we call the __Callback Function for Receive Error__...

```c
      if( ( irqRegs & IRQ_CRC_ERROR ) == IRQ_CRC_ERROR ) {

        //  If the received message has CRC Error...
        if( RxContinuous == false ) {
          //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );
        }

        //  Call the Callback Function for Receive Error
        if( ( RadioEvents.RxError ) ) {
          RadioEvents.RxError( );
        }
```

__RxError__ points to the __on_rx_error__ Callback Function that we've seen earlier.

If the received message has no CRC Error, we do this Workaround for __Implicit Header Mode Timeout Behavior__...

```c
      } else {
        //  If the received message has no CRC Error...
        uint8_t size;

        //  If we are receiving continously...
        if( RxContinuous == false ) {
          //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
          SX126xSetOperatingMode( MODE_STDBY_RC );

          // WORKAROUND - Implicit Header Mode Timeout Behavior, see DS_SX1261-2_V1.2 datasheet chapter 15.3
          SX126xWriteRegister( REG_RTC_CTRL, 0x00 );
          SX126xWriteRegister( 
            REG_EVT_CLR, 
            SX126xReadRegister( REG_EVT_CLR ) | ( 1 << 1 ) 
          );
          // WORKAROUND END
        }
```

[(__SX126xWriteRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L281-L284)

[(__SX126xReadRegister__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L294-L299)

Then we copy the __Received Message Payload__ and get the __Packet Status__...

```c
        //  Copy the Received Message Payload (max 255 bytes)
        SX126xGetPayload( RadioRxPayload, &size , 255 );
        
        //  Get the Packet Status:
        //  Packet Signal Strength (RSSI), Signal-to-Noise Ratio (SNR),
        //  Signal RSSI, Frequency Error
        SX126xGetPacketStatus( &RadioPktStatus );
```

[(__SX126xGetPacketStatus__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L746-L778)

And we call the __Callback Function for Receive Done__...

```c
        //  Call the Callback Function for Receive Done
        if( ( RadioEvents.RxDone != NULL ) ) {
          RadioEvents.RxDone( 
            RadioRxPayload, 
            size, 
            RadioPktStatus.Params.LoRa.RssiPkt, 
            RadioPktStatus.Params.LoRa.SnrPkt 
          );
        }
      }
    }
```

__RxDone__ points to the __on_rx_done__ Callback Function that we've seen earlier.

__SX126xGetPayload__ copies the received message payload from the SX1262 __Receive Buffer__: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L149-L160)

```c
/// Copy message payload from Receive Buffer
uint8_t SX126xGetPayload( uint8_t *buffer, uint8_t *size,  uint8_t maxSize ) {
  uint8_t offset = 0;

  //  Get the size and offset of the received message
  //  in the Receive Buffer
  SX126xGetRxBufferStatus( size, &offset );
  if( *size > maxSize ) {
    return 1;
  }

  //  Copy message payload from Receive Buffer
  SX126xReadBuffer( offset, buffer, *size );
  return 0;
}
```

[(__SX126xGetRxBufferStatus__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L727-L744)

__SX126xReadBuffer__ wakes up the LoRa Module, reads from the Receive Buffer and waits for the operation to be completed: [sx126x-nuttx.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L309-L315)

```c
/// Copy message payload from Receive Buffer
void SX126xReadBuffer( uint8_t offset, uint8_t *buffer, uint8_t size ) {
  //  Wake up SX1262 if sleeping
  SX126xCheckDeviceReady( );

  //  Copy message payload from Receive Buffer
  int rc = sx126x_read_buffer(NULL, offset, buffer, size);
  assert(rc == 0);

  //  Wait for SX1262 to be ready
  SX126xWaitOnBusy( );
}
```

[(__SX126xCheckDeviceReady__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L133-L142)

[(__sx126x_read_buffer__ is explained here)](https://lupyuen.github.io/articles/sx1262#receive-message)

[(__SX126xWaitOnBusy__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L185-L200)

### CAD Done

__Channel Activity Detection__ lets us __detect whether there's any ongoing transmission__ in a LoRa Radio Channel, in a power-efficient way.

We won't be doing Channel Activity Detection in our driver: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1391-L1400)

```c
    //  If Channel Activity Detection is complete...
    if( ( irqRegs & IRQ_CAD_DONE ) == IRQ_CAD_DONE ) {

      //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
      SX126xSetOperatingMode( MODE_STDBY_RC );

      //  Call Callback Function for CAD Done
      if( ( RadioEvents.CadDone != NULL ) ) {
        RadioEvents.CadDone( ( 
            ( irqRegs & IRQ_CAD_ACTIVITY_DETECTED ) 
            == IRQ_CAD_ACTIVITY_DETECTED 
        ) );
      }
    }
```

### Transmit / Receive Timeout

When the LoRa Module __fails to transmit__ a LoRa Message due to Timeout, we stop the Transmit Timer and call the __Callback Function for Transmit Timeout__: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1402-L1425)

```c
    //  If a LoRa Message failed to Transmit or Receive due to Timeout...
    if( ( irqRegs & IRQ_RX_TX_TIMEOUT ) == IRQ_RX_TX_TIMEOUT ) {

      //  If the message failed to Transmit due to Timeout...
      if( SX126xGetOperatingMode( ) == MODE_TX ) {

        //  Stop the Transmit Timer
        TimerStop( &TxTimeoutTimer );

        //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Transmit Timeout
        if( ( RadioEvents.TxTimeout != NULL ) ) {
          RadioEvents.TxTimeout( );
        }
      }
```

[(__SX126xGetOperatingMode__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L135-L138)

__TxTimeout__ points to the __on_tx_timeout__ Callback Function that we've seen earlier.

When the LoRa Module __fails to receive__ a LoRa Message due to Timeout, we stop the Receive Timer and call the __Callback Function for Receive Timeout__...

```c
      //  If the message failed to Receive due to Timeout...
      else if( SX126xGetOperatingMode( ) == MODE_RX ) {

        //  Stop the Receive Timer
        TimerStop( &RxTimeoutTimer );

        //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );

        //  Call the Callback Function for Receive Timeout
        if( ( RadioEvents.RxTimeout != NULL ) ) {
          RadioEvents.RxTimeout( );
        }
      }
    }
```

__RxTimeout__ points to the __on_rx_timeout__ Callback Function that we've seen earlier.

### Preamble Detected

Preamble is the Radio Signal that __precedes the LoRa Message__. When the LoRa Module detects the Preamble Signal, it knows that it's about to receive a LoRa Message.

We don't need to handle the Preamble Signal, the LoRa Module does it for us: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1427-L1431)

```c
    //  If LoRa Preamble was detected...
    if( ( irqRegs & IRQ_PREAMBLE_DETECTED ) == IRQ_PREAMBLE_DETECTED ) {
      //__NOP( );
    }
```

Our [__Receive Message Log__](https://gist.github.com/lupyuen/0d78b13871fca41ac6d812407890b29b) shows that the Preamble Signal (__IRQ_PREAMBLE_DETECTED__) is always detected before receiving a LoRa Message.

(__IRQ_PREAMBLE_DETECTED__ appears just before the LoRa Header: __IRQ_HEADER_VALID__)

[(More about LoRa Preamble)](https://www.link-labs.com/blog/what-is-lora)

### Sync Word Valid

__Sync Words__ are 16-bit values that differentiate the types of LoRa Networks.

The LoRa Module detects the Sync Words when it receive a LoRa Message: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1433-L1437)

```c
    //  If a valid Sync Word was detected...
    if( ( irqRegs & IRQ_SYNCWORD_VALID ) == IRQ_SYNCWORD_VALID ) {
      //__NOP( );
    }
```

Note that the __Sync Word differs for LoRaWAN__ vs Private LoRa Networks...

```c
//  Syncword for Private LoRa networks
#define LORA_MAC_PRIVATE_SYNCWORD                   0x1424

//  Syncword for Public LoRa networks (LoRaWAN)
#define LORA_MAC_PUBLIC_SYNCWORD                    0x3444
```

[(More about Sync Words)](https://lupyuen.github.io/articles/lorawan#appendix-lora-sync-word)

### Header Valid

The LoRa Module checks for a __valid LoRa Header__ when receiving a LoRa Message: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1439-L1443)

```c
    //  If a valid Header was received...
    if( ( irqRegs & IRQ_HEADER_VALID ) == IRQ_HEADER_VALID ) {
      //__NOP( );
    }
```

Our [__Receive Message Log__](https://github.com/lupyuen/lora-sx1262#receive-message) shows that the LoRa Header (__IRQ_HEADER_VALID__) is always detected before receiving a LoRa Message.

(__IRQ_HEADER_VALID__ appears right after the Preamble Signal: __IRQ_PREAMBLE_DETECTED__)

### Header Error

When the LoRa Module detects a __LoRa Header with CRC Error__, we stop the Receive Timer and call the Callback Function for Receive Timeout: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1445-L1458)

```c
    //  If a Header with CRC Error was received...
    if( ( irqRegs & IRQ_HEADER_ERROR ) == IRQ_HEADER_ERROR ) {

      //  Stop the Receive Timer
      TimerStop( &RxTimeoutTimer );

      if( RxContinuous == false ) {
        //!< Update operating mode state to a value lower than \ref MODE_STDBY_XOSC
        SX126xSetOperatingMode( MODE_STDBY_RC );
      }

      //  Call the Callback Function for Receive Timeout
      if( ( RadioEvents.RxTimeout != NULL ) ) {
        RadioEvents.RxTimeout( );
      }
    }
  }
}
```

__RxTimeout__ points to the __on_rx_timeout__ Callback Function that we've seen earlier.

### RadioOnDioIrq

__RadioIrqProcess__ (as defined above) is called by __RadioOnDioIrq__ to handle LoRa Transmit and Receive Events: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1300-L1312)

```c
/// Callback Function for Transmit and Receive Interrupts.
/// For BL602: This function runs in the context of the 
/// Background Application Task. So we are safe to call 
/// printf and SPI Functions now.
void RadioOnDioIrq( struct ble_npl_event *ev ) {
  //  Set the Interrupt Flag
  IrqFired = true;

  //  BL602 Note: It's OK to process the interrupt here because we are in
  //  Application Task Context, not Interrupt Context.
  //  The Reference Implementation processes the interrupt in the main loop.
  RadioIrqProcess();
}
```

## RadioSleep: Switch to Sleep Mode

__RadioSleep__ switches SX1262 to low-power sleep mode: [radio.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L1099-L1109)

```c
/// Switch to Sleep Mode
void RadioSleep( void ) {
  SleepParams_t params = { 0 };
  params.Fields.WarmStart = 1;

  //  Switch to Sleep Mode and wait 2 milliseconds
  SX126xSetSleep( params );
  DelayMs( 2 );
}
```

__SX126xSetSleep__ executes the Sleep Command on the LoRa Module: [sx126x.c](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L253-L268)

```c
/// Switch to Sleep Mode
void SX126xSetSleep( SleepParams_t sleepConfig ) {
  //  Switch off antenna (not used)
  SX126xAntSwOff( );

  //  Compute Sleep Parameter
  uint8_t value = ( 
      ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) 
  );

  if( sleepConfig.Fields.WarmStart == 0 ) {
    // Force image calibration
    ImageCalibrated = false;
  }

  //  Run Sleep Command
  SX126xWriteCommand( RADIO_SET_SLEEP, &value, 1 );
  SX126xSetOperatingMode( MODE_SLEEP );
}
```

[(__SX126xAntSwOff__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L342-L347)

[(__SX126xWriteCommand__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L222-L235)

[(__SX126xSetOperatingMode__ is defined here)](https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L140-L161)

# Appendix: GPIO Pin Type Issue

When we switch a GPIO Interrupt Pin Type to Trigger On Rising Edge, it crashes with an Assertion Failure... 

```
nsh> gpio -t 8 -w 1 /dev/gpio2

Driver: /dev/gpio2
up_assert: Assertion failed at file:ioexpander/gpio.c line: 544 task: gpio
```

(For PineDio Stack BL604: Use "/dev/gpio19")

I'll submit a NuttX Issue, meanwhile I have disabled the assertion...

-   [drivers/ioexpander/gpio.c (line 544)](https://github.com/lupyuen/nuttx/blob/lorawan/drivers/ioexpander/gpio.c#L544-L547)

![GPIO Pin Type Issue](https://lupyuen.github.io/images/lorawan3-int.png)

# Appendix: NimBLE Callout Issue

NimBLE Porting Layer doesn't work for multiple Callout Timers unless we loop the thread...

![NimBLE Callout Issue](https://lupyuen.github.io/images/lorawan3-callout.png)

[(Source)](https://github.com/lupyuen/nimble-porting-nuttx/blob/master/porting/npl/nuttx/src/os_callout.c#L35-L70)

I will submit a Pull Request to Apache NimBLE.

UPDATE: Unfortunately the thread never terminates, so any NuttX App that calls NimBLE Callouts won't terminate either. (Even when we call exit()). We need to terminate the thread in our code.

# Appendix: Previous SX1262 Library

This section describes the __previous (obsolete) version__ of the SX1262 Library...

-   [__lupyuen/lora-sx1262 (nuttx branch)__](https://github.com/lupyuen/lora-sx1262/tree/nuttx)

Which has been superseded by the __new version__ of the SX1262 Library...

-   [__lupyuen/lora-sx1262 (lorawan branch)__](https://github.com/lupyuen/lora-sx1262/tree/lorawan)

The previous version __does NOT support LoRaWAN, GPIO Interface and NimBLE Porting Layer.__

_Huh? SX1262 works without GPIO control?_

We found some sneaky workarounds to __control LoRa SX1262 without GPIO__...

-   __DIO1__: Because we don't support GPIO Interrupts (yet), we __poll the SX1262 Status every second__ to check if a LoRa Packet has been received.

    [(See this)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136)

-   __BUSY__: Instead of reading this pin to check if SX1262 is busy, we __sleep 10 milliseconds__.

    [(See this)](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182)

-   __NRESET__: To reset the SX1262 module, we __manually restart our NuttX gadget__.

    [(See this)](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169)
    
These sneaky hacks will need to be fixed by calling the GPIO Interface.

_What needs to be fixed for GPIO?_

We need to mod these functions to call the __NuttX GPIO Interface__...

1.  Initialise the GPIO Pins: [__SX126xIoInit__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L65-L77)

    [(Similar to BL602 IoT SDK)](https://lupyuen.github.io/articles/lorawan#appendix-bl602-spi-functions)

1.  Register GPIO Interrupt Handler for DIO1: [__SX126xIoIrqInit__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L79-L91)

    [(Similar to BL602 IoT SDK)](https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts)

1.  Reset SX1262 via GPIO: [__SX126xReset__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L149-L169)

    ```c
    void SX126xReset(void) {
        //  TODO: Set Reset pin to Low
        //  rc = bl_gpio_output_set(SX126X_NRESET, 1);
        //  assert(rc == 0);

        //  Wait 1 ms
        DelayMs(1);

        //  TODO: Configure Reset pin as a GPIO Input Pin, no pullup, no pulldown
        //  rc = bl_gpio_enable_input(SX126X_NRESET, 0, 0);
        //  assert(rc == 0);

        //  Wait 6 ms
        DelayMs(6);
    }
    ```

1.  Check SX1262 Busy State via GPIO: [__SX126xWaitOnBusy__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L171-L182)

    (__SX126xWaitOnBusy__ is called by [__SX126xCheckDeviceReady__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x.c#L133-L142), which wakes up SX1262 before checking if SX1262 is busy)

    ```c
    void SX126xWaitOnBusy(void) {
      //  TODO: Fix the GPIO check for busy state.
      //  while( bl_gpio_input_get_value( SX126X_BUSY_PIN ) == 1 );

      //  Meanwhile we sleep 10 milliseconds
      usleep(10 * 1000);
    }
    ```

1.  Get DIO1 Pin State: [__SX126xGetDio1PinState__](https://github.com/lupyuen/lora-sx1262/blob/nuttx/src/sx126x-nuttx.c#L337-L344)

    ```c
    uint32_t SX126xGetDio1PinState(void) {    
      //  TODO: Read and return DIO1 Pin State
      //  return bl_gpio_input_get_value( SX126X_DIO1 );

      //  Meanwhile we always return 0
      return 0;
    }
    ```

When we have implemented __GPIO Interrupts__ in our driver, we can remove the [__Event Polling__](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L126-L136). And we run a __Background Thread__ to handle LoRa Events.

_How will we receive LoRa Messages with GPIO Interrupts?_

After we have implemented __GPIO Interrupts__ in our SX1262 Library, this is how we'll __receive LoRa Messages__ without polling (see pic above)...

1.  When SX1262 receives a LoRa Message, it triggers a __GPIO Interrupt__ on Pin DIO1

1.  GPIO Driver forwards the GPIO Interrupt to our Interrupt Handler Function [__handle_gpio_interrupt__](https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler)

1.  __handle_gpio_interrupt__ enqueues an Event into our __Event Queue__

1.  Our __Background Thread__ removes the Event from the Event Queue and calls [__RadioOnDioIrq__](https://lupyuen.github.io/articles/sx1262#radioondioirq) to process the received LoRa Message

We handle GPIO Interrupts the same way in our __LoRa SX1262 Driver for BL602 IoT SDK__...

-   [__"BL602 GPIO Interrupts"__](https://lupyuen.github.io/articles/lorawan#appendix-bl602-gpio-interrupts)

_Why do we need a Background Thread?_

This will allow our LoRa Application to __run without blocking__ (waiting) on incoming LoRa Messages.

This is especially useful when we implement __LoRaWAN with our SX1262 Library__, because LoRaWAN needs to handle __asynchronous messages__ in the background.

[(Like when we join a LoRaWAN Network)](https://lupyuen.github.io/articles/lorawan#join-network-request)

_How will we implement the Background Thread and Event Queue?_

The code below shall be updated to __start the Background Thread__ by calling NimBLE Porting Layer: [sx1262_test_main.c](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L369-L388)

```c
/// TODO: Create a Background Thread to handle LoRa Events
static void create_task(void) {
  //  Init the Event Queue
  ble_npl_eventq_init(&event_queue);

  //  Init the Event
  ble_npl_event_init(
    &event,        //  Event
    handle_event,  //  Event Handler Function
    NULL           //  Argument to be passed to Event Handler
  );

  //  TODO: Create a Background Thread to process the Event Queue
  //  nimble_port_freertos_init(task_callback);
}
```

And we shall implement the GPIO Interrupt Handler Function [__handle_gpio_interrupt__](https://lupyuen.github.io/articles/lora2#gpio-interrupt-handler) for NuttX.

[(We don't need to code the Event Queue, it has been done here)](https://github.com/lupyuen/nuttx-apps/blob/sx1262/examples/sx1262_test/sx1262_test_main.c#L357-L432)

_When will we begin the implementation?_

Very soon! We shall implement the Background Thread and Event Queue as we __port the LoRaWAN Stack to NuttX__.

(Because LoRaWAN needs multithreading to work)
