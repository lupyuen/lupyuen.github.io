# Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S SBC)

ðŸ“ _19 May 2024_

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-title.jpg)

Soon we'll see many new 64-bit RISC-V SBCs based on the [__Sophgo SG2000 RISC-V SoC__](https://github.com/sophgo/sophgo-doc/releases).

Will they work with [__Apache NuttX RTOS__](https://nuttx.apache.org/docs/latest/index.html)? Let's find out!

- We boot Linux on [__Milk-V Duo S__](https://milkv.io/docs/duo/getting-started/duos) (with SG2000)

- Peek inside [__SG2000 Linux__](https://github.com/Fishwaldo/sophgo-sg200x-debian) and observe how it boots

- Then we take [__NuttX for RISC-V__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358) (Ox64 BL808)

- Tweak NuttX to __boot on SG2000__

- Fix the (undocumented) __Interrupt Controller__

- And Milk-V Duo S boots to a fully-functional __NuttX Shell__!

Something strangely satisfying about __NuttX on RISC-V__... We finished the port in __Only 10 Days__ ðŸŽ‰

_(Is this a sponsored review? I was given a Milk-V Duo S, and I bought another. So it cancels out, I guess?)_

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-soc.jpg)

# Sophgo SG2000 RISC-V SoC

__Sophgo SG2000 SoC__ has a fascinating mix of 64-bit RISC-V Cores (Arm too)...

- __Main Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(1.0 GHz)_

  (For NuttX and Linux)

- __Co-Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(700 MHz)_

  (No Cache)

- __Alt-Main Processor:__ 64-bit Arm Core

  __Cortex-A53__ _(1.0 GHz)_

Plus a __Low-Power 8051 MCU__ (for wakeup duties) and a __Tensor Processing Unit__ (for image recognition, not LLM)...

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-arch.jpg)

[(See the __SG2000 Reference Manual__)](https://github.com/sophgo/sophgo-doc/releases)

_Whoa RISC-V AND Arm CPUs in a single SoC?_

Actually there's a __Hardware Switch__ that selects the Main CPU: __RISC-V OR Arm__.

Don't let yer pet hamster flip it... It will get super frustrating!

([__Sophgo__](https://sophon.ai/) refers to [__3 Body__](https://three-body-problem.fandom.com/wiki/Sophon)?)

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-board.jpg)

# Boot Without MicroSD

_What happens if we boot Milk-V Duo S? Fresh from the box?_

Connect our __USB UART Dongle__ according to [__the instructions__](https://milkv.io/docs/duo/getting-started/duos#uart-serial-console) (pic above)...

| Milk-V Duo S | USB UART |
|:------------:|:--------:|
| __GND__ (Pin 6)	| __GND__ |
| __TX__ (Pin 8) |	__RX__ |
| __RX__ (Pin 10)	| __TX__ |

USB UART Dongle must be [__CP2102__](http://sun-light.com.sg/index.php?route=product/product&product_id=2367), it doesn't like [__CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) ðŸ˜¬

![Switch to "RV" (RISC-V) instead of "Arm"](https://lupyuen.github.io/images/sg2000-switch.jpg)

Flip the Switch so it's set to "__`RV`__" (RISC-V) instead of "__`Arm`__". (Pic above)

Power up the board via the __USB-C Port__. Connect to the USB UART at __115.2 kbps__.

Milk-V Duo S [__won't boot__](https://gist.github.com/lupyuen/a7c3af98be36dcd5cc5b45f5aadc5d16) because it doesn't ship with __U-Boot Bootloader__ in Flash Memory...

```bash
C.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000. 
E:eMMC initializing failed
E:Boot failed
```

We'll need U-Boot on MicroSD. (Next section)

If we see ["__`B.SCS`__"](https://gist.github.com/lupyuen/d55b77a51ee8b258d6d1c0799770742a) instead of "__`C.SCS`__"...

```bash
B.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000.
```
Nope we're in Arm Mode... Flip the switch back to RISC-V!

[__If we use CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) (instead of CP2102): UART Output will be [__gloriously garbled__](https://gist.github.com/lupyuen/1d5ba1b2a47c110ee7ff265102b1aae5).

> ![Debian Image for Sophgo SG2000](https://lupyuen.github.io/images/sg2000-linux.jpg)

# Download the Linux MicroSD

_Milk-V Duo S won't boot without MicroSD. How now?_

Let's boot __Linux on MicroSD__, thanks to the awesome work by [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Image for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__Latest Release: duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

Uncompress the Debian Image...

```bash
## For Linux
$ sudo apt install lz4

## For macOS
$ brew install lz4

## Uncompress the download to get `duos_sd.img`
$ lz4 duos_sd.img.lz4
```

Write __`duos_sd.img`__ to a MicroSD Card. Use [__Balena Etcher__](https://etcher.balena.io), [__GNOME Disks__](https://wiki.gnome.org/Apps/Disks) or [__`dd`__](https://gist.github.com/lupyuen/aae995d942d5ec3ffa6629667bcc3ae6).

We'll see these __MicroSD Files__...

```bash
## MicroSD Root Folder
$ ls -l /Volumes/boot
-rwxrwxrwx  3494900 System.map-5.10.4-20240329-1+
-rwxrwxrwx   125534 config-5.10.4-20240329-1+
drwxrwxrwx     2048 extlinux
drwxrwxrwx     2048 fdt
-rwxrwxrwx   388608 fip.bin
-rwxrwxrwx  4937389 vmlinuz-5.10.4-20240329-1+

## U-Boot Bootloader Config
$ ls -l /Volumes/boot/extlinux
-rwxrwxrwx  749 extlinux.conf

## Linux Device Tree for SG2000
$ ls -l /Volumes/boot/fdt/linux-image-duos-5.10.4-20240329-1+
-rwxrwxrwx  21575 cv181x_milkv_duos_sd.dtb
```

We peek at the __U-Boot Bootloader Config__...

```bash
$ cat /Volumes/boot/extlinux/extlinux.conf
...
label l0
  menu label Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
  linux /vmlinuz-5.10.4-20240329-1+
  fdtdir /fdt/linux-image-duos-5.10.4-20240329-1+/
  append root=/dev/root console=ttyS0,115200 earlycon=sbi root=/dev/mmcblk0p2 rootwait rw
```

With a tiny tweak, we can boot NuttX RTOS!

![OpenSBI and U-Boot Bootloader](https://lupyuen.github.io/images/sg2000-sbi.jpg)

# Boot the Linux MicroSD

_Linux on MicroSD: Will it boot on Milk-V Duo S?_

Yep Linux boots OK on Milk-V Duo S!

First we see [__OpenSBI (Supervisor Binary Interface)__](https://lupyuen.github.io/articles/sbi)...

```bash
OpenSBI v0.9
Platform Name       : Milk-V DuoS
Platform Features   : mfdeleg
Platform HART Count : 1
Platform Console Device : uart8250
Firmware Base       : 0x8000_0000
Firmware Size       : 132 KB
Runtime SBI Version : 0.3

Domain0 Region00 : 0x7400_0000-0x7400_ffff (I)
Domain0 Region01 : 0x8000_0000-0x8003_ffff ()
Domain0 Region02 : 0x0-0xffff_ffff_ffff_ffff (R,W,X)
Boot HART ISA      : rv64imafdcvsux
Boot HART Features : scounteren,mcounteren,time
Boot HART MIDELEG  : 0x0222
Boot HART MEDELEG  : 0xb109

## OpenSBI boots at 0x8000_0000.
## 0x7400_0000 looks interesting! We'll come back to this
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/01d409b7bde9607a96cd4d460e53330a)

Followed by the __U-Boot Bootloader__...

```bash
## U-Boot Boots
U-Boot 2021.10-ga57aa1f2-dirty (Apr 24 2024 - 11:24:46 +0000) cvitek_cv181x
Hit any key to stop autoboot:  0 
Scanning mmc 0:1...
Found /extlinux/extlinux.conf

## U-Boot Menu
1:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
2:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+ (rescue target)
Enter choice: 1

## U-Boot boots Debian Linux
Retrieving file: /vmlinuz-5.10.4-20240329-1+
Retrieving file: /fdt/linux-image-duos-5.10.4-20240329-1+/cv181x_milkv_duos_sd.dtb
Booting using the fdt blob at 0x81200000
```

Finally we see __Debian Linux__...

```bash
Starting kernel ...
Linux version 5.10.4-20240329-1+ (root@3abcc283c6ba) (riscv64-unknown-linux-musl-gcc (Xuantie-900 linux-5.10.4 musl gcc Toolchain V2.6.1 B-20220906) 10.2.0, GNU ld (GNU Binutils) 2.35)
...
Debian GNU/Linux trixie/sid duos ttyS0
duos login: 
```

Moving on to NuttX...

![U-Boot Bootloader](https://lupyuen.github.io/images/sg2000-uboot.jpg)

# Settings for U-Boot Bootloader

_How will we boot NuttX?_

We seek guidance from the __U-Boot Bootloader__.

As we power on Milk-V Duo S, hit Enter a few times to see the __U-Boot Command Prompt__...

```bash
U-Boot 2021.10-ga57aa1f2-dirty (May 07 2024 - 08:13:12 +0000) cvitek_cv181x
Loading Environment from FAT... mmc1 : finished tuning, code:53
Hit any key to stop autoboot:  0
cv181x_c906# 
```

Enter __`printenv`__ to dump the U-Boot Settings...

```bash
## U-Boot Settings
$ printenv
kernel_addr_r=0x80200000
kernel_comp_addr_r=0x81800000
kernel_comp_size=0x1000000
ramdisk_addr_r=0x84000000
uImage_addr=0x81800000
update_addr=0x9fe00000
```

[(See the __U-Boot Settings__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L189-L246)

__`kernel_addr_r`__ says that U-Boot will load Linux Kernel into RAM at Address __`0x8020_0000`__. (We'll set this in NuttX)

And the __Ethernet Driver__ is fully operational in U-Boot. Which means we can boot __NuttX over the Network__...

```bash
$ net list
eth0: ethernet@4070000
00:00:00:00:00:00
active
```

[(See the __U-Boot Commands__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L99-L188)

Let's do it...

![Boot NuttX over TFTP](https://lupyuen.github.io/images/sg2000-tftp.jpg)

# Boot NuttX over TFTP 

_What's the quickest way to port NuttX?_

Like Linux, we could __copy NuttX to MicroSD__, insert into Milk-V Duo S and power up. [__Again and again and again__](https://www.tindie.com/products/badgerdnl/sdwire-usb-c-sd-card-reader-sd-mux/)...

But there's a quicker way: Boot __NuttX over the Network__, thanks to U-Boot Bootloader and TFTP! (Trivial File Transfer Protocol)

- [__"Configure U-Boot for TFTP"__](https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp)

Follow the [__instructions here__](https://lupyuen.github.io/articles/tftp#install-tftp-server) to install our TFTP Server.

At the __U-Boot Command Prompt__: We configure our __TFTP Server__...

```bash
## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## If Initial RAM Disk is needed (like for Linux, not for NuttX)...
## Set the RAM Disk Size (assume the max)
## setenv ramdisk_size 0x1000000

## Save the U-Boot Config for future reboots
saveenv
```

Then we load the __NuttX Image__ into RAM over TFTP...

```bash
## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x80200000
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
fdt addr ${fdt_addr_r}

## If Initial RAM Disk is needed...
## Load the Intial RAM Disk from TFTP Server
## ramdisk_addr_r=0x81600000
## tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd
```

[(__Image-sg2000__ is here)](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/Image)

And we boot __NuttX from RAM__...

```bash
## Boot the NuttX Image with the Device Tree
## kernel_addr_r=0x80200000
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}

## For Linux: We need the RAM Disk Address
## ramdisk_addr_r=0x81600000
## ramdisk_size=0x1000000
## booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

Or mashed up in a single line...

```bash
## Boot NuttX Image over TFTP
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}
```

_What happens when we boot NuttX?_

Absolutely nothing!

```bash
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9e27f000, end 9f27f000 ... OK
Loading Device Tree to 000000009e26f000, end 000000009e27e43a ... OK
Starting kernel ...
```

But that's OK, we haven't modified NuttX Kernel for SG2000. Let's print something in the next section.

_We type these commands EVERY TIME we boot?_

We can automate this! Just do this once, and __NuttX will Auto-Boot__ whenever we power up...

```bash
## Add the Boot Command for TFTP
setenv bootcmd_tftp 'dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}'

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Targets
setenv orig_boot_targets "$boot_targets"

## Prepend TFTP to the Boot Targets
setenv boot_targets "tftp $boot_targets"

## Save it for future reboots
saveenv
```

![UART Controller for SG2000](https://lupyuen.github.io/images/sg2000-uart.jpg)

# UART Controller for SG2000

_How will NuttX print to the Serial Console?_

First we track down the __UART Controller__ for SG2000.

From [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page 638): The UART Controller is at these Base Addresses.

We'll print to UART0 in NuttX: __`0x0414_0000`__

| UART Module | Base Address |
|:-----------:|:------------:|
| UART0 | `0x0414_0000` |
| UART1 | `0x0415_0000` |
| UART2 | `0x0416_0000` |
| UART3 | `0x0417_0000` |
| UART4 | `0x041C_0000` |
| RTCSYS_UART | `0x0502_2000` |

_What UART Controller is inside SG2000?_

According to [__OpenSBI Log__](https://lupyuen.github.io/articles/sg2000#boot-the-linux-microsd): The UART Controller is __`uart8250`__.

Which is supported by NuttX. We mod the NuttX Boot Code to print something...

![Print to UART in RISC-V Assembly](https://lupyuen.github.io/images/sg2000-boot.png)

# Print to UART in RISC-V Assembly

_Printing in RISC-V Assembly? Why not C?_

That's because the very first thing that boots is the NuttX Boot Code in __RISC-V Assembly__. Which we'll modify like this...

- [__"Print to QEMU Console"__](https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console)

SG2000 UART0 Controller is at __`0x0414_0000`__ (previous section). To print something, we write to the __UART Output Register__ at that address: [bl808_head.S](https://github.com/lupyuen2/wip-nuttx/blob/sg2000/arch/risc-v/src/bl808/bl808_head.S#L70-L89)

```c
/* RISC-V Boot Code for Apache NuttX RTOS */
real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x04140000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
```

Our code will print "__`123`__" when NuttX boots. We test this...

# NuttX Boots A Tiny Bit

Follow these steps to build __Apache NuttX RTOS__ for SG2000 and Milk-V Duo S...

- [__"Build NuttX for SG2000"__](https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000)

  [(See the __Build Outputs__)](https://github.com/lupyuen2/wip-nuttx/releases/tag/sg2000-1)

This produces the NuttX Image file: [__`Image`__](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/Image). Which we copy to our __TFTP Server__...

```bash
## Copy NuttX Image to TFTP Server
## TODO: Change `tftpserver` and `tftpboot` to our TFTP Server and Path
scp Image \
  tftpserver:/tftpboot/Image-sg2000
```

To Boot NuttX: Run these commands at the __U-Boot Command Prompt__...

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123
```

See the "__`123`__"? That's evidence that our NuttX Boot Code __is actually running__ on SG2000 and Milk-V Duo S! We port some more...

[(See the __Complete Log__)](https://gist.github.com/lupyuen/78b54326daf0894a2c23ab6d2c03456d)

![NuttX Kernel Boots OK](https://lupyuen.github.io/images/sg2000-kernel.png)

# NuttX Kernel Boots OK

_NuttX Kernel prints "123". What about the rest?_

More mods for __NuttX Kernel__!

1.  We set the [__NuttX Memory Map__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map) for SG2000: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    ## Kernel RAM
    CONFIG_RAM_START=0x80200000
    CONFIG_RAM_SIZE=1048576
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  Also the [__NuttX Linker Script__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map): [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

    ```c
    MEMORY {
      kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
      ...
    SECTIONS {
      . = 0x80200000;
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  We select the [__NuttX Driver for 16550 UART__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_16550_REGINCR=4
    CONFIG_16550_UART0=y
    CONFIG_16550_UART0_BASE=0x04140000
    CONFIG_16550_UART0_SERIAL_CONSOLE=y
    CONFIG_16550_UART=y
    CONFIG_16550_WAIT_LCR=y
    CONFIG_SERIAL_UART_ARCH_MMIO=y
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

1.  Enable Logging for [__NuttX Scheduler and Binary Loader__](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_DEBUG_BINFMT=y
    CONFIG_DEBUG_BINFMT_ERROR=y
    CONFIG_DEBUG_BINFMT_WARN=y
    CONFIG_DEBUG_SCHED=y
    CONFIG_DEBUG_SCHED_ERROR=y
    CONFIG_DEBUG_SCHED_INFO=y
    CONFIG_DEBUG_SCHED_WARN=y
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler)

1.  And disable the [__PLIC Interrupt Controller__](https://lupyuen.github.io/articles/sg2000#disable-interrupt-controller) (until we figure it out)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#disable-interrupt-controller)

After applying the above fixes: __NuttX Kernel__ boots successfully! (Pic above)

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x80409140
nxtask_exit: AppBringUp pid=2,TCB=0x80408740
```

One last thing and we're done...

[(See the __Complete Log__)](https://gist.github.com/lupyuen/aaa0a6646490d45e5cd99b781cbe59f8)

[(Watch the __Demo on YouTube__)](https://www.youtube.com/watch?v=pPNDiC5NLqM)

![NuttX Kernel boots all the way to NuttX Shell](https://lupyuen.github.io/images/sg2000-nsh.png)

# NuttX Shell Too!

_But where's the NuttX Shell?_

We won't see the NuttX Shell until we fix the __Interrupt Controller__ for SG2000. Which is NOT documented!

That's because NuttX Shell requires [__UART Input Interrupts__](https://lupyuen.github.io/articles/plic#serial-input-in-nuttx-qemu) AND [__UART Output Interrupts__](https://lupyuen.github.io/articles/plic#serial-output-in-nuttx-qemu), to operate properly.

Let's sniff around and find out how the Interrupt Controller works...

1.  We dumped the [__Linux Device Tree__](https://lupyuen.github.io/articles/sg2000#dump-the-linux-device-tree) for SG2000...

    ```bash
    ## Convert the SG2000 Device Tree
    dtc \
      -o cv181x_milkv_duos_sd.dts \
      -O dts \
      -I dtb \
      cv181x_milkv_duos_sd.dtb
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#dump-the-linux-device-tree)

1.  Snooped the [__PLIC Interrupt Controller__](https://lupyuen.github.io/articles/sg2000#interrupt-controller-for-sg2000) in the Device Tree: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

    ```c
    interrupt-controller@70000000 {
      riscv,ndev = <0x65>;
      riscv,max-priority = <0x07>;
      reg-names = "control";
      reg = <0x00 0x70000000 0x00 0x4000000>;
      interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
      interrupt-controller;
      compatible = "riscv,plic0";
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#interrupt-controller-for-sg2000)

1.  And fixed the [__NuttX Driver__](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic) for PLIC Interrupts: [bl808_memorymap.h](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6#diff-8fffa570a48f8f10004d9da8d4c671d34336f6c4b8dcfc2bd72275d8cda4ac04)

    ```c
    // Base Address of PLIC Interrupt Controller
    #define BL808_PLIC_BASE 0x70000000ul
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic)

After fixing the Interrupt Controller and UART Interrupts: NuttX Kernel boots all the way to __NuttX Shell__! (Pic above)

```bash
## Load NuttX Image into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
NuttShell (NSH) NuttX-12.4.0

nsh> uname -a
NuttX 12.4.0 122c717 May  8 2024 18:13:30 risc-v ox64

nsh> ls
/:
 dev/
 proc/
 system/

nsh> ls /dev
/dev:
 console
 null
 ram0
 ttyS0
 zero
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/b778986ba87c18067cd993b92c673634)

_What about the rest of NuttX?_

[__NuttX OSTest__](https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing) is the perfect way to test everything in NuttX...

```bash
nsh> ostest
user_main: mutex test
riscv_exception:
  EXCEPTION: Load access fault
  MCAUSE:    5
  EPC:       802189ce
  MTVAL:     0000000000000000
  Segmentation fault in PID 7: ostest
```

Sadly we're hitting a RISC-V Exception: __Load Access Fault__. Needs more troubleshooting sigh.

[(See the __Complete Log__)](https://gist.github.com/lupyuen/fff5242cf77a3f52d81f3effb9aa402f)

> ![TODO: NuttX Boot Flow](https://lupyuen.github.io/images/sg2000-boot.jpg)

_What happens exactly when NuttX boots on SG2000?_

Exact same thing as NuttX booting on Ox64 BL808 SBC (pic above)...

- [__"NuttX Boot Flow"__](https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow)

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-box.jpg)

# What's Next

We're eagerly awaiting the new 64-bit RISC-V SBCs based on the [__Sophgo SG2000 RISC-V SoC__](https://github.com/sophgo/sophgo-doc/releases). Meanwhile we have done our prep...

TODO: Will they work with [__Apache NuttX RTOS__](TODO)? Let's find out!

- We boot Linux on [__Milk-V Duo S__](TODO) (SG2000 inside)

- Peek inside [__SG2000 Linux__](TODO) and observe how it boots

- Then we take [__NuttX for RISC-V__](TODO) (Ox64 BL808)

- Tweak NuttX to __boot on SG2000__

- Fix the (undocumented) __Interrupt Controller__

- And Milk-V Duo S gets a fully-functional __NuttX Shell__!

- Something strangely super satisfying about __NuttX on SG2000__... We finished the port in __Only 10 Days__ ðŸŽ‰

Up Next...

1.  We'll Upstream SG2000 to __NuttX Mainline__

    (So others may contribute)

1.  Create an __SG2000 Emulator__ for easier testing

    [(Similar to __TinyEMU for Ox64__)](TODO)

1.  Someday we might run NuttX on the SG2000 Co-Processor!

    (Also SG2002 and its upsized TPU)

1.  Join me online at the [__NuttX International Workshop__](TODO)

    (We'll chat about Ox64 BL808 and SG2000)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) (and the awesome NuttX Community) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__My Current Project: "Apache NuttX RTOS for Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64)

-   [__My Other Project: "NuttX for Star64 JH7110"__](https://github.com/lupyuen/nuttx-star64)

-   [__Older Project: "NuttX for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/sg2000.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000.md)

![Build NuttX for SG2000](https://lupyuen.github.io/images/sg2000-build.png)

# Appendix: Build NuttX for SG2000

In this article we took NuttX for [__Ox64 BL808 RISC-V SBC__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S!

1.  [__"Set the NuttX Memory Map"__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  [__"Select the 16550 UART Driver"__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

1.  [__"Enable Logging for Scheduler"__](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler)

1.  [__"Fix the NuttX Driver for PLIC"__](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic)

Follow these steps to build (work-in-progress) Apache NuttX RTOS for __SG2000 and Milk-V Duo S__...

Install the Build Prerequisites, skip the RISC-V Toolchain...

- [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

Download the RISC-V Toolchain for __riscv64-unknown-elf__...
    
- [__"Download Toolchain for 64-bit RISC-V"__](https://lupyuen.github.io/articles/riscv#appendix-download-toolchain-for-64-bit-risc-v)

Then Download and Build NuttX...

```bash
set -e  #  Exit when any command fails
set -x  #  Echo commands

## Build NuttX
function build_nuttx {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build NuttX
  make -j 8

  ## Return to previous folder
  popd
}

## Build Apps Filesystem
function build_apps {

  ## Go to NuttX Folder
  pushd ../nuttx

  ## Build Apps Filesystem
  make -j 8 export
  pushd ../apps
  ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
  make -j 8 import
  popd

  ## Return to previous folder
  popd
}

## Download WIP NuttX for SG2000 (based on Ox64 BL808)
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx \
  nuttx
git clone --branch sg2000 \
  https://github.com/lupyuen2/wip-nuttx-apps \
  apps
cd nuttx

## Pull updates
git pull && git status && hash1=`git rev-parse HEAD`
pushd ../apps
git pull && git status && hash2=`git rev-parse HEAD`
popd
echo NuttX Source: https://github.com/apache/nuttx/tree/$hash1 >nuttx.hash
echo NuttX Apps: https://github.com/apache/nuttx-apps/tree/$hash2 >>nuttx.hash

## Show the version of GCC
riscv64-unknown-elf-gcc -v

## Configure build
tools/configure.sh ox64:nsh

## Build NuttX
build_nuttx

## Build Apps Filesystem
build_apps

## Generate Initial RAM Disk
genromfs -f initrd -d ../apps/bin -V "NuttXBootVol"

## Show the size
riscv64-unknown-elf-size nuttx

## Export the Binary Image to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero >/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  >Image

## Copy the config
cp .config nuttx.config

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  >nuttx.S \
  2>&1

## Dump the init disassembly to init.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/init \
  >init.S \
  2>&1

## Dump the hello disassembly to hello.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello \
  >hello.S \
  2>&1

## Copy NuttX Image to TFTP Server
scp Image tftpserver:/tftpboot/Image-sg2000
ssh tftpserver ls -l /tftpboot/Image-sg2000
```

[(See the __Build Outputs__)](https://github.com/lupyuen2/wip-nuttx/releases/tag/sg2000-1)

The steps above assume that we have installed our TFTP Server, according to the [__instructions here__](https://lupyuen.github.io/articles/tftp#install-tftp-server).

Then follow these steps to boot NuttX on Milk-V Duo S...

- [__"Boot NuttX over TFTP"__](https://lupyuen.github.io/articles/sg2000#boot-nuttx-over-tftp)

![Virtual Memory for NuttX Apps](https://lupyuen.github.io/images/mmu-l3user.jpg)

_Why the RAM Disk? Isn't NuttX an RTOS?_

SG2000 uses a RAM Disk because it runs in __NuttX Kernel Mode__ (instead of the typical Flat Mode). This means we can do __Memory Protection__ and __Virtual Memory__ for Apps. But it also means we need to bundle the __NuttX Apps as ELF Files__, hence the RAM Disk...

- [__"NuttX Apps and Initial RAM Disk"__](https://lupyuen.github.io/articles/app)

Most of the NuttX Platforms run on __NuttX Flat Mode__, which has NuttX Apps Statically-Linked into the NuttX Kernel. It works well for Small MCUs, but probably inadequate for larger SoCs like SG2000...

- [__"NuttX Flat Mode vs Kernel Mode"__](https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode)

![Porting NuttX to SG2000](https://lupyuen.github.io/images/sg2000-commits.jpg)

# Appendix: Port NuttX to SG2000

_How did we port NuttX to SG2000?_

We started with NuttX for [__Ox64 BL808 RISC-V SBC__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S! This chapter explains the minor tweaks that we made.

_Why did we start with NuttX for Ox64?_

That's because Ox64 BL808 runs on the same RISC-V Core as SG2000: [__T-Head C906__](https://github.com/T-head-Semi/openc906/blob/main/doc/openc906%20datasheet.pdf).

_What about the T-Head Extensions for C906?_

Yep we copied (unchanged) the __T-Head Extensions for C906__ from Ox64 BL808 to SG2000. And they work hunky dory on SG2000...

- [__Enable Strong Ordering in MMU for T-Head C906__](https://lupyuen.github.io/articles/plic3#enable-strong-order)

- [__Flush the MMU Cache for T-Head C906__](https://lupyuen.github.io/articles/mmu#appendix-flush-the-mmu-cache-for-t-head-c906)

Let's talk about the tweaks...

## NuttX Memory Map

From [__U-Boot Bootloader Settings__](https://lupyuen.github.io/articles/sg2000#settings-for-u-boot-bootloader): We see that SG2000 boots at this address...

```bash
kernel_addr_r=0x80200000
```

Thus we define the __NuttX Memory Map__ for SG2000 like so...

- [__Set the NuttX Memory Map for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2)

NuttX Kernel will boot at __`0x8020_0000`__, NuttX Apps will run at Virtual Address __`0xC000_0000`__.

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
## Kernel RAM
CONFIG_RAM_START=0x80200000
CONFIG_RAM_SIZE=1048576

## Kernel Paged Pool (Allocated to NuttX Apps)
CONFIG_ARCH_PGPOOL_PBASE=0x80600000
CONFIG_ARCH_PGPOOL_VBASE=0x80600000
CONFIG_ARCH_PGPOOL_SIZE=4194304

## Virtual Memory for NuttX App Code
CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128

## Virtual Memory for NuttX App Data
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128

## Virtual Memory for NuttX App Heap
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
```

And here's the __NuttX Linker Script__: [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

```c
MEMORY {
  kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
  ksram (rwx) : ORIGIN = 0x80400000, LENGTH = 2048K   /* w/ cache */
  pgram (rwx) : ORIGIN = 0x80600000, LENGTH = 4096K   /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x80A00000, LENGTH = 16M   /* w/ cache */
}
...
SECTIONS {
  . = 0x80200000;
```

## Select the 16550 UART Driver

From [__OpenSBI Log__](https://lupyuen.github.io/articles/sg2000#settings-for-u-boot-bootloader): We see that SG2000 operates with a __8250 UART Controller__.

Thus we select the NuttX Driver for __16550 UART__, which is compatible with 8250...

- [__Select the NuttX Driver for 16550 UART__](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x04140000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y
```

Don't update the NuttX Config File directly! We ran __`make menuconfig`__ to generate the above file...

```bash
## Update NuttX Config
make menuconfig \
  && make savedefconfig \
  && grep -v CONFIG_HOST defconfig \
  >boards/risc-v/bl808/ox64/configs/nsh/defconfig
```

__To Find Menuconfig Settings:__ Press "__`/`__" and enter the name of the setting, like _"16550_ADDRWIDTH"_. This ensures that the Kconfig Dependencies are correctly updated.

![UART IRQ](https://lupyuen.github.io/images/sg2000-irq.jpg)

_How did we get IRQ 69 for UART?_

We set IRQ 69 for UART0...

- [__Set UART0 IRQ to 69 (25 + 44)__](https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e)

  ```bash
  CONFIG_16550_UART0_IRQ=69
  ```

That's because the [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page 13) says...

> __3.1 Interrupt Subsystem__

> Table 3.2: Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz

> Int #44: UART0

__Linux Device Tree__ also says UART0 IRQ is __44 (`0x2C`)__

```c
serial@04140000 {
  compatible = "snps,dw-apb-uart";
  reg = <0x00 0x4140000 0x00 0x1000>;
  clock-frequency = <0x17d7840>;
  reg-shift = <0x02>;
  reg-io-width = <0x04>;
  status = "okay";
  interrupts = <0x2c 0x04>;
  interrupt-parent = <0x04>;
};
```

Thus we compute [__NuttX IRQ__](https://lupyuen.github.io/articles/plic2#uart-interrupt) = 25 + RISC-V IRQ = 69

(We should fix the UART Clock: _16550_UART0_CLOCK_)

![Whither PLIC?](https://lupyuen.github.io/images/sg2000-memory.jpg)

## Disable Interrupt Controller

Most RISC-V SBCs (Ox64, Star64) will manage Interrupts with a [__Platform-Level Interrupt Controller (PLIC)__](https://lupyuen.github.io/articles/plic2). But PLIC isn't documented for SG2000.

For now, let's disable PLIC in NuttX...

- [__Disable the PLIC Interrupt Controller__](https://github.com/lupyuen2/wip-nuttx/commit/6d66caa1408d7a7d7b21b0e876ce32ceb5b93ec4)

Later we'll dump the SG2000 Linux Device Tree to understand the Interrupt Controller.

## Dump the Linux Device Tree

To understand the Interrupt Controller: Let's dump the __Linux Device Tree__ for SG2000.

From the SG2000 Debian Release, thanks to [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Images for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

We copy out the SG2000 __Device Tree Binary__: [cv181x_milkv_duos_sd.dtb](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dtb)

And convert it to __Device Tree Source__: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

```bash
## Convert the SG2000 Device Tree
dtc \
  -o cv181x_milkv_duos_sd.dts \
  -O dts \
  -I dtb \
  cv181x_milkv_duos_sd.dtb
```

We go inside the Device Tree...

## Interrupt Controller for SG2000

Earlier we dumped the __Linux Device Tree__ for SG2000. Let's snoop the Interrupt Controller to understand it.

Based on the __SG2000 Device Tree__: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

```c
// PLIC Interrupt Controller for External Interrupts
interrupt-controller@70000000 {
  riscv,ndev = <0x65>;
  riscv,max-priority = <0x07>;
  reg-names = "control";
  reg = <0x00 0x70000000 0x00 0x4000000>;
  interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
  interrupt-controller;
  compatible = "riscv,plic0";
  #interrupt-cells = <0x02>;
  #address-cells = <0x00>;
  phandle = <0x04>;
};

// CLINT Interrupt Controller for Internal Interrupts
clint@74000000 {
  interrupts-extended = <0x16 0x03 0x16 0x07>;
  reg = <0x00 0x74000000 0x00 0x10000>;
  compatible = "riscv,clint0";
  clint,has-no-64bit-mmio;
};
```

We see that PLIC (External Interrupts) is at __`0x7000_0000`__, CLINT (Internal Interrupts) at __`0x7400_0000`__. Let's implement this in NuttX...

![Platform-Level Interrupt Controller](https://lupyuen.github.io/images/sg2000-plic.jpg)

## Fix the NuttX Driver for PLIC

Based on the SG2000 PLIC Address from above: We fix the [__Platform-Level Interrupt Controller (PLIC)__](https://lupyuen.github.io/articles/plic2) for SG2000...

- [__Fix the PLIC Interrupt Controller for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6)

Now we see a bit more NuttX...

```bash
Starting kernel ...
123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80409130
nxtask_activate: AppBringUp pid=2,TCB=0x80409740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x8040b730
nxtask_exit: AppBringUp pid=2,TCB=0x80409740

Nuttnx_start: CPU0: Beginning Idle Loop
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/922e6379375fbc5d775d1e83cac4deb5)

_Why did it stop?_

Duh we set the wrong UART0 IRQ! Here's the fix...

- [__"Select the 16550 UART Driver"__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

## Enable Logging for Scheduler

For easier troubleshooting: We enable Logging for __NuttX Scheduler and Binary Loader__...

- [__Enable Logging for Scheduler and Binary Loader__](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_DEBUG_BINFMT=y
CONFIG_DEBUG_BINFMT_ERROR=y
CONFIG_DEBUG_BINFMT_WARN=y
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y
```

Remember: Always use __`make menuconfig`__ to update the settings!

## NuttX Crash Dump

_What happens when something goes wrong in NuttX?_

We'll see a __NuttX Crash Dump__, like so...

```bash
Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9fe00000, end 9fe00000 ... OK
Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK
Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3

_assert: Current Version: NuttX  12.4.0 f37a380-dirty May  7 2024 10:31:33 risc-v
_assert: Assertion failed 0x17 == (insn & 0x7F): at file: machine/risc-v/arch_elf.c:494 task: AppBringUp process: Kernel 0x80200f34
up_dump_register: EPC: 000000008021087a
up_dump_register: A0: 0000000080401b70 A1: 00000000000001ee A2: 0000000080228ef8 A3: 0000000000000000
up_dump_register: A4: 0000000000000017 A5: 0000000000000002 A6: 000000000000ab9c A7: fffffffffffffff8
up_dump_register: T0: 000000000000002e T1: 0000000000000007 T2: 00000000000001ff T3: 000000008040c3fc
up_dump_register: T4: 000000008040c3f0 T5: 0000000000000009 T6: 000000000000002a
up_dump_register: S0: 0000000000000000 S1: 0000000080408740 S2: 0000000000000017 S3: 0000000000000000
up_dump_register: S4: 0000000080228ef8 S5: 0000000080228de8 S6: 0000000080401e10 S7: 8000000201842022
up_dump_register: S8: 00000000000001ee S9: 000000008040b9a0 S10: 0000000000000070 S11: 000000008040b990
up_dump_register: SP: 000000008040c330 FP: 0000000000000000 TP: 0000000000000000 RA: 000000008021087a
dump_stack: User Stack:
dump_stack:   base: 0x8040c030
dump_stack:   size: 00002000
dump_stack:     sp: 0x8040c330
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/594f0df20d39001bac171412d594d517)

_What's this Assertion Failure?_

```bash
_assert: Assertion failed 0x17 == (insn & 0x7F):
at file: machine/risc-v/arch_elf.c:494
task: AppBringUp process: Kernel 0x80200f34
```

Oops we goofed and used the __Wrong U-Boot Command__...

```bash
## Nope! This won't work for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ;
booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

Which overwrites the NuttX Image in RAM. Here's the __Correct U-Boot Command__...

```bash
## This works OK for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; 
booti ${kernel_addr_r} - ${fdt_addr_r}
```
