# Apache NuttX RTOS on Sophgo SG2000 RISC-V SoC (Milk-V Duo S / Oz64 SBC)

📝 _19 May 2024_

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-title.jpg)

[__UPDATE: NuttX Mainline now supports SG2000, Oz64 and Milk-V Duo S!__](https://lupyuen.github.io/articles/sg2000#appendix-nuttx-mainline-now-supports-sg2000)

Soon we'll see many new [__64-bit RISC-V SBCs__](https://lupyuen.github.io/articles/sg2000#appendix-apache-nuttx-rtos-for-pine64-oz64-sbc) based on the [__Sophgo SG2000 RISC-V SoC__](https://github.com/sophgo/sophgo-doc/releases).

Will they work with [__Apache NuttX RTOS__](https://nuttx.apache.org/docs/latest/index.html)? (Real-Time Operating System) Let's find out...

- We boot Linux on [__Milk-V Duo S__](https://milkv.io/docs/duo/getting-started/duos) (with SG2000)

- Peek inside [__SG2000 Linux__](https://github.com/Fishwaldo/sophgo-sg200x-debian) and observe how it boots

- Then we take [__NuttX for RISC-V__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358) (Ox64 BL808)

- Tweak NuttX Kernel to __boot on SG2000__

- Fix the (undocumented) __Interrupt Controller__

- And Milk-V Duo S boots to a fully-functional __NuttX Shell__

- [__Daily Test Logs__ for Oz64 NuttX](https://gist.github.com/search?o=desc&q=user%3Anuttxpr+%22daily-build-test-oz64%22&s=updated)

Something strangely satisfying about __NuttX on RISC-V__... We finished the port in __Only 10 Days__ 🎉

_(Is this a sponsored review? I was given a Milk-V Duo S, and I bought another. So it cancels out I guess?)_

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-soc.jpg)

# Sophgo SG2000 RISC-V SoC

__Sophgo SG2000 SoC__ has a fascinating mix of 64-bit RISC-V Cores (Arm too)...

- __Main Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(1.0 GHz)_

  (For NuttX and Linux)

- __Co-Processor:__ 64-bit RISC-V Core

  __T-Head C906__ _(700 MHz)_

  (No Cache)

- __Alt-Main Processor:__ 64-bit Arm Core

  __Cortex-A53__ _(1.0 GHz)_

Plus a [__Low-Power 8051 MCU__](https://milkv.io/docs/duo/getting-started/8051core) (for Wakeup Duties) and a [__Tensor Processing Unit__](https://forum.sophgo.com/t/how-to-use-the-tpu-0-2tops-int8-on-the-duo/245) (for [__Image Recognition__](https://www.cnx-software.com/2024/05/10/sipeed-maixcam-risc-v-ai-camera-devkit-5mp-camera-2-3-inch-display-gpio/), not LLM)

![Sophgo SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-arch.jpg)

[(See the __SG2000 Reference Manual__)](https://github.com/sophgo/sophgo-doc/releases)

[(See the __Cvitek SDK Docs__)](https://milkv.io/docs/duo/resources/mmf)

_Whoa RISC-V AND Arm CPUs in a single SoC?_

Actually there's a __Physical Switch__ that selects the Main CPU: __RISC-V _OR_ Arm__.

Don't let yer pet hamster flip it... It will get super frustrating!

([__Sophgo__](https://sophon.ai/) / _Sophon.ai_ comes from [__3 Body__](https://three-body-problem.fandom.com/wiki/Sophon))

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-board.jpg)

# Boot Without MicroSD

_What happens if we boot Milk-V Duo S? Fresh from the box?_

Connect our __USB UART Dongle__ according to [__the instructions__](https://milkv.io/docs/duo/getting-started/duos#uart-serial-console) (pic above)...

| Milk-V Duo S | USB UART |
|:------------:|:--------:|
| __GND__ (Pin 6)	| __GND__ |
| __TX__ (Pin 8) |	__RX__ |
| __RX__ (Pin 10)	| __TX__ |

USB UART Dongle must be [__CP2102__](http://sun-light.com.sg/index.php?route=product/product&product_id=2367), it doesn't like [__CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) 😬

![Switch to "RV" (RISC-V) instead of "Arm"](https://lupyuen.github.io/images/sg2000-switch.jpg)

Flip the Switch so it's set to "__`RV`__" (RISC-V) instead of "__`Arm`__". (Pic above)

Power up the board via the __USB-C Port__. Connect to the USB UART at __115.2 kbps__...

```bash
screen /dev/ttyUSB0 115200
```

Milk-V Duo S [__won't boot__](https://gist.github.com/lupyuen/a7c3af98be36dcd5cc5b45f5aadc5d16) because it doesn't ship with __U-Boot Bootloader__ in Flash Memory...

```bash
C.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000. 
E:eMMC initializing failed
E:Boot failed
E:RESET:plat/mars/platform.c:114
```

We'll need U-Boot on MicroSD, in the next section.

[(__platform.c__ might be here)](https://github.com/milkv-duo/fsbl/blob/milkv/plat/sg200x/platform.c)

If we see ["__`B.SCS`__"](https://gist.github.com/lupyuen/d55b77a51ee8b258d6d1c0799770742a) instead of "__`C.SCS`__"...

```bash
B.SCS/0/0.WD.URPL.USBI.USBEF.BS/EMMC.EMI/25000000/12000000.
```
Nope we're in Arm Mode... Flip the switch back to RISC-V!

[__If we use CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) (instead of CP2102): UART Output will be [__gloriously garbled__](https://gist.github.com/lupyuen/1d5ba1b2a47c110ee7ff265102b1aae5).

> ![Debian Image for Sophgo SG2000](https://lupyuen.github.io/images/sg2000-linux.jpg)

# Download the Linux MicroSD

_Milk-V Duo S won't boot without MicroSD. How now?_

We boot __Linux on MicroSD__, thanks to the awesome work by [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Image for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__Latest Release: duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

Uncompress the Debian Image...

```bash
## For Linux:
$ sudo apt install lz4

## For macOS:
$ brew install lz4

## Uncompress the download to get `duos_sd.img`
$ lz4 duos_sd.img.lz4
```

And write __`duos_sd.img`__ to a MicroSD Card. Use [__Balena Etcher__](https://etcher.balena.io), [__GNOME Disks__](https://wiki.gnome.org/Apps/Disks) or [__`dd`__](https://gist.github.com/lupyuen/aae995d942d5ec3ffa6629667bcc3ae6).

We'll see these __MicroSD Files__...

```bash
## MicroSD Root Folder
$ ls -l /Volumes/boot
-rwx 3494900 System.map-5.10.4-20240329-1+
-rwx  125534 config-5.10.4-20240329-1+
drwx    2048 extlinux
drwx    2048 fdt
-rwx  388608 fip.bin
-rwx 4937389 vmlinuz-5.10.4-20240329-1+

## U-Boot Bootloader Config
$ ls -l /Volumes/boot/extlinux
-rwx 749 extlinux.conf

## Linux Device Tree for SG2000
$ ls -l /Volumes/boot/fdt/linux-image-duos-5.10.4-20240329-1+
-rwx 21575 cv181x_milkv_duos_sd.dtb
```

[(What's inside the __SG2000 MicroSD__)](https://lupyuen.github.io/articles/sg2000.html#appendix-inside-the-sg2000-microsd)

We peek at the __U-Boot Bootloader Config__ (which will boot NuttX with a tiny tweak)

```bash
$ cat /Volumes/boot/extlinux/extlinux.conf
...
menu label Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
linux  /vmlinuz-5.10.4-20240329-1+
fdtdir /fdt/linux-image-duos-5.10.4-20240329-1+/
append root=/dev/root console=ttyS0,115200 earlycon=sbi root=/dev/mmcblk0p2 rootwait rw
```

Watch what happens when we boot the MicroSD...

![OpenSBI and U-Boot Bootloader](https://lupyuen.github.io/images/sg2000-sbi.jpg)

# Boot the Linux MicroSD

_Linux on MicroSD: Will it boot on Milk-V Duo S?_

Yep Linux boots OK. First we see [__OpenSBI (Supervisor Binary Interface)__](https://lupyuen.github.io/articles/sbi)...

```bash
OpenSBI v0.9
Platform Name       : Milk-V DuoS
Platform Features   : mfdeleg
Platform HART Count : 1
Platform Console Device : uart8250
Firmware Base       : 0x8000_0000
Firmware Size       : 132 KB
Runtime SBI Version : 0.3

Domain0 Region00 : 0x7400_0000-0x7400_ffff (I)
Domain0 Region01 : 0x8000_0000-0x8003_ffff ()
Domain0 Region02 : 0x0-0xffff_ffff_ffff_ffff (R,W,X)
Boot HART ISA      : rv64imafdcvsux
Boot HART Features : scounteren,mcounteren,time
Boot HART MIDELEG  : 0x0222
Boot HART MEDELEG  : 0xb109

## OpenSBI boots at 0x8000_0000.
## 0x7400_0000 looks interesting! We'll come back to this
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/01d409b7bde9607a96cd4d460e53330a)

Followed by the [__U-Boot Bootloader__](https://docs.u-boot.org/en/latest/index.html)...

```bash
## U-Boot Boots
U-Boot 2021.10-ga57aa1f2-dirty (Apr 24 2024 - 11:24:46 +0000) cvitek_cv181x
Hit any key to stop autoboot:  0 
Scanning mmc 0:1...
Found /extlinux/extlinux.conf

## U-Boot Menu
1:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+
2:.Debian GNU/Linux trixie/sid 5.10.4-20240329-1+ (rescue target)
Enter choice: 1

## U-Boot boots Debian Linux
Retrieving file: /vmlinuz-5.10.4-20240329-1+
Retrieving file: /fdt/linux-image-duos-5.10.4-20240329-1+/cv181x_milkv_duos_sd.dtb
Booting using the fdt blob at 0x81200000
```

Finally we see __Debian Linux__...

```bash
Starting kernel ...
Linux version 5.10.4-20240329-1+ (root@3abcc283c6ba) (riscv64-unknown-linux-musl-gcc (Xuantie-900 linux-5.10.4 musl gcc Toolchain V2.6.1 B-20220906) 10.2.0, GNU ld (GNU Binutils) 2.35)
...
Debian GNU/Linux trixie/sid duos ttyS0
duos login: 
```

Linux works great, we hop over to NuttX...

[(__Cvitek__ is the old name of Sophgo / Sophon)](https://en.sophgo.com/about-us/index.html)

![U-Boot Bootloader](https://lupyuen.github.io/images/sg2000-uboot.jpg)

# Settings for U-Boot Bootloader

_How will we boot NuttX?_

We seek guidance from the __U-Boot Bootloader__.

As we power on Milk-V Duo S, hit Enter a few times to see the __U-Boot Command Prompt__...

```bash
U-Boot 2021.10-ga57aa1f2-dirty (May 07 2024 - 08:13:12 +0000) cvitek_cv181x
Loading Environment from FAT... mmc1 : finished tuning, code:53
Hit any key to stop autoboot:  0
cv181x_c906# 
```

Enter __`printenv`__ to dump the U-Boot Settings...

```bash
## U-Boot Settings
$ printenv
kernel_addr_r=0x80200000
kernel_comp_addr_r=0x81800000
kernel_comp_size=0x1000000
ramdisk_addr_r=0x84000000
uImage_addr=0x81800000
update_addr=0x9fe00000
```

[(See the __U-Boot Settings__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L189-L246)

__`kernel_addr_r`__ says that U-Boot will load Linux Kernel into RAM at Address __`0x8020_0000`__. (We'll set this in NuttX)

And the __Ethernet Driver__ is fully operational in U-Boot. Which means we can boot __NuttX over the Network__...

```bash
$ net list
eth0: ethernet@4070000
00:00:00:00:00:00
active
```

Here's how...

[(See the __U-Boot Commands__)](https://gist.github.com/lupyuen/000b55a46336cddf217a589f469d60e2#file-milkv-duo-s-uboot-log-L99-L188)

![Boot NuttX over TFTP](https://lupyuen.github.io/images/sg2000-tftp.jpg)

# Boot NuttX over TFTP 

_What's the quickest way to port NuttX to SG2000?_

Like Linux, we could __copy NuttX to MicroSD__, insert into Milk-V Duo S and power up. [__Again and again and again__](https://www.tindie.com/products/badgerdnl/sdwire-usb-c-sd-card-reader-sd-mux/)...

But there's a quicker way: Boot __NuttX over the Network__, thanks to U-Boot Bootloader and __TFTP (Trivial File Transfer Protocol)__

- [__"Configure U-Boot for TFTP"__](https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp)

Follow the [__instructions here__](https://lupyuen.github.io/articles/tftp#install-tftp-server) to install our TFTP Server. Copy these files to our TFTP Server...

- [__NuttX Image: Image-sg2000__](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/Image-sg2000)

- [__Device Tree: cv181x_milkv_duos_sd.dtb__](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/cv181x_milkv_duos_sd.dtb)

At the __U-Boot Command Prompt__: We configure our __TFTP Server__...

```bash
## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## If Initial RAM Disk is needed (like for Linux, not for NuttX)...
## Set the RAM Disk Size (assume the max)
## setenv ramdisk_size 0x1000000

## Save the U-Boot Config for future reboots
saveenv
```

Then we load the __NuttX Image__ into RAM over TFTP...

```bash
## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x80200000
dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
fdt addr ${fdt_addr_r}

## If Initial RAM Disk is needed...
## Load the Intial RAM Disk from TFTP Server
## ramdisk_addr_r=0x81600000
## tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd
```

And we boot __NuttX from RAM__...

```bash
## Boot the NuttX Image with the Device Tree
## kernel_addr_r=0x80200000
## fdt_addr_r=0x81200000
## TODO: Fix the Device Tree, it's not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}

## For Linux: We need the RAM Disk Address
## ramdisk_addr_r=0x81600000
## ramdisk_size=0x1000000
## booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

_What happens when we boot NuttX?_

Absolutely nothing...

```bash
## Boot NuttX over TFTP, mashed up in a single line...
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}

Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9e27f000, end 9f27f000 ... OK
Loading Device Tree to 9e26f000, end 9e27e43a ... OK
Starting kernel ...
```

But that's OK, we haven't modified NuttX Kernel for SG2000. We'll print something in a while.

_We type these commands EVERY TIME we boot?_

We can automate: Just do this once, and __NuttX will Auto-Boot__ whenever we power up...

```bash
## Add the Boot Command for TFTP
setenv bootcmd_tftp 'dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}'

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Targets: `mmc0 dhcp pxe`
setenv orig_boot_targets "$boot_targets"

## Prepend TFTP to the Boot Targets: `tftp mmc0 dhcp pxe`
setenv boot_targets "tftp $boot_targets"

## Save it for future reboots
saveenv
```

[(What about __Static IP__?)](https://github.com/lupyuen/nuttx-sg2000/issues/1)

[(How to __Undo Auto-Boot__)](https://github.com/lupyuen/nuttx-sg2000/issues/1#issuecomment-2114415245)

![UART Controller for SG2000](https://lupyuen.github.io/images/sg2000-uart.jpg)

# UART Controller for SG2000

_How will NuttX print to the Serial Console?_

First we track down the __UART Controller__ for SG2000.

From [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page 638): The UART Controller is at these Base Addresses (we'll talk to __UART0__)

| UART Module | Base Address |
|:-----------:|:------------:|
| __UART0__ | __`0x0414_0000`__ |
| UART1 | `0x0415_0000` |
| UART2 | `0x0416_0000` |
| UART3 | `0x0417_0000` |
| UART4 | `0x041C_0000` |
| RTCSYS_UART | `0x0502_2000` |

_What UART Controller is inside SG2000?_

According to [__OpenSBI Log__](https://lupyuen.github.io/articles/sg2000#boot-the-linux-microsd): The UART Controller is __`uart8250`__.

Which is supported by NuttX. We mod the NuttX Boot Code to print something...

![Print to UART in RISC-V Assembly](https://lupyuen.github.io/images/sg2000-boot2.jpg)

# Print to UART in RISC-V Assembly

_Printing in RISC-V Assembly? Why not C?_

That's because the very first thing that boots is the NuttX Boot Code in __RISC-V Assembly__ (instead of C)...

- [__"Print to QEMU Console"__](https://lupyuen.github.io/articles/nuttx2#print-to-qemu-console)

SG2000 UART0 Controller is at __`0x0414_0000`__ (previous section). To print something, we write to the __UART Output Register__ at that address: [bl808_head.S](https://github.com/lupyuen2/wip-nuttx/blob/sg2000/arch/risc-v/src/bl808/bl808_head.S#L70-L89)

```c
/* RISC-V Boot Code for Apache NuttX RTOS */
real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x04140000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)
```

[(Moved here)](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/sg2000/sg2000_head.S#L69-L73)

[(__`li`__ loads a Value into a Register)](https://lupyuen.github.io/articles/riscv#other-instructions)

[(__`sb`__ stores a byte from a Register into an Address)](https://five-embeddev.com/quickref/instructions.html#-rv32--load-and-store-instructions)

Our code will print "__`123`__" when NuttX boots. We test this...

# NuttX Boots A Tiny Bit

Follow these steps to build __Apache NuttX RTOS__ for SG2000 and Milk-V Duo S...

- [__"Build NuttX for SG2000"__](https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000)

  [(See the __Build Outputs__)](https://github.com/lupyuen2/wip-nuttx/releases/tag/sg2000-1)

This produces the NuttX Image File: [__`Image`__](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/Image-sg2000). Which we copy to our __TFTP Server__...

```bash
## Copy NuttX Image and Device Tree to TFTP Server
## TODO: Change `tftpserver` and `tftpboot` to our TFTP Server and Path
cp Image Image-sg2000
scp Image-sg2000 \
  tftpserver:/tftpboot/Image-sg2000
scp cv181x_milkv_duos_sd.dtb \
  tftpserver:/tftpboot/cv181x_milkv_duos_sd.dtb
```

[(__cv181x_milkv_duos_sd.dtb__ is here)](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/cv181x_milkv_duos_sd.dtb)

To Boot NuttX: Run these commands at the __U-Boot Command Prompt__...

```bash
## Load NuttX Image and Device Tree into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000
$ tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb
$ fdt addr ${fdt_addr_r}

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123
```

See the "__`123`__"? That's proof that our NuttX Boot Code __is actually running__ on SG2000 and Milk-V Duo S. We port some more...

[(See the __Complete Log__)](https://gist.github.com/lupyuen/78b54326daf0894a2c23ab6d2c03456d)

![NuttX Kernel Boots OK](https://lupyuen.github.io/images/sg2000-kernel.jpg)

# NuttX Kernel Boots OK

_NuttX Kernel prints "123". What about the rest?_

More mods for __NuttX Kernel__...

1.  We set the [__NuttX Memory Map__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map) for SG2000: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    ## Kernel RAM
    CONFIG_RAM_START=0x80200000
    CONFIG_RAM_SIZE=1048576
    ```

    [(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig#L76-L77)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  Also the [__NuttX Linker Script__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map): [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

    ```c
    MEMORY {
      kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
      ...
    SECTIONS {
      . = 0x80200000;
    ```

    [(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/scripts/ld.script#L20-L54)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  We select the [__NuttX Driver for 16550 UART__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_16550_REGINCR=4
    CONFIG_16550_UART0=y
    CONFIG_16550_UART0_BASE=0x04140000
    CONFIG_16550_UART0_SERIAL_CONSOLE=y
    CONFIG_16550_UART=y
    CONFIG_16550_WAIT_LCR=y
    CONFIG_SERIAL_UART_ARCH_MMIO=y
    ```

    [(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig#L10-L18)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

1.  Enable Logging for [__NuttX Scheduler and Binary Loader__](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler): [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

    ```bash
    CONFIG_DEBUG_BINFMT=y
    CONFIG_DEBUG_BINFMT_ERROR=y
    CONFIG_DEBUG_BINFMT_WARN=y
    CONFIG_DEBUG_SCHED=y
    CONFIG_DEBUG_SCHED_ERROR=y
    CONFIG_DEBUG_SCHED_INFO=y
    CONFIG_DEBUG_SCHED_WARN=y
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler)

1.  And disable the [__PLIC Interrupt Controller__](https://lupyuen.github.io/articles/sg2000#disable-interrupt-controller) (until we figure it out)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#disable-interrupt-controller)

After applying the above fixes: __NuttX Kernel__ boots successfully! (Pic above)

```bash
## Load NuttX Image and Device Tree into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000
$ tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb
$ fdt addr ${fdt_addr_r}

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x80409140
nxtask_exit: AppBringUp pid=2,TCB=0x80408740
```

One last thing and we're done...

[(See the __Complete Log__)](https://gist.github.com/lupyuen/aaa0a6646490d45e5cd99b781cbe59f8)

[(Watch the __Demo on YouTube__)](https://www.youtube.com/watch?v=pPNDiC5NLqM)

![NuttX Kernel boots all the way to NuttX Shell](https://lupyuen.github.io/images/sg2000-nsh.jpg)

# NuttX Shell Too!

_NuttX Kernel boots OK. Where's the NuttX Shell?_

We won't see the NuttX Shell until we fix the __Interrupt Controller__ for SG2000. Which is NOT documented. (Sigh)

That's because NuttX Shell requires [__UART Input Interrupts__](https://lupyuen.github.io/articles/plic#serial-input-in-nuttx-qemu) AND [__UART Output Interrupts__](https://lupyuen.github.io/articles/plic#serial-output-in-nuttx-qemu), to support Console Input / Output.

Thus we sniff around and find out how the Interrupt Controller works.

1.  We dumped the [__Linux Device Tree__](https://lupyuen.github.io/articles/sg2000#dump-the-linux-device-tree) for SG2000...

    ```bash
    ## Convert the SG2000 Device Tree
    dtc \
      -o cv181x_milkv_duos_sd.dts \
      -O dts \
      -I dtb \
      cv181x_milkv_duos_sd.dtb
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#dump-the-linux-device-tree)

1.  Snooped the [__PLIC Interrupt Controller__](https://lupyuen.github.io/articles/sg2000#interrupt-controller-for-sg2000) in the Device Tree: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts#L1021-L1034)

    ```c
    interrupt-controller@70000000 {
      riscv,ndev = <0x65>;
      riscv,max-priority = <0x07>;
      reg-names = "control";
      reg = <0x00 0x70000000 0x00 0x4000000>;
      interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
      interrupt-controller;
      compatible = "riscv,plic0";
    ```

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#interrupt-controller-for-sg2000)

1.  And fixed the [__NuttX Driver__](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic) for PLIC Interrupts: [bl808_memorymap.h](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6#diff-8fffa570a48f8f10004d9da8d4c671d34336f6c4b8dcfc2bd72275d8cda4ac04)

    ```c
    // Base Address of PLIC Interrupt Controller
    #define BL808_PLIC_BASE 0x70000000ul
    ```

    [(Moved here)](https://github.com/apache/nuttx/blob/master/arch/risc-v/src/sg2000/hardware/sg2000_memorymap.h#L27-L32)

    [(Explained here)](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic)

After fixing the Interrupt Controller and UART Interrupts: Our [__Final NuttX Image__](https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000) boots all the way to __NuttX Shell__! (Pic above)

```bash
## Load NuttX Image and Device Tree into RAM
$ dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000
$ tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb
$ fdt addr ${fdt_addr_r}

## Boot NuttX from RAM
$ booti ${kernel_addr_r} - ${fdt_addr_r}

Starting kernel ...
NuttShell (NSH) NuttX-12.4.0

nsh> uname -a
NuttX 12.4.0 122c717 May  8 2024 18:13:30 risc-v ox64

nsh> ls
/:
 dev/
 proc/
 system/

nsh> ls /dev
/dev:
 console
 null
 ram0
 ttyS0
 zero
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/b778986ba87c18067cd993b92c673634)

_What about the rest of NuttX?_

[__NuttX OSTest__](https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing) is the perfect way to test everything in NuttX...

```bash
nsh> ostest
user_main: mutex test
riscv_exception:
  EXCEPTION: Load access fault
  MCAUSE:    5
  EPC:       802189ce
  MTVAL:     0000000000000000
  Segmentation fault in PID 7: ostest
```

Sadly we're hitting a RISC-V Exception: __Load Access Fault__. Needs more troubleshooting alamak.

[(See the __Complete Log__)](https://gist.github.com/lupyuen/fff5242cf77a3f52d81f3effb9aa402f)

> ![NuttX Boot Flow](https://lupyuen.github.io/images/sg2000-boot.jpg)

_What happens exactly when NuttX boots on SG2000?_

Exact same thing as NuttX booting on Ox64 BL808 SBC (pic above)...

- [__"NuttX Boot Flow"__](https://lupyuen.github.io/articles/ox2#appendix-nuttx-boot-flow)

  [(__AI__ might explain it better?)](https://gist.github.com/lupyuen/cb14b278d2749fc83d3709f5d1f604e4)

![Milk-V Duo S SBC with SG2000 RISC-V SoC](https://lupyuen.github.io/images/sg2000-box.jpg)

# What's Next

We're eagerly awaiting the new 64-bit RISC-V SBCs based on the __Sophgo SG2000 RISC-V SoC__. Meanwhile we're all prepped and ready...

- We tested Linux on __Milk-V Duo S__ (SG2000 inside)

- And observed how __SG2000 Linux__ boots

- Then we took __NuttX for Ox64 BL808__

- Tweaked the NuttX Kernel to __boot on SG2000__

- Also fixed the (undocumented) __Interrupt Controller__

- Milk-V Duo S now boots to a fully-functional __NuttX Shell__

- Something strangely super satisfying about __NuttX on SG2000__... We finished the port in __Only 10 Days__ 🎉

Up Next...

1.  We'll Upstream SG2000 to __NuttX Mainline__

    (So others may contribute their code)

    [__UPDATE: NuttX Mainline now supports SG2000 and Milk-V Duo S!__](https://lupyuen.github.io/articles/sg2000#appendix-nuttx-mainline-now-supports-sg2000)

1.  Run __Daily Automated Testing__ on a Real SG2000 SBC...

    [__"Daily Automated Testing for Milk-V Duo S RISC-V SBC (IKEA TRETAKT / Apache NuttX RTOS)"__](https://lupyuen.github.io/articles/sg2000a)

    [__"Test Bot for Pull Requests ... Tested on Real Hardware (Apache NuttX RTOS / Oz64 SG2000 RISC-V SBC)"__](https://lupyuen.org/articles/testbot.html)

1.  Create an __SG2000 Emulator__ for easier testing...

    [__"Emulate Sophgo SG2000 SoC / Milk-V Duo S SBC with TinyEMU RISC-V Emulator"__](https://github.com/lupyuen2/sg2000-emulator)

1.  We might run NuttX on the __SG2000 Co-Processor__

    (Plus SG2002 with its upsized TPU / NPU)

1.  Join me online at the [__Apache NuttX International Workshop__](https://events.nuttx.apache.org/)

    (We'll Q&A about Ox64 BL808 and SG2000)

Many Thanks to my [__GitHub Sponsors__](https://lupyuen.github.io/articles/sponsor) (and the awesome NuttX Community) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://lupyuen.github.io/articles/sponsor)

-   [__Discuss this article on Hacker News__](https://news.ycombinator.com/item?id=40402712)

-   [__My Current Project: "Apache NuttX RTOS for Ox64 BL808"__](https://github.com/lupyuen/nuttx-ox64)

-   [__My Other Project: "NuttX for Star64 JH7110"__](https://github.com/lupyuen/nuttx-star64)

-   [__Older Project: "NuttX for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/sg2000.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000.md)

![NuttX Mainline now supports SG2000](https://lupyuen.github.io/images/sg2000-oz64.jpg)

# Appendix: Apache NuttX RTOS for Pine64 Oz64 SBC

_What about Pine64 Oz64 SBC? Which also runs on SG2000 SoC?_

Yep [__Pine64 Oz64 SBC__](https://pine64.org/documentation/Oz64/) is supported by NuttX Mainline! (Pic above)

Just follow the exact same instructions that we covered earlier...

## Connect our USB UART Adapter

Connect our __USB UART Dongle__ to Oz64 SBC (pic below)

| Oz64 SBC | USB UART |
|:------------:|:--------:|
| __GND__ (Pin 6)	| __GND__ |
| __TX__ (Pin 8) |	__RX__ |
| __RX__ (Pin 10)	| __TX__ |

USB UART Dongle must be [__CP2102__](http://sun-light.com.sg/index.php?route=product/product&product_id=2367), it doesn't like [__CH340__](https://pine64.com/product/serial-console-woodpecker-edition/) 

![Connecting our USB UART Dongle to Oz64 SBC](https://lupyuen.github.io/images/oz64-pins.jpg)

## Download the Linux MicroSD

Based on the Linux MicroSD created by [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Image for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__Latest Release: duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

Uncompress the Debian Image...

```bash
## For Linux:
$ sudo apt install lz4

## For macOS:
$ brew install lz4

## Uncompress the download to get `duos_sd.img`
$ lz4 duos_sd.img.lz4
```

And write __`duos_sd.img`__ to a MicroSD Card. Use [__Balena Etcher__](https://etcher.balena.io), [__GNOME Disks__](https://wiki.gnome.org/Apps/Disks) or [__`dd`__](https://gist.github.com/lupyuen/aae995d942d5ec3ffa6629667bcc3ae6).

Insert the MicroSD Card into Oz64, but don't power up yet...

## Download the NuttX Image

Download the NuttX Image File __`Image`__ from the Latest Daily Build of __NuttX for SG2000__...

- [__Daily Build: NuttX for SG2000__](https://github.com/lupyuen/nuttx-sg2000/tags)

  (Skip the Special Builds __"special-sg2000"__)

  [(Or __Build NuttX__ ourselves)](https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000)

And download the Oz64 Device Tree...

- [__Device Tree: cv181x_milkv_duos_sd.dtb__](https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/cv181x_milkv_duos_sd.dtb)

We'll copy them to our TFTP Server...

## Boot NuttX over TFTP 

Follow the [__instructions here__](https://lupyuen.github.io/articles/tftp#install-tftp-server) to install our TFTP Server. 

Copy the __NuttX Image__ and __Device Tree__ (previous section) to our TFTP Server...

```bash
## Copy NuttX Image and Device Tree to TFTP Server
## TODO: Change `tftpserver` and `tftpboot` to our TFTP Server and Path
cp Image Image-sg2000
scp Image-sg2000 \
  tftpserver:/tftpboot/Image-sg2000
scp cv181x_milkv_duos_sd.dtb \
  tftpserver:/tftpboot/cv181x_milkv_duos_sd.dtb
```

Power up the board via the __Oz64 Power Adapter__. Connect to the USB UART at __115.2 kbps__...

```bash
screen /dev/ttyUSB0 115200
```

When Oz64 boots, press Enter to reveal the __U-Boot Command Prompt__.

Enter these commands to configure U-Boot to __Auto-Boot NuttX__ on Oz64...

```bash
## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## Add the Boot Command for TFTP
setenv bootcmd_tftp 'dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ; tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}'

## Remember the Original Boot Targets: `mmc0 dhcp pxe`
setenv orig_boot_targets "$boot_targets"

## Prepend TFTP to the Boot Targets: `tftp mmc0 dhcp pxe`
setenv boot_targets "tftp $boot_targets"

## Save it for future reboots
saveenv
```

Power-off and power-on our SBC. NuttX now __auto-boots on Oz64__ whenever we power-on...

```bash
Starting kernel ...
NuttShell (NSH) NuttX-12.4.0

nsh> uname -a
NuttX 12.4.0 122c717 May  8 2024 18:13:30 risc-v ox64
```

[(See the __NuttX Log__)](https://gist.github.com/lupyuen/c0bf8178a1149461c750e9c71855d643)

[(What about __Static IP__?)](https://github.com/lupyuen/nuttx-sg2000/issues/1)

[(How to __Undo Auto-Boot__)](https://github.com/lupyuen/nuttx-sg2000/issues/1#issuecomment-2114415245)

__TODO:__ Boot NuttX on MicroSD

![NuttX Mainline now supports SG2000](https://lupyuen.github.io/images/sg2000-pr.jpg)

# Appendix: NuttX Mainline now supports SG2000!

Sophgo SG2000 SoC, Milk-V Duo S SBC and Pine64 Oz64 SBC are now officially supported by __Apache NuttX Mainline__! 🎉

- [__Official NuttX Docs: Milk-V Duo S__](https://nuttx.apache.org/docs/latest/platforms/risc-v/sg2000/boards/milkv_duos/index.html)

- [__arch/risc-v: Add support for SOPHGO SG2000 SoC__](https://github.com/apache/nuttx/pull/12506)

- [__boards/risc-v: Add support for Milk-V Duo S SBC__](https://github.com/apache/nuttx/pull/12510)

_How did we prepare the Pull Requests for NuttX Mainline?_

In this article we discussed the Modified Code for SG2000. We took the Modified Code and staged the changes into our NuttX Repo here...

- [__Modified Code: NuttX for SG2000__](https://github.com/lupyuen2/wip-nuttx/pull/57/files)

Next we create [__a new branch__](https://github.com/lupyuen2/wip-nuttx/tree/sg2000a). Inside the new branch: We copy the __NuttX Source Folders__ for BL808 / Ox64, and paste the folders as SG2000 / Duo S...

1. ["Copy and rename BL808 to SG2000"](https://github.com/lupyuen2/wip-nuttx/commit/f70c3e7024ba39fda808a835419e21ddac7bfa00)

1. ["Copy and rename Ox64 to DuoS"](https://github.com/lupyuen2/wip-nuttx/commit/8225b764bda81e0c7f7db3698754d11185a9ea57)

1. ["Copy and rename BL808 Include to SG2000 Include"](https://github.com/lupyuen2/wip-nuttx/commit/6af7a01482545d8b2a4025980253e1e914f15433)

1. ["Rename BL808 AppInit to SG2000 AppInit"](https://github.com/lupyuen2/wip-nuttx/commit/b5ef76b8c893e7cdd461dbee9c5124542d8c497d)

1. ["Remove BL808 UART from SG2000"](https://github.com/lupyuen2/wip-nuttx/commit/810672b47070c4848c36bf72a752354d2e456120)

Remember our __Modified Code for SG2000__? We copy the Modified Code into our new NuttX Source Folders (for SG2000 and Duo S)...

- ["Copy changes from sg2000 branch to sg2000a"](https://github.com/lupyuen2/wip-nuttx/commit/fa9e319032decea8241cd25b3ae77a86ef132746)

- ["Disable Binary Loader Debug and Scheduler Debug"](https://github.com/lupyuen2/wip-nuttx/commit/2886da6837862fad46cbaf96c672bc168cdd7b38)

- ["Fix SG2000 IRQ"](https://github.com/lupyuen2/wip-nuttx/commit/f12ad97561958e2449082faffcbf4836b70e2f84)

We create a new __NuttX SoC (Arch) for SG2000__. And a new NuttX Board for Milk-V Duo S...

- ["Add Arch for SG2000. Add Board for Milk-V Duo S."](https://github.com/lupyuen2/wip-nuttx/commit/527029c94c9cafa44d2afa248f2e11ad1dda508f)

We compute the [__UART Clock Frequency__](https://lupyuen.github.io/articles/release#appendix-uart-clock-for-jh7110) for SG2000 and configure it in NuttX...

- ["Set UART Clock to 24883200"](https://github.com/lupyuen2/wip-nuttx/commit/7a7d5e53be1ebb93ed90541859e18af694a5b64d)

- ["Restore setting of UART Divisor"](https://github.com/lupyuen2/wip-nuttx/commit/deff18c8776b14da6359b7498e159c81fb147771)

Then we goofed and realise that NSH Shell won't wait for commands to complete! (NSH Shell returns immediately) We restore the NuttX Configuration to __wait for processes__...

- ["Enable SCHED_HAVE_PARENT and SCHED_WAITPID"](https://github.com/lupyuen2/wip-nuttx/commit/db2a0327b747e18bcc2876d4cd4d6bed9982f07c)

__sleep()__ wasn't sleeping with the right duration. Thus we adjust the __RISC-V Timer Frequency__...

- ["Set MTIMER_FREQ to 25000000"](https://github.com/lupyuen2/wip-nuttx/commit/bb4906c976e44a05237f91944844cd1c68ef5d5b)

We enable __RAW_BINARY__ so that NuttX Build will generate __`nuttx.bin`__ (otherwise we need to generate it ourselves)...

- ["Enable CONFIG_RAW_BINARY to generate nuttx.bin"](https://github.com/lupyuen2/wip-nuttx/commit/1af8f07daf73fced40293dc37480b3dca1c0ad61)

We added the __NuttX Documentation__ for SG2000 and Duo S...

- ["Add Arch and Board Docs"](https://github.com/lupyuen2/wip-nuttx/commit/150643ecbfd5e897b3b216c63272c5de8d864cae)

- ["Fix Arch and Board Docs"](https://github.com/lupyuen2/wip-nuttx/commit/a7b2b8e074d1e9ad92d6624ddcac7d82a3a63e39)

- ["Update Arch and Board Docs"](https://github.com/lupyuen2/wip-nuttx/commit/c67903426e23aa001791edb65505fed03bc20245)

During PR Review: We realised that __`duos`__ wasn't a distinctive name. Hence we renamed it to __`milkv_duos`__

- ["Rename duos to milkv_duos"](https://github.com/lupyuen2/wip-nuttx/commit/11fe99366cbf1f46737ab2baee40a37ee0c0b7d3)

- ["Rename Board and Doc Folders for duos to milkv_duos"](https://github.com/lupyuen2/wip-nuttx/commit/218ccd843af0b80c92a79dc9d68956dc9d24b3bf)

And finally we run a [__script like this__](https://gist.github.com/lupyuen/b1c9779482bb0c2b0c3b690f7a74e3dd), to split the above Modified Files into __Two Pull Requests__. We made it to NuttX Mainline!

_NuttX Mainline changes every day. Can we be sure that NuttX will always run OK on SG2000?_

That's why we __Build NuttX for SG2000__ every day at GitHub Actions. And we test the Daily Build on a __Real Milk-V Duo S SBC__!

- [__Automated Daily Build: NuttX for SG2000__](https://github.com/lupyuen/nuttx-sg2000#nuttx-automated-daily-build-for-sg2000)

- [__Automated Daily Testing: NuttX for SG2000__](https://github.com/lupyuen2/autotest-nuttx-sg2000)

![Build NuttX for SG2000](https://lupyuen.github.io/images/sg2000-build.jpg)

# Appendix: Build NuttX for SG2000

We may download the NuttX Image File __`Image`__ from the Latest Daily Build of __NuttX for SG2000__...

- [__Daily Build: NuttX for SG2000__](https://github.com/lupyuen/nuttx-sg2000/tags)

If we prefer to build NuttX ourselves, please read on...

In this article we took NuttX for [__Ox64 BL808 RISC-V SBC__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S...

1.  [__"Set the NuttX Memory Map"__](https://lupyuen.github.io/articles/sg2000#nuttx-memory-map)

1.  [__"Select the 16550 UART Driver"__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

1.  [__"Enable Logging for Scheduler"__](https://lupyuen.github.io/articles/sg2000#enable-logging-for-scheduler)

1.  [__"Fix the NuttX Driver for PLIC"__](https://lupyuen.github.io/articles/sg2000#fix-the-nuttx-driver-for-plic)

Follow these steps to build Apache NuttX RTOS (Mainline) for __SG2000 and Milk-V Duo S__, based on the [__Official NuttX Docs__](https://nuttx.apache.org/docs/latest/platforms/risc-v/sg2000/boards/milkv_duos/index.html)...

Install the Build Prerequisites, skip the RISC-V Toolchain...

- [__"Install Prerequisites"__](https://lupyuen.github.io/articles/nuttx#install-prerequisites)

Download the RISC-V Toolchain for __riscv-none-elf__ (xPack)...
    
- [__"xPack GNU RISC-V Embedded GCC Toolchain for 64-bit RISC-V"__](https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v)

Then Download and Build NuttX...

```bash
set -e  #  Exit when any command fails
set -x  #  Echo commands

## Download the Source Code for NuttX Kernel and NuttX Apps
git clone https://github.com/apache/incubator-nuttx nuttx
git clone https://github.com/apache/incubator-nuttx-apps apps
cd nuttx

## Pull updates
git pull && git status && hash1=`git rev-parse HEAD`
pushd ../apps
git pull && git status && hash2=`git rev-parse HEAD`
popd
echo NuttX Source: https://github.com/apache/nuttx/tree/$hash1 >nuttx.hash
echo NuttX Apps: https://github.com/apache/nuttx-apps/tree/$hash2 >>nuttx.hash

## Show the version of GCC
riscv-none-elf-gcc -v

## Configure the build
tools/configure.sh milkv_duos:nsh

## Preserve the build config
cp .config nuttx.config

## Run the build
make

## Build the Apps Filesystem
make export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make import
popd

## Generate the Initial RAM Disk
genromfs -f initrd -d ../apps/bin -V "NuttXBootVol"

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero >/tmp/nuttx.pad

## Append the Padding and Initial RAM Disk to the NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  >Image

## Copy the NuttX Image and Device Tree to our TFTP Server
cp Image Image-sg2000
wget https://github.com/lupyuen2/wip-nuttx/releases/download/sg2000-1/cv181x_milkv_duos_sd.dtb
scp Image-sg2000 tftpserver:/tftpboot/Image-sg2000
scp cv181x_milkv_duos_sd.dtb tftpserver:/tftpboot/cv181x_milkv_duos_sd.dtb

## [For Debugging Only] Show the size
riscv-none-elf-size nuttx

## [For Debugging Only] Dump the NuttX Kernel disassembly to nuttx.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  >nuttx.S \
  2>&1

## [For Debugging Only] Dump the NSH Shell disassembly to init.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/init \
  >init.S \
  2>&1

## [For Debugging Only] Dump the Hello App disassembly to hello.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello \
  >hello.S \
  2>&1
```

[(See the __Build Script__)](https://github.com/lupyuen/nuttx-sg2000/blob/main/.github/workflows/sg2000.yml#L25-L119)

[(See the __Build Outputs__)](https://github.com/lupyuen/nuttx-sg2000/releases/tag/nuttx-sg2000-2024-06-18)

The steps above assume that we've installed our TFTP Server, according to the [__instructions here__](https://lupyuen.github.io/articles/tftp#install-tftp-server).

Then follow these steps to boot NuttX on Milk-V Duo S...

- [__"Boot NuttX over TFTP"__](https://lupyuen.github.io/articles/sg2000#boot-nuttx-over-tftp)

  (How to boot from MicroSD instead of TFTP?)

![Virtual Memory for NuttX Apps](https://lupyuen.github.io/images/mmu-l3user.jpg)

_Why the RAM Disk? Isn't NuttX an RTOS?_

SG2000 uses a RAM Disk because it runs in __NuttX Kernel Mode__ (instead of the typical Flat Mode). This means we can do __Memory Protection__ and __Virtual Memory__ for Apps. (Pic above)

But it also means we need to bundle the __NuttX Apps as ELF Files__, hence the RAM Disk...

- [__"NuttX Apps and Initial RAM Disk"__](https://lupyuen.github.io/articles/app)

Most of the NuttX Platforms run on __NuttX Flat Mode__, which has NuttX Apps Statically-Linked into the NuttX Kernel.

NuttX Flat Mode works well for Small Microcontrollers. But SG2000 and other SoCs will need the more sophisticated __NuttX Kernel Mode__...

- [__"NuttX Flat Mode vs Kernel Mode"__](https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode)

![Porting NuttX to SG2000](https://lupyuen.github.io/images/sg2000-commits.jpg)

# Appendix: Port NuttX to SG2000

_How did we port NuttX to SG2000?_

We started with NuttX for [__Ox64 BL808 RISC-V SBC__](https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358). Then made a few tweaks, and it boots on SG2000 and Milk-V Duo S. This chapter explains the minor tweaks that we made. (Pic above)

_Why did we start with NuttX for Ox64?_

That's because Ox64 BL808 runs on the same RISC-V Core as SG2000: [__T-Head C906__](https://github.com/T-head-Semi/openc906/blob/main/doc/openc906%20datasheet.pdf).

_What about the T-Head Extensions for C906?_

Yep we copied (unchanged) the __T-Head Extensions for C906__ from Ox64 BL808 to SG2000. And they work hunky dory on SG2000...

- [__Enable Strong Ordering in MMU for T-Head C906__](https://lupyuen.github.io/articles/plic3#enable-strong-order)

- [__Flush the MMU Cache for T-Head C906__](https://lupyuen.github.io/articles/mmu#appendix-flush-the-mmu-cache-for-t-head-c906)

Let's talk about the tweaks...

## NuttX Memory Map

From [__U-Boot Bootloader Settings__](https://lupyuen.github.io/articles/sg2000#settings-for-u-boot-bootloader): We see that SG2000 boots at this address...

```bash
kernel_addr_r=0x80200000
```

Thus we define the __NuttX Memory Map__ for SG2000 like so...

- [__Set the NuttX Memory Map for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2)

NuttX Kernel will boot at __`0x8020_0000`__, NuttX Apps will run at Virtual Address __`0xC000_0000`__.

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
## Kernel RAM
## TODO: Fix the size
CONFIG_RAM_START=0x80200000
CONFIG_RAM_SIZE=1048576

## Kernel Paged Pool (Allocated to NuttX Apps)
## TODO: Fix the size
CONFIG_ARCH_PGPOOL_PBASE=0x80600000
CONFIG_ARCH_PGPOOL_VBASE=0x80600000
CONFIG_ARCH_PGPOOL_SIZE=4194304

## Virtual Memory for NuttX App Code
CONFIG_ARCH_TEXT_VBASE=0xC0000000
CONFIG_ARCH_TEXT_NPAGES=128

## Virtual Memory for NuttX App Data
CONFIG_ARCH_DATA_VBASE=0xC0100000
CONFIG_ARCH_DATA_NPAGES=128

## Virtual Memory for NuttX App Heap
CONFIG_ARCH_HEAP_VBASE=0xC0200000
CONFIG_ARCH_HEAP_NPAGES=128
```

[(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig)

And here's the __NuttX Linker Script__: [ld.script](https://github.com/lupyuen2/wip-nuttx/commit/c6c0bd3882a855420acf0d53fa9d37bbd9d125b2#diff-769e7c2389b298f666c84b92f36d3c42fa852fda61dbf20b93e603df98b7bd37)

```c
/* TODO: Fix the size */
MEMORY {
  kflash (rx) : ORIGIN = 0x80200000, LENGTH = 2048K   /* w/ cache */
  ksram (rwx) : ORIGIN = 0x80400000, LENGTH = 2048K   /* w/ cache */
  pgram (rwx) : ORIGIN = 0x80600000, LENGTH = 4096K   /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x80A00000, LENGTH = 16M   /* w/ cache */
}
...
SECTIONS {
  . = 0x80200000;
```

[(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/scripts/ld.script#L20-L54)

## Select the 16550 UART Driver

From [__OpenSBI Log__](https://lupyuen.github.io/articles/sg2000#settings-for-u-boot-bootloader): We see that SG2000 runs with a __8250 UART Controller__.

Thus we select the NuttX Driver for __16550 UART__, which is compatible with 8250...

- [__Select the NuttX Driver for 16550 UART__](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/8f8831d15d6ddc913e6dd1c6c49fb0067640f6ec#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x04140000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y
```

[(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig#L10-L18)

Don't update the NuttX Config File directly! We ran __`make menuconfig`__ to generate the above file...

```bash
## Update NuttX Config
make menuconfig \
  && make savedefconfig \
  && grep -v CONFIG_HOST defconfig \
  >boards/risc-v/bl808/ox64/configs/nsh/defconfig
```

__To Find Menuconfig Settings:__ Press "__`/`__" and enter the name of the setting, like _"16550_ADDRWIDTH"_. This ensures that the Kconfig Dependencies are correctly updated.

![UART IRQ](https://lupyuen.github.io/images/sg2000-irq.jpg)

_How did we get IRQ 69 for UART?_

We set IRQ 69 for UART0...

- [__Set UART0 IRQ to 69 (25 + 44)__](https://github.com/lupyuen2/wip-nuttx/commit/122c717447f81c310a4fb082101213ad338dfb0e)

  ```bash
  CONFIG_16550_UART0_IRQ=69
  ```

  [(Moved here)](https://github.com/apache/nuttx/blob/master/boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig#L10-L18)

That's because the [__SG2000 Reference Manual__](https://github.com/sophgo/sophgo-doc/releases) (Page 13) says...

> ___3.1 Interrupt Subsystem___

> ___Table 3.2:__ Interrupt number and Interrupt source mapping for Master RISCV C906 @ 1.0Ghz_

> ___Int #44:__ UART0_

[__Linux Device Tree__](https://lupyuen.github.io/articles/sg2000#dump-the-linux-device-tree) also says UART0 IRQ is __44 (`0x2C`)__

```c
serial@04140000 {
  compatible = "snps,dw-apb-uart";
  reg = <0x00 0x4140000 0x00 0x1000>;
  clock-frequency = <0x17d7840>;
  reg-shift = <0x02>;
  reg-io-width = <0x04>;
  status = "okay";
  interrupts = <0x2c 0x04>;
  interrupt-parent = <0x04>;
};
```

Thus we compute [__NuttX IRQ__](https://lupyuen.github.io/articles/plic2#uart-interrupt) = 25 + RISC-V IRQ = 69

(We should fix the UART Clock: _16550_UART0_CLOCK_)

![Whither PLIC?](https://lupyuen.github.io/images/sg2000-memory.jpg)

## Disable Interrupt Controller

Most RISC-V SBCs (Ox64, Star64) will manage Interrupts with a [__Platform-Level Interrupt Controller (PLIC)__](https://lupyuen.github.io/articles/plic2). But PLIC isn't documented for SG2000. (Pic above sigh)

Initially we disable PLIC in NuttX...

- [__Disable the PLIC Interrupt Controller__](https://github.com/lupyuen2/wip-nuttx/commit/6d66caa1408d7a7d7b21b0e876ce32ceb5b93ec4)

Later we'll dump the SG2000 Linux Device Tree to understand the Interrupt Controller.

## Dump the Linux Device Tree

To understand the Interrupt Controller: We dump the __Linux Device Tree__ for SG2000.

Based on the SG2000 Debian Image, thanks to [__Justin Hammond__](https://github.com/Fishwaldo) (Fishwaldo)...

- [__Debian Images for Sophgo SG2000__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases)

We download the Latest Release for __Milk-V Duo S__ (SG2000)...

- [__Latest Release: duos_sd.img.lz4__](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

Then copy out the SG2000 __Device Tree Binary__: [cv181x_milkv_duos_sd.dtb](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dtb)

And convert it to __Device Tree Source__: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts)

```bash
## Convert the SG2000 Device Tree
dtc \
  -o cv181x_milkv_duos_sd.dts \
  -O dts \
  -I dtb \
  cv181x_milkv_duos_sd.dtb
```

We go inside the Device Tree...

## Interrupt Controller for SG2000

Earlier we dumped the __Linux Device Tree__ for SG2000. We snoop inside to understand the Interrupt Controller: [cv181x_milkv_duos_sd.dts](https://github.com/lupyuen/nuttx-sg2000/blob/main/cv181x_milkv_duos_sd.dts#L1021-L1042)

```c
// PLIC Interrupt Controller for External Interrupts
interrupt-controller@70000000 {
  riscv,ndev = <0x65>;
  riscv,max-priority = <0x07>;
  reg-names = "control";
  reg = <0x00 0x70000000 0x00 0x4000000>;
  interrupts-extended = <0x16 0xffffffff 0x16 0x09>;
  interrupt-controller;
  compatible = "riscv,plic0";
  #interrupt-cells = <0x02>;
  #address-cells = <0x00>;
  phandle = <0x04>;
};

// CLINT Interrupt Controller for Internal Interrupts
clint@74000000 {
  interrupts-extended = <0x16 0x03 0x16 0x07>;
  reg = <0x00 0x74000000 0x00 0x10000>;
  compatible = "riscv,clint0";
  clint,has-no-64bit-mmio;
};
```

We see that PLIC (External Interrupts) is at __`0x7000_0000`__, CLINT (Internal Interrupts) at __`0x7400_0000`__...

![Platform-Level Interrupt Controller](https://lupyuen.github.io/images/sg2000-plic.jpg)

## Fix the NuttX Driver for PLIC

Based on the PLIC Address from above: We fix the [__Platform-Level Interrupt Controller (PLIC)__](https://lupyuen.github.io/articles/plic2) for SG2000...

- [__Fix the PLIC Interrupt Controller for SG2000__](https://github.com/lupyuen2/wip-nuttx/commit/f5f1aeac36350b8149fc2a77c817217711f082f6)

Now we see a bit more NuttX...

```bash
Starting kernel ...
123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80409130
nxtask_activate: AppBringUp pid=2,TCB=0x80409740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3
nxtask_activate: /system/bin/init pid=3,TCB=0x8040b730
nxtask_exit: AppBringUp pid=2,TCB=0x80409740

Nuttnx_start: CPU0: Beginning Idle Loop
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/922e6379375fbc5d775d1e83cac4deb5)

_Why did it stop?_

Duh we set the wrong UART0 IRQ! Here's the fix...

- [__"Select the 16550 UART Driver"__](https://lupyuen.github.io/articles/sg2000#select-the-16550-uart-driver)

## Enable Logging for Scheduler

For easier troubleshooting: We enable Logging for __NuttX Scheduler and Binary Loader__...

- [__Enable Logging for Scheduler and Binary Loader__](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47)

Here's the NuttX Config: [nsh/defconfig](https://github.com/lupyuen2/wip-nuttx/commit/4cee79630359f6b31fc9fa40f31bb476c8bc4d47#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078)

```bash
CONFIG_DEBUG_BINFMT=y
CONFIG_DEBUG_BINFMT_ERROR=y
CONFIG_DEBUG_BINFMT_WARN=y
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y
```

Remember: Always use __`make menuconfig`__ to update the settings!

## NuttX Crash Dump

_What happens when something goes wrong in NuttX?_

We'll see a __NuttX Crash Dump__, like so...

```bash
Booting using the fdt blob at 0x81200000
Loading Ramdisk to 9fe00000, end 9fe00000 ... OK
Loading Device Tree to 000000009f26f000, end 000000009f27e43a ... OK
Starting kernel ...

123ABCnx_start: Entry
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_lowpri: Starting low-priority kernel worker thread(s)
nxtask_activate: lpwork pid=1,TCB=0x80408130
nxtask_activate: AppBringUp pid=2,TCB=0x80408740
nx_start_application: Starting init task: /system/bin/init
elf_symname: Symbol has no name
elf_symvalue: SHN_UNDEF: Failed to get symbol name: -3
elf_relocateadd: Section 2 reloc 2: Undefined symbol[0] has no name: -3

_assert: Current Version: NuttX  12.4.0 f37a380-dirty May  7 2024 10:31:33 risc-v
_assert: Assertion failed 0x17 == (insn & 0x7F): at file: machine/risc-v/arch_elf.c:494 task: AppBringUp process: Kernel 0x80200f34
up_dump_register: EPC: 000000008021087a
up_dump_register: A0: 0000000080401b70 A1: 00000000000001ee A2: 0000000080228ef8 A3: 0000000000000000
up_dump_register: A4: 0000000000000017 A5: 0000000000000002 A6: 000000000000ab9c A7: fffffffffffffff8
up_dump_register: T0: 000000000000002e T1: 0000000000000007 T2: 00000000000001ff T3: 000000008040c3fc
up_dump_register: T4: 000000008040c3f0 T5: 0000000000000009 T6: 000000000000002a
up_dump_register: S0: 0000000000000000 S1: 0000000080408740 S2: 0000000000000017 S3: 0000000000000000
up_dump_register: S4: 0000000080228ef8 S5: 0000000080228de8 S6: 0000000080401e10 S7: 8000000201842022
up_dump_register: S8: 00000000000001ee S9: 000000008040b9a0 S10: 0000000000000070 S11: 000000008040b990
up_dump_register: SP: 000000008040c330 FP: 0000000000000000 TP: 0000000000000000 RA: 000000008021087a
dump_stack: User Stack:
dump_stack:   base: 0x8040c030
dump_stack:   size: 00002000
dump_stack:     sp: 0x8040c330
```

[(See the __Complete Log__)](https://gist.github.com/lupyuen/594f0df20d39001bac171412d594d517)

_What's this Assertion Failure?_

```bash
_assert: Assertion failed 0x17 == (insn & 0x7F):
at file: machine/risc-v/arch_elf.c:494
task: AppBringUp process: Kernel 0x80200f34
```

Oops we goofed and used the __Wrong U-Boot Command__...

```bash
## Nope! This won't work for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb ; fdt addr ${fdt_addr_r} ;
booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
```

Which overwrites the NuttX Image in RAM. Here's the __Correct U-Boot Command__...

```bash
## This works OK for NuttX. RAM Disk Address must be `-`!
setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-sg2000 ;
tftpboot ${fdt_addr_r} ${tftp_server}:cv181x_milkv_duos_sd.dtb ; fdt addr ${fdt_addr_r} ; 
booti ${kernel_addr_r} - ${fdt_addr_r}
```

# Appendix: Inside the SG2000 MicroSD

_What's inside the SG2000 MicroSD?_

Let's snoop the MicroSD Image based on the [__earlier instructions__](https://lupyuen.github.io/articles/sg2000#download-the-linux-microsd)...

1.  We download [_sophgo-sg200x-debian/duos_sd.img.lz4_](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4)

1.  Uncompress it...

    ```bash
    ## Uncompress the download to get `duos_sd.img`
    $ lz4 duos_sd.img.lz4
    ```

1.  Mount the IMG Filesystem. Yes it's MBR...

    ![SG2000 MicroSD contains MBR](https://lupyuen.github.io/images/sg2000-microsd1.png)

1.  With a __`boot`__ partition (FAT16)...

    ![SG2000 MicroSD contains Boot Partition](https://lupyuen.github.io/images/sg2000-microsd2.png)

    (Plus other EXT Paritions, which won't appear on macOS)

1.  SG2000 Firmware is probably hardcoded to load __`fip.bin`__ from the __`boot`__ partition...

    ![SG2000 MicroSD contains fip.bin](https://lupyuen.github.io/images/sg2000-microsd1.png)

1.  We see that __`fip.bin`__ contains OpenSBI...

    ```text
    $ strings fip.bin
    OpenSBI v%d.%d
      ____                    _____ ____ _____
     / __ \                  / ____|  _ \_   _|
    | |  | |_ __   ___ _ __ | (___ | |_) || |
    | |  | | '_ \ / _ \ '_ \ \___ \|  _ < | |
    | |__| | |_) |  __/ | | |____) | |_) || |_
     \____/| .__/ \___|_| |_|_____/|____/_____|
           | |
           |_|
    ```

    [(See the __Complete Log__)](https://gist.github.com/lupyuen/0d3f790f0b34cb2d1329a0130e13039c)

1.  __`fip.bin`__ probably also contains U-Boot Bootloader, since [__U-Boot is started by OpenSBI__](https://lupyuen.github.io/articles/sg2000#download-the-linux-microsd) (pic below)

1.  Then U-Boot Bootloader boots the NuttX __`Image`__ over TFTP (pic below). This __`Image`__ file comes from the [__SG2000 Daily Build__](https://github.com/lupyuen/nuttx-sg2000/tags). (Please don't burn __`Image`__ into a MicroSD!)

1.  What's inside the NuttX __`Image`__ file? It contains the __NuttX Kernel Image__ (which will run in RAM as-is) plus an Initial RAM Disk that contains the __NuttX Apps__ (e.g. NuttX Shell).

    Definitely not meant to be burned into a MicroSD. And it won't have a Bootloader inside! [__As explained above...__](https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000)

    ```bash
    ## Run the build
    make

    ## Build the Apps Filesystem
    make export
    pushd ../apps
    ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
    make import
    popd

    ## Generate the Initial RAM Disk
    genromfs -f initrd -d ../apps/bin -V "NuttXBootVol"

    ## Prepare a Padding with 64 KB of zeroes
    head -c 65536 /dev/zero >/tmp/nuttx.pad

    ## Append the Padding and Initial RAM Disk to the NuttX Kernel
    cat nuttx.bin /tmp/nuttx.pad initrd \
      >Image
    ```

_Once Again: How exactly does NuttX boot on SG2000?_

1.  SG2000 powers up

1.  SG2000 Onboard Firmware (Flash Memory) looks for __`fip.bin`__ in __`boot`__ partition of MicroSD Card

    (Which we burned from [_sophgo-sg200x-debian/duos_sd.img.lz4_](https://github.com/Fishwaldo/sophgo-sg200x-debian/releases/download/v1.2.0/duos_sd.img.lz4))

1.  SG2000 starts OpenSBI (from __`fip.bin`__)

1.  OpenSBI starts U-Boot Bootloader (from __`fip.bin`__)

1.  U-Boot loads NuttX over TFTP. This is the __`Image`__ file from [__SG2000 Daily Build__](https://github.com/lupyuen/nuttx-sg2000/tags)

    (This __`Image`__ file won't burn to MicroSD!)

_So fip.bin sounds super important for booting SG2000?_

Yeah we could possibly replace __`fip.bin`__ by [__NuttX SBI__](https://github.com/apache/nuttx/tree/master/arch/risc-v/src/nuttsbi). (Which will start NuttX in RISC-V Supervisor Mode)

Or we could replace __`fip.bin`__ by __NuttX Kernel__, executing in __RISC-V Machine Mode__. (Assuming we don't need RISC-V Supervisor Mode)

![OpenSBI and U-Boot Bootloader](https://lupyuen.github.io/images/sg2000-sbi.jpg)
