# Rendering PinePhone's Display (DE and TCON0)

ðŸ“ _30 Oct 2022_

![PinePhone rendering Mandelbrot Set on Apache NuttX RTOS](https://lupyuen.github.io/images/de-title.jpg)

_PinePhone rendering Mandelbrot Set on Apache NuttX RTOS_

In the last 2 articles we talked about [__Pine64 PinePhone__](https://wiki.pine64.org/index.php/PinePhone) (pic above) and how we built a __Display Driver__ for PinePhone's MIPI Display Serial Interface...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

But our PinePhone Display Driver __isn't complete__... It won't render any graphics!

Today we'll learn about the missing bits in our Display Driver...

-   What's the __Display Engine (DE)__ inside PinePhone

-   How the __Timing Controller (TCON0)__ controls PinePhone's LCD Display

-   How we call DE and TCON0 to __render graphics__

-   How our new __PinePhone Display Driver__ will support DE and TCON0

_Why are we doing this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone and we have created a (barebones) [__Display Driver in Zig__](https://lupyuen.github.io/articles/dsi2) that initialises the LCD Display.

To finish the driver, we need to understand what's inside PinePhone's Display Engine and Timing Controller.

Let's dive in and continue the journey from our (super long) __NuttX Porting Journal__...

-   [__lupyuen/pinephone-nuttx__](https://github.com/lupyuen/pinephone-nuttx)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Display Rendering on PinePhone

_Suppose we're building our own Operating System for PinePhone..._

_How do we render graphics on the LCD Display?_

Rendering graphics directly to PinePhone Hardware ("Bare Metal") is more complicated than we expect!

Let's walk through the steps (pic above)...

1.  Inside PinePhone's [__Allwinner A64 SoC__](https://linux-sunxi.org/A64) is a __Display Engine__ that combines and transforms Pixel Data for display

1.  The Display Engine reads the Pixel Data from __Framebuffers in RAM__ via __Direct Memory Access (DMA)__

    (Up to 3 Framebuffers)

1.  Inside the Display Engine is a __Real-Time Mixer__ (RT Mixer Core 0) that handles real-time __DMA, Overlay, Scaling and Blending__ of the Pixel Data (from the Framebuffers)

    (We won't need RT Mixer Core 1 today, it's a smaller version of Core 0)

1.  The Real-Time Mixer supports __3 UI Channels__ (for graphics), all mixed together into a __Single Image Frame__ in real time

    (The Mixer supports Video, but we won't use it today)

1.  The successive Image Frames (generated by the Display Engine) are pumped in real time to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0)

1.  The Timing Controller pushes the Image Frames to __PinePhone's LCD Controller__ as a stream of pixels (over MIPI Display Serial Interface)

All this happens in __Real Time__... Any updates to the Framebuffers in RAM are __pushed out instantly__ to the LCD Display.

(Super efficiently thanks to DMA!)

_Why so complicated?_

PinePhone's ST7703 LCD Controller __doesn't have any RAM__ inside...

-   [__"Sitronix ST7703 LCD Controller"__](https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller)

That's why we need to __pump a constant stream of pixels__ to the LCD Display via DMA, Display Engine and Timing Controller... Otherwise the display stays blank!

[(Sounds a bit like the Amiga Video Toaster)](https://en.wikipedia.org/wiki/Video_Toaster)

Let's look inside the Display Engine...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

# Display Engine in Allwinner A64

Recall that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display.

The pic above shows how the Display Engine mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3.

(Plus a Video Channel on DMA0, but we won't use it today)

_Is the Display Engine documented?_

The official doc for the A64 Display Engine is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

Though it doesn't describe the actual steps for programming the Display Engine.

In a while we'll boot [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) on PinePhone and experiment with the Display Engine, to understand it better.

[(Overview of A64 Display Engine)](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But the Display Engine doc doesn't mention A64?_

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with 64-bit Arm Cores...

> "The A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks."

> [(Source)](https://linux-sunxi.org/A64)

_Why are there 2 Mixers in the A64 Display Engine?_

Maybe because A64 (or H3) was designed for [__OTT Set-Top Boxes__](https://linux-sunxi.org/H3) with Picture-In-Picture Overlay Video?

The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.

[(Wait... Wasn't Pine64 created thanks to OTT Boxes? ðŸ¤”)](https://en.wikipedia.org/wiki/Pine64#History)

![Rendering simple Colour Blocks on the PinePhone Display](https://lupyuen.github.io/images/de-code1a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

# Render Colours

_How do we program the A64 Display Engine to render graphics?_

Let's begin by rendering simple __Colour Blocks__ on the PinePhone Display...

![Blue, Green, Red Blocks on PinePhone](https://lupyuen.github.io/images/de-rgb.jpg)

First we __allocate the Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

[(PinePhone's display resolution is 720 x 1440)](https://en.wikipedia.org/wiki/PinePhone)

Each Pixel occupies __4 bytes__. (ARGB 8888 Format)

Then we __fill the Framebuffer__ with Blue, Green and Red: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

```c
// Fill with Blue, Green and Red
for (int i = 0; i < fb0_len; i++) {
  // Colours are in ARGB format
  if (i < fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i < fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}
```

Each Pixel in the Framebuffer is stored as __32-bit ARGB 8888__.

Thus __`0x8000` `8000`__ means Semi-Transparent Green...

| Channel | Value |
|:--------|-------|
| Alpha | `0x80` |
| Red   | `0x00` |
| Green | `0x80` |
| Blue  | `0x00` |

A64 Display Engine lets us render 3 Framebuffers as __3 UI Channels__.

This is how we allocate the 3 UI Channels: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262)

```c
// Allocate 3 UI Channels
static struct display disp;
memset(&disp, 0, sizeof(disp));
struct display *d = &disp;
```

[(__`display`__ struct is defined here)](https://megous.com/git/p-boot/tree/src/display.h#n28)

We point the __First UI Channel__ to our Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271)

```c
// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d->planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d->planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[0].src_w    = 720;   // Source Width
d->planes[0].src_h    = 1440;  // Source Height
d->planes[0].dst_w    = 720;   // Dest Width
d->planes[0].dst_h    = 1440;  // Dest Height
```

(__`fb_pitch`__ is the number of bytes per row of pixels)

We disable the __Second and Third UI Channels__ for now: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299)

```c
// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d->planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d->planes[2].fb_start = 0;

// Render the UI Channels over DMA
display_commit(d);
```

And we __render the 3 UI Channels__.

([__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) is defined in the p-boot Display Code, we'll come back to this)

That's all! We should see the [__Blue, Green and Red Blocks__](https://lupyuen.github.io/images/de-rgb.jpg) like in the pic above.

(Not sure why there are black lines, needs investigation)

_Didn't we set the Alpha Channel to `0x80`?_

__UI Channel 1__ is the Base UI Channel, so the Alpha Channel has no effect.

(Actually UI Channel 1 is configured as [__XRGB 8888__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine))

In a while we'll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.

![Rendering Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-code3a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

# Render Mandelbrot Set

_Colour Blocks are so blah. Are we sure we can render every single pixel correctly?_

Let's render something infinitely more detailed and sophisticated... [__Mandelbrot Set__](https://en.wikipedia.org/wiki/Mandelbrot_set)!

![Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-title.jpg)

Earlier we created a __Fullscreen Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

Now we fill the Framebuffer with the __Mandelbrot Set__, pixel by pixel: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

```c
// Fill with Mandelbrot Set.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations.
    // MAX_ITER is 80
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m < MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p < fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}
```

[(__`mandelbrot`__ and __`hsvToRgb`__ are defined here)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432)

Then we initialise the __3 UI Channels__ and render them. [(Like this)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L299)

The [__Mandelbrot Set__](https://lupyuen.github.io/images/de-title.jpg) appears on PinePhone, like in the pic above.

Yep we can render every single pixel precisely on PinePhone!

![Animating the Madelbrot Set](https://lupyuen.github.io/images/de-code4a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L299-L334)

# Animate Madelbrot Set

_Earlier we said that updates to the Framebuffer are instantly pushed to PinePhone's Display via DMA..._

_Can we prove it?_

Yep let's __animate the Mandelbrot Set__ in our Framebuffer. And watch the updates appear instantly on PinePhone's Display, thanks to __Direct Memory Access (DMA)__!

This is how we animate the Mandelbrot Set: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L334)

```c
// Omitted: Init UI Channels 1, 2 and 3
d->planes[0].fb_start = ...
d->planes[1].fb_start = ...
d->planes[2].fb_start = ...
...

// Render the UI Channels over DMA
display_commit(d);

// Animate the Mandelbrot Set forever.
// For every frame of animation...
for (;;) {

  // Fill with Mandelbrot Set.
  // For every pixel row...
  for (int y = 0; y < 1440; y++) {

    // For every pixel column...
    for (int x = 0; x < 720; x++) {
```

In the code above, we __repeatly render__ the Mandelbrot Set for every frame of animation.

We __render each frame__ the exact same way as before...

```c
      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      // MAX_ITER is 80
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m < MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p < fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }
```

But now we __tweak slightly the position__ of the Mandelbrot Set...

```c
  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}
```

Before looping back to render the next frame.

We should see this Animated Mandelbrot Set...

-   [__Demo Video on YouTube__](https://youtu.be/toC9iiPRwRI)

Thus DMA works correctly for rendering our Framebuffers on the fly!

_We don't call `display_commit` after every frame?_

[__`display_commit`__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L296-L299) only needs to be called once. It configures the Display Engine to read our Framebuffer directly via DMA.

Subsequent updates to the Framebuffer will be automatically pushed to the display over DMA.

![Rendering a Square Overlay on PinePhone](https://lupyuen.github.io/images/de-code5b.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

# Render Square Overlay

_Earlier we said that A64 Display Engine can render Framebuffers as Overlays. How can we do it?_

The pic below shows that A64 Display Engine can render __3 Framebuffers (UI Channels)__ as overlays, via DMA1, 2 and 3...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

(Skipping DMA0 because it's for Video only)

The UI Channels are rendered as overlays in a specific sequence (pic above)...

-   __UI Channel 2__ (DMA2) is rendered on top of __UI Channel 1__ (DMA1), then...

-   __UI Channel 3__ (DMA3) is rendered on top of __UI Channel 2__ (DMA2)

Our Mandelbrot Set is rendered on __UI Channel 1__ (DMA1), which is the Base Channel.

Let's overlay a __Blue Square__ on __UI Channel 2__ (DMA2).

First we prepare a __600 x 600 Framebuffer__ that contains a Semi-Transparent Blue Square: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

```c
// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Semi-Transparent Blue
for (int i = 0; i < fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}
```

The new Framebuffer is a little __smaller than the Screen Width__. (600 pixels vs 720 pixels)

Thanks to __Framebuffer Blending__ in A64 Display Engine, it's perfectly OK to render the new Framebuffer at 600 x 600. (As a partial screen region).

This is how we set __UI Channel 2__ to the 600 x 600 Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L283)

```c
// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d->planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d->planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d->planes[1].src_w    = 600;  // Source Width
d->planes[1].src_h    = 600;  // Source Height
d->planes[1].dst_w    = 600;  // Dest Width
d->planes[1].dst_h    = 600;  // Dest Height
d->planes[1].dst_x    = 52;   // Dest X Offset
d->planes[1].dst_y    = 52;   // Dest Y Offset
```

_Can the Dest Width / Height be different from the Source Width / Height?_

Yes, because the Display Engine supports Scaling. But we won't do that today, to simplify our discussion.

Before we watch the outcome, let's render another overlay...

![Rendering a Circle Overlay on PinePhone](https://lupyuen.github.io/images/de-code5c.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

# Render Circle Overlay

Our PinePhone UI Overlay Sandwich has these goodies inside...

-   __UI Channel 1__: Mandelbrot Set (Base Channel)

-   __UI Channel 2__: Semi-Transparent Blue Square

Let's top off our Cucumber Sandwich...

-   __UI Channel 3__: Semi-Transparent Green Circle

First we fill a Fullscreen Framebuffer with a __Semi-Transparent Green Circle__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

```c
// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Semi-Transparent Green Circle.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Get pixel index
    int p = (y * 720) + x;
    assert(p < fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If pixel is inside circle (x^2 + y^2 < radius^2)...
    // Set the pixel to Semi-Transparent Green
    if (x_shift*x_shift + y_shift*y_shift < 360*360) {
      fb2[p] = 0x80008000;  // Semi-Transparent Green in ARGB Format
    } else {  // Otherwise set to Transparent Black
      fb2[p] = 0x00000000;  // Transparent Black in ARGB Format
    }
  }
}
```

Note that pixels outside the circle are set to __Transparent Black__.

(Which makes them invisible)

Next we point __UI Channel 3__ to the Fullscreen Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L283-L296)

```c
// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d->planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d->planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[2].src_w    = 720;   // Source Width
d->planes[2].src_h    = 1440;  // Source Height
d->planes[2].dst_w    = 720;   // Dest Width
d->planes[2].dst_h    = 1440;  // Dest Height
d->planes[2].dst_x    = 0;     // Dest X
d->planes[2].dst_y    = 0;     // Dest Y
d->planes[2].alpha    = 128;   // Dest Alpha
```

Note that we set the __Destination Alpha__ for the entire UI Channel. So our Green Circle will appear super transparent.

Finally we render the 3 UI Channels...

```c
// Render the UI Channels over DMA
display_commit(d);
```

We should see the Animated Mandelbrot Set, with Blue Square and (very faint) Green Circle as Overlays. (Pic below)

That's how we render 3 UI Channels (with overlay blending) on PinePhone's Display Engine!

(Why the horizontal lines in the Blue Square and Green Circle?)

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

_Mandelbrot Set with Blue Square and Green Circle as Overlays_

# Test PinePhone Display Engine

_We've seen the Test Code for Display Engine... How do we run the code?_

To test the A64 Display Engine, we'll boot __Apache NuttX RTOS__ on PinePhone and run our Test App...

-   [__test_display.c__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c)

Follow these steps to __download NuttX RTOS__ (with our Test App inside) to a microSD Card...

-   [__"Test PinePhone Display Engine"__](https://github.com/lupyuen/pinephone-nuttx#test-pinephone-display-engine)

Connect our computer to PinePhone via a [__USB Serial Debug Cable__](https://wiki.pine64.org/index.php/PinePhone#Serial_console). (At 115.2 kbps)

Boot PinePhone with NuttX RTOS in the microSD Card.

(NuttX won't disturb the eMMC Flash Memory)

At the NuttX Shell, enter this command to run our __Test App__...

```bash
hello
```

Our Test App controls the A64 Display Engine by setting the Hardware Registers (for the 3 UI Channels)...

```text
HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh> hello
...
display_commit
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0
Channel 1: Set Overlay ...
Channel 1: Set Blender Output ...
Channel 1: Set Blender Input Pipe 0 ...
Channel 1: Disable Scaler ...
Channel 2: Set Overlay ...
Channel 2: Set Blender Input Pipe 1 ...
Channel 2: Disable Scaler ...
Channel 3: Set Overlay ...
Channel 3: Set Blender Input Pipe 2 ...
Channel 3: Disable Scaler ...
Set BLD Route and BLD FColor Control
  BLD Route:          0x1101080 = 0x321
  BLD FColor Control: 0x1101000 = 0x701
Apply Settings
  GLB DBuff: 0x1100008 = 0x1
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

And the Mandelbrot Set appears on PinePhone, together with the Blue Square and Green Circle as overlays. (Pic above)

Yep we have successfully tested the A64 Display Engine on PinePhone! ðŸŽ‰

_Hmmm building the Test Code looks complicated..._

Yeah we need a few steps to build the Test Code because we patched together a few programs to make it work...

-   __Apache NuttX RTOS__ for PinePhone

    [(See this)](https://lupyuen.github.io/articles/uboot)

-   __Zig Driver__ for MIPI Display Serial Interface

    [(More about this)](https://lupyuen.github.io/articles/dsi2)

-   __p-boot Display Code__

    [(See the next chapter)](https://lupyuen.github.io/articles/de#p-boot-display-code)

The steps will be a lot simpler when we have completed the  Display Engine Driver for NuttX.

Let's talk about the p-boot Display Code...

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

# p-boot Display Code

_About the code that controls A64 Display Engine... Where is `display_commit` defined?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) comes from the super-helpful [__p-boot PinePhone Bootloader__](https://xnux.eu/p-boot/) project, which runs directly on PinePhone Hardware. ("Bare Metal")

To test the A64 Display Engine on Apache NuttX RTOS, we borrowed these [__Source Files__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L135-L142) (relevant to the Display Engine) from p-boot...

-   [__display.c__](https://megous.com/git/p-boot/tree/src/display.c)
-   [__pmic.c__](https://megous.com/git/p-boot/tree/src/pmic.c)
-   [__clock_sun6i.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c)
-   [__sunxi_gpio.c__](https://megous.com/git/p-boot/tree/src/uboot/drivers/gpio/sunxi_gpio.c)
-   [__pinmux.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/pinmux.c)

[(Plus a whole bunch of Header Files)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L115-L135)

Then we modified the above files to compile on NuttX...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which lets us experiment with the A64 Display Engine on NuttX.

_How does it control the A64 Display Engine?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) controls the A64 Display Engine by writing to the __Hardware Registers__ for the Display Engine.

The Display Engine's Hardware Registers are described here...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But what values does `display_commit` write to the Hardware Registers?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which tells us all the __Hardware Registers and their values__...

```text
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0

Channel 1: Set Overlay
  UI Config Attr:      0x1103000 = 0xff000405
  UI Config Top LAddr: 0x1103010 = 0x4064a6ac
  UI Config Pitch:     0x110300c = 0xb40
  UI Config Size:      0x1103004 = 0x59f02cf
  UI Overlay Size:     0x1103088 = 0x59f02cf
  IO Config Coord:     0x1103008 = 0x0

Channel 1: Set Blender Output
  BLD Output Size: 0x110108c = 0x59f02cf
  GLB Size:        0x110000c = 0x59f02cf

Channel 1: Set Blender Input Pipe 0
  BLD Pipe InSize: 0x1101008 = 0x59f02cf
  BLD Pipe FColor: 0x1101004 = 0xff000000
  BLD Pipe Offset: 0x110100c = 0x0
  BLD Pipe Mode:   0x1101090 = 0x3010301

Channel 1: Disable Scaler
  Mixer: 0x1140000 = 0x0

Channel 2: ...
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

When we study the log, we'll understand how we should __program the A64 Display Engine__ to render the 3 UI Channels.

Our findings are documented here...

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

This is very helpful as we create the NuttX Display Driver for PinePhone...

![Testing the NuttX Display Driver for PinePhone](https://lupyuen.github.io/images/dsi2-title.jpg)

[_Testing the NuttX Display Driver for PinePhone_](https://lupyuen.github.io/articles/dsi2)

# NuttX Display Driver for PinePhone

_Once again, why are we doing all this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone.

Someday we hope to have a __fully-functional PinePhone__ running on NuttX RTOS...

-   [__"PinePhone on RTOS"__](https://lupyuen.github.io/articles/arm#pinephone-on-rtos)

(Or maybe just run PinePhone on NuttX as a simple touchscreen gadget)

To do that, we need a __NuttX Display Driver__.

That's why we're probing the internals of PinePhone, to learn everything we need to build the driver.

We've documented our earlier research on PinePhone's __MIPI Display Serial Interface__...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

Today we learnt so much about PinePhone's __A64 Display Engine__...

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

We're all set to build the NuttX Display Driver for PinePhone!

_How shall we build the PinePhone Display Driver?_

We'll create the PinePhone Display Driver based on the __NuttX Driver for Sitronix ST7789__...

-   [__nuttx/drivers/lcd/st7789.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/st7789.c)

That's because ST7789 is somewhat similar to PinePhone's ST7703 LCD Controller.

_But ST7789 doesn't support Framebuffers?_

Yeah for PinePhone we'll wrap the A64 DMA Framebuffers with this interface for __NuttX Framebuffers__...

-   [__nuttx/include/nuttx/video/fb.h__](https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/video/fb.h)

-   [__nuttx/drivers/video/fb.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/video/fb.c)

-   [__nuttx/drivers/lcd/lcd_framebuffer.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/lcd_framebuffer.c)

And we might get inspired by this implementation of __Display Overlays__ in the STM32 LCD TFT Display Controller (LTDC)...

-   [__nuttx/arch/arm/src/stm32/stm32_ltdc.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/arch/arm/src/stm32/stm32_ltdc.c)

We have started the __Zig Implementation__ of the NuttX Driver (for MIPI Display Serial Interface)...

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

We'll add the A64 Display Engine in the next article!

![Testing the A64 Display Engine on PinePhone](https://lupyuen.github.io/images/de-test.jpg)

# Notes

1.  Some parts of the PinePhone DE and TCON0 Drivers still need to be reverse-engineered...

    [__de2_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init)

    [__tcon0_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#tcon0_init)

# What's Next

I hope we learnt lots today about __Display Rendering on PinePhone__...

-   What's the [__Display Engine (DE)__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone) inside PinePhone

-   How the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) controls PinePhone's LCD Display

-   How we call DE and TCON0 to [__render graphics__](https://lupyuen.github.io/articles/de#render-colours)

-   How our new [__PinePhone Display Driver__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone) will support DE and TCON0

Please join me in the next article as we create the PinePhone Display Engine Driver for [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot)!

Check out the other articles on __NuttX RTOS for PinePhone__...

-   [__"Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone"__](https://lupyuen.github.io/articles/arm)

-   [__"PinePhone boots Apache NuttX RTOS"__](https://lupyuen.github.io/articles/uboot)

-   [__"NuttX RTOS for PinePhone: Fixing the Interrupts"__](https://lupyuen.github.io/articles/interrupt)

-   [__"NuttX RTOS for PinePhone: UART Driver"__](https://lupyuen.github.io/articles/serial)

-   [__"NuttX RTOS for PinePhone: Blinking the LEDs"__](https://lupyuen.github.io/articles/pio)

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__Discuss this article on Reddit__](https://www.reddit.com/r/PINE64official/comments/ygz5kt/rendering_pinephones_display_de_and_tcon0/)

-   [__My Current Project: "The RISC-V BL602 Book"__](https://lupyuen.github.io/articles/book)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/de.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Appendix: Overview of Allwinner A64 Display Engine

The official doc for the __Allwinner A64 Display Engine__ is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with [__64-bit Arm Cores__](https://linux-sunxi.org/A64).

(Also check out this [__DE2 Register Guide__](https://linux-sunxi.org/DE2_Register_Guide))

Earlier we said that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display...

-   [__"Display Rendering on PinePhone"__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone)

According to the doc, the __Display Engine Base Address__ is __`0x0100` `0000`__ (Page 24)

_What's a Display Engine Mixer?_

__DE RT-MIXER:__ (Page 87)
> "The RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing."

The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1.

__DE RT-MIXER0__ has 4 Channels (DE Offset __`0x10` `0000`__, Page 87)

-   __Channel 0__ for Video

    (DMA0, Video Overlay, Video Scaler)

-   __Channels 1, 2 and 3__ for UI

    (DMA1 / 2 / 3, 3 x UI Overlays, 3 x UI Scalers, 3 x UI Blenders)

-   __4 Overlay Layers__ per Channel

    (We only use 1 Overlay Layer per Channel)

-   __Layer Priority__ is Layer 3 > Layer2 > Layer 1 > Layer 0 (Page 89)

Our Display Engine Demo __configures the 4 Channels__ as follows...

-   __Channel 0__ is unused

    (No video right now)

-   __Channel 1__ has Pixel Format XRGB 8888

    (Alpha Channel is disabled)

-   __Channels 2 and 3__ have Pixel Format ARGB 8888

    (Alpha Channel is enabled)

__Hardware Registers__ for RT-MIXER0 (Page 90)...

| Hardware Register | RT-MIXER0 Offset 
|--------------------|-----------------
|__GLB__ (Global Registers) | __`0x00` `0000`__
|__BLD__ (Blender) | __`0x00` `1000`__
|__OVL_V(CH0)__ (Video Overlay / Channel 0) | __`0x00` `2000`__
|__OVL_UI(CH1)__ (UI Overlay / Channel 1) | __`0x00` `3000`__
|__OVL_UI(CH2)__ (UI Overlay / Channel 2) | __`0x00` `4000`__
|__OVL_UI(CH3)__ (UI Overlay / Channel 3) | __`0x00` `5000`__
|__VIDEO_SCALER(CH0)__ (Video Scaler / Channel 0) | __`0x02` `0000`__
|__UI_SCALER1(CH1)__ (UI Scaler / Channel 1) | __`0x04` `0000`__
|__UI_SCALER2(CH2)__ (UI Scaler / Channel 2) | __` 0x05` `0000`__
|__UI_SCALER3(CH3)__ (UI Scaler / Channel 3) | __` 0x06` `0000`__
|__POST_PROC1__ (Post Processor 1) | __`0x0A` `0000`__
|__POST_PROC2__ (Post Processor 2) | __`0x0B` `0000`__
|__DMA__ (Direct Memory Access) | __`0x0C` `0000`__

The pic below shows how DE RT-MIXER0 mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3 (plus a Video Channel on DMA0)...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

__DE RT-MIXER1__ has 2 Channels (DE Offset __`0x20` `0000`__, Page 23)
-   __Channel 0__ for Video 

    (DMA0, Video Overlay, Video Scaler)

-   __Channel 1__ for UI 

    (DMA1, UI Overlay, UI Scaler, UI Blender)

(We don't use RT-MIXER1 right now)

RT-MIXER0 and RT-MIXER1 are multiplexed to __Timing Controller TCON0__. [(Like this)](https://lupyuen.github.io/images/de-block1a.jpg)

TCON0 is connected to PinePhone's __ST7703 LCD Controller__ over MIPI Display Serial Interface. [(See this)](https://lupyuen.github.io/articles/dsi)

Hence RT-MIXER0 __mixes 1 Video Channel with 3 UI Channels__ over DMA. And pumps the pixels continuously to ST7703 LCD Controller. (Via the Timing Controller TCON0)

In today's demo we used the 3 UI Channels to render (pic below)...
1.  Mandelbrot Set
1.  Blue Square
1.  Green Circle

In the next chapter we explain how the 3 UI Channels were rendered by setting the Hardware Registers for A64 Display Engine.

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

[_Mandelbrot Set with Blue Square and Green Circle as Overlays_](https://lupyuen.github.io/articles/de#test-pinephone-display-engine)

We won't use these Display Engine Features today...

__DE RT-WB (Write-Back Controller):__ (Page 116)
> "The Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM."

(For screen capture?)

__DE VSU (Video Scaler):__ (Page 128)
> "The Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules."

__DE Rotation:__ (Page 137)
> "There are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation."

# Appendix: Initialising the Allwinner A64 Display Engine

TODO

Based on the log captured from [de2_init](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init)

```text
Set SRAM for video use
  0x1c00004 = 0x0 (DMB)
```

TODO

```text
Setup DE2 PLL
clock_set_pll_de: clk=297000000
PLL10 rate = 24000000 * n / m
  0x1c20048 = 0x81001701 (DMB)
  while (!(readl(0x1c20048) & 0x10000000))
```

TODO

```text
Enable DE2 special clock
  clrsetbits 0x1c20104, 0x3000000, 0x81000000
```

TODO

```text
Enable DE2 ahb
  setbits 0x1c202c4, 0x1000
  setbits 0x1c20064, 0x1000
```

TODO

```text
Enable clock for mixer 0, set route MIXER0->TCON0
  setbits 0x1000000, 0x1
  setbits 0x1000008, 0x1
  setbits 0x1000004, 0x1
  clrbits 0x1000010, 0x1
```

TODO

```text
Clear all registers
  0x1100000 to 0x1105fff = 0x0
  0x1120000 = 0x0
  0x1130000 = 0x0
  0x1140000 = 0x0
  0x1150000 = 0x0
  0x11a0000 = 0x0
  0x11a2000 = 0x0
  0x11a4000 = 0x0
  0x11a6000 = 0x0
  0x11a8000 = 0x0
  0x11aa000 = 0x0
  0x11b0000 = 0x0
```

TODO

```text
Enable mixer
  0x1100000 = 0x1 (DMB)
```

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://lupyuen.github.io/articles/de#p-boot-display-code)

# Appendix: Programming the Allwinner A64 Display Engine

We've seen the __Hardware Registers__ for the Allwinner A64 Display Engine...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

And we need to program the Hardware Registers to create the __NuttX Display Driver__ for PinePhone...

-   [__"NuttX Display Driver for PinePhone"__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone)

_How will we program the Hardware Registers to render the UI Channels?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which produces a log that tells us all the __Hardware Registers and their values__...

-   [__"Testing p-boot Display Engine on PinePhone"__](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

After studying the log, we have identified the steps to render the 3 UI Channels with the Display Engine.

This is how we'll create a NuttX Driver for PinePhone's A64 Display Engine that implements Display Rendering...

[(Refer to __Memory Mapping List__ and __Register List__ at Page 90)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

1.  __Configure Blender...__

    -   BLD BkColor (__BLD_BK_COLOR__ @ BLD Offset `0x88`): BLD background color register

        Set to `0xff00` `0000` _(Why?)_

    -   BLD Premultiply (__BLD_PREMUL_CTL__ @ BLD Offset `0x84`): BLD pre-multiply control register

        Set to 0

    ```text
    Configure Blender
    BLD BkColor:     0x110 1088 = 0xff000000
    BLD Premultiply: 0x110 1084 = 0x0
    ```

1.  __For Channels 1 to 3...__

    1.  __If Channel is unused,__ disable Overlay, Pipe and Scaler. Skip to next Channel

        -   UI Config Attr (__OVL_UI_ATTCTL__ @ OVL_UI Offset `0x00`): _OVL_UI attribute control register_

            Set to 0

        -   Mixer (__???__ @ `0x113` `0000` + `0x10000` * Channel)

            Set to 0

        ```text
        Channel 2: Disable Overlay and Pipe
        UI Config Attr: 0x110 4000 = 0x0

        Channel 3: Disable Overlay and Pipe
        UI Config Attr: 0x110 5000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

    1.  Channel 1 has Pixel Format __XRGB 8888__:

        __OVL_V_ATTCTL â†’ LAY_FBFMT__ = `0x04`
    
        Channels 2 and 3 have Pixel Format __ARGB 8888__:

        __OVL_V_ATTCTL â†’ LAY_FBFMT__ = `0x01`

        _(See page 94)_

    1.  __Set Overlay__ (Assume Layer = 0)

        -   UI Config Attr (__OVL_UI_ATTCTL__ @ OVL_UI Offset `0x00`): _OVL_UI attribute control register_

            __For Channel 1:__ Set to `0xff00` `0405` _(Why?)_

            __For Channel 2:__ `0xff00` `0005` _(Why?)_

            __For Channel 3:__ `0x7f00` `0005` _(Why?)_

        -   UI Config Top LAddr (__OVL_UI_TOP_LADD__ @ OVL_UI Offset `0x10`): _OVL_UI top field memory block low address register_

            Set to Framebuffer Address: `fb0`, `fb1` or `fb2`

        -   UI Config Pitch (__OVL_UI_PITCH__ @ OVL_UI Offset `0x0C`): _OVL_UI memory pitch register_

            Set to `(width * 4)`

        -   UI Config Size (__OVL_UI_MBSIZE__ @ OVL_UI Offset `0x04`): _OVL_UI memory block size register_

            Set to `(height-1) << 16 + (width-1)`

        -   UI Overlay Size (__OVL_UI_SIZE__ @ OVL_UI Offset `0x88`): _OVL_UI overlay window size register_

            Set to `(height-1) << 16 + (width-1)`

        -   IO Config Coord (__OVL_UI_COOR__ @ OVL_UI Offset `0x08`): _OVL_UI memory block coordinate register_

            Set to 0

        ```text
        Channel 1: Set Overlay (fb0 is 720 x 1440)
        UI Config Attr:      0x110 3000 = 0xff00 0405
        UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
        UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
        UI Config Size:      0x110 3004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 3008 = 0x0

        Channel 2: Set Overlay (fb1 is 600 x 600)
        UI Config Attr:      0x110 4000 = 0xff00 0005
        UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
        UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
        UI Config Size:      0x110 4004 = 0x257 0257 (599 << 16 + 599)
        UI Overlay Size:     0x110 4088 = 0x257 0257 (599 << 16 + 599)
        IO Config Coord:     0x110 4008 = 0x0

        Channel 3: Set Overlay (fb2 is 720 x 1440)
        UI Config Attr:      0x110 5000 = 0x7f00 0005
        UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
        UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
        UI Config Size:      0x110 5004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 5008 = 0x0
        ```

    1.  __For Channel 1:__ Set Blender Output

        -   BLD Output Size (__BLD_SIZE__ @ BLD Offset `0x08C`): _BLD output size setting register_

            Set to `(height-1) << 16 + (width-1)`
            
        -   GLB Size (__GLB_SIZE__ @ GLB Offset `0x00C`): _Global size register_

            Set to `(height-1) << 16 + (width-1)`

        ```text
        Channel 1: Set Blender Output
        BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
        GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)
        ```

    1.  __Set Blender Input Pipe__ (N = Pipe Number, from 0 to 2 for Channels 1 to 3)

        -   BLD Pipe InSize (__BLD_CH_ISIZE__ @ BLD Offset `0x008` + `N*0x10`): _BLD input memory size register(N=0,1,2,3,4)_

            Set to `(height-1) << 16 + (width-1)`

        -   BLD Pipe FColor (__BLD_FILL_COLOR__ @ BLD Offset `0x004` + `N*0x10`): _BLD fill color register(N=0,1,2,3,4)_

            Set to `0xff00` `0000` _(Why?)_

        -   BLD Pipe Offset (__BLD_CH_OFFSET__ @ BLD Offset `0x00C` + `N*0x10`): _BLD input memory offset register(N=0,1,2,3,4)_

            __For Channel 1:__ Set to 0 _(Why?)_

            __For Channel 2:__ Set to `0x34` `0034` _(Why?)_

            __For Channel 3:__ Set to 0 _(Why?)_

        -   BLD Pipe Mode (__BLD_CTL__ @ BLD Offset `0x090` + `N*4`): _BLD control register_

            Set to `0x301` `0301` _(Why?)_

        __Note: Log shows BLD_CH_ISIZE, BLD_FILL_COLOR and  BLD_CH_OFFSET are at `N*0x10`, but doc says `N*0x14`__

        ```text
        Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
        BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1004 = 0xff00 0000
        BLD Pipe Offset: 0x110 100c = 0x0
        BLD Pipe Mode:   0x110 1090 = 0x301 0301

        Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
        BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 << 16 + 599)
        BLD Pipe FColor: 0x110 1014 = 0xff00 0000
        BLD Pipe Offset: 0x110 101c = 0x34 0034
        BLD Pipe Mode:   0x110 1094 = 0x301 0301

        Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
        BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1024 = 0xff00 0000
        BLD Pipe Offset: 0x110 102c = 0x0
        BLD Pipe Mode:   0x110 1098 = 0x301 0301
        ```

    1.  __Disable Scaler__ (Assume we're not scaling)

        -   Mixer (__???__ @ `0x113` `0000` + `0x10000` * Channel)

            Set to 0

        ```text
        Channel 1: Disable Scaler
        Mixer: 0x114 0000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

1.  __Set BLD Route and BLD FColor Control__

    -   BLD Route (__BLD_CH_RTCTL__ @ BLD Offset `0x080`): _BLD routing control register_

        __For 3 UI Channels:__ Set to `0x321` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

        __For 1 UI Channel:__ Set to `1` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    -   BLD FColor Control (__BLD_FILLCOLOR_CTL__ @ BLD Offset `0x000`): _BLD fill color control register_

        __For 3 UI Channels:__ Set to `0x701` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

        __For 1 UI Channels:__ Set to `0x101` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    ```text
    For 3 UI Channels: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x321 (DMB)
    BLD FColor Control: 0x110 1000 = 0x701 (DMB)

    For 1 UI Channel: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x1   (DMB)
    BLD FColor Control: 0x110 1000 = 0x101 (DMB)
    ```

1.  __Apply Settings__

    -   GLB DBuff (__GLB_DBUFFER__ @ GLB Offset `0x008`): _Global double buffer control register_

        Set to 1 [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    ```text
    Apply Settings
    GLB DBuff: 0x110 0008 = 0x1 (DMB)
    ```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)
