# Rendering PinePhone's Display (DE and TCON0)

ðŸ“ _30 Oct 2022_

![PinePhone rendering Mandelbrot Set on Apache NuttX RTOS](https://lupyuen.github.io/images/de-title.jpg)

_PinePhone rendering Mandelbrot Set on Apache NuttX RTOS_

__UPDATE:__ PinePhone is now officially supported by Apache NuttX RTOS [(See this)](https://lupyuen.github.io/articles/uboot#appendix-pinephone-is-now-supported-by-apache-nuttx-rtos)

In the last 2 articles we talked about [__Pine64 PinePhone__](https://wiki.pine64.org/index.php/PinePhone) (pic above) and how we built a __Display Driver__ for PinePhone's MIPI Display Serial Interface...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

But our PinePhone Display Driver __isn't complete__... It won't render any graphics!

Today we'll learn about the missing bits in our Display Driver...

-   What's the __Display Engine (DE)__ inside PinePhone

-   How the __Timing Controller (TCON0)__ controls PinePhone's LCD Display

-   How we call DE and TCON0 to __render graphics__

-   How our new __PinePhone Display Driver__ will support DE and TCON0

_Why are we doing this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone and we have created a (barebones) [__Display Driver in Zig__](https://lupyuen.github.io/articles/dsi2) that initialises the LCD Display.

To finish the driver, we need to understand what's inside PinePhone's Display Engine and Timing Controller.

Let's dive in and continue the journey from our (super long) __NuttX Porting Journal__...

-   [__lupyuen/pinephone-nuttx__](https://github.com/lupyuen/pinephone-nuttx)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Display Rendering on PinePhone

_Suppose we're building our own Operating System for PinePhone..._

_How do we render graphics on the LCD Display?_

Rendering graphics directly to PinePhone Hardware ("Bare Metal") is more complicated than we expect!

Let's walk through the steps (pic above)...

1.  Inside PinePhone's [__Allwinner A64 SoC__](https://linux-sunxi.org/A64) is a __Display Engine__ that combines and transforms Pixel Data for display

1.  The Display Engine reads the Pixel Data from __Framebuffers in RAM__ via __Direct Memory Access (DMA)__

    (Up to 3 Framebuffers)

1.  Inside the Display Engine is a __Real-Time Mixer__ (RT Mixer Core 0) that handles real-time __DMA, Overlay, Scaling and Blending__ of the Pixel Data (from the Framebuffers)

    (We won't need RT Mixer Core 1 today, it's a smaller version of Core 0)

1.  The Real-Time Mixer supports __3 UI Channels__ (for graphics), all mixed together into a __Single Image Frame__ in real time

    (The Mixer supports Video, but we won't use it today)

1.  The successive Image Frames (generated by the Display Engine) are pumped in real time to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0)

1.  The Timing Controller pushes the Image Frames to __PinePhone's LCD Controller__ as a stream of pixels (over MIPI Display Serial Interface)

All this happens in __Real Time__... Any updates to the Framebuffers in RAM are __pushed out instantly__ to the LCD Display.

(Super efficiently thanks to DMA!)

_Why so complicated?_

PinePhone's ST7703 LCD Controller __doesn't have any RAM__ inside...

-   [__"Sitronix ST7703 LCD Controller"__](https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller)

That's why we need to __pump a constant stream of pixels__ to the LCD Display via DMA, Display Engine and Timing Controller... Otherwise the display stays blank!

[(Sounds a bit like the Amiga Video Toaster)](https://en.wikipedia.org/wiki/Video_Toaster)

Let's look inside the Display Engine...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

# Display Engine in Allwinner A64

Recall that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display.

The pic above shows how the Display Engine mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3.

(Plus a Video Channel on DMA0, but we won't use it today)

_Is the Display Engine documented?_

The official doc for the A64 Display Engine is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

Though it doesn't describe the actual steps for programming the Display Engine.

In a while we'll boot [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) on PinePhone and experiment with the Display Engine, to understand it better.

[(Overview of A64 Display Engine)](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But the Display Engine doc doesn't mention A64?_

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with 64-bit Arm Cores...

> "The A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks."

> [(Source)](https://linux-sunxi.org/A64)

_Why are there 2 Mixers in the A64 Display Engine?_

Maybe because A64 (or H3) was designed for [__OTT Set-Top Boxes__](https://linux-sunxi.org/H3) with Picture-In-Picture Overlay Video?

The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.

[(Wait... Wasn't Pine64 created thanks to OTT Boxes? ðŸ¤”)](https://en.wikipedia.org/wiki/Pine64#History)

[(__DE2TCON_MUX__ at Page 26 says that Mixer 0 is for TCON0 MIPI DSI, Mixer 1 for TCON1 HDMI Output)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

![Rendering simple Colour Blocks on the PinePhone Display](https://lupyuen.github.io/images/de-code1a.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

# Render Colours

_How do we program the A64 Display Engine to render graphics?_

Let's begin by rendering simple __Colour Blocks__ on the PinePhone Display...

![Blue, Green, Red Blocks on PinePhone](https://lupyuen.github.io/images/de-rgb.jpg)

First we __allocate the Framebuffer__: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

[(PinePhone's display resolution is 720 x 1440)](https://en.wikipedia.org/wiki/PinePhone)

Each Pixel occupies __4 bytes__. (ARGB 8888 Format)

Then we __fill the Framebuffer__ with Blue, Green and Red: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

```c
// Fill with Blue, Green and Red
for (int i = 0; i < fb0_len; i++) {
  // Colours are in ARGB format
  if (i < fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i < fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}
```

Each Pixel in the Framebuffer is stored as __32-bit ARGB 8888__.

Thus __`0x8000` `8000`__ means Semi-Transparent Green...

| Channel | Value |
|:--------|-------|
| Alpha | `0x80` |
| Red   | `0x00` |
| Green | `0x80` |
| Blue  | `0x00` |

A64 Display Engine lets us render 3 Framebuffers as __3 UI Channels__.

This is how we allocate the 3 UI Channels: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262)

```c
// Allocate 3 UI Channels
static struct display disp;
memset(&disp, 0, sizeof(disp));
struct display *d = &disp;
```

[(__`display`__ struct is defined here)](https://megous.com/git/p-boot/tree/src/display.h#n28)

We point the __First UI Channel__ to our Framebuffer: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271)

```c
// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d->planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d->planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[0].src_w    = 720;   // Source Width
d->planes[0].src_h    = 1440;  // Source Height
d->planes[0].dst_w    = 720;   // Dest Width
d->planes[0].dst_h    = 1440;  // Dest Height
```

(__`fb_pitch`__ is the number of bytes per row of pixels)

We disable the __Second and Third UI Channels__ for now: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299)

```c
// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d->planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d->planes[2].fb_start = 0;

// Render the UI Channels over DMA
display_commit(d);
```

And we __render the 3 UI Channels__.

([__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) is defined in the p-boot Display Code, we'll come back to this)

That's all! We should see the [__Blue, Green and Red Blocks__](https://lupyuen.github.io/images/de-rgb.jpg) like in the pic above.

(Not sure why there are black lines, needs investigation)

_Didn't we set the Alpha Channel to `0x80`?_

__UI Channel 1__ is the Base UI Channel, so the Alpha Channel has no effect.

(Actually UI Channel 1 is configured as [__XRGB 8888__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine))

In a while we'll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.

![Rendering Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-code3a.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

# Render Mandelbrot Set

_Colour Blocks are so blah. Are we sure we can render every single pixel correctly?_

Let's render something infinitely more detailed and sophisticated... [__Mandelbrot Set__](https://en.wikipedia.org/wiki/Mandelbrot_set)!

![Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-title.jpg)

Earlier we created a __Fullscreen Framebuffer__: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

Now we fill the Framebuffer with the __Mandelbrot Set__, pixel by pixel: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

```c
// Fill with Mandelbrot Set.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations.
    // MAX_ITER is 80
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m < MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p < fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}
```

[(__`mandelbrot`__ and __`hsvToRgb`__ are defined here)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432)

Then we initialise the __3 UI Channels__ and render them. [(Like this)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L299)

The [__Mandelbrot Set__](https://lupyuen.github.io/images/de-title.jpg) appears on PinePhone, like in the pic above.

Yep we can render every single pixel precisely on PinePhone!

![Animating the Madelbrot Set](https://lupyuen.github.io/images/de-code4a.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L299-L334)

# Animate Madelbrot Set

_Earlier we said that updates to the Framebuffer are instantly pushed to PinePhone's Display via DMA..._

_Can we prove it?_

Yep let's __animate the Mandelbrot Set__ in our Framebuffer. And watch the updates appear instantly on PinePhone's Display, thanks to __Direct Memory Access (DMA)__!

This is how we animate the Mandelbrot Set: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L334)

```c
// Omitted: Init UI Channels 1, 2 and 3
d->planes[0].fb_start = ...
d->planes[1].fb_start = ...
d->planes[2].fb_start = ...
...

// Render the UI Channels over DMA
display_commit(d);

// Animate the Mandelbrot Set forever.
// For every frame of animation...
for (;;) {

  // Fill with Mandelbrot Set.
  // For every pixel row...
  for (int y = 0; y < 1440; y++) {

    // For every pixel column...
    for (int x = 0; x < 720; x++) {
```

In the code above, we __repeatly render__ the Mandelbrot Set for every frame of animation.

We __render each frame__ the exact same way as before...

```c
      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      // MAX_ITER is 80
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m < MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p < fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }
```

But now we __tweak slightly the position__ of the Mandelbrot Set...

```c
  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}
```

Before looping back to render the next frame.

We should see this Animated Mandelbrot Set...

-   [__Demo Video on YouTube__](https://youtu.be/toC9iiPRwRI)

Thus DMA works correctly for rendering our Framebuffers on the fly!

_We don't call `display_commit` after every frame?_

[__`display_commit`__](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L296-L299) only needs to be called once. It configures the Display Engine to read our Framebuffer directly via DMA.

Subsequent updates to the Framebuffer will be automatically pushed to the display over DMA.

![Rendering a Square Overlay on PinePhone](https://lupyuen.github.io/images/de-code5b.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

# Render Square Overlay

_Earlier we said that A64 Display Engine can render Framebuffers as Overlays. How can we do it?_

The pic below shows that A64 Display Engine can render __3 Framebuffers (UI Channels)__ as overlays, via DMA1, 2 and 3...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

(Skipping DMA0 because it's for Video only)

The UI Channels are rendered as overlays in a specific sequence (pic above)...

-   __UI Channel 2__ (DMA2) is rendered on top of __UI Channel 1__ (DMA1), then...

-   __UI Channel 3__ (DMA3) is rendered on top of __UI Channel 2__ (DMA2)

Our Mandelbrot Set is rendered on __UI Channel 1__ (DMA1), which is the Base Channel.

Let's overlay a __Blue Square__ on __UI Channel 2__ (DMA2).

First we prepare a __600 x 600 Framebuffer__ that contains a Semi-Transparent Blue Square: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

```c
// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Semi-Transparent Blue
for (int i = 0; i < fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}
```

The new Framebuffer is a little __smaller than the Screen Width__. (600 pixels vs 720 pixels)

Thanks to __Framebuffer Blending__ in A64 Display Engine, it's perfectly OK to render the new Framebuffer at 600 x 600. (As a partial screen region).

This is how we set __UI Channel 2__ to the 600 x 600 Framebuffer: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L283)

```c
// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d->planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d->planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d->planes[1].src_w    = 600;  // Source Width
d->planes[1].src_h    = 600;  // Source Height
d->planes[1].dst_w    = 600;  // Dest Width
d->planes[1].dst_h    = 600;  // Dest Height
d->planes[1].dst_x    = 52;   // Dest X Offset
d->planes[1].dst_y    = 52;   // Dest Y Offset
```

_Can the Dest Width / Height be different from the Source Width / Height?_

Yes, because the Display Engine supports Scaling. But we won't do that today, to simplify our discussion.

Before we watch the outcome, let's render another overlay...

![Rendering a Circle Overlay on PinePhone](https://lupyuen.github.io/images/de-code5c.png)

[(Source)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

# Render Circle Overlay

Our PinePhone UI Overlay Sandwich has these goodies inside...

-   __UI Channel 1__: Mandelbrot Set (Base Channel)

-   __UI Channel 2__: Semi-Transparent Blue Square

Let's top off our Cucumber Sandwich...

-   __UI Channel 3__: Semi-Transparent Green Circle

First we fill a Fullscreen Framebuffer with a __Semi-Transparent Green Circle__: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

```c
// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Semi-Transparent Green Circle.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Get pixel index
    int p = (y * 720) + x;
    assert(p < fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If pixel is inside circle (x^2 + y^2 < radius^2)...
    // Set the pixel to Semi-Transparent Green
    if (x_shift*x_shift + y_shift*y_shift < 360*360) {
      fb2[p] = 0x80008000;  // Semi-Transparent Green in ARGB Format
    } else {  // Otherwise set to Transparent Black
      fb2[p] = 0x00000000;  // Transparent Black in ARGB Format
    }
  }
}
```

Note that pixels outside the circle are set to __Transparent Black__.

(Which makes them invisible)

Next we point __UI Channel 3__ to the Fullscreen Framebuffer: [test_display.c](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L283-L296)

```c
// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d->planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d->planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[2].src_w    = 720;   // Source Width
d->planes[2].src_h    = 1440;  // Source Height
d->planes[2].dst_w    = 720;   // Dest Width
d->planes[2].dst_h    = 1440;  // Dest Height
d->planes[2].dst_x    = 0;     // Dest X
d->planes[2].dst_y    = 0;     // Dest Y
d->planes[2].alpha    = 128;   // Dest Alpha
```

Note that we set the __Destination Alpha__ for the entire UI Channel. So our Green Circle will appear super transparent.

Finally we render the 3 UI Channels...

```c
// Render the UI Channels over DMA
display_commit(d);
```

We should see the Animated Mandelbrot Set, with Blue Square and (very faint) Green Circle as Overlays. (Pic below)

That's how we render 3 UI Channels (with overlay blending) on PinePhone's Display Engine!

(Why the horizontal lines in the Blue Square and Green Circle?)

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

_Mandelbrot Set with Blue Square and Green Circle as Overlays_

# Test PinePhone Display Engine

_We've seen the Test Code for Display Engine... How do we run the code?_

To test the A64 Display Engine, we'll boot __Apache NuttX RTOS__ on PinePhone and run our Test App...

-   [__test_display.c__](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c)

Follow these steps to __download NuttX RTOS__ (with our Test App inside) to a microSD Card...

-   [__"Test PinePhone Display Engine"__](https://github.com/lupyuen/pinephone-nuttx#test-pinephone-display-engine)

Connect our computer to PinePhone via a [__USB Serial Debug Cable__](https://wiki.pine64.org/index.php/PinePhone#Serial_console). (At 115.2 kbps)

Boot PinePhone with NuttX RTOS in the microSD Card.

(NuttX won't disturb the eMMC Flash Memory)

At the NuttX Shell, enter this command to run our __Test App__...

```bash
hello
```

Our Test App controls the A64 Display Engine by setting the Hardware Registers (for the 3 UI Channels)...

```text
HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh> hello
...
display_commit
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0
Channel 1: Set Overlay ...
Channel 1: Set Blender Output ...
Channel 1: Set Blender Input Pipe 0 ...
Channel 1: Disable Scaler ...
Channel 2: Set Overlay ...
Channel 2: Set Blender Input Pipe 1 ...
Channel 2: Disable Scaler ...
Channel 3: Set Overlay ...
Channel 3: Set Blender Input Pipe 2 ...
Channel 3: Disable Scaler ...
Set BLD Route and BLD FColor Control
  BLD Route:          0x1101080 = 0x321
  BLD FColor Control: 0x1101000 = 0x701
Apply Settings
  GLB DBuff: 0x1100008 = 0x1
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

And the Mandelbrot Set appears on PinePhone, together with the Blue Square and Green Circle as overlays. (Pic above)

Yep we have successfully tested the A64 Display Engine on PinePhone! ðŸŽ‰

_Hmmm building the Test Code looks complicated..._

Yeah we need a few steps to build the Test Code because we patched together a few programs to make it work...

-   __Apache NuttX RTOS__ for PinePhone

    [(See this)](https://lupyuen.github.io/articles/uboot)

-   __Zig Driver__ for MIPI Display Serial Interface

    [(More about this)](https://lupyuen.github.io/articles/dsi2)

-   __p-boot Display Code__

    [(See the next chapter)](https://lupyuen.github.io/articles/de#p-boot-display-code)

The steps will be a lot simpler when we have completed the  Display Engine Driver for NuttX.

Let's talk about the p-boot Display Code...

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

# p-boot Display Code

_About the code that controls A64 Display Engine... Where is `display_commit` defined?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) comes from the super-helpful [__p-boot PinePhone Bootloader__](https://xnux.eu/p-boot/) project, which runs directly on PinePhone Hardware. ("Bare Metal")

To test the A64 Display Engine on Apache NuttX RTOS, we borrowed these [__Source Files__](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L135-L142) (relevant to the Display Engine) from p-boot...

-   [__display.c__](https://megous.com/git/p-boot/tree/src/display.c)
-   [__pmic.c__](https://megous.com/git/p-boot/tree/src/pmic.c)
-   [__clock_sun6i.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c)
-   [__sunxi_gpio.c__](https://megous.com/git/p-boot/tree/src/uboot/drivers/gpio/sunxi_gpio.c)
-   [__pinmux.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/pinmux.c)

[(Plus a whole bunch of Header Files)](https://github.com/lupyuen/nuttx-apps/blob/de2/examples/hello/test_display.c#L115-L135)

Then we modified the above files to compile on NuttX...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which lets us experiment with the A64 Display Engine on NuttX.

_How does it control the A64 Display Engine?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) controls the A64 Display Engine by writing to the __Hardware Registers__ for the Display Engine.

The Display Engine's Hardware Registers are described here...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But what values does `display_commit` write to the Hardware Registers?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which tells us all the __Hardware Registers and their values__...

```text
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0

Channel 1: Set Overlay
  UI Config Attr:      0x1103000 = 0xff000405
  UI Config Top LAddr: 0x1103010 = 0x4064a6ac
  UI Config Pitch:     0x110300c = 0xb40
  UI Config Size:      0x1103004 = 0x59f02cf
  UI Overlay Size:     0x1103088 = 0x59f02cf
  IO Config Coord:     0x1103008 = 0x0

Channel 1: Set Blender Output
  BLD Output Size: 0x110108c = 0x59f02cf
  GLB Size:        0x110000c = 0x59f02cf

Channel 1: Set Blender Input Pipe 0
  BLD Pipe InSize: 0x1101008 = 0x59f02cf
  BLD Pipe FColor: 0x1101004 = 0xff000000
  BLD Pipe Offset: 0x110100c = 0x0
  BLD Pipe Mode:   0x1101090 = 0x3010301

Channel 1: Disable Scaler
  Mixer: 0x1140000 = 0x0

Channel 2: ...
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

When we study the log, we'll understand how we should __program the A64 Display Engine__ to render the 3 UI Channels.

Our findings are documented here...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

This is very helpful as we create the NuttX Display Driver for PinePhone...

![Testing the NuttX Display Driver for PinePhone](https://lupyuen.github.io/images/dsi2-title.jpg)

[_Testing the NuttX Display Driver for PinePhone_](https://lupyuen.github.io/articles/dsi2)

# NuttX Display Driver for PinePhone

_Once again, why are we doing all this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone.

Someday we hope to have a __fully-functional PinePhone__ running on NuttX RTOS...

-   [__"PinePhone on RTOS"__](https://lupyuen.github.io/articles/arm#pinephone-on-rtos)

(Or maybe just run PinePhone on NuttX as a simple touchscreen gadget)

To do that, we need a __NuttX Display Driver__.

That's why we're probing the internals of PinePhone, to learn everything we need to build the driver.

We've documented our earlier research on PinePhone's __MIPI Display Serial Interface__...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

Today we learnt so much about PinePhone's __A64 Display Engine__...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

We're all set to build the NuttX Display Driver for PinePhone!

_How shall we build the PinePhone Display Driver?_

We'll create the PinePhone Display Driver based on the __NuttX Driver for Sitronix ST7789__...

-   [__nuttx/drivers/lcd/st7789.c__](https://github.com/lupyuen/nuttx/blob/master/drivers/lcd/st7789.c)

That's because ST7789 is somewhat similar to PinePhone's ST7703 LCD Controller.

_But ST7789 doesn't support Framebuffers?_

Yeah for PinePhone we'll wrap the A64 DMA Framebuffers with this interface for __NuttX Framebuffers__...

-   [__nuttx/include/nuttx/video/fb.h__](https://github.com/lupyuen/nuttx/blob/master/include/nuttx/video/fb.h)

-   [__nuttx/drivers/video/fb.c__](https://github.com/lupyuen/nuttx/blob/master/drivers/video/fb.c)

-   [__nuttx/drivers/lcd/lcd_framebuffer.c__](https://github.com/lupyuen/nuttx/blob/master/drivers/lcd/lcd_framebuffer.c)

And we might get inspired by this implementation of __Display Overlays__ in the STM32 LCD TFT Display Controller (LTDC)...

-   [__nuttx/arch/arm/src/stm32/stm32_ltdc.c__](https://github.com/lupyuen/nuttx/blob/master/arch/arm/src/stm32/stm32_ltdc.c)

We have started the __Zig Implementation__ of the NuttX Driver (for MIPI Display Serial Interface)...

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

We'll add the A64 Display Engine in the next article!

-   [__"NuttX RTOS for PinePhone: Render Graphics in Zig"__](https://lupyuen.github.io/articles/de2)

![Testing the A64 Display Engine on PinePhone](https://lupyuen.github.io/images/de-test.jpg)

# What's Next

I hope we learnt lots today about __Display Rendering on PinePhone__...

-   What's the [__Display Engine (DE)__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone) inside PinePhone

-   How the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) controls PinePhone's LCD Display

-   How we call DE and TCON0 to [__render graphics__](https://lupyuen.github.io/articles/de#render-colours)

-   How our new [__PinePhone Display Driver__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone) will support DE and TCON0

Please join me in the next article as we create the PinePhone Display Engine Driver for [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot)!

-   [__"NuttX RTOS for PinePhone: Render Graphics in Zig"__](https://lupyuen.github.io/articles/de2)

Check out the other articles on __NuttX RTOS for PinePhone__...

-   [__"Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone"__](https://lupyuen.github.io/articles/arm)

-   [__"PinePhone boots Apache NuttX RTOS"__](https://lupyuen.github.io/articles/uboot)

-   [__"NuttX RTOS for PinePhone: Fixing the Interrupts"__](https://lupyuen.github.io/articles/interrupt)

-   [__"NuttX RTOS for PinePhone: UART Driver"__](https://lupyuen.github.io/articles/serial)

-   [__"NuttX RTOS for PinePhone: Blinking the LEDs"__](https://lupyuen.github.io/articles/pio)

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

-   [__"NuttX RTOS for PinePhone: Render Graphics in Zig"__](https://lupyuen.github.io/articles/de2)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__Discuss this article on Reddit__](https://www.reddit.com/r/PINE64official/comments/ygz5kt/rendering_pinephones_display_de_and_tcon0/)

-   [__My Current Project: "Apache NuttX RTOS for PinePhone"__](https://github.com/lupyuen/pinephone-nuttx)

-   [__My Other Project: "The RISC-V BL602 Book"__](https://lupyuen.github.io/articles/book)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/de.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Appendix: Overview of Allwinner A64 Display Engine

The official doc for the __Allwinner A64 Display Engine__ is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with [__64-bit Arm Cores__](https://linux-sunxi.org/A64).

(Also check out this [__DE2 Register Guide__](https://linux-sunxi.org/DE2_Register_Guide))

Earlier we said that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display...

-   [__"Display Rendering on PinePhone"__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone)

According to the doc, the __Display Engine Base Address__ is __`0x0100` `0000`__ [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

_What's a Display Engine Mixer?_

__DE RT-MIXER:__ [(DE Page 87)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing."

The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1.

__DE RT-MIXER0__ has 4 Channels (DE Offset __`0x10` `0000`__, [DE Page 87](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf))

-   __Channel 0__ for Video

    (DMA0, Video Overlay, Video Scaler)

-   __Channels 1, 2 and 3__ for UI

    (DMA1 / 2 / 3, 3 x UI Overlays, 3 x UI Scalers, 3 x UI Blenders)

-   __4 Overlay Layers__ per Channel

    (We only use 1 Overlay Layer per Channel)

-   __Layer Priority__ is Layer 3 > Layer2 > Layer 1 > Layer 0 [(DE Page 89)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

Our Display Engine Demo __configures the 4 Channels__ as follows...

-   __Channel 0__ is unused

    (No video right now)

-   __Channel 1__ has Pixel Format XRGB 8888

    (Alpha Channel is disabled)

-   __Channels 2 and 3__ have Pixel Format ARGB 8888

    (Alpha Channel is enabled)

__Hardware Registers__ for RT-MIXER0 [(DE Page 90)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)...

| Hardware Register | RT-MIXER0 Offset 
|--------------------|-----------------
|__GLB__ (Global Registers) | __`0x00` `0000`__
|__BLD__ (Blender) | __`0x00` `1000`__
|__OVL_V(CH0)__ (Video Overlay / Channel 0) | __`0x00` `2000`__
|__OVL_UI(CH1)__ (UI Overlay / Channel 1) | __`0x00` `3000`__
|__OVL_UI(CH2)__ (UI Overlay / Channel 2) | __`0x00` `4000`__
|__OVL_UI(CH3)__ (UI Overlay / Channel 3) | __`0x00` `5000`__
|__VIDEO_SCALER(CH0)__ (Video Scaler / Channel 0) | __`0x02` `0000`__
|__UI_SCALER1(CH1)__ (UI Scaler / Channel 1) | __`0x04` `0000`__
|__UI_SCALER2(CH2)__ (UI Scaler / Channel 2) | __` 0x05` `0000`__
|__UI_SCALER3(CH3)__ (UI Scaler / Channel 3) | __` 0x06` `0000`__
|__POST_PROC1__ (Post Processor 1) | __`0x0A` `0000`__
|__POST_PROC2__ (Post Processor 2) | __`0x0B` `0000`__
|__DMA__ (Direct Memory Access) | __`0x0C` `0000`__

The pic below shows how DE RT-MIXER0 mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3 (plus a Video Channel on DMA0)...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

__DE RT-MIXER1__ has 2 Channels (DE Offset __`0x20` `0000`__, [DE Page 23](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf))
-   __Channel 0__ for Video 

    (DMA0, Video Overlay, Video Scaler)

-   __Channel 1__ for UI 

    (DMA1, UI Overlay, UI Scaler, UI Blender)

(We don't use RT-MIXER1 right now)

RT-MIXER0 and RT-MIXER1 are multiplexed to __Timing Controller TCON0__. [(Like this)](https://lupyuen.github.io/images/de-block1a.jpg)

TCON0 is connected to PinePhone's __ST7703 LCD Controller__ over MIPI Display Serial Interface. [(See this)](https://lupyuen.github.io/articles/dsi)

Hence RT-MIXER0 __mixes 1 Video Channel with 3 UI Channels__ over DMA. And pumps the pixels continuously to ST7703 LCD Controller. (Via the Timing Controller TCON0)

In today's demo we used the 3 UI Channels to render (pic below)...
1.  Mandelbrot Set
1.  Blue Square
1.  Green Circle

In the following chapters we explain how the 3 UI Channels were initialised and rendered by setting the Hardware Registers for A64 Display Engine...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

[_Mandelbrot Set with Blue Square and Green Circle as Overlays_](https://lupyuen.github.io/articles/de#test-pinephone-display-engine)

We won't use these Display Engine Features today...

__DE RT-WB (Write-Back Controller):__ [(DE Page 116)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM."

(For screen capture?)

__DE VSU (Video Scaler):__ [(DE Page 128)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules."

__DE Rotation:__ [(DE Page 137)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)
> "There are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation."

Nope to these too...

-   Fresh and Contrast Enhancement (FCE)
-   Black and White Stetch (BWS)
-   Luminance Transient Improvement (LTI)
-   Luma Peaking (PEAKING)
-   Adaptive Saturation Enhancement (ASE)
-   Fancy Color Curvature Change (FCC)
-   Dynamic Range Controller (DRC)

# Appendix: Initialising the Allwinner A64 Display Engine

_How do we initialise PinePhone's Allwinner A64 Display Engine at startup?_

As deciphered from the following logs...

-   [__`de2_init` Log__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init) 

    (Captured from [__p-boot `de2_init`__](https://megous.com/git/p-boot/tree/src/display.c#n1871))

-   [__`clock_set_pll_de` Log__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#clock_set_pll_de)

    (Captured from [__p-boot `clock_set_pll_de`__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c#n260))

Below are the steps to __initialise the Allwinner A64 Display Engine__ at startup...

1.  Set __High Speed SRAM__ to DMA Mode

    -   Set __BIST_DMA_CTRL_SEL__ to __0__ for DMA [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)
    
        [(A31 Page 191, `0x1C0` `0004`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/A31_User_Manual_v1.3_20150510.pdf)

    -   __BIST_DMA_CTRL_SEL__ (Bist and DMA Control Select) is __Bit 0__ of SRAM_CTRL_REG1

    -   __SRAM_CTRL_REG1__ (SRAM Control Register 1) is at SRAM Registers Offset __`0x4`__

    -   __SRAM Registers__ Base Address is __`0x01C0` `0000`__
    
        [(A31 Page 191)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/A31_User_Manual_v1.3_20150510.pdf)
    
    ```text
    Set SRAM for video use
      0x1c0 0004 = 0x0 (DMB)
    ```

1.  Set __Display Engine PLL__ to 297 MHz

    -   Set __PLL_DE_CTRL_REG__ to __`0x8100` `1701`__ [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        __PLL_ENABLE__ (Bit 31) = 1 (Enable PLL)

        __PLL_MODE_SEL__ (Bit 24) = 1 (Integer Mode)

        __PLL_FACTOR_N__ (Bits 8 to 14) = 23 (N = 24)

        __PLL_PRE_DIV_M__ (Bits 0 to 3) = 1 (M = 2)

        Actual PLL Output = 24 MHz * N / M = 288 MHz
        
        (Slighltly below 297 MHz due to truncation)

    -   __PLL_DE_CTRL_REG__ (PLL Display Engine Control Register) is at CCU Offset __`0x0048`__

        [(A64 Page 96, `0x1C2` `0048`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Setup DE2 PLL
      clock_set_pll_de: clk=297000000
      PLL10 rate = 24000000 * n / m
      0x1c2 0048 = 0x8100 1701 (DMB)
    ```

1.  Wait for __Display Engine PLL__ to be stable

    -   Poll __PLL_DE_CTRL_REG__ (from above) until __LOCK__ (Bit 28) is 1
    
        (PLL is Locked and Stable)

    ```text
    Setup DE2 PLL
      while (!(readl(0x1c2 0048) & 0x1000 0000))
    ```

1.  Set __Special Clock__ to Display Engine PLL

    -   Clear __DE_CLK_REG__ bits __`0x0300` `0000`__

        Set __DE_CLK_REG__   bits __`0x8100` `0000`__

        __SCLK_GATING__ (Bit 31) = 1 (Enable Special Clock)        

        __CLK_SRC_SEL__ (Bits 24 to 26) = 1 (Clock Source is Display Engine PLL)

    -   __DE_CLK_REG__ (Display Engine Clock Register) is at CCU Offset __`0x0104`__
    
        [(A64 Page 117, `0x1C2` `0104`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 special clock
      clrsetbits 0x1c2 0104, 0x300 0000, 0x8100 0000
    ```

1.  Enable __AHB (AMBA High-speed Bus)__ for Display Engine: De-Assert Display Engine

    -   Set __BUS_SOFT_RST_REG1__ bits __`0x1000`__

        __DE_RST__ (Bit 12) = 1 (De-Assert Display Engine)

    -   __BUS_SOFT_RST_REG1__ (Bus Software Reset Register 1) is at CCU Offset `0x02C4`

        [(A64 Page 140, `0x1C2` `02C4`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 ahb
      setbits 0x1c2 02c4, 0x1000
    ```

1.  Enable __AHB (AMBA High-speed Bus)__ for Display Engine: Pass Display Engine

    -   Set __BUS_CLK_GATING_REG1__ bits __`0x1000`__

        __DE_GATING__ (Bit 12) = 1 (Pass Display Engine)

    -   __BUS_CLK_GATING_REG1__ (Bus Clock Gating Register 1) is at CCU Offset __`0x0064`__
        
        [(A64 Page 102, `0x1C2` `0064`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 ahb
      setbits 0x1c2 0064, 0x1000
    ```

1.  Enable __Clock for MIXER0__: SCLK Clock Pass

    -   Set __SCLK_GATE__ bits __`0x1`__

        __CORE0_SCLK_GATE__ (Bit 0) = 1 (Clock Pass)

    -   __SCLK_GATE__ is at DE Offset __`0x000`__
    
        [(DE Page 25, `0x100` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0000, 0x1
    ```

1.  Enable __Clock for MIXER0__: HCLK Clock Reset Off

    -   Set __AHB_RESET__ bits __`0x1`__

        __CORE0_HCLK_RESET__ (Bit 0) = 1 (Reset Off)

    -   __AHB_RESET__ is at DE Offset __`0x008`__
    
        [(DE Page 25, `0x100` `0008`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0008, 0x1
    ```

1.  Enable __Clock for MIXER0__: HCLK Clock Pass

    -   Set __HCLK_GATE__ bits __`0x1`__

        __CORE0_HCLK_GATE__ (Bit 0) = 1 (Clock Pass)

    -   __HCLK_GATE__ is at DE Offset __`0x004`__
    
        [(DE Page 25, `0x100` `0004`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0004, 0x1
    ```

1.  Route __MIXER0 to TCON0__

    -   Clear __DE2TCON_MUX__ bits __`0x1`__

        __DE2TCON_MUX__ (Bit 0) = 0
        
        (Route MIXER0 to TCON0; Route MIXER1 to TCON1)

    -   __DE2TCON_MUX__ is at DE Offset __`0x010`__
    
        [(DE Page 26, `0x100` `0010`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      clrbits 0x100 0010, 0x1
    ```

1.  Clear __MIXER0 Registers__: Global Registers (GLB), Blender (BLD), Video Overlay (OVL_V), UI Overlay (OVL_UI)

    -   Set __MIXER0__ Offsets __`0x0000`__ - __`0x5FFF`__ to 0

        Which covers...

        __GLB__ (Global Regisers) at MIXER0 Offset __`0x0000`__

        __BLD__ (Blender) at MIXER0 Offset __`0x1000`__

        __OVL_V(CH0)__ (Video Overlay) at MIXER0 Offset __`0x2000`__

        __OVL_UI(CH1)__ (UI Overlay 1) at MIXER0 Offset __`0x3000`__

        __OVL_UI(CH2)__ (UI Overlay 2) at MIXER0 Offset __`0x4000`__

        __OVL_UI(CH3)__ (UI Overlay 3) at MIXER0 Offset __`0x5000`__

        [(DE Page 90, `0x110` `0000` - `0x110` `5FFF`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Clear all registers
      0x110 0000 to 0x110 5fff = 0x0
    ```

1.  Disable __MIXER0 Modules__...

    -   Video Scaler (VSU)
    -   UI Scaler (UIS)
    -   Fresh and Contrast Enhancement (FCE)
    -   Black and White Stetch (BWS)
    -   Luminance Transient Improvement (LTI)
    -   Luma Peaking (PEAKING)
    -   Adaptive Saturation Enhancement (ASE)
    -   Fancy Color Curvature Change (FCC)
    -   Dynamic Range Controller (DRC)

    Set to __`0`__ the following registers...

    -   __VS_CTRL_REG__ at VIDEO_SCALER(CH0) Offset 0

        EN (Bit 0) = 0 (Disable Video Scaler)

        [(DE Page 130, `0x112` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   TODO: __`0x113` `0000`__ is Undocumented

        (Is there a mixup with UI_SCALER3?)

    -   __UIS_CTRL_REG__ at UI_SCALER1(CH1) Offset 0

        EN (Bit 0) = 0 (Disable UI Scaler) 

        [(DE Page 66, `0x114` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UIS_CTRL_REG__ at UI_SCALER2(CH2) Offset 0

        EN (Bit 0) = 0 (Disable UI Scaler)

        [(DE Page 66, `0x115` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   TODO: Missing __UI_SCALER3(CH3)__ at MIXER0 Offset `0x06` `0000`

        [(DE Page 90, `0x116` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        (Is there a mixup with `0x113` `0000` above?)

    -   __GCTRL_REG(FCE)__ at FCE Offset 0

        EN (Bit 0) = 0 (Disable FCE)

        [(DE Page 62, `0x11A` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GCTRL_REG(BWS)__ at BWS Offset 0

        EN (Bit 0) = 0 (Disable BWS)

        [(DE Page 42, `0x11A` `2000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LTI_CTL__ at LTI Offset 0

        LTI_EN (Bit 0) = 0 (Close LTI)

        [(DE Page 72, `0x11A` `4000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LP_CTRL_REG__ at PEAKING Offset 0

        EN (Bit 0) = 0 (Disable PEAKING)

        [(DE Page 80, `0x11A` `6000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __ASE_CTL_REG__ at ASE Offset 0

        ASE_EN (Bit 0) = 0 (Disable ASE)

        [(DE Page 40, `0x11A` `8000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCC_CTL_REG__ at FCC Offset 0

        Enable (Bit 0) = 0 (Disable FCC)

        [(DE Page 56, `0x11A` `A000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GNECTL_REG__ at DRC Offset 0

        BIST_EN (Bit 0) = 0 (Disable BIST)

        [(DE Page 49, `0x11B` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    Offsets of the above registers...

    -   __VIDEO_SCALER(CH0)__ is at MIXER0 Offset `0x02` `0000`
        
        [(DE Page 90, `0x112` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UI_SCALER1(CH1)__ is at MIXER0 Offset `0x04` `0000`

        [(DE Page 90, `0x114` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UI_SCALER2(CH2)__ is at MIXER0 Offset `0x05` `0000`
    
        [(DE Page 90, `0x115` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCE__ is at MIXER0 Offset `0x0A` `0000`

        [(DE Page 61, `0x11A` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __BWS__ is at MIXER0 Offset `0x0A` `2000`

        [(DE Page 42, `0x11A` `2000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LTI__ is at MIXER0 Offset `0x0A` `4000`

        [(DE Page 71, `0x11A` `4000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __PEAKING__ is at MIXER0 Offset `0x0A` `6000`

        [(DE Page 80, `0x11A` `6000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __ASE__ is at MIXER0 Offset `0x0A` `8000`

        [(DE Page 40, `0x11A` `8000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCC__ is at MIXER0 Offset `0x0A` `A000`

        [(DE Page 56, `0x11A` `A000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __DRC__ is at Address `0x011B` `0000`
    
        [(DE Page 48, `0x11B` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Clear all registers
      0x112 0000 = 0x0
      0x113 0000 = 0x0
      0x114 0000 = 0x0
      0x115 0000 = 0x0
      0x11a 0000 = 0x0
      0x11a 2000 = 0x0
      0x11a 4000 = 0x0
      0x11a 6000 = 0x0
      0x11a 8000 = 0x0
      0x11a a000 = 0x0
      0x11b 0000 = 0x0
    ```

1.  Enable __MIXER0__

    -   Set __GLB_CTL__ to 1 [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        EN (Bit 0) = 1 (Enable Mixer)

        [(DE Page 92)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GLB_CTL__ is at MIXER0 Offset 0

        [(DE Page 90, `0x110` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24, `0x110` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable mixer
      0x110 0000 = 0x1 (DMB)
    ```

We have __implemented in Zig__ the above A64 Display Engine Initialisation...

-   [__pinephone-nuttx/render.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig)

-   [__Output Log for render.zig__](https://gist.github.com/lupyuen/2df0f8c016dae54f4e4210866a7cd118)

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://lupyuen.github.io/articles/de#p-boot-display-code)

# Appendix: Programming the Allwinner A64 Display Engine

We've seen the __Hardware Registers__ for the Allwinner A64 Display Engine...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

And we need to program the Hardware Registers to create the __NuttX Display Driver__ for PinePhone...

-   [__"NuttX Display Driver for PinePhone"__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone)

_How will we program the Hardware Registers to render the UI Channels?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which produces a log that tells us all the __Hardware Registers and their values__...

-   [__"Testing p-boot Display Engine on PinePhone"__](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

After studying the log, we have identified the steps to render the 3 UI Channels with the Display Engine.

This is how we'll create a NuttX Driver for PinePhone's A64 Display Engine that implements Display Rendering...

[(Refer to __Memory Mapping List__ and __Register List__ at DE Page 90)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

1.  Set __Blender Background and Pre-Multiply...__

    -   __BLD_BK_COLOR__ (Blender Background Color) at BLD Offset `0x88`

        Set to `0xFF00` `0000` (Black Background Color)

        RESERVED (Bits 24 to 31) = 0xFF (Undocumented)

        RED (Bits 16 to 23) = 0

        GREEN (Bits 8 to 15) = 0

        BLUE (Bits 0 to 7) = 0

        [(DE Page 109, `0x110` `1088`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __BLD_PREMUL_CTL__ (Blender Pre-Multiply Control) at BLD Offset `0x84`

        Set to 0 (No Pre-Multiply for Alpha, Pipes 0 to 3)

        P3_ALPHA_MODE (Bit 3) = 0 (Pipe 3: No Pre-Multiply)

        P2_ALPHA_MODE (Bit 2) = 0 (Pipe 2: No Pre-Multiply)

        P1_ALPHA_MODE (Bit 1) = 0 (Pipe 1: No Pre-Multiply)

        P0_ALPHA_MODE (Bit 0) = 0 (Pipe 0: No Pre-Multiply)

        [(DE Page 109, `0x110` `1084`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Configure Blender
    BLD BkColor:     0x110 1088 = 0xff00 0000
    BLD Premultiply: 0x110 1084 = 0x0
    ```

1.  __For Channels 1 to 3...__

    1.  __If Channel is unused,__ disable Overlay, Pipe and Scaler. Skip to next Channel

        -   __OVL_UI_ATTR_CTL__ (UI Overlay Attribute Control) at OVL_UI Offset `0x00`

            Set to 0 (Disable UI Overlay Channel)

            LAY_EN (Bit 0) = 0 (Disable Layer)

            [(DE Page 102, `0x110` `3000` / `0x110` `4000` / `0x110` `5000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __UIS_CTRL_REG__ at Offset 0 of UI_SCALER1(CH1) or UI_SCALER2(CH2) or UI_SCALER3(CH3)

            Set to 0 (Disable UI Scaler)

            EN (Bit 0) = 0 (Disable UI Scaler) 

            [(DE Page 66, `0x114` `0000` / `0x115` `0000` / `0x116` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI(CH1)__ (UI Overlay 1) is at MIXER0 Offset `0x3000`

            [(DE Page 102, `0x110` `3000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __OVL_UI(CH2)__ (UI Overlay 2) is at MIXER0 Offset `0x4000`

            [(DE Page 102, `0x110` `4000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __OVL_UI(CH3)__ (UI Overlay 3) is at MIXER0 Offset `0x5000`

            [(DE Page 102, `0x110` `5000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __UI_SCALER1(CH1)__ is at MIXER0 Offset `0x04` `0000`

            [(DE Page 90, `0x114` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __UI_SCALER2(CH2)__ is at MIXER0 Offset `0x05` `0000`
        
            [(DE Page 90, `0x115` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __UI_SCALER3(CH3)__ is at MIXER0 Offset `0x06` `0000`
        
            [(DE Page 90, `0x116` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __MIXER0__ is at DE Offset `0x0010` `0000`

            [(DE Page 24, `0x110` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

            __Display Engine (DE)__ Base Address is `0x0100` `0000`
    
            [(DE Page 24)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        ```text
        Channel 2: Disable Overlay and Pipe
        UI Config Attr: 0x110 4000 = 0x0

        Channel 3: Disable Overlay and Pipe
        UI Config Attr: 0x110 5000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

    1.  Channel 1 has Pixel Format __XRGB 8888__:

        __OVL_UI_ATTR_CTL â†’ LAY_FBFMT__ = 4
    
        Channels 2 and 3 have Pixel Format __ARGB 8888__:

        __OVL_UI_ATTR_CTL â†’ LAY_FBFMT__ = 0

        [(DE Page 94)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    1.  __Set Overlay__ (Assume Layer = 0)

        -   __OVL_UI_ATTR_CTL__ (UI Overlay Attribute Control) at OVL_UI Offset `0x00`

            __For Channel 1:__ Set to `0xFF00` `0405`

            __For Channel 2:__ Set to `0xFF00` `0005`

            __For Channel 3:__ Set to `0x7F00` `0005`

            LAY_GLBALPHA (Bits 24 to 31) = `0xFF` or `0x7F`
            
            (Global Alpha Value is Opaque or Semi-Transparent)

            LAY_FBFMT (Bits 8 to 12) = 4 or 0
            
            (Input Data Format is XRGB 8888 or ARGB 8888)

            LAY_ALPHA_MODE (Bits 1 to 2) = 2
            
            (Global Alpha is mixed with Pixel Alpha)

            (Input Alpha Value = Global Alpha Value * Pixel's Alpha Value)

            LAY_EN (Bit 0) = 1 (Enable Layer)

            [(DE Page 102, `0x110` `3000` / `0x110` `4000` / `0x110` `5000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI_TOP_LADD__ (UI Overlay Top Field Memory Block Low Address) at OVL_UI Offset `0x10`

            Set to Framebuffer Address: `fb0`, `fb1` or `fb2`

            [(DE Page 104, `0x110` `3010` / `0x110` `4010` / `0x110` `5010`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI_PITCH__ (UI Overlay Memory Pitch) at OVL_UI Offset `0x0C`

            Set to `(width * 4)`, number of bytes per row

            [(DE Page 104, `0x110` `300C` / `0x110` `400C` / `0x110` `500C`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI_MBSIZE__ (UI Overlay Memory Block Size) at OVL_UI Offset `0x04`

            Set to `(height-1) << 16 + (width-1)`

            [(DE Page 104, `0x110` `3004` / `0x110` `4004` / `0x110` `5004`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI_SIZE__ (UI Overlay Overlay Window Size) at OVL_UI Offset `0x88`

            Set to `(height-1) << 16 + (width-1)`

            [(DE Page 106, `0x110` `3088` / `0x110` `4088` / `0x110` `5088`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __OVL_UI_COOR__ (UI Overlay Memory Block Coordinate) at OVL_UI Offset `0x08`

            Set to 0 (Overlay at X=0, Y=0)

            [(DE Page 104, `0x110` `3008` / `0x110` `4008` / `0x110` `5008`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        ```text
        Channel 1: Set Overlay (fb0 is 720 x 1440)
        UI Config Attr:      0x110 3000 = 0xff00 0405
        UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
        UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
        UI Config Size:      0x110 3004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 3008 = 0x0

        Channel 2: Set Overlay (fb1 is 600 x 600)
        UI Config Attr:      0x110 4000 = 0xff00 0005
        UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
        UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
        UI Config Size:      0x110 4004 = 0x257 0257 (599 << 16 + 599)
        UI Overlay Size:     0x110 4088 = 0x257 0257 (599 << 16 + 599)
        IO Config Coord:     0x110 4008 = 0x0

        Channel 3: Set Overlay (fb2 is 720 x 1440)
        UI Config Attr:      0x110 5000 = 0x7f00 0005
        UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
        UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
        UI Config Size:      0x110 5004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 5008 = 0x0
        ```

    1.  __For Channel 1:__ Set Blender Output

        -   __BLD_SIZE__ (Blender Output Size Setting) at BLD Offset `0x08C`

            Set to `(height-1) << 16 + (width-1)`

            [(DE Page 110, `0x110` `108C`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __GLB_SIZE__ (Global Size) at GLB Offset `0x00C`

            Set to `(height-1) << 16 + (width-1)`

            [(DE Page 93, `0x110` `000C`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        ```text
        Channel 1: Set Blender Output
        BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
        GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)
        ```

    1.  __Set Blender Input Pipe__ (N = Pipe Number, from 0 to 2 for Channels 1 to 3)

        -   __BLD_CH_ISIZE__ (Blender Input Memory Size) at BLD Offset `0x008` + `N*0x10` (N=0,1,2,3,4) 

            Set to `(height-1) << 16 + (width-1)`

            [(DE Page 108, `0x110 1008` / `0x110 1018` / `0x110 1028`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __BLD_FILL_COLOR__ (Blender Fill Color) at BLD Offset `0x004` + `N*0x10` (N=0,1,2,3,4)

            Set to `0xFF00` `0000` (Opaque Black)

            ALPHA (Bits 24 to 31) = `0xFF`

            RED (Bits 16 to 23) = 0

            GREEN (Bits 8 to 15) = 0

            BLUE (Bits 0 to 7) = 0

            [(DE Page 107, `0x110 1004` / `0x110` `1014` / `0x110` `1024`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __BLD_CH_OFFSET__ (Blender Input Memory Offset) at BLD Offset `0x00C` + `N*0x10` (N=0,1,2,3,4)

            Set to `y_offset << 16 + x_offset`

            __For Channel 1:__ Set to 0

            __For Channel 2:__ Set to `0x34` `0034`

            __For Channel 3:__ Set to 0

            [(DE Page 108, `0x110` `100C` / `0x110` `101C` / `0x110` `102C`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        -   __BLD_CTL__ (Blender Control) at BLD Offset `0x090` + `N*4`

            Set to `0x301` `0301`

            BLEND_AFD (Bits 24 to 27) = 3

            (Coefficient for destination alpha data Q[d] is 1-A[s])

            BLEND_AFS (Bits 16 to 19) = 1

            (Coefficient for source alpha data Q[s] is 1)

            BLEND_PFD (Bits 8 to 11) = 3

            (Coefficient for destination pixel data F[d] is 1-A[s])

            BLEND_PFS (Bits 0 to 3) = 1

            (Coefficient for source pixel data F[s] is 1)

            [(DE Page 110, `0x110` `1090` / `0x110` `1094` / `0x110` `1098`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        __Note:__ [DE Page 91](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf) shows incorrect offset `N*0x14` for __BLD_CH_ISIZE__, __BLD_FILL_COLOR__ and __BLD_CH_OFFSET__. Correct offset is `N*0x10`, see [DE Page 108](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        ```text
        Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
        BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1004 = 0xff00 0000
        BLD Pipe Offset: 0x110 100c = 0x0
        BLD Pipe Mode:   0x110 1090 = 0x301 0301

        Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
        BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 << 16 + 599)
        BLD Pipe FColor: 0x110 1014 = 0xff00 0000
        BLD Pipe Offset: 0x110 101c = 0x34 0034
        BLD Pipe Mode:   0x110 1094 = 0x301 0301

        Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
        BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1024 = 0xff00 0000
        BLD Pipe Offset: 0x110 102c = 0x0
        BLD Pipe Mode:   0x110 1098 = 0x301 0301
        ```

    1.  __Disable Scaler__ (Assume we're not scaling)

        -   __UIS_CTRL_REG__ at Offset 0 of UI_SCALER1(CH1) or UI_SCALER2(CH2) or UI_SCALER3(CH3)

            Set to 0 (Disable UI Scaler)

            EN (Bit 0) = 0 (Disable UI Scaler) 

            [(DE Page 66, `0x114` `0000` / `0x115` `0000` / `0x116` `0000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

        ```text
        Channel 1: Disable Scaler
        Mixer: 0x114 0000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

1.  __Set Blender Route and Enable Blender Pipes__

    -   __BLD_CH_RTCTL__ (Blender Routing Control) at BLD Offset `0x080`

        __If Rendering 3 UI Channels:__ Set to `0x321` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        P2_RTCTL (Bits 8 to 11) = 3 (Pipe 2 from Channel 3)

        P1_RTCTL (Bits 4 to 7) = 2 (Pipe 1 from Channel 2)

        P0_RTCTL (Bits 0 to 3) = 1 (Pipe 0 from Channel 1)

        __If Rendering 1 UI Channel:__ Set to `1` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        P0_RTCTL (Bits 0 to 3) = 1 (Pipe 0 from Channel 1)

        [(DE Page 108, `0x110` `1080`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __BLD_FILL_COLOR_CTL__ (Blender Fill Color Control) at BLD Offset `0x000`

        __If Rendering 3 UI Channels:__ Set to `0x701` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        P2_EN (Bit 10) = 1 (Enable Pipe 2)

        P1_EN (Bit 9) = 1 (Enable Pipe 1)

        P0_EN (Bit 8) = 1 (Enable Pipe 0)

        P0_FCEN (Bit 0) = 1 (Enable Pipe 0 Fill Color)

        __If Rendering 1 UI Channel:__ Set to `0x101` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        P0_EN (Bit 8) = 1 (Enable Pipe 0)

        P0_FCEN (Bit 0) = 1 (Enable Pipe 0 Fill Color)

        [(DE Page 106, `0x110` `1000`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    For 3 UI Channels: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x321 (DMB)
    BLD FColor Control: 0x110 1000 = 0x701 (DMB)

    For 1 UI Channel: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x1   (DMB)
    BLD FColor Control: 0x110 1000 = 0x101 (DMB)
    ```

1.  __Apply Settings__

    -   __GLB_DBUFFER__ (Global Double Buffer Control) at GLB Offset `0x008`

        Set to 1 [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        DOUBLE_BUFFER_RDY (Bit 0) = 1

        (Register Value is ready for update)

        [(DE Page 93, `0x110` `0008`)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Apply Settings
    GLB DBuff: 0x110 0008 = 0x1 (DMB)
    ```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

[(Captured from p-boot `display_commit`)](https://megous.com/git/p-boot/tree/src/display.c#n2017)

Based on the above steps, we have __implemented in Zig__ the A64 Display Engine Rendering...

-   [__pinephone-nuttx/render.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig)

-   [__Output Log for render.zig__](https://gist.github.com/lupyuen/2df0f8c016dae54f4e4210866a7cd118)

# Appendix: Display Backlight

We captured the log from [__p-boot backlight_enable__](https://megous.com/git/p-boot/tree/src/display.c#n1929)...

-   [__Log from backlight_enable__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#backlight_enable)

By decoding the captured addresses and values, we decipher the following steps for turning on __PinePhone's Display Backlight__...

1.  Configure PL10 for PWM
    - Register PL_CFG1 (Port L Configure Register 1)
    - At R_PIO Offset 4 [(A64 Page 412)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - Set PL10_SELECT (Bits 8 to 10) to 2 (S_PWM)

    ```text
    backlight_enable: pct=0x5a
    1.0 has incorrectly documented non-presence of PH10, the circuit is in fact the same as on 1.1+
    configure pwm: GPL(10), GPL_R_PWM
    sunxi_gpio_set_cfgpin: pin=0x16a, val=2
    sunxi_gpio_set_cfgbank: bank_offset=362, val=2
    clrsetbits 0x1f02c04, 0xf00, 0x200
    TODO: Should 0xf00 be 0x700 instead?
    ```

1.  Disable R_PWM (Undocumented)
    - Register R_PWM_CTRL_REG? (R_PWM Control Register?)
    - At R_PWM Offset 0 [(A64 Page 194)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - Set SCLK_CH0_GATING (Bit 6) to 0 (Mask)

    ```text
    clrbits 0x1f03800, 0x40
    ```

1.  Configure R_PWM Period (Undocumented)
    - Register R_PWM_CH0_PERIOD? (R_PWM Channel 0 Period Register?)
    - At R_PWM Offset 4 [(A64 Page 195)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - PWM_CH0_ENTIRE_CYS (Upper 16 Bits) = Period (`0x4af`)
    - PWM_CH0_ENTIRE_ACT_CYS (Lower 16 Bits) = Period * Percent / 100 (`0x0437`)
    - Period = 1199 (Cycles of PWM Clock)
    - Percent = 90 (90% Brightness)

    ```text
    0x1f03804 = 0x4af0437
    ```

1.  Enable R_PWM (Undocumented)
    - Register R_PWM_CTRL_REG? (R_PWM Control Register?)
    - At R_PWM Offset 0 [(A64 Page 194)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - Set SCLK_CH0_GATING (Bit 6) to 1 (Pass)
    - Set PWM_CH0_EN (Bit 4) to 1 (Enable)
    - Set PWM_CH0_PRESCAL (Bits 0 to 3) to 0b1111 (Prescalar 1)

    ```text
    0x1f03800 = 0x5f
    ```

1.  Configure PH10 for Output
    - Register PH_CFG1 (PH Configure Register 1)
    - At PIO Offset `0x100` [(A64 Page 401)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - Set PH10_SELECT (Bits 8 to 10) to 1 (Output)

    ```text
    enable backlight: GPH(10), 1
    sunxi_gpio_set_cfgpin: pin=0xea, val=1
    sunxi_gpio_set_cfgbank: bank_offset=234, val=1
    clrsetbits 0x1c20900, 0xf00, 0x100
    TODO: Should 0xf00 be 0x700 instead?
    ```

1.  Set PH10 to High
    - Register PH_DATA (PH Data Register)
    - At PIO Offset `0x10C` [(A64 Page 403)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)
    - Set PH10 (Bit 10) to 1 (High)

    ```text
    sunxi_gpio_output: pin=0xea, val=1
    TODO: Set Bit 10 of PH_DATA (0x1c2090c)
    ```

[(See the Complete Log)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#backlight_enable)

The Base Addresses above are...

-   __PIO Base Address__ (CPUx-PORT): `0x01C2` `0800` [(A64 Page 376)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

-   __PWM Base Address__ (CPUx-PWM?): `0x01C2` `1400` [(A64 Page 194)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

-   __R_PIO Base Address__ (CPUs-PORT): `0x01F0` `2C00` [(A64 Page 410)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

-   __R_PWM Base Address__ (CPUs-PWM?): `0x01F0` `3800` [(CPUs Domain, A64 Page 256)](https://github.com/lupyuen/pinephone-nuttx/releases/download/doc/Allwinner_A64_User_Manual_V1.1.pdf)

Based on the above steps, we have __implemented in Zig__ the Display Backlight Driver...

-   [__pinephone-nuttx/backlight.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/backlight.zig)

-   [__Output Log for backlight.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

# Appendix: Power Management Integrated Circuit

We captured the log from [__p-boot display_board_init__](https://megous.com/git/p-boot/tree/src/display.c#n1947)...

-   [__Log from display_board_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#display_board_init)

```text
display_board_init: start
assert reset: GPD(23), 0  // PD23 - LCD-RST (active low)
sunxi_gpio_set_cfgpin: pin=0x77, val=1
sunxi_gpio_set_cfgbank: bank_offset=119, val=1
  clrsetbits 0x1c20874, 0xf0000000, 0x10000000
sunxi_gpio_output: pin=0x77, val=0
  before: 0x1c2087c = 0x1c0000
  after: 0x1c2087c = 0x1c0000 (DMB)
dldo1 3.3V
  pmic_write: reg=0x15, val=0x1a
  rsb_write: rt_addr=0x2d, reg_addr=0x15, value=0x1a
  pmic_clrsetbits: reg=0x12, clr_mask=0x0, set_mask=0x8
  rsb_read: rt_addr=0x2d, reg_addr=0x12
  rsb_write: rt_addr=0x2d, reg_addr=0x12, value=0xd9
ldo_io0 3.3V
  pmic_write: reg=0x91, val=0x1a
  rsb_write: rt_addr=0x2d, reg_addr=0x91, value=0x1a
  pmic_write: reg=0x90, val=0x3
  rsb_write: rt_addr=0x2d, reg_addr=0x90, value=0x3
dldo2 1.8V
  pmic_write: reg=0x16, val=0xb
  rsb_write: rt_addr=0x2d, reg_addr=0x16, value=0xb
  pmic_clrsetbits: reg=0x12, clr_mask=0x0, set_mask=0x10
  rsb_read: rt_addr=0x2d, reg_addr=0x12
  rsb_write: rt_addr=0x2d, reg_addr=0x12, value=0xd9
wait for power supplies and power-on init
  udelay 15000
display_board_init: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#display_board_init)

Based on the above log, we have __implemented in Zig__ the PinePhone Driver for Power Management Integrated Circuit (PMIC)...

-   [__pinephone-nuttx/pmic.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/pmic.zig)

-   [__Output Log for pmic.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

TODO: Reverse Engineering

```text
assert reset: GPD(23), 0  // PD23 - LCD-RST (active low)
sunxi_gpio_set_cfgpin: pin=0x77, val=1
sunxi_gpio_set_cfgbank: bank_offset=119, val=1
  clrsetbits 0x1c20874, 0xf0000000, 0x10000000
sunxi_gpio_output: pin=0x77, val=0
  before: 0x1c2087c = 0x1c0000
  after: 0x1c2087c = 0x1c0000 (DMB)
```

TODO: dldo1 3.3V

```text
dldo1 3.3V
  pmic_write: reg=0x15, val=0x1a
  rsb_write: rt_addr=0x2d, reg_addr=0x15, value=0x1a
  pmic_clrsetbits: reg=0x12, clr_mask=0x0, set_mask=0x8
  rsb_read: rt_addr=0x2d, reg_addr=0x12
  rsb_write: rt_addr=0x2d, reg_addr=0x12, value=0xd9
```

TODO: ldo_io0 3.3V

```text
ldo_io0 3.3V
  pmic_write: reg=0x91, val=0x1a
  rsb_write: rt_addr=0x2d, reg_addr=0x91, value=0x1a
  pmic_write: reg=0x90, val=0x3
  rsb_write: rt_addr=0x2d, reg_addr=0x90, value=0x3
```

TODO: dldo2 1.8V

```text
dldo2 1.8V
  pmic_write: reg=0x16, val=0xb
  rsb_write: rt_addr=0x2d, reg_addr=0x16, value=0xb
  pmic_clrsetbits: reg=0x12, clr_mask=0x0, set_mask=0x10
  rsb_read: rt_addr=0x2d, reg_addr=0x12
  rsb_write: rt_addr=0x2d, reg_addr=0x12, value=0xd9
```

TODO: Wait

```text
wait for power supplies and power-on init
  udelay 15000
```

# Appendix: Reset LCD Panel

We captured the log from [__p-boot dsi_init__](https://megous.com/git/p-boot/tree/src/display.c#n1236)...

-   [__Log from dsi_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#panel_reset)

```text
panel_reset: start
deassert reset: GPD(23), 1  // PD23 - LCD-RST (active low)
sunxi_gpio_set_cfgpin: pin=0x77, val=1
sunxi_gpio_set_cfgbank: bank_offset=119, val=1
  clrsetbits 0x1c20874, 0xf0000000, 0x10000000
sunxi_gpio_output: pin=0x77, val=1
  before: 0x1c2087c = 0x1c0000
  after: 0x1c2087c = 0x9c0000 (DMB)
wait for initialization
udelay 15000
panel_reset: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#panel_reset)

Based on the above log, we have __implemented in Zig__ the PinePhone Driver that resets the LCD Panel...

-   [__pinephone-nuttx/panel.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/panel.zig)

-   [__Output Log for panel.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

# Appendix: Enable MIPI DSI Block

We captured the log from [__p-boot dsi_init__](https://megous.com/git/p-boot/tree/src/display.c#n1236)...

-   [__Log from dsi_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#enable_dsi_block)

```text
enable_dsi_block: start
mipi dsi bus enable
  setbits 0x1c20060, 0x2 (DMB)
  setbits 0x1c202c0, 0x2 (DMB)
Enable the DSI block
  0x1ca0000 = 0x1 (DMB)
  0x1ca0010 = 0x30000 (DMB)
  0x1ca0060 = 0xa (DMB)
  0x1ca0078 = 0x0 (DMB)
inst_init
  0x1ca0020 = 0x1f (DMB)
  0x1ca0024 = 0x10000001 (DMB)
  0x1ca0028 = 0x20000010 (DMB)
  0x1ca002c = 0x2000000f (DMB)
  0x1ca0030 = 0x30100001 (DMB)
  0x1ca0034 = 0x40000010 (DMB)
  0x1ca0038 = 0xf (DMB)
  0x1ca003c = 0x5000001f (DMB)
  0x1ca004c = 0x560001 (DMB)
  0x1ca02f8 = 0xff (DMB)
get_video_start_delay
  0x1ca0014 = 0x5bc7 (DMB)
setup_burst
  0x1ca007c = 0x10000007 (DMB)
setup_inst_loop
  0x1ca0040 = 0x30000002 (DMB)
  0x1ca0044 = 0x310031 (DMB)
  0x1ca0054 = 0x310031 (DMB)
setup_format
  0x1ca0090 = 0x1308703e (DMB)
  0x1ca0098 = 0xffff (DMB)
  0x1ca009c = 0xffffffff (DMB)
  0x1ca0080 = 0x10008 (DMB)
setup_timings
  0x1ca000c = 0x0 (DMB)
  0x1ca00b0 = 0x12000021 (DMB)
  0x1ca00b4 = 0x1000031 (DMB)
  0x1ca00b8 = 0x7000001 (DMB)
  0x1ca00bc = 0x14000011 (DMB)
  0x1ca0018 = 0x11000a (DMB)
  0x1ca001c = 0x5cd05a0 (DMB)
  0x1ca00c0 = 0x9004a19 (DMB)
  0x1ca00c4 = 0x50b40000 (DMB)
  0x1ca00c8 = 0x35005419 (DMB)
  0x1ca00cc = 0x757a0000 (DMB)
  0x1ca00d0 = 0x9004a19 (DMB)
  0x1ca00d4 = 0x50b40000 (DMB)
  0x1ca00e0 = 0xc091a19 (DMB)
  0x1ca00e4 = 0x72bd0000 (DMB)
  0x1ca00e8 = 0x1a000019 (DMB)
  0x1ca00ec = 0xffff0000 (DMB)
enable_dsi_block: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#enable_dsi_block)

Based on the above steps, we have __implemented in Zig__ the PinePhone Driver that enables the Allwinner A64 MIPI DSI Block...

-   [__pinephone-nuttx/display.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L884-L1007)

-   [__Output Log for display.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

TODO: Reverse Engineering

By decoding the captured addresses and values, we decipher the following steps to __enable the Allwinner A64 MIPI DSI Block__...

1.  Enable MIPI DSI Bus

    BUS_CLK_GATING_REG0: CCU Offset `0x60` (A64 Page 100)
    - Set MIPIDSI_GATING (Bit 1) to 1 (Pass Gating Clock for MIPI DSI)

    BUS_SOFT_RST_REG0: CCU Offset `0x2C0` (A64 Page 138)
    - Set MIPI_DSI_RST (Bit 1) to 1 (Deassert MIPI DSI Reset)

    CCU Base Address: `0x01C2` `0000` (A64 Page 82)

    ```text
    mipi dsi bus enable
    setbits 0x1c20060, 0x2 (DMB)
    setbits 0x1c202c0, 0x2 (DMB)
    ```

1.  Enable DSI Block

    DSI_CTL_REG: DSI Offset `0x0` (A31 Page 843)
    - Set DSI_En (Bit 0) to 1 (Enable DSI)

    DSI_BASIC_CTL0_REG: DSI Offset `0x10` (A31 Page 845)
    - Set CRC_En (Bit 17) to 1 (Enable CRC)
    - Set ECC_En (Bit 16) to 1 (Enable ECC)

    DSI_TRANS_START_REG: DSI Offset `0x60` (Undocumented)
    - Set to 10

    DSI_TRANS_ZERO_REG: DSI Offset `0x78` (Undocumented)
    - Set to 0

    DSI Base Address: `0x01CA` `0000` (A31 Page 842)

    ```text
    Enable the DSI block
    0x1ca0000 = 0x1 (DMB)
    0x1ca0010 = 0x30000 (DMB)
    0x1ca0060 = 0xa (DMB)
    0x1ca0078 = 0x0 (DMB)
    ```

1.  Set Instructions (Undocumented)

    DSI_INST_FUNC_REG(0): DSI Offset `0x20` (DSI_INST_ID_LP11)

    DSI_INST_FUNC_REG(1): DSI Offset `0x24` (DSI_INST_ID_TBA)

    DSI_INST_FUNC_REG(2): DSI Offset `0x28` (DSI_INST_ID_HSC)

    DSI_INST_FUNC_REG(3): DSI Offset `0x2c` (DSI_INST_ID_HSD)

    DSI_INST_FUNC_REG(4): DSI Offset `0x30` (DSI_INST_ID_LPDT)

    DSI_INST_FUNC_REG(5): DSI Offset `0x34` (DSI_INST_ID_HSCEXIT)

    DSI_INST_FUNC_REG(6): DSI Offset `0x38` (DSI_INST_ID_NOP)

    DSI_INST_FUNC_REG(7): DSI Offset `0x3c` (DSI_INST_ID_DLY)

    (DSI_INST_FUNC_REG(n) is `(0x020 + (n) * 0x04)`)

    ```text
    inst_init
    0x1ca0020 = 0x1f (DMB)
    0x1ca0024 = 0x10000001 (DMB)
    0x1ca0028 = 0x20000010 (DMB)
    0x1ca002c = 0x2000000f (DMB)
    0x1ca0030 = 0x30100001 (DMB)
    0x1ca0034 = 0x40000010 (DMB)
    0x1ca0038 = 0xf (DMB)
    0x1ca003c = 0x5000001f (DMB)
    ```

1.  Configure Jump Instructions (Undocumented)

    DSI_INST_JUMP_CFG_REG(0): DSI Offset 0x4c (DSI_INST_JUMP_CFG)

    (DSI_INST_JUMP_CFG_REG(n) is `(0x04c + (n) * 0x04)`)

    DSI_DEBUG_DATA_REG: Offset 0x2f8

    ```text
    0x1ca004c = 0x560001 (DMB)
    0x1ca02f8 = 0xff (DMB)
    ```

1.  Set Video Start Delay

    DSI_BASIC_CTL1_REG: DSI Offset `0x14` (A31 Page 846)
    - Set Video_Start_Delay (Bits 4 to 11) to 1468 (Line Delay)
    - Set Video_Precision_Mode_Align (Bit 2) to 1 (Fill Mode)
    - Set Video_Frame_Start (Bit 1) to 1 (Precision Mode)
    - Set DSI_Mode (Bit 0) to 1 (Video Mode)

    ```text
    get_video_start_delay
    0x1ca0014 = 0x5bc7 (DMB)
    ```

1.  Set Burst (Undocumented)

    DSI_TCON_DRQ_REG: DSI Offset 0x7c

    ```text
    setup_burst
    0x1ca007c = 0x10000007 (DMB)
    ```

1.  Set Instruction Loop (Undocumented)

    DSI_INST_LOOP_SEL_REG: DSI Offset 0x40

    DSI_INST_LOOP_NUM_REG(0): DSI Offset 0x44

    DSI_INST_LOOP_NUM_REG(1): DSI Offset 0x54

    (DSI_INST_LOOP_NUM_REG(n) is `(0x044 + (n) * 0x10)`)

    ```text
    setup_inst_loop
    0x1ca0040 = 0x30000002 (DMB)
    0x1ca0044 = 0x310031 (DMB)
    0x1ca0054 = 0x310031 (DMB)
    ```

1.  Set Pixel Format

    DSI_PIXEL_PH_REG: DSI Offset `0x90` (A31 Page 848)
    - Set ECC (Bits 24 to 31) to 19
    - Set WC (Bits 8 to 23) to 2160 (Byte Numbers of PD in a Pixel Packet)
    - Set VC (Bits 6 to 7) to 0 (Virtual Channel)
    - Set DT (Bits 0 to 5) to `0x3E` (24-bit Video Mode)

    DSI_PIXEL_PF0_REG: DSI Offset `0x98` (A31 Page 849)
    - Set CRC_Force (Bits 0 to 15) to `0xffff` (Force CRC to this value)

    DSI_PIXEL_PF1_REG: DSI Offset `0x9c` (A31 Page 849)
    - Set CRC_Init_LineN (Bits 16 to 31) to `0xffff` (CRC initial to this value in transmitions except 1st one)
    - Set CRC_Init_Line0 (Bits 0 to 15) to `0xffff` (CRC initial to this value in 1st transmition every frame)

    DSI_PIXEL_CTL0_REG: DSI Offset `0x80` (A31 Page 847)
    - Set PD_Plug_Dis (Bit 16) to 1 (Disable PD plug before pixel bytes)
    - Set Pixel_Endian (Bit 4) to 0 (LSB first)
    - Set Pixel_Format (Bits 0 to 3) to 8 (24-bit RGB888)

    ```text
    setup_format
    0x1ca0090 = 0x1308703e (DMB)
    0x1ca0098 = 0xffff (DMB)
    0x1ca009c = 0xffffffff (DMB)
    0x1ca0080 = 0x10008 (DMB)
    ```

1.  Set Sync Timings

    DSI_BASIC_CTL_REG: DSI Offset `0x0c` (Undocumented)

    DSI_SYNC_HSS_REG: DSI Offset `0xb0` (A31 Page 850)
    - Set ECC (Bits 24 to 31) to 0x12
    - Set D1 (Bits 16 to 23) to 0
    - Set D0 (Bits 8 to 15) to 0
    - Set VC (Bits 6 to 7) to 0 (Virtual Channel)
    - Set DT (Bits 0 to 5) to `0x21` (HSS)

    DSI_SYNC_HSE_REG: DSI Offset `0xb4` (A31 Page 850)
    - Set ECC (Bits 24 to 31) to 1
    - Set D1 (Bits 16 to 23) to 0
    - Set D0 (Bits 8 to 15) to 0
    - Set VC (Bits 6 to 7) to 0 (Virtual Channel)
    - Set DT (Bits 0 to 5) to `0x31` (HSE)

    DSI_SYNC_VSS_REG: DSI Offset `0xb8` (A31 Page 851)
    - Set ECC (Bits 24 to 31) to 7
    - Set D1 (Bits 16 to 23) to 0
    - Set D0 (Bits 8 to 15) to 0
    - Set VC (Bits 6 to 7) to 0 (Virtual Channel)
    - Set DT (Bits 0 to 5) to 1 (VSS)

    DSI_SYNC_VSE_REG: DSI Offset `0xbc` (A31 Page 851)
    - Set ECC (Bits 24 to 31) to `0x14`
    - Set D1 (Bits 16 to 23) to 0
    - Set D0 (Bits 8 to 15) to 0
    - Set VC (Bits 6 to 7) to 0 (Virtual Channel)
    - Set DT (Bits 0 to 5) to `0x11` (VSE)

    ```text
    setup_timings
    0x1ca000c = 0x0 (DMB)
    0x1ca00b0 = 0x12000021 (DMB)
    0x1ca00b4 = 0x1000031 (DMB)
    0x1ca00b8 = 0x7000001 (DMB)
    0x1ca00bc = 0x14000011 (DMB)
    ```

1.  Set Basic Size (Undocumented)

    DSI_BASIC_SIZE0_REG: DSI Offset `0x18`
    - Set Video_VBP (Bits 16 to 27) to 17
    - Set Video_VSA (Bits 0 to 11) to 10

    DSI_BASIC_SIZE1_REG: DSI Offset `0x1c`
    - Set Video_VT (Bits 16 to 28) to 1485
    - Set Video_VACT (Bits 0 to 11) to 1440

    ```text
    0x1ca0018 = 0x11000a (DMB)
    0x1ca001c = 0x5cd05a0 (DMB)
    ```

1.  Set Horizontal Blank Packets

    DSI_BLK_HSA0_REG: DSI Offset `0xc0` (A31 Page 852)
    - Set HSA_PH (Bits 0 to 31) to `0x900` `4a19`

    DSI_BLK_HSA1_REG: DSI Offset `0xc4` (A31 Page 852)
    - Set HSA_PF (Bits 16 to 31) to `0x50b4`
    - Set HSA_PD (Bits 0 to 7) to 0

    DSI_BLK_HBP0_REG: DSI Offset `0xc8` (A31 Page 852)
    - Set HBP_PH (Bits 0 to 31) to `0x3500` `5419`

    DSI_BLK_HBP1_REG: DSI Offset `0xcc` (A31 Page 852)
    - Set HBP_PF (Bits 16 to 31) to `0x757a`
    - Set HBP_PD (Bits 0 to 7) to 0

    DSI_BLK_HFP0_REG: DSI Offset `0xd0` (A31 Page 852)
    - Set HFP_PH (Bits 0 to 31) to `0x900` `4a19`

    DSI_BLK_HFP1_REG: DSI Offset `0xd4` (A31 Page 853)
    - Set HFP_PF (Bits 16 to 31) to `0x50b4`
    - Set HFP_PD (Bits 0 to 7) to 0

    DSI_BLK_HBLK0_REG: DSI Offset `0xe0` (A31 Page 853)
    - Set HBLK_PH (Bits 0 to 31) to `0xc09` `1a19`

    DSI_BLK_HBLK1_REG: DSI Offset `0xe4` (A31 Page 853)
    - Set HBLK_PF (Bits 16 to 31) to `0x72bd`
    - Set HBLK_PD (Bits 0 to 7) to 0

    ```text
    0x1ca00c0 = 0x9004a19 (DMB)
    0x1ca00c4 = 0x50b40000 (DMB)
    0x1ca00c8 = 0x35005419 (DMB)
    0x1ca00cc = 0x757a0000 (DMB)
    0x1ca00d0 = 0x9004a19 (DMB)
    0x1ca00d4 = 0x50b40000 (DMB)
    0x1ca00e0 = 0xc091a19 (DMB)
    0x1ca00e4 = 0x72bd0000 (DMB)
    ```

1.  Set Vertical Blank Packets

    DSI_BLK_VBLK0_REG: DSI Offset `0xe8` (A31 Page 854)
    - Set VBLK_PH (Bits 0 to 31) to `0x1a00` `0019`

    DSI_BLK_VBLK1_REG: DSI Offset `0xec` (A31 Page 854)
    - Set VBLK_PF (Bits 16 to 31) to `0xffff`
    - Set VBLK_PD (Bits 0 to 7) to 0

    ```text
    0x1ca00e8 = 0x1a000019 (DMB)
    0x1ca00ec = 0xffff0000 (DMB)
    ```

# Appendix: Start MIPI DSI HSC and HSD

We captured the log from [__p-boot dsi_init__](https://megous.com/git/p-boot/tree/src/display.c#n1236)...

-   [__Log from dsi_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#start_dsi)

```text
start_dsi: start
dsi_start DSI_START_HSC
  0x1ca0048 = 0xf02 (DMB)
dsi_update_bits: 0x01ca0010 : 00030000 -> (00000001) 00000001 (DMB)
  addr=0x1ca0010, mask=0x1, val=0x1 (DMB)
dsi_update_bits: 0x01ca0020 : 0000001f -> (00000010) 00000000 (DMB)
  addr=0x1ca0020, mask=0x10, val=0x0 (DMB)
udelay 1000
dsi_start DSI_START_HSD
  0x1ca0048 = 0x63f07006 (DMB)
dsi_update_bits: 0x01ca0010 : 00030000 -> (00000001) 00000001 (DMB)
  addr=0x1ca0010, mask=0x1, val=0x1 (DMB)
start_dsi: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#start_dsi)

Based on the above steps, we have __implemented in Zig__ the PinePhone Driver that starts Allwinner A64 MIPI DSI (in HSC and HSD Modes)...

-   [__pinephone-nuttx/display.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L1009-L1047)

-   [__Output Log for display.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

TODO: Reverse Engineering

By decoding the captured addresses and values, we decipher the following steps to __start Allwinner A64 MIPI DSI (in HSC and HSD Modes)__...

    TODO: DSI_START_HSC

    ```text
    DSI Base Address: 0x01CA0000 (A31 Page 842)

    DSI_INST_JUMP_SEL_REG: DSI Offset 0x48

    dsi_start DSI_START_HSC
    0x1ca0048 = 0xf02 (DMB)
    ```

    TODO: Commit

    ```text
    DSI_BASIC_CTL0_REG: DSI Offset 0x10 (A31 Page 845)
    - Set Instru_En (Bit 0) to 1 (Enable DSI Processing from Instruction 0)

    dsi_update_bits: 0x01ca0010 : 00030000 -> (00000001) 00000001 (DMB)
    addr=0x1ca0010, mask=0x1, val=0x1 (DMB)
    ```

    TODO: DSI_INST_FUNC_LANE_CEN

    ```text
    DSI_INST_FUNC_REG(n): (0x020 + (n) * 0x04)
    DSI_INST_FUNC_REG(0): DSI Offset 0x20 (DSI_INST_ID_LP11)
    - Set DSI_INST_FUNC_LANE_CEN (Bit 4) to 0

    dsi_update_bits: 0x01ca0020 : 0000001f -> (00000010) 00000000 (DMB)
    addr=0x1ca0020, mask=0x10, val=0x0 (DMB)
    ```

    TODO: Delay

    ```text
    udelay 1000
    ```

    TODO: DSI_START_HSD

    ```text
    DSI_INST_JUMP_SEL_REG: DSI Offset 0x48

    dsi_start DSI_START_HSD
    0x1ca0048 = 0x63f07006 (DMB)
    ```

    TODO: Commit

    ```text
    DSI_BASIC_CTL0_REG: DSI Offset 0x10 (A31 Page 845)
    - Set Instru_En (Bit 0) to 1 (Enable DSI Processing from Instruction 0)

    dsi_update_bits: 0x01ca0010 : 00030000 -> (00000001) 00000001 (DMB)
    addr=0x1ca0010, mask=0x1, val=0x1 (DMB)
    ```

# Appendix: Enable MIPI Display Physical Layer (DPHY)

We captured the log from [__p-boot dphy_enable__](https://megous.com/git/p-boot/tree/src/display.c#n331)...

-   [__Log from dphy_enable__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#dphy_enable)

```text
dphy_enable: start
150MHz (600 / 4)
  0x1c20168 = 0x8203 (DMB)
  0x1ca1004 = 0x10000000 (DMB)
  0x1ca1010 = 0xa06000e (DMB)
  0x1ca1014 = 0xa033207 (DMB)
  0x1ca1018 = 0x1e (DMB)
  0x1ca101c = 0x0 (DMB)
  0x1ca1020 = 0x303 (DMB)
  0x1ca1000 = 0x31 (DMB)
  0x1ca104c = 0x9f007f00 (DMB)
  0x1ca1050 = 0x17000000 (DMB)
  0x1ca105c = 0x1f01555 (DMB)
  0x1ca1054 = 0x2 (DMB)
  udelay 5
  0x1ca1058 = 0x3040000 (DMB)
  udelay 1
  update_bits addr=0x1ca1058, mask=0xf8000000, val=0xf8000000 (DMB)
  udelay 1
  update_bits addr=0x1ca1058, mask=0x4000000, val=0x4000000 (DMB)
  udelay 1
  update_bits addr=0x1ca1054, mask=0x10, val=0x10 (DMB)
  udelay 1
  update_bits addr=0x1ca1050, mask=0x80000000, val=0x80000000 (DMB)
  update_bits addr=0x1ca1054, mask=0xf000000, val=0xf000000 (DMB)
dphy_enable: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#dphy_enable)

Based on the above log, we have __implemented in Zig__ the PinePhone Driver that enables the Allwinner A64 MIPI Display Physical Layer (DPHY)...

-   [__pinephone-nuttx/dphy.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/dphy.zig)

-   [__Output Log for dphy.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

TODO: Reverse Engineering

```text
CCU Base Address: 0x01C20000 (A64 Page 82)
MIPI_DSI_CLK_REG: Offset 0x168 (A64 Page 122)

150MHz (600 / 4)
  0x1c20168 = 0x8203 (DMB)
```

TODO: DPHY Tx Power On

```text
DPHY Base Address: 0x01ca1000
DPHY_TX_CTL_REG: Offset 0x04
DPHY_TX_TIME0_REG: Offset 0x10
DPHY_TX_TIME1_REG: Offset 0x14
DPHY_TX_TIME2_REG: Offset 0x18
DPHY_TX_TIME3_REG: Offset 0x1c
DPHY_TX_TIME4_REG: Offset 0x20

  0x1ca1004 = 0x10000000 (DMB)
  0x1ca1010 = 0xa06000e (DMB)
  0x1ca1014 = 0xa033207 (DMB)
  0x1ca1018 = 0x1e (DMB)
  0x1ca101c = 0x0 (DMB)
  0x1ca1020 = 0x303 (DMB)
```

TODO

```text
DPHY_GCTL_REG: Offset 0x00 (Enable DPHY)
DPHY_ANA0_REG: Offset 0x4c (PWS)
DPHY_ANA1_REG: Offset 0x50 (CSMPS)
DPHY_ANA4_REG: Offset 0x5c (CKDV)

  0x1ca1000 = 0x31 (DMB)
  0x1ca104c = 0x9f007f00 (DMB)
  0x1ca1050 = 0x17000000 (DMB)
  0x1ca105c = 0x1f01555 (DMB)
```

TODO

```text
DPHY_ANA2_REG: Offset 0x54 (ENIB)
DPHY_ANA3_REG: Offset 0x58 (Enable LDOR, LDOC, LDOD)
DPHY_ANA3_REG: Offset 0x58 (Enable VTTC, VTTD)
DPHY_ANA3_REG: Offset 0x58 (Enable DIV)
DPHY_ANA2_REG: Offset 0x54 (Enable CK_CPU)
DPHY_ANA1_REG: Offset 0x50 (VTT Mode)
DPHY_ANA2_REG: Offset 0x54 (Enable P2S CPU)

  0x1ca1054 = 0x2 (DMB)
  udelay 5
  0x1ca1058 = 0x3040000 (DMB)
  udelay 1
  update_bits addr=0x1ca1058, mask=0xf8000000, val=0xf8000000 (DMB)
  udelay 1
  update_bits addr=0x1ca1058, mask=0x4000000, val=0x4000000 (DMB)
  udelay 1
  update_bits addr=0x1ca1054, mask=0x10, val=0x10 (DMB)
  udelay 1
  update_bits addr=0x1ca1050, mask=0x80000000, val=0x80000000 (DMB)
  update_bits addr=0x1ca1054, mask=0xf000000, val=0xf000000 (DMB)
```

# Appendix: Timing Controller (TCON0)

We captured the log from [__p-boot tcon0_init__](https://megous.com/git/p-boot/tree/src/display.c#n1567)...

-   [__Log from tcon0_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#tcon0_init)

```text
tcon0_init: start
PLL_VIDEO0
  0x1c20010 = 0x81006207 (DMB)
PLL_MIPI
  0x1c20040 = 0xc00000 (DMB)
  udelay 100
  0x1c20040 = 0x80c0071a (DMB)
TCON0 source MIPI_PLL
  0x1c20118 = 0x80000000 (DMB)
Clock on
  0x1c20064 = 0x8 (DMB)
Reset off
  0x1c202c4 = 0x8 (DMB)
Init lcdc: Disable tcon, Disable all interrupts
  0x1c0c000 = 0x0 (DMB)
  0x1c0c004 = 0x0
  0x1c0c008 = 0x0
Set all io lines to tristate
  0x1c0c08c = 0xffffffff
  0x1c0c0f4 = 0xffffffff
mode set: DCLK = MIPI_PLL / 6
  0x1c0c044 = 0x80000006
  0x1c0c040 = 0x81000000
  0x1c0c048 = 0x2cf059f
  0x1c0c0f8 = 0x8
  0x1c0c060 = 0x10010005
The datasheet says that this should be set higher than 20 * pixel cycle, but it's not clear what a pixel cycle is.
  0x1c0c160 = 0x2f02cf
  0x1c0c164 = 0x59f
  0x1c0c168 = 0x1bc2000a
The Allwinner BSP has a comment that the period should be the display clock * 15, but uses an hardcoded 3000
  0x1c0c1f0 = 0xbb80003
Enable the output on the pins
  0x1c0c08c = 0xe0000000 (DMB)
enable tcon as a whole
  setbits 0x1c0c000, 0x80000000 (DMB)
tcon0_init: end
```

[(Source)](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#tcon0_init)

Based on the above log, we have __implemented in Zig__ the PinePhone Driver for Allwinner A64 Timing Controller (TCON0)...

-   [__pinephone-nuttx/tcon.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/tcon.zig)

-   [__Output Log for tcon.zig__](https://github.com/lupyuen/pinephone-nuttx#testing-zig-backlight-driver-on-pinephone)

TODO: Reverse Engineering

TODO: Configure PLL_VIDEO0

```text
CCU Base Address: 0x01C20000 (A64 Page 82)
PLL_VIDEO0_CTRL_REG: Offset 0x10 (A64 Page 86)
- Set PLL_ENABLE (Bit 31) to 1 (Enable PLL)
- Set PLL_MODE (Bit 30) to 0 (Manual Mode)
- Set LOCK (Bit 28) to 0 (Unlocked)
- Set FRAC_CLK_OUT (Bit 25) to 0
- Set PLL_MODE_SEL (Bit 24) to 1 (Integer Mode)
- Set PLL_SDM_EN (Bit 20) to 0 (Disable)
- Set PLL_FACTOR_N (Bits 8 to 14) to 0x62 (PLL Factor N)
- Set PLL_PREDIV_M (Bits 0 to 3) to 7 (PLL Pre Divider)

PLL_VIDEO0
  0x1c20010 = 0x81006207 (DMB)
```

TODO: Enable LDO1 and LDO2

```text
PLL_MIPI_CTRL_REG: Offset 0x40 (A64 Page 94)
- Set LDO1_EN (Bit 23) to 1 (Enable On-chip LDO1)
- Set LDO2_EN (Bit 22) to 1 (Enable On-chip LDO2)

PLL_MIPI
  0x1c20040 = 0xc00000 (DMB)
  udelay 100
```

TODO: Configure PLL_MIPI

```text
PLL_MIPI_CTRL_REG: Offset 0x40 (A64 Page 94)
- Set PLL_ENABLE (Bit 31) to 1 (Enable MIPI PLL)
- Set LOCK (Bit 28) to 0 (Unlocked)
- Set SINT_FRAC (Bit 27) to 0 (Integer Mode)
- Set SDIV2 (Bit 26) to 0 (PLL Output)
- Set S6P25_7P5 (Bit 25) to 0 (PLL Output=PLL Input*6.25)
- Set LDO1_EN (Bit 23) to 1 (Enable On-chip LDO1)
- Set LDO2_EN (Bit 22) to 1 (Enable On-chip LDO2)
- Set PLL_SRC (Bit 21) to 0 (PLL Source is VIDEO0 PLL)
- Set PLL_SDM_EN (Bit 20) to 0 (Disable SDM PLL)
- Set PLL_FEEDBACK_DIV (Bit 17) to 0 (PLL Feedback Divider Control: Divide by 5)
- Set VFB_SEL (Bit 16) to 0 (MIPI Mode)
- Set PLL_FACTOR_N (Bits 8 to 11) to 7 (PLL Factor N)
- Set PLL_FACTOR_K (Bits 4 to 5) to 1 (PLL Factor K)
- Set PLL_PRE_DIV_M (Bits 0 to 3) to 10 (PLL Pre Divider)

  0x1c20040 = 0x80c0071a (DMB)
```

TODO: TCON0 source MIPI_PLL

```text
TCON0_CLK_REG: Offset 0x118 (A64 Page 117)
- Set SCLK_GATING (Bit 31) to 1 (Special Clock is On)
- Set CLK_SRC_SEL (Bits 24 to 26) to 0 (Clock Source is PLL_MIPI)

TCON0 source MIPI_PLL
  0x1c20118 = 0x80000000 (DMB)
```

TODO: Clock on

```text
BUS_CLK_GATING_REG1: Offset 0x64 (A64 Page 102)
- Set TCON0_GATING (Bit 3) to 1 (Pass Clock for TCON0)

Clock on
  0x1c20064 = 0x8 (DMB)
```

TODO: Reset off

```text
BUS_SOFT_RST_REG1: Offset 0x2c4 (A64 Page 140)
- Set TCON0_RST (Bit 3) to 1 (Deassert TCON0 Reset)

Reset off
  0x1c202c4 = 0x8 (DMB)
```

TODO: Init lcdc

```text
TCON0 Base Address: 0x01C0C000 (A64 Page 507)

TCON_GCTL_REG: Offset 0x00 (A64 Page 508)
- Set TCON_En (Bit 31) to 0 (Disable TCON0)

TCON_GINT0_REG: Offset 0x04 (A64 Page 509)
- Set to 0 (Disable TCON0 Interrupts)

TCON_GINT1_REG: Offset 0x08 (A64 Page 510)
- Set to 0 (Disable TCON0 Interrupts)

Init lcdc: Disable tcon, Disable all interrupts
  0x1c0c000 = 0x0 (DMB)
  0x1c0c004 = 0x0
  0x1c0c008 = 0x0
```

TODO: Set all io lines to tristate

```text
TCON0_IO_TRI_REG: Offset 0x8c (A64 Page 520)
- Set to 0xffffffff to Enable TCON0 Output Tristate

TCON1_IO_TRI_REG: Offset 0xf4 (Undocumented?)
- Set to 0xffffffff to Enable TCON1 Output Tristate

Set all io lines to tristate
  0x1c0c08c = 0xffffffff
  0x1c0c0f4 = 0xffffffff
```

TODO: mode set

```text
TCON0_DCLK_REG: Offset 0x44 (A64 Page 513)
- Set TCON0_Dclk_En (Bits 28 to 31) to 8 (Enable TCON0 Clock: dclk_en = 1; dclk1_en = 1; dclk2_en = 0; dclkm2_en = 0)
- Set TCON0_Dclk_Div (Bits 0 to 6) to 6 (DCLK Divisor)

TCON0_CTL_REG: Offset 0x40 (A64 Page 512)
- Set TCON0_En (Bit 31) to 1 (Enable TCON0)
- Set TCON0_Work_Mode (Bit 28) to 0 (Normal Work Mode)
- Set TCON0_IF (Bits 24 to 25) to 1 (8080 Interface)
- Set TCON0_RB_Swap (Bit 23) to 0 (No Red/Blue Swap)
- Set TCON0_FIFO1_Rst (Bit 21) to 0 (No FIFO1 Reset)
- Set TCON0_Start_Delay (Bits 4 to 8) to 0 (No STA Delay)
- Set TCON0_SRC_SEL (Bits 0 to 2) to 0 (TCON0 Source is DE0)

TCON0_BASIC0_REG: Offset 0x48 (A64 Page 514)
- Set TCON0_X (Bits 16 to 27) to 719 (Panel Width - 1)
- Set TCON0_Y (Bits 0 to 11) to 1439 (Panel Height - 1)

ECC_FIFO: Offset 0xf8 (Undocumented)

TCON0_CPU_IF_REG: Offset 0x60 (A64 Page 516)
- Set CPU_Mode (Bits 28 to 31) to 1 (24-bit DSI)
- Set AUTO (Bit 17) to 0 (Disable Auto Transfer Mode)
- Set FLUSH (Bit 16) to 1 (Enable Direct Transfer Mode)
- Set Trigger_FIFO_Bist_En (Bit 3) to 0 (Disable FIFO Bist Trigger)
- Set Trigger_FIFO_En (Bit 2) to 1 (Enable FIFO Trigger)
- Set Trigger_En (Bit 0) to 1 (Enable Trigger Mode)

mode set: DCLK = MIPI_PLL / 6
  0x1c0c044 = 0x80000006
  0x1c0c040 = 0x81000000
  0x1c0c048 = 0x2cf059f
  0x1c0c0f8 = 0x8
  0x1c0c060 = 0x10010005
```

TODO: Set pixel cycle

```text
TCON0_CPU_TRI0_REG: Offset 0x160 (A64 Page 521)
- Set Block_Space (Bits 16 to 27) to 47 (Block Space)
- Set Block_Size (Bits 0 to 11) to 719 (Panel Width - 1)

TCON0_CPU_TRI1_REG: Offset 0x164 (A64 Page 522)
- Set Block_Current_Num (Bits 16 to 31) to 0 (Block Current Number)
- Set Block_Num (Bits 0 to 15) to 1439 (Panel Height - 1)

TCON0_CPU_TRI2_REG: Offset 0x168 (A64 Page 522)
- Set Start_Delay (Bits 16 to 31) to 7106 (Start Delay)
- Set Trans_Start_Mode (Bit 15) to 0 (Trans Start Mode is ECC FIFO + TRI FIFO)
- Set Sync_Mode (Bits 13 to 14) to 0 (Sync Mode is Auto)
- Set Trans_Start_Set (Bits 0 to 12) to 10 (Trans Start Set)

The datasheet says that this should be set higher than 20 * pixel cycle, but it's not clear what a pixel cycle is.
  0x1c0c160 = 0x2f02cf
  0x1c0c164 = 0x59f
  0x1c0c168 = 0x1bc2000a
```

TODO: Set period

```text
TCON_SAFE_PERIOD_REG: Offset 0x1f0 (A64 Page 525)
- Set Safe_Period_FIFO_Num (Bits 16 to 28) to 3000
- Set Safe_Period_Line (Bits 4 to 15) to 0
- Set Safe_Period_Mode (Bits 0 to 2) to 3 (Safe Period Mode: Safe at 2 and safe at sync active)

The Allwinner BSP has a comment that the period should be the display clock * 15, but uses an hardcoded 3000
  0x1c0c1f0 = 0xbb80003
```

TODO: Enable output

```text
TCON0_IO_TRI_REG: Offset 0x8c (A64 Page 520)
- Set Reserved (Bits 29 to 31) to 0b111
- Set RGB_Endian (Bit 28) to 0 (Normal RGB Endian)
- Set IO3_Output_Tri_En (Bit 27) to 0 (Enable IO3 Output Tri)
- Set IO2_Output_Tri_En (Bit 26) to 0 (Enable IO2 Output Tri)
- Set IO1_Output_Tri_En (Bit 25) to 0 (Enable IO1 Output Tri)
- Set IO0_Output_Tri_En (Bit 24) to 0 (Enable IO0 Output Tri)
- Set Data_Output_Tri_En (Bits 0 to 23) to 0 (Enable TCON0 Output Port)

Enable the output on the pins
  0x1c0c08c = 0xe0000000 (DMB)
```

TODO: Enable TCON

```text
TCON_GCTL_REG: Offset 0x00 (A64 Page 508)
- Set TCON_En (Bit 31) to 1 (Enable TCON0)

enable tcon as a whole
  setbits 0x1c0c000, 0x80000000 (DMB)
```
