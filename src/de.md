# Rendering PinePhone's Display (DE and TCON0)

ðŸ“ _30 Oct 2022_

![PinePhone rendering Mandelbrot Set on Apache NuttX RTOS](https://lupyuen.github.io/images/de-title.jpg)

_PinePhone rendering Mandelbrot Set on Apache NuttX RTOS_

In the last 2 articles we talked about [__Pine64 PinePhone__](https://wiki.pine64.org/index.php/PinePhone) (pic above) and how we built a __Display Driver__ for PinePhone's MIPI Display Serial Interface...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

But our PinePhone Display Driver __isn't complete__... It won't render any graphics!

Today we'll learn about the missing bits in our Display Driver...

-   What's the __Display Engine (DE)__ inside PinePhone

-   How the __Timing Controller (TCON0)__ controls PinePhone's LCD Display

-   How we call DE and TCON0 to __render graphics__

-   How our new __PinePhone Display Driver__ will support DE and TCON0

_Why are we doing this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone and we have created a (barebones) [__Display Driver in Zig__](https://lupyuen.github.io/articles/dsi2) that initialises the LCD Display.

To finish the driver, we need to understand what's inside PinePhone's Display Engine and Timing Controller.

Let's dive in and continue the journey from our (super long) __NuttX Porting Journal__...

-   [__lupyuen/pinephone-nuttx__](https://github.com/lupyuen/pinephone-nuttx)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Display Rendering on PinePhone

_Suppose we're building our own Operating System for PinePhone..._

_How do we render graphics on the LCD Display?_

Rendering graphics directly to PinePhone Hardware ("Bare Metal") is more complicated than we expect!

Let's walk through the steps (pic above)...

1.  Inside PinePhone's [__Allwinner A64 SoC__](https://linux-sunxi.org/A64) is a __Display Engine__ that combines and transforms Pixel Data for display

1.  The Display Engine reads the Pixel Data from __Framebuffers in RAM__ via __Direct Memory Access (DMA)__

    (Up to 3 Framebuffers)

1.  Inside the Display Engine is a __Real-Time Mixer__ (RT Mixer Core 0) that handles real-time __DMA, Overlay, Scaling and Blending__ of the Pixel Data (from the Framebuffers)

    (We won't need RT Mixer Core 1 today, it's a smaller version of Core 0)

1.  The Real-Time Mixer supports __3 UI Channels__ (for graphics), all mixed together into a __Single Image Frame__ in real time

    (The Mixer supports Video, but we won't use it today)

1.  The successive Image Frames (generated by the Display Engine) are pumped in real time to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0)

1.  The Timing Controller pushes the Image Frames to __PinePhone's LCD Controller__ as a stream of pixels (over MIPI Display Serial Interface)

All this happens in __Real Time__... Any updates to the Framebuffers in RAM are __pushed out instantly__ to the LCD Display.

(Super efficiently thanks to DMA!)

_Why so complicated?_

PinePhone's ST7703 LCD Controller __doesn't have any RAM__ inside...

-   [__"Sitronix ST7703 LCD Controller"__](https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller)

That's why we need to __pump a constant stream of pixels__ to the LCD Display via DMA, Display Engine and Timing Controller... Otherwise the display stays blank!

[(Sounds a bit like the Amiga Video Toaster)](https://en.wikipedia.org/wiki/Video_Toaster)

Let's look inside the Display Engine...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

# Display Engine in Allwinner A64

Recall that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display.

The pic above shows how the Display Engine mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3.

(Plus a Video Channel on DMA0, but we won't use it today)

_Is the Display Engine documented?_

The official doc for the A64 Display Engine is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

Though it doesn't describe the actual steps for programming the Display Engine.

In a while we'll boot [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) on PinePhone and experiment with the Display Engine, to understand it better.

[(Overview of A64 Display Engine)](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But the Display Engine doc doesn't mention A64?_

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with 64-bit Arm Cores...

> "The A64 is basically an Allwinner H3 with the Cortex-A7 cores replaced with Cortex-A53 cores (ARM64 architecture). They share most of the memory map, clocks, interrupts and also uses the same IP blocks."

> [(Source)](https://linux-sunxi.org/A64)

_Why are there 2 Mixers in the A64 Display Engine?_

Maybe because A64 (or H3) was designed for [__OTT Set-Top Boxes__](https://linux-sunxi.org/H3) with Picture-In-Picture Overlay Video?

The 3 UI Overlay Channels would be super helpful for overlaying an OTT Graphical UI on top of a Video Channel.

[(Wait... Wasn't Pine64 created thanks to OTT Boxes? ðŸ¤”)](https://en.wikipedia.org/wiki/Pine64#History)

![Rendering simple Colour Blocks on the PinePhone Display](https://lupyuen.github.io/images/de-code1a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

# Render Colours

_How do we program the A64 Display Engine to render graphics?_

Let's begin by rendering simple __Colour Blocks__ on the PinePhone Display...

![Blue, Green, Red Blocks on PinePhone](https://lupyuen.github.io/images/de-rgb.jpg)

First we __allocate the Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

[(PinePhone's display resolution is 720 x 1440)](https://en.wikipedia.org/wiki/PinePhone)

Each Pixel occupies __4 bytes__. (ARGB 8888 Format)

Then we __fill the Framebuffer__ with Blue, Green and Red: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L201-L214)

```c
// Fill with Blue, Green and Red
for (int i = 0; i < fb0_len; i++) {
  // Colours are in ARGB format
  if (i < fb0_len / 4) {
    // Blue for top quarter
    fb0[i] = 0x80000080;
  } else if (i < fb0_len / 2) {
    // Green for next quarter
    fb0[i] = 0x80008000;
  } else {
    // Red for lower half
    fb0[i] = 0x80800000;
  }
}
```

Each Pixel in the Framebuffer is stored as __32-bit ARGB 8888__.

Thus __`0x8000` `8000`__ means Semi-Transparent Green...

| Channel | Value |
|:--------|-------|
| Alpha | `0x80` |
| Red   | `0x00` |
| Green | `0x80` |
| Blue  | `0x00` |

A64 Display Engine lets us render 3 Framebuffers as __3 UI Channels__.

This is how we allocate the 3 UI Channels: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L262)

```c
// Allocate 3 UI Channels
static struct display disp;
memset(&disp, 0, sizeof(disp));
struct display *d = &disp;
```

[(__`display`__ struct is defined here)](https://megous.com/git/p-boot/tree/src/display.h#n28)

We point the __First UI Channel__ to our Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L262-L271)

```c
// Init UI Channel 1: (Base Channel)
// Fullscreen 720 x 1440
d->planes[0].fb_start = (uintptr_t) fb0;  // Framebuffer Address
d->planes[0].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[0].src_w    = 720;   // Source Width
d->planes[0].src_h    = 1440;  // Source Height
d->planes[0].dst_w    = 720;   // Dest Width
d->planes[0].dst_h    = 1440;  // Dest Height
```

(__`fb_pitch`__ is the number of bytes per row of pixels)

We disable the __Second and Third UI Channels__ for now: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L299)

```c
// Init UI Channel 2: (First Overlay)
// Disable Channel for now
d->planes[1].fb_start = 0;

// Init UI Channel 3: (Second Overlay)
// Disable Channel for now
d->planes[2].fb_start = 0;

// Render the UI Channels over DMA
display_commit(d);
```

And we __render the 3 UI Channels__.

([__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) is defined in the p-boot Display Code, we'll come back to this)

That's all! We should see the [__Blue, Green and Red Blocks__](https://lupyuen.github.io/images/de-rgb.jpg) like in the pic above.

(Not sure why there are black lines, needs investigation)

_Didn't we set the Alpha Channel to `0x80`?_

__UI Channel 1__ is the Base UI Channel, so the Alpha Channel has no effect.

(Actually UI Channel 1 is configured as [__XRGB 8888__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine))

In a while we'll set the Alpha Channels for UI Channels 2 and 3. And the UI Channels will appear as semi-transparent overlays.

![Rendering Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-code3a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

# Render Mandelbrot Set

_Colour Blocks are so blah. Are we sure we can render every single pixel correctly?_

Let's render something infinitely more detailed and sophisticated... [__Mandelbrot Set__](https://en.wikipedia.org/wiki/Mandelbrot_set)!

![Mandelbrot Set on PinePhone](https://lupyuen.github.io/images/de-title.jpg)

Earlier we created a __Fullscreen Framebuffer__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L170-L175)

```c
// Init Framebuffer 0:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb0_len is 720 * 1440
static uint32_t fb0[720 * 1440];
int fb0_len = sizeof(fb0) / sizeof(fb0[0]);
```

Now we fill the Framebuffer with the __Mandelbrot Set__, pixel by pixel: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L175-L200)

```c
// Fill with Mandelbrot Set.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Convert Pixel Coordinates to a Complex Number
    float cx = x_start + (y / 1440.0) * (x_end - x_start);
    float cy = y_start + (x / 720.0)  * (y_end - y_start);

    // Compute Manelbrot Set
    int m = mandelbrot(cx, cy);

    // Color depends on the number of iterations.
    // MAX_ITER is 80
    uint8_t hue = 255.0 * m / MAX_ITER;
    uint8_t saturation = 255;
    uint8_t value = (m < MAX_ITER) ? 255 : 0;

    // Convert Hue / Saturation / Value to RGB
    uint32_t rgb = hsvToRgb(hue, saturation, value);

    // Set the Pixel Colour (ARGB Format)
    int p = (y * 720) + x;
    assert(p < fb0_len);
    fb0[p] = 0x80000000 | rgb;
  }
}
```

[(__`mandelbrot`__ and __`hsvToRgb`__ are defined here)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L335-L432)

Then we initialise the __3 UI Channels__ and render them. [(Like this)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L299)

The [__Mandelbrot Set__](https://lupyuen.github.io/images/de-title.jpg) appears on PinePhone, like in the pic above.

Yep we can render every single pixel precisely on PinePhone!

![Animating the Madelbrot Set](https://lupyuen.github.io/images/de-code4a.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L299-L334)

# Animate Madelbrot Set

_Earlier we said that updates to the Framebuffer are instantly pushed to PinePhone's Display via DMA..._

_Can we prove it?_

Yep let's __animate the Mandelbrot Set__ in our Framebuffer. And watch the updates appear instantly on PinePhone's Display, thanks to __Direct Memory Access (DMA)__!

This is how we animate the Mandelbrot Set: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L257-L334)

```c
// Omitted: Init UI Channels 1, 2 and 3
d->planes[0].fb_start = ...
d->planes[1].fb_start = ...
d->planes[2].fb_start = ...
...

// Render the UI Channels over DMA
display_commit(d);

// Animate the Mandelbrot Set forever.
// For every frame of animation...
for (;;) {

  // Fill with Mandelbrot Set.
  // For every pixel row...
  for (int y = 0; y < 1440; y++) {

    // For every pixel column...
    for (int x = 0; x < 720; x++) {
```

In the code above, we __repeatly render__ the Mandelbrot Set for every frame of animation.

We __render each frame__ the exact same way as before...

```c
      // Convert Pixel Coordinates to a Complex Number
      float cx = x_start + (y / 1440.0) * (x_end - x_start);
      float cy = y_start + (x / 720.0)  * (y_end - y_start);

      // Compute Manelbrot Set
      int m = mandelbrot(cx, cy);

      // Color depends on the number of iterations
      // MAX_ITER is 80
      uint8_t hue = 255.0 * m / MAX_ITER;
      uint8_t saturation = 255;
      uint8_t value = (m < MAX_ITER) ? 255 : 0;

      // Convert Hue / Saturation / Value to RGB
      uint32_t rgb = hsvToRgb(hue, saturation, value);

      // Set the Pixel Colour (ARGB Format)
      int p = (y * 720) + x;
      assert(p < fb0_len);
      fb0[p] = 0x80000000 | rgb;
    }
  }
```

But now we __tweak slightly the position__ of the Mandelbrot Set...

```c
  // Zoom in to (-1.4, 0)
  float x_dest = -1.4;
  float y_dest = 0;
  x_start += (x_dest - x_start) * 0.05;
  x_end   -= (x_end  - x_dest)  * 0.05;
  y_start += (y_dest - y_start) * 0.05;
  y_end   -= (y_end  - y_dest)  * 0.05;
}
```

Before looping back to render the next frame.

We should see this Animated Mandelbrot Set...

-   [__Demo Video on YouTube__](https://youtu.be/toC9iiPRwRI)

Thus DMA works correctly for rendering our Framebuffers on the fly!

_We don't call `display_commit` after every frame?_

[__`display_commit`__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L296-L299) only needs to be called once. It configures the Display Engine to read our Framebuffer directly via DMA.

Subsequent updates to the Framebuffer will be automatically pushed to the display over DMA.

![Rendering a Square Overlay on PinePhone](https://lupyuen.github.io/images/de-code5b.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

# Render Square Overlay

_Earlier we said that A64 Display Engine can render Framebuffers as Overlays. How can we do it?_

The pic below shows that A64 Display Engine can render __3 Framebuffers (UI Channels)__ as overlays, via DMA1, 2 and 3...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

(Skipping DMA0 because it's for Video only)

The UI Channels are rendered as overlays in a specific sequence (pic above)...

-   __UI Channel 2__ (DMA2) is rendered on top of __UI Channel 1__ (DMA1), then...

-   __UI Channel 3__ (DMA3) is rendered on top of __UI Channel 2__ (DMA2)

Our Mandelbrot Set is rendered on __UI Channel 1__ (DMA1), which is the Base Channel.

Let's overlay a __Blue Square__ on __UI Channel 2__ (DMA2).

First we prepare a __600 x 600 Framebuffer__ that contains a Semi-Transparent Blue Square: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L215-L226)

```c
// Init Framebuffer 1:
// Square 600 x 600 (4 bytes per ARGB pixel)
// fb1_len is 600 * 600
static uint32_t fb1[600 * 600];
int fb1_len = sizeof(fb1) / sizeof(fb1[0]);

// Fill with Semi-Transparent Blue
for (int i = 0; i < fb1_len; i++) {
  // Colours are in ARGB format
  fb1[i] = 0x80000080;
}
```

The new Framebuffer is a little __smaller than the Screen Width__. (600 pixels vs 720 pixels)

Thanks to __Framebuffer Blending__ in A64 Display Engine, it's perfectly OK to render the new Framebuffer at 600 x 600. (As a partial screen region).

This is how we set __UI Channel 2__ to the 600 x 600 Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L271-L283)

```c
// Init UI Channel 2: (First Overlay)
// Square 600 x 600
d->planes[1].fb_start = (uintptr_t) fb1;  // Framebuffer Address
d->planes[1].fb_pitch = 600 * 4;  // Framebuffer Pitch
d->planes[1].src_w    = 600;  // Source Width
d->planes[1].src_h    = 600;  // Source Height
d->planes[1].dst_w    = 600;  // Dest Width
d->planes[1].dst_h    = 600;  // Dest Height
d->planes[1].dst_x    = 52;   // Dest X Offset
d->planes[1].dst_y    = 52;   // Dest Y Offset
```

_Can the Dest Width / Height be different from the Source Width / Height?_

Yes, because the Display Engine supports Scaling. But we won't do that today, to simplify our discussion.

Before we watch the outcome, let's render another overlay...

![Rendering a Circle Overlay on PinePhone](https://lupyuen.github.io/images/de-code5c.png)

[(Source)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

# Render Circle Overlay

Our PinePhone UI Overlay Sandwich has these goodies inside...

-   __UI Channel 1__: Mandelbrot Set (Base Channel)

-   __UI Channel 2__: Semi-Transparent Blue Square

Let's top off our Cucumber Sandwich...

-   __UI Channel 3__: Semi-Transparent Green Circle

First we fill a Fullscreen Framebuffer with a __Semi-Transparent Green Circle__: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L226-L251)

```c
// Init Framebuffer 2:
// Fullscreen 720 x 1440 (4 bytes per ARGB pixel)
// fb2_len is 720 * 1440
static uint32_t fb2[720 * 1440];
int fb2_len = sizeof(fb2) / sizeof(fb2[0]);

// Fill with Semi-Transparent Green Circle.
// For every pixel row...
for (int y = 0; y < 1440; y++) {

  // For every pixel column...
  for (int x = 0; x < 720; x++) {

    // Get pixel index
    int p = (y * 720) + x;
    assert(p < fb2_len);

    // Shift coordinates so that centre of screen is (0,0)
    int x_shift = x - 360;
    int y_shift = y - 720;

    // If pixel is inside circle (x^2 + y^2 < radius^2)...
    // Set the pixel to Semi-Transparent Green
    if (x_shift*x_shift + y_shift*y_shift < 360*360) {
      fb2[p] = 0x80008000;  // Semi-Transparent Green in ARGB Format
    } else {  // Otherwise set to Transparent Black
      fb2[p] = 0x00000000;  // Transparent Black in ARGB Format
    }
  }
}
```

Note that pixels outside the circle are set to __Transparent Black__.

(Which makes them invisible)

Next we point __UI Channel 3__ to the Fullscreen Framebuffer: [test_display.c](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L283-L296)

```c
// Init UI Channel 3: (Second Overlay)
// Fullscreen 720 x 1440 with Alpha Blending
d->planes[2].fb_start = (uintptr_t) fb2;  // Framebuffer Address
d->planes[2].fb_pitch = 720 * 4;  // Framebuffer Pitch
d->planes[2].src_w    = 720;   // Source Width
d->planes[2].src_h    = 1440;  // Source Height
d->planes[2].dst_w    = 720;   // Dest Width
d->planes[2].dst_h    = 1440;  // Dest Height
d->planes[2].dst_x    = 0;     // Dest X
d->planes[2].dst_y    = 0;     // Dest Y
d->planes[2].alpha    = 128;   // Dest Alpha
```

Note that we set the __Destination Alpha__ for the entire UI Channel. So our Green Circle will appear super transparent.

Finally we render the 3 UI Channels...

```c
// Render the UI Channels over DMA
display_commit(d);
```

We should see the Animated Mandelbrot Set, with Blue Square and (very faint) Green Circle as Overlays. (Pic below)

That's how we render 3 UI Channels (with overlay blending) on PinePhone's Display Engine!

(Why the horizontal lines in the Blue Square and Green Circle?)

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

_Mandelbrot Set with Blue Square and Green Circle as Overlays_

# Test PinePhone Display Engine

_We've seen the Test Code for Display Engine... How do we run the code?_

To test the A64 Display Engine, we'll boot __Apache NuttX RTOS__ on PinePhone and run our Test App...

-   [__test_display.c__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c)

Follow these steps to __download NuttX RTOS__ (with our Test App inside) to a microSD Card...

-   [__"Test PinePhone Display Engine"__](https://github.com/lupyuen/pinephone-nuttx#test-pinephone-display-engine)

Connect our computer to PinePhone via a [__USB Serial Debug Cable__](https://wiki.pine64.org/index.php/PinePhone#Serial_console). (At 115.2 kbps)

Boot PinePhone with NuttX RTOS in the microSD Card.

(NuttX won't disturb the eMMC Flash Memory)

At the NuttX Shell, enter this command to run our __Test App__...

```bash
hello
```

Our Test App controls the A64 Display Engine by setting the Hardware Registers (for the 3 UI Channels)...

```text
HELLO NUTTX ON PINEPHONE!
...
Shell (NSH) NuttX-11.0.0-RC2
nsh> hello
...
display_commit
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0
Channel 1: Set Overlay ...
Channel 1: Set Blender Output ...
Channel 1: Set Blender Input Pipe 0 ...
Channel 1: Disable Scaler ...
Channel 2: Set Overlay ...
Channel 2: Set Blender Input Pipe 1 ...
Channel 2: Disable Scaler ...
Channel 3: Set Overlay ...
Channel 3: Set Blender Input Pipe 2 ...
Channel 3: Disable Scaler ...
Set BLD Route and BLD FColor Control
  BLD Route:          0x1101080 = 0x321
  BLD FColor Control: 0x1101000 = 0x701
Apply Settings
  GLB DBuff: 0x1100008 = 0x1
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

And the Mandelbrot Set appears on PinePhone, together with the Blue Square and Green Circle as overlays. (Pic above)

Yep we have successfully tested the A64 Display Engine on PinePhone! ðŸŽ‰

_Hmmm building the Test Code looks complicated..._

Yeah we need a few steps to build the Test Code because we patched together a few programs to make it work...

-   __Apache NuttX RTOS__ for PinePhone

    [(See this)](https://lupyuen.github.io/articles/uboot)

-   __Zig Driver__ for MIPI Display Serial Interface

    [(More about this)](https://lupyuen.github.io/articles/dsi2)

-   __p-boot Display Code__

    [(See the next chapter)](https://lupyuen.github.io/articles/de#p-boot-display-code)

The steps will be a lot simpler when we have completed the  Display Engine Driver for NuttX.

Let's talk about the p-boot Display Code...

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

# p-boot Display Code

_About the code that controls A64 Display Engine... Where is `display_commit` defined?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) comes from the super-helpful [__p-boot PinePhone Bootloader__](https://xnux.eu/p-boot/) project, which runs directly on PinePhone Hardware. ("Bare Metal")

To test the A64 Display Engine on Apache NuttX RTOS, we borrowed these [__Source Files__](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L135-L142) (relevant to the Display Engine) from p-boot...

-   [__display.c__](https://megous.com/git/p-boot/tree/src/display.c)
-   [__pmic.c__](https://megous.com/git/p-boot/tree/src/pmic.c)
-   [__clock_sun6i.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c)
-   [__sunxi_gpio.c__](https://megous.com/git/p-boot/tree/src/uboot/drivers/gpio/sunxi_gpio.c)
-   [__pinmux.c__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/pinmux.c)

[(Plus a whole bunch of Header Files)](https://github.com/lupyuen/incubator-nuttx-apps/blob/de2/examples/hello/test_display.c#L115-L135)

Then we modified the above files to compile on NuttX...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which lets us experiment with the A64 Display Engine on NuttX.

_How does it control the A64 Display Engine?_

[__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) controls the A64 Display Engine by writing to the __Hardware Registers__ for the Display Engine.

The Display Engine's Hardware Registers are described here...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

_But what values does `display_commit` write to the Hardware Registers?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which tells us all the __Hardware Registers and their values__...

```text
Configure Blender
  BLD BkColor:     0x1101088 = 0xff000000
  BLD Premultiply: 0x1101084 = 0x0

Channel 1: Set Overlay
  UI Config Attr:      0x1103000 = 0xff000405
  UI Config Top LAddr: 0x1103010 = 0x4064a6ac
  UI Config Pitch:     0x110300c = 0xb40
  UI Config Size:      0x1103004 = 0x59f02cf
  UI Overlay Size:     0x1103088 = 0x59f02cf
  IO Config Coord:     0x1103008 = 0x0

Channel 1: Set Blender Output
  BLD Output Size: 0x110108c = 0x59f02cf
  GLB Size:        0x110000c = 0x59f02cf

Channel 1: Set Blender Input Pipe 0
  BLD Pipe InSize: 0x1101008 = 0x59f02cf
  BLD Pipe FColor: 0x1101004 = 0xff000000
  BLD Pipe Offset: 0x110100c = 0x0
  BLD Pipe Mode:   0x1101090 = 0x3010301

Channel 1: Disable Scaler
  Mixer: 0x1140000 = 0x0

Channel 2: ...
```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

When we study the log, we'll understand how we should __program the A64 Display Engine__ to render the 3 UI Channels.

Our findings are documented here...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

This is very helpful as we create the NuttX Display Driver for PinePhone...

![Testing the NuttX Display Driver for PinePhone](https://lupyuen.github.io/images/dsi2-title.jpg)

[_Testing the NuttX Display Driver for PinePhone_](https://lupyuen.github.io/articles/dsi2)

# NuttX Display Driver for PinePhone

_Once again, why are we doing all this?_

We're now porting [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot) to PinePhone.

Someday we hope to have a __fully-functional PinePhone__ running on NuttX RTOS...

-   [__"PinePhone on RTOS"__](https://lupyuen.github.io/articles/arm#pinephone-on-rtos)

(Or maybe just run PinePhone on NuttX as a simple touchscreen gadget)

To do that, we need a __NuttX Display Driver__.

That's why we're probing the internals of PinePhone, to learn everything we need to build the driver.

We've documented our earlier research on PinePhone's __MIPI Display Serial Interface__...

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

Today we learnt so much about PinePhone's __A64 Display Engine__...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

We're all set to build the NuttX Display Driver for PinePhone!

_How shall we build the PinePhone Display Driver?_

We'll create the PinePhone Display Driver based on the __NuttX Driver for Sitronix ST7789__...

-   [__nuttx/drivers/lcd/st7789.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/st7789.c)

That's because ST7789 is somewhat similar to PinePhone's ST7703 LCD Controller.

_But ST7789 doesn't support Framebuffers?_

Yeah for PinePhone we'll wrap the A64 DMA Framebuffers with this interface for __NuttX Framebuffers__...

-   [__nuttx/include/nuttx/video/fb.h__](https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/video/fb.h)

-   [__nuttx/drivers/video/fb.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/video/fb.c)

-   [__nuttx/drivers/lcd/lcd_framebuffer.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/drivers/lcd/lcd_framebuffer.c)

And we might get inspired by this implementation of __Display Overlays__ in the STM32 LCD TFT Display Controller (LTDC)...

-   [__nuttx/arch/arm/src/stm32/stm32_ltdc.c__](https://github.com/lupyuen/incubator-nuttx/blob/master/arch/arm/src/stm32/stm32_ltdc.c)

We have started the __Zig Implementation__ of the NuttX Driver (for MIPI Display Serial Interface)...

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

We'll add the A64 Display Engine in the next article!

![Testing the A64 Display Engine on PinePhone](https://lupyuen.github.io/images/de-test.jpg)

# Notes

1.  Some parts of the PinePhone DE and TCON0 Drivers still need to be reverse-engineered...

    [__de2_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init)

    [__tcon0_init__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#tcon0_init)

# What's Next

I hope we learnt lots today about __Display Rendering on PinePhone__...

-   What's the [__Display Engine (DE)__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone) inside PinePhone

-   How the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) controls PinePhone's LCD Display

-   How we call DE and TCON0 to [__render graphics__](https://lupyuen.github.io/articles/de#render-colours)

-   How our new [__PinePhone Display Driver__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone) will support DE and TCON0

Please join me in the next article as we create the PinePhone Display Engine Driver for [__Apache NuttX RTOS__](https://lupyuen.github.io/articles/uboot)!

Check out the other articles on __NuttX RTOS for PinePhone__...

-   [__"Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone"__](https://lupyuen.github.io/articles/arm)

-   [__"PinePhone boots Apache NuttX RTOS"__](https://lupyuen.github.io/articles/uboot)

-   [__"NuttX RTOS for PinePhone: Fixing the Interrupts"__](https://lupyuen.github.io/articles/interrupt)

-   [__"NuttX RTOS for PinePhone: UART Driver"__](https://lupyuen.github.io/articles/serial)

-   [__"NuttX RTOS for PinePhone: Blinking the LEDs"__](https://lupyuen.github.io/articles/pio)

-   [__"Understanding PinePhone's Display (MIPI DSI)"__](https://lupyuen.github.io/articles/dsi)

-   [__"NuttX RTOS for PinePhone: Display Driver in Zig"__](https://lupyuen.github.io/articles/dsi2)

Many Thanks to my [__GitHub Sponsors__](https://github.com/sponsors/lupyuen) for supporting my work! This article wouldn't have been possible without your support.

-   [__Sponsor me a coffee__](https://github.com/sponsors/lupyuen)

-   [__Discuss this article on Reddit__](https://www.reddit.com/r/PINE64official/comments/ygz5kt/rendering_pinephones_display_de_and_tcon0/)

-   [__My Current Project: "The RISC-V BL602 Book"__](https://lupyuen.github.io/articles/book)

-   [__Check out my articles__](https://lupyuen.github.io)

-   [__RSS Feed__](https://lupyuen.github.io/rss.xml)

_Got a question, comment or suggestion? Create an Issue or submit a Pull Request here..._

[__lupyuen.github.io/src/de.md__](https://github.com/lupyuen/lupyuen.github.io/blob/master/src/de.md)

![Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)](https://lupyuen.github.io/images/de-block1a.jpg)

[_Display Engine (DE) and Timing Controller (TCON0) from A64 User Manual (Page 498)_](https://dl.linux-sunxi.org/A64/A64_Datasheet_V1.1.pdf)

# Appendix: Overview of Allwinner A64 Display Engine

The official doc for the __Allwinner A64 Display Engine__ is here...

-   [__Allwinner Display Engine 2.0 Specifications__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

PinePhone's A64 Display Engine is hidden under [__Allwinner H3 (page 22)__](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf), because Allwinner A64 is actually a H3 upgraded with [__64-bit Arm Cores__](https://linux-sunxi.org/A64).

(Also check out this [__DE2 Register Guide__](https://linux-sunxi.org/DE2_Register_Guide))

Earlier we said that Allwinner A64's Display Engine is a __Real-Time Mixer__ that handles real-time __DMA, Overlay, Scaling and Blending__ of the Framebuffers...

And the Display Engine pushes the output pixels to the [__Timing Controller (TCON0)__](https://lupyuen.github.io/articles/pio#lcd-controller-tcon0) for display on PinePhone's LCD Display...

-   [__"Display Rendering on PinePhone"__](https://lupyuen.github.io/articles/de#display-rendering-on-pinephone)

According to the doc, the __Display Engine Base Address__ is __`0x0100` `0000`__ [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

_What's a Display Engine Mixer?_

__DE RT-MIXER:__ [(DE Page 87)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The RT-mixer Core consist of dma, overlay, scaler and blender block. It supports 4 layers overlay in one pipe, and its result can scaler up or down to blender in the next processing."

The Display Engine has 2 Mixers: RT-MIXER0 and RT-MIXER1.

__DE RT-MIXER0__ has 4 Channels (DE Offset __`0x10` `0000`__, [DE Page 87](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf))

-   __Channel 0__ for Video

    (DMA0, Video Overlay, Video Scaler)

-   __Channels 1, 2 and 3__ for UI

    (DMA1 / 2 / 3, 3 x UI Overlays, 3 x UI Scalers, 3 x UI Blenders)

-   __4 Overlay Layers__ per Channel

    (We only use 1 Overlay Layer per Channel)

-   __Layer Priority__ is Layer 3 > Layer2 > Layer 1 > Layer 0 [(DE Page 89)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

Our Display Engine Demo __configures the 4 Channels__ as follows...

-   __Channel 0__ is unused

    (No video right now)

-   __Channel 1__ has Pixel Format XRGB 8888

    (Alpha Channel is disabled)

-   __Channels 2 and 3__ have Pixel Format ARGB 8888

    (Alpha Channel is enabled)

__Hardware Registers__ for RT-MIXER0 [(DE Page 90)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)...

| Hardware Register | RT-MIXER0 Offset 
|--------------------|-----------------
|__GLB__ (Global Registers) | __`0x00` `0000`__
|__BLD__ (Blender) | __`0x00` `1000`__
|__OVL_V(CH0)__ (Video Overlay / Channel 0) | __`0x00` `2000`__
|__OVL_UI(CH1)__ (UI Overlay / Channel 1) | __`0x00` `3000`__
|__OVL_UI(CH2)__ (UI Overlay / Channel 2) | __`0x00` `4000`__
|__OVL_UI(CH3)__ (UI Overlay / Channel 3) | __`0x00` `5000`__
|__VIDEO_SCALER(CH0)__ (Video Scaler / Channel 0) | __`0x02` `0000`__
|__UI_SCALER1(CH1)__ (UI Scaler / Channel 1) | __`0x04` `0000`__
|__UI_SCALER2(CH2)__ (UI Scaler / Channel 2) | __` 0x05` `0000`__
|__UI_SCALER3(CH3)__ (UI Scaler / Channel 3) | __` 0x06` `0000`__
|__POST_PROC1__ (Post Processor 1) | __`0x0A` `0000`__
|__POST_PROC2__ (Post Processor 2) | __`0x0B` `0000`__
|__DMA__ (Direct Memory Access) | __`0x0C` `0000`__

The pic below shows how DE RT-MIXER0 mixes together __3 UI Channels (Framebuffers)__ via DMA1, 2 and 3 (plus a Video Channel on DMA0)...

![Real-Time Mixer in A64 Display Engine (Page 22)](https://lupyuen.github.io/images/de-mixer1a.jpg)

[_Real-Time Mixer in A64 Display Engine (Page 22)_](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

__DE RT-MIXER1__ has 2 Channels (DE Offset __`0x20` `0000`__, [DE Page 23](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf))
-   __Channel 0__ for Video 

    (DMA0, Video Overlay, Video Scaler)

-   __Channel 1__ for UI 

    (DMA1, UI Overlay, UI Scaler, UI Blender)

(We don't use RT-MIXER1 right now)

RT-MIXER0 and RT-MIXER1 are multiplexed to __Timing Controller TCON0__. [(Like this)](https://lupyuen.github.io/images/de-block1a.jpg)

TCON0 is connected to PinePhone's __ST7703 LCD Controller__ over MIPI Display Serial Interface. [(See this)](https://lupyuen.github.io/articles/dsi)

Hence RT-MIXER0 __mixes 1 Video Channel with 3 UI Channels__ over DMA. And pumps the pixels continuously to ST7703 LCD Controller. (Via the Timing Controller TCON0)

In today's demo we used the 3 UI Channels to render (pic below)...
1.  Mandelbrot Set
1.  Blue Square
1.  Green Circle

In the following chapters we explain how the 3 UI Channels were initialised and rendered by setting the Hardware Registers for A64 Display Engine...

-   [__"Initialising the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-initialising-the-allwinner-a64-display-engine)

-   [__"Programming the Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine)

![Mandelbrot Set with Blue Square and Green Circle as Overlays](https://lupyuen.github.io/images/de-overlay.jpg)

[_Mandelbrot Set with Blue Square and Green Circle as Overlays_](https://lupyuen.github.io/articles/de#test-pinephone-display-engine)

We won't use these Display Engine Features today...

__DE RT-WB (Write-Back Controller):__ [(DE Page 116)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The Real-time write-back controller (RT-WB) provides data capture function for display engine. It captures data from RT-mixer module, performs the image resizing function, and then write-back to SDRAM."

(For screen capture?)

__DE VSU (Video Scaler):__ [(DE Page 128)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)
> "The Video Scaler (VS) provides YUV format image resizing function for display engine. It receives data from overlay module, performs the image resizing function, and outputs to video post-processing modules."

__DE Rotation:__ [(DE Page 137)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)
> "There are several types of rotation: clockwise 0/90/180/270 degree Rotation and H-Flip/V-Flip. Operation of Copy is the same as a 0 degree rotation."

Nope to these too...

-   Fresh and Contrast Enhancement (FCE)
-   Black and White Stetch (BWS)
-   Luminance Transient Improvement (LTI)
-   Luma Peaking (PEAKING)
-   Adaptive Saturation Enhancement (ASE)
-   Fancy Color Curvature Change (FCC)
-   Dynamic Range Controller (DRC)

# Appendix: Initialising the Allwinner A64 Display Engine

_How do we initialise PinePhone's Allwinner A64 Display Engine at startup?_

As deciphered from the following logs...

-   [__`de2_init` Log__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#de2_init) 

    (Captured from [__p-boot `de2_init`__](https://megous.com/git/p-boot/tree/src/display.c#n1871))

-   [__`clock_set_pll_de` Log__](https://gist.github.com/lupyuen/c12f64cf03d3a81e9c69f9fef49d9b70#clock_set_pll_de)

    (Captured from [__p-boot `clock_set_pll_de`__](https://megous.com/git/p-boot/tree/src/uboot/arch/arm/mach-sunxi/clock_sun6i.c#n260))

Below are the steps to __initialise the Allwinner A64 Display Engine__ at startup...

1.  Set __High Speed SRAM__ to DMA Mode

    -   Set __BIST_DMA_CTRL_SEL__ to __0__ for DMA [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)
    
        [(A31 Page 191, `0x1C0` `0004`)](https://github.com/allwinner-zh/documents/raw/master/A31/A31_User_Manual_v1.3_20150510.pdf)

    -   __BIST_DMA_CTRL_SEL__ (Bist and DMA Control Select) is __Bit 0__ of SRAM_CTRL_REG1

    -   __SRAM_CTRL_REG1__ (SRAM Control Register 1) is at SRAM Registers Offset __`0x4`__

    -   __SRAM Registers__ Base Address is __`0x01C0` `0000`__
    
        [(A31 Page 191)](https://github.com/allwinner-zh/documents/raw/master/A31/A31_User_Manual_v1.3_20150510.pdf)
    
    ```text
    Set SRAM for video use
      0x1c0 0004 = 0x0 (DMB)
    ```

1.  Set __Display Engine PLL__ to 297 MHz

    -   Set __PLL_DE_CTRL_REG__ to __`0x8100` `1701`__ [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        __PLL_ENABLE__ (Bit 31) = 1 (Enable PLL)

        __PLL_MODE_SEL__ (Bit 24) = 1 (Integer Mode)

        __PLL_FACTOR_N__ (Bits 8 to 14) = 23 (N = 24)

        __PLL_PRE_DIV_M__ (Bits 0 to 3) = 1 (M = 2)

        Actual PLL Output = 24 MHz * N / M = 288 MHz
        
        (Slighltly below 297 MHz due to truncation)

    -   __PLL_DE_CTRL_REG__ (PLL Display Engine Control Register) is at CCU Offset __`0x0048`__

        [(A64 Page 96, `0x1C2` `0048`)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Setup DE2 PLL
      clock_set_pll_de: clk=297000000
      PLL10 rate = 24000000 * n / m
      0x1c2 0048 = 0x8100 1701 (DMB)
    ```

1.  Wait for __Display Engine PLL__ to be stable

    -   Poll __PLL_DE_CTRL_REG__ (from above) until __LOCK__ (Bit 28) is 1
    
        (PLL is Locked and Stable)

    ```text
    Setup DE2 PLL
      while (!(readl(0x1c2 0048) & 0x1000 0000))
    ```

1.  Set __Special Clock__ to Display Engine PLL

    -   Clear __DE_CLK_REG__ bits __`0x0300` `0000`__

        Set __DE_CLK_REG__   bits __`0x8100` `0000`__

        __SCLK_GATING__ (Bit 31) = 1 (Enable Special Clock)        

        __CLK_SRC_SEL__ (Bits 24 to 26) = 1 (Clock Source is Display Engine PLL)

    -   __DE_CLK_REG__ (Display Engine Clock Register) is at CCU Offset __`0x0104`__
    
        [(A64 Page 117, `0x1C2` `0104`)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 special clock
      clrsetbits 0x1c2 0104, 0x300 0000, 0x8100 0000
    ```

1.  Enable __AHB (AMBA High-speed Bus)__ for Display Engine: De-Assert Display Engine

    -   Set __BUS_SOFT_RST_REG1__ bits __`0x1000`__

        __DE_RST__ (Bit 12) = 1 (De-Assert Display Engine)

    -   __BUS_SOFT_RST_REG1__ (Bus Software Reset Register 1) is at CCU Offset `0x02C4`

        [(A64 Page 140, `0x1C2` `02C4`)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 ahb
      setbits 0x1c2 02c4, 0x1000
    ```

1.  Enable __AHB (AMBA High-speed Bus)__ for Display Engine: Pass Display Engine

    -   Set __BUS_CLK_GATING_REG1__ bits __`0x1000`__

        __DE_GATING__ (Bit 12) = 1 (Pass Display Engine)

    -   __BUS_CLK_GATING_REG1__ (Bus Clock Gating Register 1) is at CCU Offset __`0x0064`__
        
        [(A64 Page 102, `0x1C2` `0064`)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    -   __CCU__ (Clock Control Unit) Base Address is __`0x01C2` `0000`__

        [(A64 Page 81)](https://linux-sunxi.org/images/b/b4/Allwinner_A64_User_Manual_V1.1.pdf)

    ```text
    Enable DE2 ahb
      setbits 0x1c2 0064, 0x1000
    ```

1.  Enable __Clock for MIXER0__: SCLK Clock Pass

    -   Set __SCLK_GATE__ bits __`0x1`__

        __CORE0_SCLK_GATE__ (Bit 0) = 1 (Clock Pass)

    -   __SCLK_GATE__ is at DE Offset __`0x000`__
    
        [(DE Page 25, `0x100` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0000, 0x1
    ```

1.  Enable __Clock for MIXER0__: HCLK Clock Reset Off

    -   Set __AHB_RESET__ bits __`0x1`__

        __CORE0_HCLK_RESET__ (Bit 0) = 1 (Reset Off)

    -   __AHB_RESET__ is at DE Offset __`0x008`__
    
        [(DE Page 25, `0x100` `0008`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0008, 0x1
    ```

1.  Enable __Clock for MIXER0__: HCLK Clock Pass

    -   Set __HCLK_GATE__ bits __`0x1`__

        __CORE0_HCLK_GATE__ (Bit 0) = 1 (Clock Pass)

    -   __HCLK_GATE__ is at DE Offset __`0x004`__
    
        [(DE Page 25, `0x100` `0004`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      setbits 0x100 0004, 0x1
    ```

1.  Route __MIXER0 to TCON0__

    -   Clear __DE2TCON_MUX__ bits __`0x1`__

        __DE2TCON_MUX__ (Bit 0) = 0
        
        (Route MIXER0 to TCON0; Route MIXER1 to TCON1)

    -   __DE2TCON_MUX__ is at DE Offset __`0x010`__
    
        [(DE Page 26, `0x100` `0010`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable clock for mixer 0, set route MIXER0->TCON0
      clrbits 0x100 0010, 0x1
    ```

1.  Clear __MIXER0 Registers__: Global Registers (GLB), Blender (BLD), Video Overlay (OVL_V), UI Overlay (OVL_UI)

    -   Set __MIXER0__ Offsets __`0x0000`__ - __`0x5FFF`__ to 0

        __GLB__ (Global Regisers) at MIXER0 Offset __`0x0000`__

        __BLD__ (Blender) at MIXER0 Offset __`0x1000`__

        __OVL_V(CH0)__ (Video Overlay) at MIXER0 Offset __`0x2000`__

        __OVL_UI(CH1)__ (UI Overlay 1) at MIXER0 Offset __`0x3000`__

        __OVL_UI(CH2)__ (UI Overlay 2) at MIXER0 Offset __`0x4000`__

        __OVL_UI(CH3)__ (UI Overlay 3) at MIXER0 Offset __`0x5000`__

        [(DE Page 90, `0x110` `0000` - `0x110` `5FFF`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Clear all registers
      0x110 0000 to 0x110 5fff = 0x0
    ```

1.  Disable __MIXER0 Modules__...

    -   Video Scaler (VSU)
    -   UI Scaler (UIS)
    -   Fresh and Contrast Enhancement (FCE)
    -   Black and White Stetch (BWS)
    -   Luminance Transient Improvement (LTI)
    -   Luma Peaking (PEAKING)
    -   Adaptive Saturation Enhancement (ASE)
    -   Fancy Color Curvature Change (FCC)
    -   Dynamic Range Controller (DRC)

    Set to __`0`__ the following registers...

    -   __VS_CTRL_REG__ at VIDEO_SCALER(CH0) Offset 0

        EN (Bit 0) = 0 (Disable Video Scaler)

        [(DE Page 130, `0x112` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   TODO: __`0x113` `0000`__ is Undocumented

        (Is there a mixup with UI_SCALER3?)

    -   __UIS_CTRL_REG__ at UI_SCALER1(CH1) Offset 0

        EN (Bit 0) = 0 (Disable UI Scaler) 

        [(DE Page 66, `0x114` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UIS_CTRL_REG__ at UI_SCALER2(CH2) Offset 0

        EN (Bit 0) = 0 (Disable UI Scaler)

        [(DE Page 66, `0x115` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   TODO: Missing __UI_SCALER3(CH3)__ at MIXER0 Offset `0x06` `0000`

        [(DE Page 90, `0x116` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

        (Is there a mixup with `0x113` `0000` above?)

    -   __GCTRL_REG(FCE)__ at FCE Offset 0

        EN (Bit 0) = 0 (Disable FCE)

        [(DE Page 62, `0x11A` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GCTRL_REG(BWS)__ at BWS Offset 0

        EN (Bit 0) = 0 (Disable BWS)

        [(DE Page 42, `0x11A` `2000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LTI_CTL__ at LTI Offset 0

        LTI_EN (Bit 0) = 0 (Close LTI)

        [(DE Page 72, `0x11A` `4000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LP_CTRL_REG__ at PEAKING Offset 0

        EN (Bit 0) = 0 (Disable PEAKING)

        [(DE Page 80, `0x11A` `6000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __ASE_CTL_REG__ at ASE Offset 0

        ASE_EN (Bit 0) = 0 (Disable ASE)

        [(DE Page 40, `0x11A` `8000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCC_CTL_REG__ at FCC Offset 0

        Enable (Bit 0) = 0 (Disable FCC)

        [(DE Page 56, `0x11A` `A000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GNECTL_REG__ at DRC Offset 0

        BIST_EN (Bit 0) = 0 (Disable BIST)

        [(DE Page 49, `0x11B` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    Offsets of the above registers...

    -   __VIDEO_SCALER(CH0)__ is at MIXER0 Offset `0x02` `0000`
        
        [(DE Page 90, `0x112` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UI_SCALER1(CH1)__ is at MIXER0 Offset `0x04` `0000`

        [(DE Page 90, `0x114` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __UI_SCALER2(CH2)__ is at MIXER0 Offset `0x05` `0000`
    
        [(DE Page 90, `0x115` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCE__ is at MIXER0 Offset `0x0A` `0000`

        [(DE Page 61, `0x11A` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __BWS__ is at MIXER0 Offset `0x0A` `2000`

        [(DE Page 42, `0x11A` `2000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __LTI__ is at MIXER0 Offset `0x0A` `4000`

        [(DE Page 71, `0x11A` `4000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __PEAKING__ is at MIXER0 Offset `0x0A` `6000`

        [(DE Page 80, `0x11A` `6000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __ASE__ is at MIXER0 Offset `0x0A` `8000`

        [(DE Page 40, `0x11A` `8000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __FCC__ is at MIXER0 Offset `0x0A` `A000`

        [(DE Page 56, `0x11A` `A000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __DRC__ is at Address `0x011B` `0000`
    
        [(DE Page 48, `0x11B` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Clear all registers
      0x112 0000 = 0x0
      0x113 0000 = 0x0
      0x114 0000 = 0x0
      0x115 0000 = 0x0
      0x11a 0000 = 0x0
      0x11a 2000 = 0x0
      0x11a 4000 = 0x0
      0x11a 6000 = 0x0
      0x11a 8000 = 0x0
      0x11a a000 = 0x0
      0x11b 0000 = 0x0
    ```

1.  Enable __MIXER0__

    -   Set __GLB_CTL__ to 1 [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb)

        EN (Bit 0) = 1 (Enable Mixer)

        [(DE Page 92)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __GLB_CTL__ is at MIXER0 Offset 0

        [(DE Page 90, `0x110` `0000`)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __MIXER0__ is at DE Offset __`0x0010` `0000`__

        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    -   __Display Engine (DE)__ Base Address is __`0x0100` `0000`__
    
        [(DE Page 24)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

    ```text
    Enable mixer
      0x110 0000 = 0x1 (DMB)
    ```

We have __implemented in Zig__ the above A64 Display Engine Initialisation...

-   [__pinephone-nuttx/render.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig)

-   [__Output Log for render.zig__](https://gist.github.com/lupyuen/2df0f8c016dae54f4e4210866a7cd118)

![Running p-boot Display Code on Apache NuttX RTOS with logging](https://lupyuen.github.io/images/de-run.png)

[_Running p-boot Display Code on Apache NuttX RTOS with logging_](https://lupyuen.github.io/articles/de#p-boot-display-code)

# Appendix: Programming the Allwinner A64 Display Engine

We've seen the __Hardware Registers__ for the Allwinner A64 Display Engine...

-   [__"Overview of Allwinner A64 Display Engine"__](https://lupyuen.github.io/articles/de#appendix-overview-of-allwinner-a64-display-engine)

And we need to program the Hardware Registers to create the __NuttX Display Driver__ for PinePhone...

-   [__"NuttX Display Driver for PinePhone"__](https://lupyuen.github.io/articles/de#nuttx-display-driver-for-pinephone)

_How will we program the Hardware Registers to render the UI Channels?_

To find out how [__`display_commit`__](https://megous.com/git/p-boot/tree/src/display.c#n2017) updates the Hardware Registers (while rendering the UI Channels), we modded the p-boot Display Code to __log all Register Writes__...

-   [__Modified p-boot Display Code__](https://github.com/lupyuen/pinephone-nuttx/releases/download/pboot6/p-boot.6.zip)

Which produces a log that tells us all the __Hardware Registers and their values__...

-   [__"Testing p-boot Display Engine on PinePhone"__](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

After studying the log, we have identified the steps to render the 3 UI Channels with the Display Engine.

This is how we'll create a NuttX Driver for PinePhone's A64 Display Engine that implements Display Rendering...

[(Refer to __Memory Mapping List__ and __Register List__ at Page 90)](https://linux-sunxi.org/images/7/7b/Allwinner_DE2.0_Spec_V1.0.pdf)

1.  __Configure Blender...__

    -   __BLD_BK_COLOR__ (Blender Background Color) at BLD Offset `0x88`

        Set to `0xFF00` `0000` _(Why?)_

    -   __BLD_PREMUL_CTL__ (Blender Pre-Multiply Control) at BLD Offset `0x84`

        Set to 0

    ```text
    Configure Blender
    BLD BkColor:     0x110 1088 = 0xff000000
    BLD Premultiply: 0x110 1084 = 0x0
    ```

1.  __For Channels 1 to 3...__

    1.  __If Channel is unused,__ disable Overlay, Pipe and Scaler. Skip to next Channel

        -   __OVL_UI_ATTCTL__ (UI Overlay Attribute Control) at OVL_UI Offset `0x00`

            Set to 0

        -   Mixer (__???__ @ `0x113` `0000` + `0x10000` * Channel)

            Set to 0

        ```text
        Channel 2: Disable Overlay and Pipe
        UI Config Attr: 0x110 4000 = 0x0

        Channel 3: Disable Overlay and Pipe
        UI Config Attr: 0x110 5000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

    1.  Channel 1 has Pixel Format __XRGB 8888__:

        __OVL_V_ATTCTL â†’ LAY_FBFMT__ = `0x04`
    
        Channels 2 and 3 have Pixel Format __ARGB 8888__:

        __OVL_V_ATTCTL â†’ LAY_FBFMT__ = `0x01`

        _(See page 94)_

    1.  __Set Overlay__ (Assume Layer = 0)

        -   __OVL_UI_ATTCTL__ (UI Overlay Attribute Control) at OVL_UI Offset `0x00`

            __For Channel 1:__ Set to `0xFF00` `0405` _(Why?)_

            __For Channel 2:__ `0xFF00` `0005` _(Why?)_

            __For Channel 3:__ `0x7F00` `0005` _(Why?)_

        -   __OVL_UI_TOP_LADD__ (UI Overlay Top Field Memory Block Low Address) at OVL_UI Offset `0x10`

            Set to Framebuffer Address: `fb0`, `fb1` or `fb2`

        -   __OVL_UI_PITCH__ (UI Overlay Memory Pitch) at OVL_UI Offset `0x0C`

            Set to `(width * 4)`

        -   __OVL_UI_MBSIZE__ (UI Overlay Memory Block Size) at OVL_UI Offset `0x04`

            Set to `(height-1) << 16 + (width-1)`

        -   __OVL_UI_SIZE__ (UI Overlay Overlay Window Size) at OVL_UI Offset `0x88`

            Set to `(height-1) << 16 + (width-1)`

        -   __OVL_UI_COOR__ (UI Overlay Memory Block Coordinate) at OVL_UI Offset `0x08`

            Set to 0

        ```text
        Channel 1: Set Overlay (fb0 is 720 x 1440)
        UI Config Attr:      0x110 3000 = 0xff00 0405
        UI Config Top LAddr: 0x110 3010 = 0x4064 a6ac (Address of fb0)
        UI Config Pitch:     0x110 300c = 0xb40 (720 * 4)
        UI Config Size:      0x110 3004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 3088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 3008 = 0x0

        Channel 2: Set Overlay (fb1 is 600 x 600)
        UI Config Attr:      0x110 4000 = 0xff00 0005
        UI Config Top LAddr: 0x110 4010 = 0x404e adac (Address of fb1)
        UI Config Pitch:     0x110 400c = 0x960 (600 * 4)
        UI Config Size:      0x110 4004 = 0x257 0257 (599 << 16 + 599)
        UI Overlay Size:     0x110 4088 = 0x257 0257 (599 << 16 + 599)
        IO Config Coord:     0x110 4008 = 0x0

        Channel 3: Set Overlay (fb2 is 720 x 1440)
        UI Config Attr:      0x110 5000 = 0x7f00 0005
        UI Config Top LAddr: 0x110 5010 = 0x400f 65ac (Address of fb2)
        UI Config Pitch:     0x110 500c = 0xb40 (720 * 4)
        UI Config Size:      0x110 5004 = 0x59f 02cf (1439 << 16 + 719)
        UI Overlay Size:     0x110 5088 = 0x59f 02cf (1439 << 16 + 719)
        IO Config Coord:     0x110 5008 = 0x0
        ```

    1.  __For Channel 1:__ Set Blender Output

        -   __BLD_SIZE__ (BLD Output Size Setting) at BLD Offset `0x08C`

            Set to `(height-1) << 16 + (width-1)`
            
        -   __GLB_SIZE__ (Global Size) at GLB Offset `0x00C`

            Set to `(height-1) << 16 + (width-1)`

        ```text
        Channel 1: Set Blender Output
        BLD Output Size: 0x110 108c = 0x59f 02cf (1439 * 16 + 719)
        GLB Size:        0x110 000c = 0x59f 02cf (1439 * 16 + 719)
        ```

    1.  __Set Blender Input Pipe__ (N = Pipe Number, from 0 to 2 for Channels 1 to 3)

        -   __BLD_CH_ISIZE__ (Blender Input Memory Size) at BLD Offset `0x008` + `N*0x10` (N=0,1,2,3,4) 

            Set to `(height-1) << 16 + (width-1)`

        -   __BLD_FILL_COLOR__ (Blender Fill Color) at BLD Offset `0x004` + `N*0x10` (N=0,1,2,3,4)

            Set to `0xFF00` `0000` _(Why?)_

        -   __BLD_CH_OFFSET__ (Blender Input Memory Offset) at BLD Offset `0x00C` + `N*0x10` (N=0,1,2,3,4)

            __For Channel 1:__ Set to 0 _(Why?)_

            __For Channel 2:__ Set to `0x34` `0034` _(Why?)_

            __For Channel 3:__ Set to 0 _(Why?)_

        -   __BLD_CTL__ (Blender Control) at BLD Offset `0x090` + `N*4`

            Set to `0x301` `0301` _(Why?)_

        __Note: Log shows BLD_CH_ISIZE, BLD_FILL_COLOR and  BLD_CH_OFFSET are at `N*0x10`, but doc says `N*0x14`__

        ```text
        Channel 1: Set Blender Input Pipe 0 (fb0 is 720 x 1440)
        BLD Pipe InSize: 0x110 1008 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1004 = 0xff00 0000
        BLD Pipe Offset: 0x110 100c = 0x0
        BLD Pipe Mode:   0x110 1090 = 0x301 0301

        Channel 2: Set Blender Input Pipe 1 (fb1 is 600 x 600)
        BLD Pipe InSize: 0x110 1018 = 0x257 0257 (599 << 16 + 599)
        BLD Pipe FColor: 0x110 1014 = 0xff00 0000
        BLD Pipe Offset: 0x110 101c = 0x34 0034
        BLD Pipe Mode:   0x110 1094 = 0x301 0301

        Channel 3: Set Blender Input Pipe 2 (fb2 is 720 x 1440)
        BLD Pipe InSize: 0x110 1028 = 0x59f 02cf (1439 * 16 + 719)
        BLD Pipe FColor: 0x110 1024 = 0xff00 0000
        BLD Pipe Offset: 0x110 102c = 0x0
        BLD Pipe Mode:   0x110 1098 = 0x301 0301
        ```

    1.  __Disable Scaler__ (Assume we're not scaling)

        -   Mixer (__???__ @ `0x113` `0000` + `0x10000` * Channel)

            Set to 0

        ```text
        Channel 1: Disable Scaler
        Mixer: 0x114 0000 = 0x0

        Channel 2: Disable Scaler
        Mixer: 0x115 0000 = 0x0

        Channel 3: Disable Scaler
        Mixer: 0x116 0000 = 0x0
        ```

1.  __Set Blender Route and Fill Color__

    -   __BLD_CH_RTCTL__ (Blender Routing Control) at BLD Offset `0x080`

        __For 3 UI Channels:__ Set to `0x321` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

        __For 1 UI Channel:__ Set to `1` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    -   __BLD_FILLCOLOR_CTL__ (Blender Fill Color Control) at BLD Offset `0x000`

        __For 3 UI Channels:__ Set to `0x701` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

        __For 1 UI Channels:__ Set to `0x101` [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    ```text
    For 3 UI Channels: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x321 (DMB)
    BLD FColor Control: 0x110 1000 = 0x701 (DMB)

    For 1 UI Channel: Set BLD Route and BLD FColor Control
    BLD Route:          0x110 1080 = 0x1   (DMB)
    BLD FColor Control: 0x110 1000 = 0x101 (DMB)
    ```

1.  __Apply Settings__

    -   __GLB_DBUFFER__ (Global double buffer control register) at GLB Offset `0x008`

        Set to 1 [__(DMB)__](https://developer.arm.com/documentation/dui0489/c/arm-and-thumb-instructions/miscellaneous-instructions/dmb--dsb--and-isb) _(Why?)_

    ```text
    Apply Settings
    GLB DBuff: 0x110 0008 = 0x1 (DMB)
    ```

[(See the Complete Log)](https://github.com/lupyuen/pinephone-nuttx#testing-p-boot-display-engine-on-pinephone)

[(Captured from p-boot `display_commit`)](https://megous.com/git/p-boot/tree/src/display.c#n2017)

We have __implemented in Zig__ the above A64 Display Engine Rendering...

-   [__pinephone-nuttx/render.zig__](https://github.com/lupyuen/pinephone-nuttx/blob/main/render.zig)

-   [__Output Log for render.zig__](https://gist.github.com/lupyuen/2df0f8c016dae54f4e4210866a7cd118)
