<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/starpro64-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/starpro64.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?</h1>
    <nav id="rustdoc"><ul>
<li><a href="#eswin-eic7700x-risc-v-soc" title="ESWIN EIC7700X RISC-V SoC">1 ESWIN EIC7700X RISC-V SoC</a><ul></ul></li>
<li><a href="#boot-without-microsd" title="Boot Without MicroSD">2 Boot Without MicroSD</a><ul></ul></li>
<li><a href="#download-the-linux-image" title="Download the Linux Image">3 Download the Linux Image</a><ul></ul></li>
<li><a href="#prepare-the-linux-image" title="Prepare the Linux Image">4 Prepare the Linux Image</a><ul></ul></li>
<li><a href="#starpro64-gets-smokin-hot" title="StarPro64 Gets Smokin‚Äô Hot!">5 StarPro64 Gets Smokin‚Äô Hot!</a><ul></ul></li>
<li><a href="#boot-the-linux-image" title="Boot the Linux Image">6 Boot the Linux Image</a><ul></ul></li>
<li><a href="#settings-for-u-boot-bootloader" title="Settings for U-Boot Bootloader">7 Settings for U-Boot Bootloader</a><ul></ul></li>
<li><a href="#boot-nuttx-over-tftp" title="Boot NuttX over TFTP">8 Boot NuttX over TFTP</a><ul></ul></li>
<li><a href="#llm-on-npu-on-nuttx" title="LLM on NPU on NuttX?">9 LLM on NPU on NuttX?</a><ul></ul></li>
<li><a href="#smart-power-plug" title="Smart Power Plug">10 Smart Power Plug</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-multiple-harts-on-starpro64" title="Appendix: Multiple Harts on StarPro64">12 Appendix: Multiple Harts on StarPro64</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-starpro64" title="Appendix: Build NuttX for StarPro64">13 Appendix: Build NuttX for StarPro64</a><ul></ul></li>
<li><a href="#appendix-port-nuttx-to-starpro64" title="Appendix: Port NuttX to StarPro64">14 Appendix: Port NuttX to StarPro64</a><ul>
<li><a href="#risc-v-boot-code" title="RISC-V Boot Code">14.1 RISC-V Boot Code</a><ul></ul></li>
<li><a href="#nuttx-start-code" title="NuttX Start Code">14.2 NuttX Start Code</a><ul></ul></li>
<li><a href="#plic-interrupt-controller" title="PLIC Interrupt Controller">14.3 PLIC Interrupt Controller</a><ul></ul></li>
<li><a href="#memory-map" title="Memory Map">14.4 Memory Map</a><ul></ul></li>
<li><a href="#nuttx-config" title="NuttX Config">14.5 NuttX Config</a><ul></ul></li>
<li><a href="#paste-slowly" title="Paste Slowly">14.6 Paste Slowly</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>2 Mar 2025</em></p>
<p><img src="https://lupyuen.org/images/starpro64-title.jpg" alt="StarPro64 EIC7700X RISC-V SBC: Maybe LLM on NPU on NuttX?" /></p>
<p><a href="https://pine64.org/2024/10/02/september_2024/#starpro64"><strong>StarPro64 EIC7700X</strong></a> is the <em>(literally) Hot</em> New RISC-V SBC by PINE64. In this article we chat about‚Ä¶</p>
<ul>
<li>
<p><strong>ESWIN EIC7700X</strong>, the RISC-V SoC inside StarPro64</p>
</li>
<li>
<p>Its <strong>Neural Processing Unit</strong> that supports <strong>Large Language Models</strong></p>
</li>
<li>
<p>Booting <strong>RockOS Linux</strong> on StarPro64</p>
</li>
<li>
<p>Porting <strong>Apache NuttX RTOS</strong> to StarPro64</p>
</li>
<li>
<p><strong>Multiple Harts</strong> are a little problematic</p>
</li>
<li>
<p>Beware of <strong>Overheating</strong>!</p>
</li>
<li>
<p><strong>Smart Power Plug</strong> might be helpful</p>
</li>
</ul>
<p>We begin with the RISC-V SoC‚Ä¶</p>
<p><a href="https://youtu.be/Yr7aYNIMUsw"><em>(Watch the NuttX Demo on YouTube)</em></a></p>
<p><em>(Thanks to PINE64 for providing the Prototype StarPro64)</em></p>
<p><img src="https://lupyuen.org/images/starpro64-fan2.jpg" alt="StarPro64 EIC7700X RISC-V SBC" /></p>
<h1 id="eswin-eic7700x-risc-v-soc"><a class="doc-anchor" href="#eswin-eic7700x-risc-v-soc">¬ß</a>1 ESWIN EIC7700X RISC-V SoC</h1>
<p><em>StarPro64: Isn‚Äôt it a souped-up Star64?</em></p>
<p>Nope it‚Äôs a totally different beast! <em>(From a different SoC Maker)</em></p>
<p>Inside StarPro64 is the <a href="https://www.eswincomputing.com/en/products/index/36.html"><strong>ESWIN EIC7700X SoC</strong></a>. EIC7700X has <strong>Four RISC-V Cores</strong> and it‚Äôs based on <a href="https://www.sifive.com/cores/performance-p550"><strong>SiFive Architecture</strong></a> <em>(a bit like JH7110 SoC)</em></p>
<p><img src="https://lupyuen.org/images/starpro64-arch.jpg" alt="ESWIN EIC7700X SoC" /></p>
<p>But its super-speedy <a href="https://www.sifive.com/document-file/eic7700x-datasheet"><strong>Neural Processing Unit</strong></a> (NPU) makes it a very special <em>(llama?)</em> beast. Later we‚Äôll talk about the <a href="https://lupyuen.github.io/articles/starpro64#llm-on-npu-on-nuttx"><strong>Fun LLM Experiments</strong></a> that we can run on the NPU.</p>
<p><em>(20 TOPS INT8 = 20 Trillion Ops Per Second for 8-bit Integers)</em></p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-npu.jpg" alt="ESWIN EIC7700X NPU" /></p>
</blockquote>
<p><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual"><strong>EIC7700X Technical Reference Manual</strong></a> is probably the best among the RISC-V SoCs <em>(BL808, SG2000, JH7110)</em></p>
<ul>
<li>
<p><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf"><strong>Part 1: Hardware, System, Interrupts</strong></a></p>
</li>
<li>
<p><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part2.pdf"><strong>Part 2: Memory Interface, Image / Video Processors</strong></a></p>
</li>
<li>
<p><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part3.pdf"><strong>Part 3: Video Input / Output</strong></a></p>
</li>
<li>
<p><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf"><strong>Part 4: Peripherals, USB, PCI, Ethernet</strong></a></p>
</li>
</ul>
<p>We go hands-on‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-uart.jpg" alt="Connecting USB UART Dongle to StarPro64" /></p>
<h1 id="boot-without-microsd"><a class="doc-anchor" href="#boot-without-microsd">¬ß</a>2 Boot Without MicroSD</h1>
<p><em>What happens if we boot StarPro64? Fresh from the box?</em></p>
<p>We monitor the <strong>UART0 Port</strong> for Debug Messages. Connect our <a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>USB UART Dongle</strong></a> (CH340 or CP2102) to these pins (pic above)</p>
<div><table><thead><tr><th style="text-align: center">StarPro64</th><th style="text-align: center">USB UART</th><th style="text-align: center">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center"><em>Yellow</em></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td><td style="text-align: center"><em>Blue</em></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td><td style="text-align: center"><em>Green</em></td></tr>
</tbody></table>
</div><span style="font-size:80%">
<p><em>(Same Pins as the GPIO Header on Oz64 SG2000 and Star64 JH7110)</em></p>
</span>
<p>Connect to the USB UART at <strong>115.2 kbps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 115200</code></pre></div>
<p>Power up the board with a <strong>Power Adapter</strong>. <a href="https://pine64.com/product/12v-5a-us-power-supply/">(Same one as <strong>Star64 JH7110</strong>)</a></p>
<p>We‚Äôll see <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>OpenSBI v1.5
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | &#39;_ \ / _ \ &#39;_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|____/_____|
        | |
        |_|
Platform Name             : ESWIN EIC7700 EVB
Platform Features         : medeleg
Platform HART Count       : 4
Platform Console Device   : uart8250
Firmware Base             : 0x80000000

Domain0 Boot HART         : 2
Domain0 HARTs             : 0*,1*,2*,3*
Domain0 Next Address      : 0x0000000080200000

Boot HART ID              : 2
Boot HART Base ISA        : rv64imafdchx
Boot HART ISA Extensions  : sscofpmf,zihpm,sdtrig
Boot HART MIDELEG         : 0x0000000000002666
Boot HART MEDELEG         : 0x0000000000f0b509</code></pre></div></span>
<p>Then <a href="https://docs.u-boot.org/en/latest/index.html"><strong>U-Boot Bootloader</strong></a>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot 2024.01-gaa36f0b4 (Jan 23 2025 - 02:49:59 +0000)
CPU:     rv64imafdc_zba_zbb
Model:   ESWIN EIC7700 EVB
DRAM:    32 GiB (effective 16 GiB)
llCore:  143 devices, 31 uclasses, devicetree: separate
Warning: Device tree includes old &#39;u-boot,dm-&#39; tags: please fix by 2023.07!
MMC:    sdhci@50450000: 0, sd@50460000: 1

Loading Environment from SPIFlash...
SF: Detected w25q128fw with page size 256 Bytes, erase size 4 KiB, total 16 MiB
*** Warning - bad CRC, using default environment
No SATA device found!
Hit any key to stop autoboot:  0
=&gt;</code></pre></div></span>
<p>And it stops at U-Boot, waiting to boot from MicroSD or eMMC. Let‚Äôs init our eMMC‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-hdmi.jpg" alt="HDMI Output will show U-Boot, but not OpenSBI" /></p>
<p><em>HDMI Output will show U-Boot, but not OpenSBI</em></p>
<h1 id="download-the-linux-image"><a class="doc-anchor" href="#download-the-linux-image">¬ß</a>3 Download the Linux Image</h1>
<p><em>Is there a Linux Image for StarPro64?</em></p>
<p>The fine folks at <a href="https://github.com/rockos-riscv"><strong>PLCT Lab RockOS</strong></a> are busy preparing the <strong>Linux Image</strong> for StarPro64. Thanks to <a href="https://nightcord.de/@icenowy/114027871300585376"><strong>@icenowy</strong></a>, we have a <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of the Linux Image‚Ä¶</p>
<ol>
<li>
<p><strong>Bootloader (OpenSBI + U-Boot)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/bootloader_secboot_ddr5_pine64-starpro64.bin"><em>bootloader_secboot_ddr5_pine64-starpro64.bin</em></a></p>
</li>
<li>
<p><strong>Linux Boot Image (Linux Kernel)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/boot-rockos-20250123-210346.ext4.zst"><em>boot-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
<li>
<p><strong>Linux Root Image (Linux Filesystem)</strong></p>
<p><a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/root-rockos-20250123-210346.ext4.zst"><em>root-rockos-20250123-210346.ext4.zst</em></a></p>
</li>
</ol>
<p>Uncompress the files and rename them. Copy them to a <a href="https://qoto.org/@lupyuen/114036829364673417"><strong>USB Drive</strong></a> (not MicroSD)</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -lh *.bin *.zst
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
154M  boot-rockos-20250123-210346.ext4.zst
2.3G  root-rockos-20250123-210346.ext4.zst

$ unzstd boot-rockos-20250123-210346.ext4.zst
boot-rockos-20250123-210346.ext4.zst: 524288000 bytes

$ unzstd root-rockos-20250123-210346.ext4.zst
root-rockos-20250123-210346.ext4.zst: 7516192768 bytes

$ mv boot-rockos-20250123-210346.ext4 boot.ext4
$ mv root-rockos-20250123-210346.ext4 root.ext4

$ ls -lh *.bin *.ext4
4.2M  bootloader_secboot_ddr5_pine64-starpro64.bin
500M  boot.ext4
7.0G  root.ext4

$ cp *.bin *.ext4 /media/$USER/YOUR_USB_DRIVE</code></pre></div>
<p>We‚Äôll skip the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/sdcard-rockos-20250123-210346.img.zst"><strong>MicroSD Image</strong></a>, because <a href="https://qoto.org/@lupyuen/114036829364673417"><strong>MicroSD Interface</strong></a> wasn‚Äôt working reliably on our Prototype StarPro64.</p>
<p><img src="https://lupyuen.org/images/starpro64-emmc.jpg" alt="StarPro64 with eMMC" /></p>
<h1 id="prepare-the-linux-image"><a class="doc-anchor" href="#prepare-the-linux-image">¬ß</a>4 Prepare the Linux Image</h1>
<p><em>How to load the Linux Image into eMMC?</em></p>
<p>Based on the <a href="https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/Development_board_image_installation_and_upgrade_manual.pdf"><strong>ESWIN Official Doc</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Connect our <strong>eMMC to StarPro64</strong> (pic above)</p>
</li>
<li>
<p>Connect our <strong>USB Drive</strong> (Previous Section)</p>
</li>
<li>
<p><strong>At U-Boot:</strong> Press <strong>Ctrl-C</strong> to stop Autoboot</p>
</li>
<li>
<p>Verify that the <strong>eMMC is OK</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls mmc 0
[ Nothing ]

$ mmc part
[ Nothing ]</code></pre></div></li>
<li>
<p>First Time Only: <strong>GPT Partition</strong> our eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ echo $partitions
partitions=
  name=boot,start=1MiB,size=2048MiB,type=${typeid_filesystem},uuid=${uuid_boot};
  name=swap,size=4096MiB,type=${typeid_swap},uuid=${uuid_swap};
  name=root,size=-,type=${typeid_filesystem},uuid=${uuid_root}

$ run gpt_partition
$ mmc part
  1 0x00000800 0x001007ff &quot;boot&quot;
  2 0x00100800 0x009007ff &quot;swap&quot;
  3 0x00900800 0x0e677fde &quot;root&quot;</code></pre></div></li>
<li>
<p>Verify that our <strong>USB Drive</strong> works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls usb 0
 524288000 boot.ext4
7516192768 root.ext4
   4380760 bootloader_secboot_ddr5_pine64-starpro64.bin   </code></pre></div></li>
<li>
<p>Install the <strong>Bootloader, Boot Image and Root Image</strong>, from USB Drive to eMMC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ es_fs update usb 0 boot.ext4 mmc 0:1
mmc has been successfully writen in mmc 0:1

$ es_fs update usb 0 root.ext4 mmc 0:3
mmc has been successfully writen in mmc 0:3

$ ext4load usb 0 0x100000000 bootloader_secboot_ddr5_pine64-starpro64.bin
4380760 bytes read in 162 ms (25.8 MiB/s)

$ es_burn write 0x100000000 flash
bootloader write OK</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/a07e8dcd56d3fb306dce8983f4924702">(See the <strong>eMMC Log</strong>)</a></p>
</li>
<li>
<p><strong>Beware of Overheating!</strong> Keep StarPro64 cool, or the previous step might corrupt the <strong>SPI Boot Flash</strong> and cause unspeakable agony‚Ä¶</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/starpro64-fan.jpg" alt="StarPro64 with USB Fan" /></p>
<h1 id="starpro64-gets-smokin-hot"><a class="doc-anchor" href="#starpro64-gets-smokin-hot">¬ß</a>5 StarPro64 Gets Smokin‚Äô Hot!</h1>
<p><em>Something is smelling like barbecue?</em></p>
<p>Whoa StarPro64 is on fire: Drop it, stop it and <strong>power off</strong>! StarPro64 will show <a href="https://gist.github.com/lupyuen/47170b4c4d7117ac495c5faede48280b#file-gistfile1-txt-L796-L894"><strong>PLL Errors</strong></a> when it overheats‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>pll failed.
pll failed.
pll failed.</code></pre></div>
<p>Also watch for <a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f#file-gistfile1-txt-L1940-L1947"><strong>Thermal Errors</strong></a> when booting Linux‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>thermal thermal_zone0: thermal0:
critical temperature reached, shutting down
reboot: HARDWARE PROTECTION shutdown (Temperature too high)</code></pre></div>
<p>Install a <a href="https://www.lazada.sg/products/i2932991583-s20178422377.html"><strong>USB Fan</strong></a>, preferably something stronger. <em>(Pic above, boxed up with IKEA 365+)</em></p>
<p>But don‚Äôt power it with the USB Port on StarPro64! Instead, connect it to our <a href="https://lupyuen.github.io/articles/starpro64#smart-power-plug"><strong>Smart Power Plug</strong></a>.</p>
<p><em>Anything else we should worry about?</em></p>
<p>The <a href="https://qoto.org/@lupyuen/114036829364673417"><strong>MicroSD Interface</strong></a> wasn‚Äôt working well on our Prototype StarPro64. The MicroSD Card deactivated itself after a bit of U-Boot Access.</p>
<p>Hence the <strong>Headless Ironman</strong>: USB Drive on StarPro64‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-ironman.jpg" alt="Headless Ironman: USB Drive on StarPro64" /></p>
<h1 id="boot-the-linux-image"><a class="doc-anchor" href="#boot-the-linux-image">¬ß</a>6 Boot the Linux Image</h1>
<p><em>Earlier we flashed Linux to eMMC. Can we boot Linux now?</em></p>
<p>Yep just power up StarPro64. eMMC will <strong>Boot Linux</strong>‚Ä¶</p>
<span style="font-size:80%">
<div class="example-wrap"><pre class="language-text"><code>U-Boot menu
1:      RockOS GNU/Linux 6.6.73-win2030
2:      RockOS GNU/Linux 6.6.73-win2030 (rescue target)
Enter choice: 1:        RockOS GNU/Linux 6.6.73-win2030
Retrieving file: /vmlinuz-6.6.73-win2030
Retrieving file: /initrd.img-6.6.73-win2030
append: root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 console=ttyS0,115200 root=PARTUUID=b0f77ad6-36cd-4a99-a8c0-31d73649aa08 rootfstype=ext4 rootwait rw earlycon selinux=0 LANG=en_US.UTF-8

Retrieving file: /dtbs/linux-image-6.6.73-win2030/eswin/eic7700-pine64-starpro64.dtb
   Uncompressing Kernel Image
Moving Image from 0x84000000 to 0x80200000, end=81e63000
## Flattened Device Tree blob at 88000000
   Booting using the fdt blob at 0x88000000
Working FDT set to 88000000
ERROR: reserving fdt memory region failed (addr=fffff000 size=1000 flags=4)
   Using Device Tree in place at 0000000088000000, end 0000000088027af4
Working FDT set to 88000000

Starting kernel ...
Linux version 6.6.73-win2030 (riscv@riscv-builder) (riscv64-unknown-linux-gnu-gcc () 13.2.0, GNU ld (GNU Binutils) 2.42) #2025.01.23.02.46+aeb0f375c SMP Thu Jan 23 03:08:39 UTC 2025
Machine model: Pine64 StarPro64
...
mmc0: Timeout waiting for hardware interrupt.
mmc0: sdhci: ============ SDHCI REGISTER DUMP ===========
mmc0: sdhci: Sys addr:  0x00000008 | Version:  0x00000005
mmc0: sdhci: Blk size:  0x00007200 | Blk cnt:  0x00000000</code></pre></div></span>
<p>Sadly the <a href="https://fast-mirror.isrc.ac.cn/rockos/images/generic/20241230_20250124/"><strong>Preview Version</strong></a> of RockOS won‚Äôt boot correctly on our Prototype StarPro64 (pic below). Hopefully we‚Äôll sort this out real soon and do some <a href="https://lupyuen.github.io/articles/starpro64#llm-on-npu-on-nuttx"><strong>Serious NPU LLM</strong></a>!</p>
<p><a href="https://gist.github.com/lupyuen/89e1e87e7f213b6f52f31987f254b32f">(See the <strong>Boot Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-linux.jpg" alt="RockOS won‚Äôt boot correctly on our Prototype StarPro64" /></p>
<h1 id="settings-for-u-boot-bootloader"><a class="doc-anchor" href="#settings-for-u-boot-bootloader">¬ß</a>7 Settings for U-Boot Bootloader</h1>
<p><em>Bummer. What else can we boot on StarPro64?</em></p>
<p>Let‚Äôs snoop around <a href="https://docs.u-boot.org/en/latest/index.html"><strong>U-Boot Bootloader</strong></a>. And figure out how to boot <a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong>. At the <strong>U-Boot Prompt</strong>: We enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ help
printenv  - print environment variables
saveenv   - save environment variables to persistent storage
net       - NET sub-system
dhcp      - boot image via network using DHCP/TFTP protocol
tftpboot  - load file via network using TFTP protocol
fdt       - flattened device tree utility commands
booti     - boot Linux kernel &#39;Image&#39; format from memory

$ printenv
fdt_addr_r=0x88000000
kernel_addr_r=0x84000000
loadaddr=0x80200000</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9db7b36f3cdf26f7b7f75c0d35177ee7">(See the <strong>U-Boot Log</strong>)</a></p>
<p>A-ha! This says‚Ä¶</p>
<ul>
<li>
<p>U-Boot supports booting over TFTP: <a href="https://lupyuen.github.io/articles/tftp"><strong>Trivial File Transfer Protocol</strong></a></p>
</li>
<li>
<p>It will load the <strong>Kernel Image</strong> <em>(Linux / NuttX)</em> into RAM at <strong><code>0x8400</code> <code>0000</code></strong></p>
</li>
<li>
<p>Then it will move the Kernel Image to <strong><code>0x8020</code> <code>0000</code></strong> and boot there</p>
</li>
<li>
<p>Also it loads the <strong>Device Tree</strong> into <strong><code>0x8800</code> <code>0000</code></strong></p>
</li>
</ul>
<p>Thanks U-Boot! You told us everything we need to Boot NuttX‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-flow2.jpg" alt="Booting NuttX over TFTP" /></p>
<h1 id="boot-nuttx-over-tftp"><a class="doc-anchor" href="#boot-nuttx-over-tftp">¬ß</a>8 Boot NuttX over TFTP</h1>
<p><em>How to boot NuttX over TFTP? (Pic above)</em></p>
<ol>
<li>
<p>Install our <strong>TFTP Server</strong>: Follow the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Copy these files to our TFTP Server‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/starpro64-1/Image"><strong>NuttX Image:</strong> <em>Image</em></a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/download/starpro64-1/jh7110-star64-pine64.dtb"><strong>Device Tree:</strong> <em>jh7110-star64-pine64.dtb</em></a></p>
<p>Like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the NuttX Image and Device Tree
wget https://github.com/lupyuen2/wip-nuttx/releases/download/starpro64-1/Image
wget https://github.com/lupyuen2/wip-nuttx/releases/download/starpro64-1/jh7110-star64-pine64.dtb

## Copy the NuttX Image and Device Tree to our TFTP Server
scp Image tftpserver:/tftpboot/Image-starpro64
scp jh7110-star64-pine64.dtb tftpserver:/tftpboot/
ssh tftpserver ls -l /tftpboot/</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-build-nuttx-for-starpro64">(How to <strong>Build NuttX</strong> ourselves)</a></p>
<p>(NuttX won‚Äôt read the <strong>Device Tree</strong>)</p>
</li>
<li>
<p>Power up StarPro64 and press <strong>Ctrl-C</strong></p>
</li>
<li>
<p>At the <strong>U-Boot Prompt</strong>: Enter these commands‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Check if the Network Adapter is alive
## &quot;eth0 : ethernet@50400000 f6:70:f9:6e:73:ae active&quot;
net list

## Set the U-Boot TFTP Server
## TODO: Change to your TFTP Server
setenv tftp_server 192.168.31.10

## Save the U-Boot Config for future reboots
saveenv

## Fetch the IP Address over DHCP
## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x84000000
dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x88000000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x88000000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
fdt addr ${fdt_addr_r}

## Boot the NuttX Image with the Device Tree
## kernel_addr_r=0x84000000
## fdt_addr_r=0x88000000
## TODO: Fix the Device Tree, it&#39;s not needed by NuttX
booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div><span style="font-size:80%">
<p><a href="https://lupyuen.github.io/articles/starpro64#paste-slowly">(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</a></p>
</span>
</li>
<li>
<p>NuttX boots OK on StarPro64 yay! (Pic below)</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt; uname -a
NuttX 12.4.0 83424f8d26 Feb 24 2025 06:50:22 risc-v milkv_duos

nsh&gt; hello
Hello, World!!

nsh&gt; getprime
getprime took 148 msec    

nsh&gt; ostest
ostest_main: Exiting with status 0</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2823528f7b53375f080256bc798b2bf5">(See the <strong>NuttX Log</strong>)</a></p>
<p><a href="https://youtu.be/Yr7aYNIMUsw">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-port-nuttx-to-starpro64"><strong>‚ÄúPort NuttX to StarPro64‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/starpro64-ostest.png" alt="NuttX boots OK on StarPro64 yay!" /></p>
<p><em>We type these commands EVERY TIME we boot?</em></p>
<p>We can automate: Just do this once, and NuttX will <strong>Auto-Boot</strong> whenever we power up‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Add the Boot Command for TFTP
setenv bootcmd_tftp &#39;dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}&#39;

## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Command: `bootflow scan -lb`
setenv orig_bootcmd &quot;$bootcmd&quot;

## Prepend TFTP to the Boot Command: `run bootcmd_tftp ; bootflow scan -lb`
setenv bootcmd &quot;run bootcmd_tftp ; $bootcmd&quot;

## Save it for future reboots
saveenv</code></pre></div>
<p>Next comes the fun part that turns StarPro64 into a totally different beast from Star64‚Ä¶</p>
<span style="font-size:80%">
<p><a href="https://lupyuen.github.io/articles/starpro64#paste-slowly">(U-Boot dropping chars? Try <strong>iTerm &gt; Edit &gt; Paste Special &gt; Paste Slowly</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-starpro64#auto-boot-and-static-ip-for-starpro64">(How to <strong>Undo Auto-Boot</strong>? Allow <strong>Static IP</strong>?)</a></p>
</span>
<p><img src="https://lupyuen.org/images/starpro64-touchscreen.jpg" alt="StarPro64 with Touchscreen" /></p>
<h1 id="llm-on-npu-on-nuttx"><a class="doc-anchor" href="#llm-on-npu-on-nuttx">¬ß</a>9 LLM on NPU on NuttX?</h1>
<p><em>Oh really? Large Language Model on Single-Board Computer? (Eyes roll)</em></p>
<p>Hear me out‚Ä¶</p>
<ol>
<li>
<p><a href="https://www.eswincomputing.com/en/bocupload/2024/06/19/17187920991529ene8q.pdf"><strong>20 TOPS INT8</strong></a>: That‚Äôs the spec of the speedy <strong>Neural Processing Unit</strong> (NPU) inside StarPro64. <em>(20 Trillion Ops Per Second for 8-bit Integers)</em></p>
<p>Yeah an <a href="https://github.com/ggml-org/llama.cpp?tab=readme-ov-file#description"><strong>Offline Disconnected LLM</strong></a> will run <em>(somewhat)</em> OK on any CPU. But this NPU is designed for such LLMs. <em>(Goodbye ‚ÄúTensorFlow Lite‚Äù)</em></p>
</li>
<li>
<p><a href="https://github.com/eswincomputing/eic7x-images/releases/download/Debian-v1.0.0-p550-20241230/ESWIN_AI_Sample_User_Guide.pdf"><strong>Qwen LLM</strong></a> runs locally on EIC7700X NPU today. Probably Next: <a href="https://www.llama.com/"><strong>Llama LLM</strong></a> and <a href="https://github.com/deepseek-ai/DeepSeek-LLM"><strong>DeepSeek LLM</strong></a>?</p>
<p><em>(Qwen 2 with 0.5 Billion Parameters, pic below)</em></p>
<p><img src="https://lupyuen.org/images/starpro64-qwen.jpg" alt="Qwen LLM on ETC7700X NPU" /></p>
</li>
<li>
<p><strong>Offline Disconnected LLM on SBC</strong> might be useful for <strong>Smart Home Security</strong>‚Ä¶</p>
<p><em>‚ÄúHi LLM: Please connect my Home Security System to this Doorbell Camera and my IKEA Zigbee Lights and Xiaomi Motion Sensor and Samsung TV‚Äù</em></p>
</li>
<li>
<p><strong>Creature Sensor</strong> Maybe? A Remote Sensor that uses Cameras to identify Rainforest Critters and Underwater Creatures. But everything it sees becomes ultra-compressed into <strong>16 bytes of text</strong>‚Ä¶</p>
<p><em>‚ÄúDUCK!‚Äù ‚ÄúOCTOPUS!‚Äù (Pic below)</em></p>
</li>
<li>
<p><a href="https://github.com/eswincomputing/linux-stable/tree/linux-6.6.18-EIC7X/drivers/soc/eswin/ai_driver/npu"><strong>EIC7700X NPU Driver</strong></a> is Dual-Licensed: BSD and GPL. Which means we can run it on all kinds of software platforms and create interesting apps.</p>
</li>
<li>
<p><strong>Will it be Expensive?</strong> We hear that StarPro64 will be priced <em>super affordably</em>. Works with a Touchscreen too. (Pic above)</p>
<p>This is the right time to experiment with an <strong>Offline Disconnected LLM</strong>!</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/starpro64-sensor.jpg" alt="LLM Creature Sensor: A Remote Sensor that uses Cameras to identify Rainforest Critters and Underwater Creatures. But everything it sees becomes ultra-compressed into 16 bytes of text" /></p>
<span style="font-size:60%">
<p>(Here‚Äôs an idea for Sci-Fi Horror: We install an LLM Sensor in a Remote Uninhabited Island. One day we receive sinister words from our LLM Sensor: ‚ÄúEVIL!‚Äù, ‚ÄúDEATH!‚Äù, ‚ÄúDOOM!‚Äù‚Ä¶)</p>
</span>
<p><em>Isn‚Äôt Linux a little wonky on StarPro64?</em></p>
<p>Ah here‚Äôs our opportunity to create a <em>‚ÄúPower Efficient‚Äù (?)</em> LLM with NuttX‚Ä¶</p>
<ul>
<li>
<p>We port the <a href="https://github.com/eswincomputing/linux-stable/tree/linux-6.6.18-EIC7X/drivers/soc/eswin/ai_driver/npu"><strong>EIC7700X NPU Driver</strong></a> to NuttX. <em>(Dual-Licensed: BSD and GPL)</em></p>
</li>
<li>
<p>To Execute the LLM Models: We‚Äôll need <a href="https://github.com/ggml-org/llama.cpp"><strong>llama.cpp</strong></a> <em>(C++)</em> or <a href="https://github.com/ollama/ollama/blob/main/model/models/llama/model.go"><strong>ollama</strong></a> <em>(GoLang)</em></p>
</li>
</ul>
<p><em>Odd name innit: Qwen?</em></p>
<p><strong>Qwen</strong> will sound confusing to Bilingual Folks‚Ä¶</p>
<ul>
<li>
<p>It‚Äôs NOT supposed to rhyme with Gwen Stefani / Gwen Stacy</p>
</li>
<li>
<p>Instead it‚Äôs pronounced <strong>‚ÄúQ Wen‚Äù</strong></p>
</li>
<li>
<p>And it confuses me: <em>‚ÄúQ = Question‚Äù</em> and <em>‚ÄúWen = ÈóÆ = Question‚Äù</em>, thus contracting to <em>‚ÄúQQ‚Äù</em>, which means <em>‚ÄúBouncy‚Äù</em></p>
</li>
<li>
<p>Thankfully <em>‚ÄúQ Wen‚Äù</em> actually means something: <strong>‚ÄúÂçÉÈóÆ‚Äù</strong> <em>(Ask a Thousand Questions, ‚ÄúQian1 Wen4‚Äù)</em></p>
</li>
<li>
<p>Which is short for <strong>‚ÄúÈÄö‰πâÂçÉÈóÆ‚Äù</strong> <em>(Tong1 Yi4 Qian1 Wen4)</em>, meaning <a href="https://baike.baidu.com/item/%E9%80%9A%E4%B9%89/64394178"><strong>‚ÄúÈÄöÊÉÖÔºåËææ‰πâ‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/starpro64-flow.jpg" alt="StarPro64 with Smart Power Plug" /></p>
<h1 id="smart-power-plug"><a class="doc-anchor" href="#smart-power-plug">¬ß</a>10 Smart Power Plug</h1>
<p><em>Flipping StarPro64 on and off. Again and again. Must be an easier way?</em></p>
<p>Try a <strong>Smart Power Plug</strong> (pic above), integrated with our Build Script.</p>
<p>In our <a href="https://youtu.be/Yr7aYNIMUsw"><strong>Demo Video</strong></a>: Skip to <a href="https://youtu.be/Yr7aYNIMUsw?t=35"><strong>00:35</strong></a> and watch our <a href="https://gist.github.com/lupyuen/d13b000da6bb0004121685f80a2a845f#file-build-nuttx-starpro64-log-L1211-L1222"><strong>Build Script</strong></a> auto-power up StarPro64‚Ä¶</p>
<ol>
<li>
<p>Our Script will build the <strong>NuttX Image</strong> and copy to TFTP Server</p>
</li>
<li>
<p>Power StarPro64 <strong>Off then On</strong></p>
</li>
<li>
<p>Wait Manually for <strong>Testing to Complete</strong> <em>(‚ÄúPress Enter‚Äù)</em></p>
</li>
<li>
<p>And <strong>Power Off</strong> StarPro64</p>
</li>
</ol>
<p>How it works? Here‚Äôs our <strong>Build Script</strong>: <a href="https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac#file-run-sh-L118-L163">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Omitted: Build the NuttX Image and copy to TFTP Server
## make -j ...

## Get the Home Assistant Token, copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait Manually for SBC Testing to complete
## Don&#39;t wait too long, it will overheat!
echo Press Enter to Power Off
read

## Power Off the SBC, because it will overheat!
## Excessive Heatiness needs Oldenlandia Cooling Water?  
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.starpro64_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac#file-run-sh-L118-L163">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/d13b000da6bb0004121685f80a2a845f">(See the <strong>Build Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-power1.jpg" alt="Smart Power Plug in IKEA App and Google Home" /></p>
<p>This script assumes that we have‚Ä¶</p>
<ul>
<li>
<p>Installed a <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Home Assistant Server</strong></a></p>
<p><em>(Works fine with Docker)</em></p>
</li>
<li>
<p>Added the Smart Power Plug to <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant</strong></a></p>
<p><em>‚ÄúStarPro64 Power‚Äù (pic above)</em></p>
</li>
<li>
<p>Installed the <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant SDK</strong></a> for Home Assistant</p>
<p><em>(So we don‚Äôt need Zigbee programming)</em></p>
</li>
<li>
<p>Created the <a href="https://lupyuen.github.io/articles/sg2000a#call-the-home-assistant-api"><strong>Power Automation</strong></a> in Home Assistant</p>
<p><em>‚ÄúStarPro64 Power On‚Äù</em> and <em>‚ÄúStarPro64 Power Off‚Äù (pic below)</em></p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/starpro64-power2.jpg" alt="Smart Power Plug in Home Assistant" /></p>
<p><em>Smart Power Plug might disconnect USB UART sometimes?</em></p>
<p>To work around this: We run a loop for the <strong>UART Terminal</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## First Time Only
echo &quot;defscrollback 1000000&quot; &gt;&gt; ~/.screenrc

## On Power Off: USB Serial might disconnect
## So we reconnect forever
set -x
for (( ; ; )) do 
  screen /dev/ttyUSB* 115200
  sleep 5
done</code></pre></div>
<p><em>(We could actually allow a Remote Developer to boot and test NuttX on StarPro64‚Ä¶ From anywhere in the world!)</em></p>
<p>Remember our <a href="https://lupyuen.github.io/articles/starpro64#starpro64-gets-smokin-hot"><strong>USB Fan</strong></a>? It goes into our Smart Power Plug as a Power Jenga like so‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.org/images/starpro64-power3.jpg" alt="USB Fan goes into our Smart Power Plug as a Power Jenga" /></p>
</blockquote>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>11 What‚Äôs Next</h1>
<p>We‚Äôre upstreaming StarPro64 to <strong>NuttX Mainline</strong> right now! Stay tuned for updates.</p>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/starpro64.md"><strong>lupyuen.org/src/starpro64.md</strong></a></p>
<p><img src="https://lupyuen.org/images/starpro64-hartid0.png" alt="NuttX boots only on Hart 0" /></p>
<h1 id="appendix-multiple-harts-on-starpro64"><a class="doc-anchor" href="#appendix-multiple-harts-on-starpro64">¬ß</a>12 Appendix: Multiple Harts on StarPro64</h1>
<p><em>Multiple Harts are problematic. Why?</em></p>
<p>Inside EIC7700X SoC: We have <strong>Four Harts</strong> (RISC-V CPU Cores) numbered 0 to 3.</p>
<p>This SoC will boot OpenSBI on <strong>Any Random Hart</strong>, 0 to 3! Which means U-Boot and NuttX will subsequently boot on the <strong>Same Random Hart</strong>.</p>
<p><em>What‚Äôs the problem?</em></p>
<p>NuttX assumes that it always <strong>Boots on Hart 0</strong>. (Pic above)</p>
<p>When NuttX boots on <strong>Harts 1 to 3</strong>: Our <a href="https://lupyuen.github.io/articles/starpro64#risc-v-boot-code"><strong>RISC-V Boot Code</strong></a> calls <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_macros.S#L383-L423"><strong>riscv_set_inital_sp</strong></a>. Which <strong>will fail</strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_macros.S#L383-L423">riscv_macros.S</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set inital sp for riscv core. This function should be only called when initing.
## TODO: Support Non-Zero Boot Hart.
.macro riscv_set_inital_sp base, size, hartid
  la      t0, \base
  li      t1, \size
  mul     t1, \hartid, t1
  add     t0, t0, t1

  ## Ensure the last XCPTCONTEXT_SIZE is reserved for non boot CPU
  bnez \hartid, 998f
  li   t1, STACK_ALIGN_DOWN(\size)
  j    999f
998:
  li   t1, STACK_ALIGN_DOWN(\size - XCPTCONTEXT_SIZE)
999:
  add  t0, t0, t1
  mv   sp, t0
.endm</code></pre></div>
<p><em>How to fix this?</em></p>
<p>Our workaround is to <a href="https://lupyuen.github.io/articles/starpro64#nuttx-start-code"><strong>Always Reboot NuttX on Hart 0</strong></a>‚Ä¶</p>
<ol>
<li>
<p><strong>If Boot Hart is Not 0:</strong></p>
<p>Restart NuttX with Hart 0</p>
</li>
<li>
<p><strong>If Boot Hart is 0:</strong></p>
<p>Continue Starting NuttX</p>
</li>
</ol>
<p><em>Harts vs CPUs: What‚Äôs the difference?</em></p>
<p>NuttX insists on booting with CPU 0. Otherwise it fails with this <a href="https://gist.github.com/lupyuen/7278c35c3d556a5d4574668b54272fef"><strong>nx_start Error</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>[CPU2] dump_assert_info:
Assertion failed up_cpu_index() == 0: 
at file: init/nx_start.c:745 task(CPU2):
CPU2 IDLE process: Kernel 0x802019a6</code></pre></div>
<p>That‚Äôs why we <a href="https://lupyuen.github.io/articles/starpro64#nuttx-start-code"><strong>Renumber the CPUs</strong></a>: Boot Hart is always <strong>CPU 0</strong>. Other Harts become <strong>CPUs 1 to 3</strong>. For Example: If <em>boot_hartid=2</em> then‚Ä¶</p>
<ul>
<li><em>hart=2, cpu=0</em></li>
<li><em>hart=0, cpu=1</em></li>
<li><em>hart=1, cpu=2</em></li>
<li><em>hart=3, cpu=3</em></li>
</ul>
<p><em>Can‚Äôt we use One Hart and ignore the Other Harts?</em></p>
<p>OK Mister Cold-Harted: We tried <a href="https://github.com/lupyuen2/wip-nuttx/commits/starpro64c"><strong>Enabling One Hart Only (CPU 0)</strong></a>. But OSTest <a href="https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6"><strong>hangs at sem_test</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## OSTest hangs for StarPro64 when we enable One Hart only...
user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191
## Oops: Thread 1 is NOT started!

sem_test: Starting waiter thread 2
sem_test: Set thread 2 priority to 128
waiter_func: Thread 2 Started

## Oops: Semaphore Value should be -1!
waiter_func: Thread 2 initial semaphore value = 0
waiter_func: Thread 2 waiting on semaphore
## Hangs here</code></pre></div>
<p>Compare the above with <a href="https://github.com/lupyuen/nuttx-sg2000/releases/tag/nuttx-sg2000-2025-02-23"><strong>SG2000 sem_test</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## OSTest runs OK for SG2000...
user_main: semaphore test
sem_test: Initializing semaphore to 0
sem_test: Starting waiter thread 1
sem_test: Set thread 1 priority to 191
## Yep Thread 1 is started
waiter_func: Thread 1 Started

sem_test: Starting waiter thread 2
waiter_func: Thread 1 initial semaphore value = 0
sem_test: Set thread 2 priority to 128
waiter_func: Thread 1 waiting on semaphore
waiter_func: Thread 2 Started

## Yep Semaphore Value is -1
waiter_func: Thread 2 initial semaphore value = -1
waiter_func: Thread 2 waiting on semaphore
sem_test: Starting poster thread 3
## Completes successfully</code></pre></div>
<p>Here‚Äôs the problem: <a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/sem.c#L159-L253"><strong>sem_test</strong></a> calls <a href="https://github.com/apache/nuttx/blob/master/sched/pthread/pthread_create.c#L179-L412"><strong>nx_pthread_create</strong></a> to create <strong>Thread #1</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int nx_pthread_create(...) { ...
#ifdef CONFIG_SMP
  // pthread_setup_scheduler() will set the affinity mask by inheriting the
  // setting from the parent task.  We need to override this setting
  // with the value from the pthread attributes unless that value is
  // zero:  Zero is the default value and simply means to inherit the
  // parent thread&#39;s affinity mask.
  if (attr-&gt;affinity != 0) {
    ptcb-&gt;cmn.affinity = attr-&gt;affinity;
  }
#endif</code></pre></div>
<p>But‚Ä¶</p>
<ul>
<li>
<p>Our New Thread defaults to <strong>No CPU Affinity</strong></p>
</li>
<li>
<p>Thus it <strong>Lacks Affinity for CPU 0</strong></p>
</li>
<li>
<p>So it gets allocated to <strong>Another CPU</strong></p>
</li>
<li>
<p>Which <strong>never runs</strong>!</p>
</li>
</ul>
<p>Hence <a href="https://github.com/apache/nuttx-apps/blob/master/testing/ostest/sem.c#L244-L253"><strong>sem_test loops forever</strong></a> waiting for the Semaphore Value to change.</p>
<p><a href="https://youtu.be/70DQ4YlQMMw">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/901365650d8f908a7caa431de4e84ff6">(See the <strong>NuttX Log</strong>)</a></p>
<p><em>In Future: How to enable Multiple Harts?</em></p>
<p>To <strong>Enable Multiple Harts</strong> in future, we undo these changes‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/commit/6b321e1cd56bf74b0529711bfad62780291f841b"><strong>‚ÄúStarPro64: Disable SMP‚Äù</strong></a></li>
</ul>
<p>Remember to update the <a href="https://github.com/lupyuen2/wip-nuttx/commit/6b321e1cd56bf74b0529711bfad62780291f841b#diff-82b3bf6ae151a2f4e1fb9b23de18af9fd683accc70aff2c88e0b5d6d0e26904b"><strong>StarPro64 defconfig</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Enable SMP with 4 CPUs
CONFIG_SMP=y
CONFIG_SMP_NCPUS=4</code></pre></div>
<p>And remember to fix <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_macros.S#L383-L423"><strong>riscv_set_inital_sp</strong></a>. Meanwhile let‚Äôs run everything on Hart 0‚Ä¶</p>
<p><img src="https://lupyuen.org/images/starpro64-build.png" alt="NuttX Build for StarPro64" /></p>
<h1 id="appendix-build-nuttx-for-starpro64"><a class="doc-anchor" href="#appendix-build-nuttx-for-starpro64">¬ß</a>13 Appendix: Build NuttX for StarPro64</h1>
<p><em>Earlier we booted Image-starpro64 over TFTP. How to get the file?</em></p>
<p>Download the file <strong><code>Image</code></strong> from below and rename it <strong><code>Image-starpro64</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/starpro64-1"><strong>NuttX Build for StarPro64</strong></a></li>
</ul>
<p>If we prefer to build NuttX ourselves‚Ä¶</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv-none-elf</strong> (xPack)‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v"><strong>‚ÄúxPack GNU RISC-V Embedded GCC Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and Build <strong>NuttX for StarPro64</strong> (work-in-progress)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch starpro64
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch starpro64
cd nuttx
tools/configure.sh milkv_duos:nsh

## Build the NuttX Kernel and Apps
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Copy the NuttX Image and Device Tree to TFTP Server
wget https://github.com/lupyuen2/wip-nuttx/releases/download/starpro64-1/jh7110-star64-pine64.dtb
scp Image tftpserver:/tftpboot/Image-starpro64
scp jh7110-star64-pine64.dtb tftpserver:/tftpboot/
ssh tftpserver ls -l /tftpboot

## In U-Boot: Boot NuttX over TFTP
## setenv tftp_server 192.168.31.10 ; dhcp ${kernel_addr_r} ${tftp_server}:Image-starpro64 ; tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; fdt addr ${fdt_addr_r} ; booti ${kernel_addr_r} - ${fdt_addr_r}</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/16cd1ba3a56de1928cb956503ebdb9ac">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/d13b000da6bb0004121685f80a2a845f">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/starpro64-1">(See the <strong>Build Outputs</strong>)</a></p>
</li>
<li>
<p>The steps above assume that we‚Äôve installed our TFTP Server, according to the <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>instructions here</strong></a></p>
</li>
<li>
<p>Then follow these steps to boot NuttX on StarPro64‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#boot-nuttx-over-tftp"><strong>‚ÄúBoot NuttX over TFTP‚Äù</strong></a></p>
</li>
<li>
<p>Powering StarPro64 on and off can get tiresome. Try a Smart Power Plug, integrated with our Build Script‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#smart-power-plug"><strong>‚ÄúSmart Power Plug‚Äù</strong></a></p>
</li>
<li>
<p>How did we port NuttX to StarPro64? Check the details here‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-port-nuttx-to-starpro64"><strong>‚ÄúPort NuttX to StarPro64‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/mmu-l3user.jpg" alt="Virtual Memory for NuttX Apps" /></p>
<p><em>Why the RAM Disk? Isn‚Äôt NuttX an RTOS?</em></p>
<p>StarPro64 uses a RAM Disk because it runs in <strong>NuttX Kernel Mode</strong> (instead of the typical Flat Mode). This means we can do <strong>Memory Protection</strong> and <strong>Virtual Memory</strong> for Apps. (Pic above)</p>
<p>But it also means we need to bundle the <strong>NuttX Apps as ELF Files</strong>, hence the RAM Disk‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/app"><strong>‚ÄúNuttX Apps and Initial RAM Disk‚Äù</strong></a></li>
</ul>
<p>Most of the NuttX Platforms run on <strong>NuttX Flat Mode</strong>, which has NuttX Apps Statically-Linked into the NuttX Kernel.</p>
<p>NuttX Flat Mode works well for Small Microcontrollers. But StarPro64 and other SoCs will need the more sophisticated <strong>NuttX Kernel Mode</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode"><strong>‚ÄúNuttX Flat Mode vs Kernel Mode‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.org/images/starpro64-ostest.png" alt="NuttX boots OK on StarPro64 yay!" /></p>
<h1 id="appendix-port-nuttx-to-starpro64"><a class="doc-anchor" href="#appendix-port-nuttx-to-starpro64">¬ß</a>14 Appendix: Port NuttX to StarPro64</h1>
<p><em>How did we port NuttX to StarPro64? In under One Week?</em></p>
<p>We took the NuttX Port of <strong>Milk-V Duo S (Oz64 SG2000)</strong> and tweaked it for <strong>StarPro64 EIC7700X</strong>, with these minor modifications‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files"><strong>Modified Files: NuttX for StarPro64</strong></a></p>
</li>
<li>
<p><a href="https://gist.github.com/lupyuen/2823528f7b53375f080256bc798b2bf5"><strong>NuttX Log for StarPro64</strong></a></p>
</li>
</ul>
<p>Here‚Äôs what we changed‚Ä¶</p>
<h2 id="risc-v-boot-code"><a class="doc-anchor" href="#risc-v-boot-code">¬ß</a>14.1 RISC-V Boot Code</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-d8bd71e8ea93fc23ec348eeaca3d45f89dc896eff80311583d758d42e6e8fc58"><em>arch/risc-v/src/sg2000/sg2000_head.S</em></a></p>
<p>This is the <strong>RISC-V Boot Code</strong> that runs first when U-Boot Bootloader starts NuttX.</p>
<p>In the <strong>Linux Kernel Header</strong>: We modified the Kernel Size based on U-Boot (<code>fdt_addr_r</code> - <code>kernel_addr_r</code>)</p>
<p>This ensures that the <strong>Entire NuttX Image</strong> (including Initial RAM Disk) will be copied correctly from <code>kernel_addr_r</code> <em>(0x8400_0000)</em> to <code>loadaddr</code> <em>(0x8020_0000)</em></p>
<div class="example-wrap"><pre class="language-c"><code>/* Linux Kernel Header*/
__start:
  ...
  .quad  0x4000000  /* Kernel size (fdt_addr_r-kernel_addr_r) */</code></pre></div>
<p>We inserted this code to print ‚Äú<code>123</code>‚Äù to UART0 at startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* NuttX Boots Here */
real_start:

  /* Print `123` to UART */
  /* Load UART Base Address to Register t0 */
  li  t0, 0x50900000

  /* Load `1` to Register t1 */
  li  t1, 0x31
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `2` to Register t1 */
  li  t1, 0x32
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)

  /* Load `3` to Register t1 */
  li  t1, 0x33
  /* Store byte from Register t1 to UART Base Address, Offset 0 */
  sb  t1, 0(t0)</code></pre></div>
<p>The Original Code assumes that we always <strong>Boot at Hart 0</strong>. But EIC7700X will <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Boot From Any Hart</strong></a>. (0 to 3)</p>
<p>This modification allows NuttX to Boot from any Hart‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  /* TODO SMP: Enable this for SMP
  /* If a0 (hartid) &gt;= t1 (the number of CPUs), stop here
  blt  a0, t1, 3f
  csrw CSR_SIE, zero
  wfi
  */

3:
  /* Set stack pointer to the idle thread stack */
  li a2, 0
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a2

  /* TODO SMP: Enable this for SMP
  riscv_set_inital_sp SG2000_IDLESTACK_BASE, SMP_STACK_SIZE, a0
  */</code></pre></div>
<p>Right now we support <strong>One Single Hart</strong> for EIC7700X. ‚Äú<code>TODO</code> <code>SMP</code>‚Äù flags the code that will be modified (in future) to support Multiple Harts for EIC7700X.</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<h2 id="nuttx-start-code"><a class="doc-anchor" href="#nuttx-start-code">¬ß</a>14.2 NuttX Start Code</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-84111f6f800efef513a2420c571ea39fe2068d19cff6c1eab015da0f9755b9c7"><em>arch/risc-v/src/sg2000/sg2000_start.c</em></a></p>
<p>NuttX boots here, called by the RISC-V Boot Code (from above). We made these changes to allow <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Booting from Any Hart</strong></a>‚Ä¶</p>
<ol>
<li>
<p><strong>If Boot Hart is Not 0:</strong></p>
<p>Restart NuttX with Hart 0</p>
</li>
<li>
<p><strong>If Boot Hart is 0:</strong></p>
<p>Continue Starting NuttX</p>
</li>
</ol>
<div class="example-wrap"><pre class="language-c"><code>// We remember the Boot Hart ID (0 to 3)
int boot_hartid = -1;

// NuttX boots here, called by the RISC-V Assembly Boot Code
void sg2000_start(int mhartid) {

  // UART Driver is not up yet. We print the primitive way.
  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;e&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;l&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;o&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39; &#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;N&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;u&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;X&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;!&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;

  // Print the Hart ID (0 to 3)
  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;
  up_mdelay(1000);  // Wait a while for UART Queue to flush

  // If Boot Hart is not 0: Restart NuttX with Hart 0
  if (mhartid != 0) {

    //  Clear the BSS and Restart with Hart 0
    //  __start points to our RISC-V Assembly Start Code
    sg2000_clear_bss();
    riscv_sbi_boot_secondary(0, (uintptr_t)&amp;__start);

    // Let this Hart idle forever (while Hart 0 runs)
    while (true) { asm(&quot;WFI&quot;); }  
    PANIC();  // Should never come here
  }

  // Else Boot Hart is 0: We have successfully booted NuttX on Hart 0!
  if (boot_hartid &lt; 0) {

    // Init the globals once only. Remember the Boot Hart.
    // Clear the BSS
    boot_hartid = mhartid;
    sg2000_clear_bss();

    // TODO SMP: Start the Other Harts by calling OpenSBI
    // sg2000_boot_secondary();

    // Copy the RAM Disk
    // Initialize the per CPU areas
    sg2000_copy_ramdisk();
    riscv_percpu_add_hart(mhartid);
  }
  // Omitted: Call sg2000_start_s</code></pre></div>
<p>The code below will be used (in future) to support <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Multiple Harts</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Boot NuttX on the Hart
void sg2000_start_s(int mhartid) {

  // Configure the FPU
  // If this is not the Boot Hart: Jump to cpux
  riscv_fpuconfig();
  if (mhartid != boot_hartid) { goto cpux; }

  // Omitted: Boot Hart starts here and calls nx_start()
  ...

cpux:
  // TODO SMP: Non-Boot Hart starts here.
  // We print the Hart ID and init the NuttX CPU
  *(volatile uint8_t *) 0x50900000ul = &#39;H&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;a&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;t&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;0&#39; + mhartid;
  *(volatile uint8_t *) 0x50900000ul = &#39;\r&#39;;
  *(volatile uint8_t *) 0x50900000ul = &#39;\n&#39;;
  riscv_cpu_boot(mhartid);</code></pre></div>
<p>How to <strong>Restart NuttX on Hart 0</strong>? By calling <strong>OpenSBI</strong>, adapted from <a href="https://github.com/apache/nuttx/blob/fb853be004c5960cd6bdd210e892ae88d96c9b9f/arch/risc-v/src/common/supervisor/riscv_sbi.c#L46-L158"><strong>riscv_sbi.c</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// We start a Hart (0 to 3) by calling OpenSBI
// addr points to our RISC-V Assembly Start Code
static int riscv_sbi_boot_secondary(uintreg_t hartid, uintreg_t addr) {

  // Make an ECALL to OpenSBI
  sbiret_t ret = sbi_ecall(
    SBI_EXT_HSM, SBI_EXT_HSM_HART_START,
    hartid, addr, 0, 0, 0, 0
  );

  // Check for OpenSBI Errors
  if (ret.error &lt; 0) { _err(&quot;Boot Hart %d failed\n&quot;, hartid); PANIC(); }
  return 0;
}

// Make an ECALL to OpenSBI
static sbiret_t sbi_ecall(unsigned int extid, unsigned int fid, uintreg_t parm0, uintreg_t parm1, uintreg_t parm2, uintreg_t parm3, uintreg_t parm4, uintreg_t parm5) {
  register long r0 asm(&quot;a0&quot;) = (long)(parm0);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);
  register long r4 asm(&quot;a4&quot;) = (long)(parm4);
  register long r5 asm(&quot;a5&quot;) = (long)(parm5);
  register long r6 asm(&quot;a6&quot;) = (long)(fid);
  register long r7 asm(&quot;a7&quot;) = (long)(extid);
  sbiret_t ret;

  asm volatile
    (
     &quot;ecall&quot;
     : &quot;+r&quot;(r0), &quot;+r&quot;(r1)
     : &quot;r&quot;(r2), &quot;r&quot;(r3), &quot;r&quot;(r4), &quot;r&quot;(r5), &quot;r&quot;(r6), &quot;r&quot;(r7)
     : &quot;memory&quot;
     );
  ret.error = r0;
  ret.value = (uintreg_t)r1;
  return ret;
}

// OpenSBI returns an Error Code and Result Value
struct sbiret_s {
  intreg_t    error;
  uintreg_t   value;
};
typedef struct sbiret_s sbiret_t;

// These are the Standard OpenSBI Extension Codes
#define SBI_EXT_HSM (0x0048534D)
#define SBI_EXT_HSM_HART_START (0x0)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>For Multiple Harts</strong></a> in future: We shall start the other Non-Boot Harts by calling OpenSBI‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// TODO SMP: Start the other Non-Boot Harts by calling OpenSBI
static void sg2000_boot_secondary(void) {
  for (int i = 0; i &lt; CONFIG_SMP_NCPUS; i++) {
    if (i == boot_hartid) { continue; }
    riscv_sbi_boot_secondary(i, (uintptr_t)&amp;__start);
  }
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>For Multiple Harts</strong></a> in future: NuttX insists on <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Booting with CPU 0 Only</strong></a>. Thus we set <strong>Boot Hart as CPU 0</strong>, and we Renumber the Other Harts‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// TODO SMP: Convert Hart ID to CPU ID.
// Boot Hart is CPU 0. Renumber the Other Harts.
int weak_function riscv_hartid_to_cpuid(int hart) {
  if (hart == boot_hartid)
    { return 0; }
  else if (hart &lt; boot_hartid)
    { return hart + 1; }
  else
    { return hart; }
}

// TODO SMP: Convert CPU ID to Hart ID.
// Boot Hart is CPU 0. Renumber the Other Harts.
int weak_function riscv_cpuid_to_hartid(int cpu) {
  if (cpu == 0)
    { return boot_hartid; }
  else if (cpu &lt; boot_hartid + 1)
    { return cpu - 1; }
  else
    { return cpu; }
}</code></pre></div>
<p><strong>For Example:</strong> If <em>boot_hartid=2</em> then‚Ä¶</p>
<ul>
<li><em>hart=0, cpu=1</em></li>
<li><em>hart=1, cpu=2</em></li>
<li><em>hart=2, cpu=0</em></li>
<li><em>hart=3, cpu=3</em></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<h2 id="plic-interrupt-controller"><a class="doc-anchor" href="#plic-interrupt-controller">¬ß</a>14.3 PLIC Interrupt Controller</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-523f77920746a4b6cb3e02ef9dfb71223593ae328aa8019e8d8fd730b828ab9f"><em>arch/risc-v/include/sg2000/irq.h</em></a></p>
<div class="example-wrap"><pre class="language-c"><code>// Number of External Interrupts
// Offset by RISCV_IRQ_SEXT
#define NR_IRQS (RISCV_IRQ_SEXT + 458)</code></pre></div>
<p>That‚Äôs because EIC7700X supports <strong>458 External Interrupts</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 374</th></tr></thead><tbody>
<tr><td style="text-align: left">Max Interrupts</td><td style="text-align: left">458</td></tr>
</tbody></table>
</div></div>
</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-14db47e674d6ddcbffc6f855a536a173b5833e3bd96a3490a45f1ef94e3b2767"><em>arch/risc-v/src/sg2000/hardware/sg2000_memorymap.h</em></a></p>
<div class="example-wrap"><pre class="language-c"><code>// PLIC Base Address
#define SG2000_PLIC_BASE 0x0C000000ul</code></pre></div>
<p><strong>PLIC Base Address</strong> is specified here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 239</th></tr></thead><tbody>
<tr><td style="text-align: left">PLIC Memory Map</td><td style="text-align: left"><em>0x0C00_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-64c2a42d4a59409becf86f2967d2a27ff48635231437f56620d3e86a28002a28"><em>arch/risc-v/src/sg2000/hardware/sg2000_plic.h</em></a></p>
<div class="example-wrap"><pre class="language-c"><code>// PLIC Interrupt Priority: Single Global Register
#define SG2000_PLIC_PRIORITY (SG2000_PLIC_BASE + 0x000000)

// Hart 0 S-Mode Interrupt Enable and Offset Between Harts
#define SG2000_PLIC_ENABLE0     (SG2000_PLIC_BASE + 0x002080)
#define SG2000_PLIC_ENABLE_HART (0x100)

// Hart 0 S-Mode Priority Threshold and Offset Between Harts
#define SG2000_PLIC_THRESHOLD0     (SG2000_PLIC_BASE + 0x201000)
#define SG2000_PLIC_THRESHOLD_HART (0x2000)

// Hart 0 S-Mode Claim / Complete and Offset Between Harts
#define SG2000_PLIC_CLAIM0     (SG2000_PLIC_BASE + 0x201004)
#define SG2000_PLIC_CLAIM_HART (0x2000)</code></pre></div>
<p><strong>Interrupt Enable: PLIC_ENABLE_HART</strong> is <em>0x100</em> because we skip <em>0x100</em> bytes per Hart‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 240</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><em>0x0C00_2080</em></td><td style="text-align: left">Start Hart 0 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left"><em>0x0C00_2180</em></td><td style="text-align: left">Start Hart 1 S-Mode interrupt enables</td></tr>
<tr><td style="text-align: left"><em>0x0C00_2280</em></td><td style="text-align: left">Start Hart 2 S-Mode interrupt enables</td></tr>
</tbody></table>
</div></div>
</p>
<p><strong>Priority Threshold: PLIC_THRESHOLD_HART</strong> is <em>0x2000</em> because we skip <em>0x2000</em> bytes per Hart</p>
<p><strong>Claim / Complete: PLIC_CLAIM_HART</strong> is <em>0x2000</em> because we skip <em>0x2000</em> bytes per Hart</p>
<p>Which comes from this‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 241</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>(Skip the M-Modes)</em></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><em>0x0C20_1000</em></td><td style="text-align: left">Hart 0 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left"><em>0x0C20_1004</em></td><td style="text-align: left">Hart 0 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left"><em>0x0C20_3000</em></td><td style="text-align: left">Hart 1 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left"><em>0x0C20_3004</em></td><td style="text-align: left">Hart 1 S-Mode Claim / Complete</td></tr>
<tr><td style="text-align: left"><em>0x0C20_5000</em></td><td style="text-align: left">Hart 2 S-Mode Priority Threshold</td></tr>
<tr><td style="text-align: left"><em>0x0C20_5004</em></td><td style="text-align: left">Hart 2 S-Mode Claim / Complete</td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-0c39d310c3819d6b7bfecb05f6a203019d0f937b171abe539f299fa37805b366"><em>arch/risc-v/src/sg2000/sg2000_irq.c</em></a></p>
<p>In future we shall support <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Multiple Harts</strong></a>. That‚Äôs why we extended this code to <strong>Initialize the Interrupts</strong> for Harts 0 to 3‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Initialize the Interrupts
void up_irqinitialize(void) { ...

  // Disable all global interrupts
  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++) {
    addr = SG2000_PLIC_ENABLE0 + (hart * SG2000_PLIC_ENABLE_HART);
    for (offset = 0; offset &lt; (NR_IRQS - RISCV_IRQ_EXT) &gt;&gt; 3; offset += 4) {
      putreg32(0x0, addr + offset);          
    }
  }

  // Clear pendings in PLIC
  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++) {
    addr = SG2000_PLIC_CLAIM0 + (hart * SG2000_PLIC_CLAIM_HART);
    claim = getreg32(addr);
    putreg32(claim, addr);
  }

  // Set irq threshold to 0 (permits all global interrupts)
  for (hart = 0; hart &lt; CONFIG_SMP_NCPUS; hart++) {
    addr = SG2000_PLIC_THRESHOLD0 + (hart * SG2000_PLIC_THRESHOLD_HART);
    putreg32(0, addr);
  }</code></pre></div>
<p>We do this to <strong>Disable the Interrupts</strong> for Boot Hart 0 to 3 (in future)</p>
<div class="example-wrap"><pre class="language-c"><code>// Disable the Interrupt
void up_disable_irq(int irq) { ...

  // Clear enable bit for the irq
  if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT) {
    addr = SG2000_PLIC_ENABLE0 + 
           (boot_hartid * SG2000_PLIC_ENABLE_HART);
    modifyreg32(addr + (4 * (extirq / 32)),
                1 &lt;&lt; (extirq % 32), 0);
  }</code></pre></div>
<p>And this to <strong>Enable the Interrupts</strong> for Boot Hart 0 to 3 (in future)</p>
<div class="example-wrap"><pre class="language-c"><code>// Enable the Interrupt
void up_enable_irq(int irq) { ...

  // Set enable bit for the irq
  if (0 &lt;= extirq &amp;&amp; extirq &lt;= NR_IRQS - RISCV_IRQ_EXT) {
    addr = SG2000_PLIC_ENABLE0 + 
           (boot_hartid * SG2000_PLIC_ENABLE_HART);
    modifyreg32(addr + (4 * (extirq / 32)),
                0, 1 &lt;&lt; (extirq % 32));
  }</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-75ceaf9a0a70840fc2e15cea303fff5e9d2339d4f524574df94b5d0ec46e37ea"><em>arch/risc-v/src/sg2000/sg2000_irq_dispatch.c</em></a></p>
<p>In future we shall support <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Multiple Harts</strong></a>. That‚Äôs why we extended this code to <strong>Dispatch the Interrupt</strong> for Boot Hart 0 to 3‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Dispatch the Interrupt
void *riscv_dispatch_irq(uintptr_t vector, uintptr_t *regs) {
  int irq = (vector &gt;&gt; RV_IRQ_MASK) | (vector &amp; 0xf);
  uintptr_t claim = SG2000_PLIC_CLAIM0 + 
                    (boot_hartid * SG2000_PLIC_CLAIM_HART);
  ...
  // Read the PLIC_CLAIM for the Boot Hart
  uintptr_t val = getreg32(claim);
  ...
  // Write PLIC_CLAIM to clear pending for Boot Hart
  putreg32(irq - RISCV_IRQ_EXT, claim);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<h2 id="memory-map"><a class="doc-anchor" href="#memory-map">¬ß</a>14.4 Memory Map</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-cacefdc3058a54e86027d411b0a6711d8a322b1750150521d5c640e72daa8b5f"><em>arch/risc-v/src/sg2000/sg2000_mm_init.c</em></a></p>
<div class="example-wrap"><pre class="language-c"><code>// I/O Memory Map
#define MMU_IO_BASE (0x00000000ul)
#define MMU_IO_SIZE (0x80000000ul)</code></pre></div>
<p>We derived the above from the <strong>EIC7700X Memory Map</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 380</th></tr></thead><tbody>
<tr><td style="text-align: left">System Memory Map</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">System Space (Low)</td><td style="text-align: left"><em>0x0000_0000</em> to <em>0x8000_0000</em></td></tr>
<tr><td style="text-align: left">Memory Space</td><td style="text-align: left"><em>0x8000_0000</em> to <em>0x10_0000_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>The rest of the Memory Map is identical to SG2000. We removed all <strong>T-Head MMU Extensions</strong>, including <strong>mmu_flush_cache</strong>.</p>
<h2 id="nuttx-config"><a class="doc-anchor" href="#nuttx-config">¬ß</a>14.5 NuttX Config</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-9c348f27c59e1ed0d1d9c24e172d233747ee09835ab0aa7f156da1b7caa6a5fb"><em>arch/risc-v/Kconfig</em></a></p>
<p>In future we shall support <a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64"><strong>Multiple Harts</strong></a>. This <strong>Arch Config</strong> will enable the <strong>Hart-To-CPU Mapping</strong> we saw earlier: <em>riscv_hartid_to_cpuid, riscv_cpuid_to_hartid</em></p>
<div class="example-wrap"><pre class="language-bash"><code>config ARCH_CHIP_SG2000
	select ARCH_RV_CPUID_MAP</code></pre></div>
<p>Also we removed <strong>ARCH_MMU_EXT_THEAD</strong>. (T-Head MMU Extensions)</p>
<p><a href="https://lupyuen.github.io/articles/starpro64#appendix-multiple-harts-on-starpro64">(<strong>Multiple Harts</strong> explained)</a></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-82b3bf6ae151a2f4e1fb9b23de18af9fd683accc70aff2c88e0b5d6d0e26904b"><em>boards/risc-v/sg2000/milkv_duos/configs/nsh/defconfig</em></a></p>
<p>We modified the <strong>NuttX Board Config</strong> for UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## UART0 Configuration
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0_BASE=0x50900000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_IRQ=125

## Enable Scheduler Debugging
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p><strong>16550_REGINCR</strong> is 4 because the UART Registers are spaced 4 bytes apart‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 524</th></tr></thead><tbody>
<tr><td style="text-align: left">UART Register Offset</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left"><em>0x0</em></td><td style="text-align: left">Receive Buffer Register (RBR)</td></tr>
<tr><td style="text-align: left"><em>0x4</em></td><td style="text-align: left">Interrupt Enable Register (IER)</td></tr>
<tr><td style="text-align: left"><em>0x8</em></td><td style="text-align: left">Interrupt Identification Register (IIR)</td></tr>
</tbody></table>
</div></div>
</p>
<p><strong>UART0 Base Address</strong> is here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part4.pdf">EIC7700X Tech Ref #4</a></th><th style="text-align: left">Page 353</th></tr></thead><tbody>
<tr><td style="text-align: left">Peripheral Address Space</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">UART0</td><td style="text-align: left"><em>0x5090_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p><strong>Why IRQ 125?</strong> UART0 Interrupt Number is 100, we add 25 because of <em>RISCV_IRQ_SEXT</em>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://github.com/eswincomputing/EIC7700X-SoC-Technical-Reference-Manual/releases/download/v1.0.0-20250103/EIC7700X_SoC_Technical_Reference_Manual_Part1.pdf">EIC7700X Tech Ref #1</a></th><th style="text-align: left">Page 366</th></tr></thead><tbody>
<tr><td style="text-align: left">UART0 Interrupt Number</td><td style="text-align: left">100 <em>(lsp_uart0_intr)</em></td></tr>
</tbody></table>
</div></div>
</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1"><em>drivers/serial/uart_16550.c</em></a></p>
<p>We commented out this code that <strong>Configures the UART Clock</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Configure the UART Clock
static int u16550_setup(FAR struct uart_dev_s *dev) { ...

#ifdef TODO
  // Enter DLAB=1
  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));
  // Omitted: Configure the UART Clock
  ...
  // Clear DLAB
  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif</code></pre></div>
<p>This will be restored when we have computed <a href="https://lupyuen.github.io/articles/release#appendix-uart-clock-for-jh7110"><strong>16550_UART0_CLOCK</strong></a>.</p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/93/files#diff-1c190e766d71f3e5a43109b975405c9e43b2d01e50f748b0f0c19a8d942caffe"><em>arch/risc-v/src/sg2000/sg2000_timerisr.c</em></a></p>
<p>Finally we changed the <strong>RISC-V Timer Frequency</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Previously for SG2000: 25000000ul
#define MTIMER_FREQ 1000000ul</code></pre></div><h2 id="paste-slowly"><a class="doc-anchor" href="#paste-slowly">¬ß</a>14.6 Paste Slowly</h2>
<p><em>U-Boot Bootloader is dropping chars when we paste long lines. How now brown cow?</em></p>
<p><strong>In iTerm</strong>: Try <strong>Edit &gt; Paste Special &gt; Paste Slowly</strong></p>
<p><strong>But Before That:</strong> Click <strong>Settings &gt; Advanced &gt; Pasteboard</strong></p>
<ul>
<li>
<p><em>‚ÄúDelay in seconds between chunks when Pasting Slowly‚Äù</em></p>
<p>Set to <strong>1 second</strong></p>
</li>
<li>
<p><em>‚ÄúNumber of bytes to paste in each chunk when Pasting Slowly‚Äù</em></p>
<p>Set to <strong>16 bytes</strong></p>
</li>
</ul>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>