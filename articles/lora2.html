<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>PineCone BL602 RISC-V Board Receives LoRa Packets</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="PineCone BL602 RISC-V Board Receives LoRa Packets" 
    data-rh="true">
<meta property="og:description" 
    content="How PineCone BL602 RISC-V Board with SX1276 receives LoRa packets... Transmitted by RAKwireless WisBlock"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lora2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">PineCone BL602 RISC-V Board Receives LoRa Packets</h1>
    <nav id="TOC"><ul>
<li><a href="#connect-bl602-to-lora-transceiver">1 Connect BL602 to LoRa Transceiver</a><ul></ul></li>
<li><a href="#initialise-lora-transceiver">2 Initialise LoRa Transceiver</a><ul></ul></li>
<li><a href="#receive-lora-packet">3 Receive LoRa Packet</a><ul>
<li><a href="#receive-callback">3.1 Receive Callback</a><ul></ul></li>
<li><a href="#timeout-and-error-callbacks">3.2 Timeout and Error Callbacks</a><ul></ul></li></ul></li>
<li><a href="#bl602-gpio-interrupts">4 BL602 GPIO Interrupts</a><ul>
<li><a href="#register-handler-function">4.1 Register Handler Function</a><ul></ul></li>
<li><a href="#gpio-interrupt-handler">4.2 GPIO Interrupt Handler</a><ul></ul></li>
<li><a href="#enqueue-interrupt-event">4.3 Enqueue Interrupt Event</a><ul></ul></li>
<li><a href="#register-handlers-for-dio0-to-dio5">4.4 Register Handlers for DIO0 to DIO5</a><ul></ul></li></ul></li>
<li><a href="#multitask-with-nimble-porting-layer">5 Multitask with NimBLE Porting Layer</a><ul>
<li><a href="#background-task">5.1 Background Task</a><ul></ul></li>
<li><a href="#event-queue">5.2 Event Queue</a><ul></ul></li>
<li><a href="#send-event">5.3 Send Event</a><ul></ul></li>
<li><a href="#receive-event">5.4 Receive Event</a><ul></ul></li>
<li><a href="#lora-events">5.5 LoRa Events</a><ul></ul></li>
<li><a href="#timer">5.6 Timer</a><ul></ul></li>
<li><a href="#source-files">5.7 Source Files</a><ul></ul></li></ul></li>
<li><a href="#start-the-rakwireless-wisblock-transmitter">6 Start the RAKwireless WisBlock Transmitter</a><ul>
<li><a href="#connect-wisblock">6.1 Connect WisBlock</a><ul></ul></li>
<li><a href="#install-vscode-and-platformio">6.2 Install VSCode and PlatformIO</a><ul></ul></li>
<li><a href="#build-the-firmware">6.3 Build the firmware</a><ul></ul></li>
<li><a href="#flash-the-firmware">6.4 Flash the firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">6.5 Run the firmware</a><ul></ul></li></ul></li>
<li><a href="#build-and-run-the-bl602-lora-firmware">7 Build and Run the BL602 LoRa Firmware</a><ul>
<li><a href="#flash-the-firmware-1">7.1 Flash the firmware</a><ul></ul></li>
<li><a href="#run-the-firmware-1">7.2 Run the firmware</a><ul></ul></li>
<li><a href="#enter-lora-commands">7.3 Enter LoRa commands</a><ul></ul></li>
<li><a href="#receive-timeout">7.4 Receive Timeout</a><ul></ul></li></ul></li>
<li><a href="#troubleshoot-lora">8 Troubleshoot LoRa</a><ul>
<li><a href="#sniff-lora-packets">8.1 Sniff LoRa Packets</a><ul></ul></li>
<li><a href="#read-registers">8.2 Read Registers</a><ul></ul></li>
<li><a href="#trace-spi-requests">8.3 Trace SPI Requests</a><ul></ul></li>
<li><a href="#show-interrupt-counters">8.4 Show Interrupt Counters</a><ul></ul></li>
<li><a href="#test-event-queue">8.5 Test Event Queue</a><ul></ul></li>
<li><a href="#bl602-stack-trace">8.6 BL602 Stack Trace</a><ul></ul></li>
<li><a href="#bl602-stack-dump">8.7 BL602 Stack Dump</a><ul></ul></li></ul></li>
<li><a href="#whats-next">9 What's Next</a><ul></ul></li>
<li><a href="#notes">10 Notes</a><ul></ul></li></ul></nav><p>üìù <em>4 Apr 2021</em></p>
<p>Not too long ago (and not so far away) we embarked on an epic quest to create a low-power, long-range <a href="https://en.wikipedia.org/wiki/LoRa"><strong>LoRa IoT Sensor</strong></a> with <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a></p>
<ol>
<li>
<p>We created a <strong>LoRa Transmitter</strong> with BL602...</p>
<p><a href="https://lupyuen.github.io/articles/lora"><strong>&quot;Connect PineCone BL602 to LoRa Transceiver&quot;</strong></a></p>
</li>
<li>
<p>Then we tested it with a <strong>LoRa Receiver</strong>: RAKwireless WisBlock...</p>
<p><a href="https://lupyuen.github.io/articles/wisblock"><strong>&quot;RAKwireless WisBlock talks LoRa with PineCone BL602 RISC-V Board&quot;</strong></a></p>
</li>
</ol>
<p>Today we shall create the LoRa Firmware for BL602 that will <strong>Receive LoRa Packets</strong>. And test it with RAKwireless WisBlock as the LoRa Transmitter.</p>
<p><em>Why do we need to receive LoRa Packets... If our BL602 LoRa Sensor will only transmit sensor data?</em></p>
<p>Because we'll soon connect our BL602 LoRa Sensor to a <strong>secure, managed LoRaWAN Network</strong> like <a href="https://www.thethingsnetwork.org/"><strong>The Things Network</strong></a>. (Or maybe <a href="https://www.helium.com/lorawan"><strong>Helium</strong></a>)</p>
<p>Our BL602 gadget can't join these networks unless it can receive packets and respond to the network.</p>
<p>Let's make it so! (Because we do... Or do not... There is no try!)</p>
<p>The LoRa Firmware in this article will run on <strong>PineCone, Pinenut and Any BL602 Board</strong>.</p>
<ul>
<li>
<p><a href="https://youtu.be/3TSvo0dwwnQ"><strong>Watch the demo video on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#lora-vs-lorawan"><strong>More about the 3 Levels of LoRa and LoRaWAN</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lora2-title.jpg" alt="PineCone BL602 RISC-V Board with Hope RF96 LoRa Transceiver (top) receives LoRa packets from RAKwireless WisBlock (bottom)" /></p>
<p><em>PineCone BL602 RISC-V Board with Hope RF96 LoRa Transceiver (top) receives LoRa packets from RAKwireless WisBlock (bottom)</em></p>
<h1 id="connect-bl602-to-lora-transceiver" class="section-header"><a href="#connect-bl602-to-lora-transceiver">1 Connect BL602 to LoRa Transceiver</a></h1>
<p>Connect BL602 to Semtech SX1276 or Hope RF96 as follows...</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect3.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<table><thead><tr><th align="left">BL602 Pin</th><th align="left">SX1276 / RF96 Pin</th><th align="left">Wire Colour</th></tr></thead><tbody>
<tr><td align="left"><strong><code>GPIO 0</code></strong></td><td align="left"><code>DIO1</code></td><td align="left">Dark Green</td></tr>
<tr><td align="left"><strong><code>GPIO 1</code></strong></td><td align="left"><code>ISO</code> <em>(MISO)</em></td><td align="left">Light Green (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 2</code></strong></td><td align="left">Do Not Connect</td><td align="left">(Unused Chip Select)</td></tr>
<tr><td align="left"><strong><code>GPIO 3</code></strong></td><td align="left"><code>SCK</code></td><td align="left">Yellow (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 4</code></strong></td><td align="left"><code>OSI</code> <em>(MOSI)</em></td><td align="left">Blue (Top)</td></tr>
<tr><td align="left"><strong><code>GPIO 5</code></strong></td><td align="left"><code>DIO2</code></td><td align="left">Blue (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 11</code></strong></td><td align="left"><code>DIO0</code></td><td align="left">Yellow (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 12</code></strong></td><td align="left"><code>DIO3</code></td><td align="left">Light Green (Bottom)</td></tr>
<tr><td align="left"><strong><code>GPIO 14</code></strong></td><td align="left"><code>NSS</code></td><td align="left">Orange</td></tr>
<tr><td align="left"><strong><code>GPIO 17</code></strong></td><td align="left"><code>RST</code></td><td align="left">White</td></tr>
<tr><td align="left"><strong><code>3V3</code></strong></td><td align="left"><code>3.3V</code></td><td align="left">Red</td></tr>
<tr><td align="left"><strong><code>GND</code></strong></td><td align="left"><code>GND</code></td><td align="left">Black</td></tr>
</tbody></table>
<p><a href="https://electronics.stackexchange.com/questions/335912/can-i-break-a-radio-tranceiving-device-by-operating-it-with-no-antenna-connected"><strong>CAUTION: Always connect the Antenna before Powering On... Or the LoRa Transceiver may get damaged! See this</strong></a></p>
<p>Here's a closer look at the pins connected on BL602...</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect4.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<p><em>Why is BL602 Pin 2 unused?</em></p>
<p><strong><code>GPIO 2</code></strong> is the <strong>Unused SPI Chip Select</strong> on BL602.</p>
<p>We won't use this pin because we'll control Chip Select ourselves on <code>GPIO 14</code>. <a href="https://lupyuen.github.io/articles/spi#control-our-own-chip-select-pin">(See this)</a></p>
<p>Here are the pins connected on our LoRa Transceiver: SX1276 or RF96...</p>
<p>(<code>ISO</code> and <code>OSI</code> appear flipped in this pic... Rotate your phone / computer screen 180 degrees for the proper perspective)</p>
<p><img src="https://lupyuen.github.io/images/lora2-connect5.jpg" alt="PineCone BL602 RISC-V Board connected to Hope RF96 LoRa Transceiver" /></p>
<p><em>Why do we connect so many pins on SX1276 (or RF96)?</em></p>
<p>The SX1276 and RF96 transceivers have <strong>6 (!) Digital Input / Output pins: <code>DIO0</code> to <code>DIO5</code></strong></p>
<p>The transceiver shifts the Logic Levels of these pins from <strong>Low to High</strong> when specific conditions occur...</p>
<ul>
<li>
<p><strong><code>DIO0</code> Packet Received</strong>: This pin is triggered when the transceiver <strong>receives a LoRa Packet.</strong></p>
<p><code>DIO0</code> is also triggered after the transceiver has transmitted a LoRa Packet, but that's not so useful.</p>
</li>
<li>
<p><strong><code>DIO1</code> Receive Timeout</strong>: This pin is triggered when the transceiver <strong>doesn't receive any LoRa Packets</strong> within a timeout window.</p>
<p>This works only when the transceiver is configured for <strong>Single Receive Mode</strong>.</p>
<p>However today we're configuring our transceiver for <strong>Continuous Receive Mode</strong> so we won't be using <code>DIO1</code>. We shall trigger receive timeouts with a BL602 Timer.</p>
</li>
<li>
<p><strong><code>DIO2</code> Change Channel</strong>: This is used for <strong>Spread Spectrum Transmission</strong> (Frequency Hopping). </p>
<p>When we transmit / receive LoRa Packets over multiple frequencies (spread spectrum), we reduce the likelihood of packet collisions over the airwaves.</p>
<p>We won't be using Spread Spectrum Transmission today, so <code>DIO2</code> shall stay idle.</p>
</li>
<li>
<p><strong><code>DIO3</code> Channel Activity Detection</strong>: The transceiver lets us <strong>detect whether there's any ongoing transmission</strong> in a LoRa Radio Channel, in a power-efficient way.</p>
<p>We won't be using Channel Activity Detection today.</p>
</li>
<li>
<p><strong><code>DIO4</code></strong> and <strong><code>DIO5</code></strong> are not connected to BL602.  They are used for <strong>FSK Radio Modulation</strong> only.</p>
<p>(We're using LoRa Radio Modulation)</p>
</li>
</ul>
<p>Only <strong>1 pin <code>DIO0</code></strong> is required for receiving simple LoRa Packets, without the frills (like Spread Spectrum Transmission).</p>
<p>But for now we shall connect <strong>4 pins <code>DIO0</code> to <code>DIO3</code></strong>, just in case they will be needed later for LoRaWAN. (Which will probably use Spread Spectrum Transmission)</p>
<p>We shall configure BL602 to trigger <strong>GPIO Interrupts</strong> when the 4 pins shift from Low to High.</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#getting-the-lora-transceiver-and-antenna"><strong>More about Semtech SX1276 and Hope RF96</strong></a></p>
</li>
<li>
<p><a href="https://semtech.my.salesforce.com/sfc/p/E0000000JelG/a/2R0000001Rbr/6EfVZUorrpoKFfvaF_Fkpgp5kzjiNyiAbqcpqh9qSjE?__hstc=212684107.81023fceb80b3e55c1c4e19a916804ba.1616925682449.1616925682449.1616925682449.1&amp;__hssc=212684107.1.1616925682449&amp;__hsfp=1469659345"><strong>Semtech SX1276 Datasheet</strong></a></p>
</li>
</ul>
<h1 id="initialise-lora-transceiver" class="section-header"><a href="#initialise-lora-transceiver">2 Initialise LoRa Transceiver</a></h1>
<p>Let's look at the code inside our LoRa Firmware for BL602: <code>sdk_app_lora</code></p>
<p><strong>Super Important:</strong> We should set the LoRa Frequency in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L43-L58"><code>demo.c</code></a> like so...</p>
<pre><code class="language-c">/// TODO: We are using LoRa Frequency 923 MHz 
/// for Singapore. Change this for your region.
#define USE_BAND_923
</code></pre>
<p>In a while we shall change <code>923</code> to the LoRa Frequency for our region: <code>434</code>, <code>780</code>, <code>868</code>, <code>915</code> or <code>923</code> MHz. <a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html">(Check this list)</a></p>
<p>For now we'll study this function <strong><code>init_driver</code></strong> that initialises the LoRa Driver for SX1276 (and RF96) in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L126-L179"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to initialise the SX1276 / RF96 driver
static void init_driver(char *buf, int len, int argc, char **argv) {
    //  Set the LoRa Callback Functions
    RadioEvents_t radio_events;
    memset(&amp;radio_events, 0, sizeof(radio_events));  //  Must init radio_events to null, because radio_events lives on stack!
    radio_events.TxDone    = on_tx_done;
    radio_events.RxDone    = on_rx_done;
    radio_events.TxTimeout = on_tx_timeout;
    radio_events.RxTimeout = on_rx_timeout;
    radio_events.RxError   = on_rx_error;
</code></pre>
<p><code>init_driver</code> begins by defining the <strong>Callback Functions</strong> that will be called when we have transmitted or received a LoRa Packet (successfully or unsuccessfully)...</p>
<ul>
<li>
<p><strong>Packet Transmitted: <code>on_tx_done</code></strong></p>
<p>Called when the transceiver has successfully transmitted a LoRa Packet.</p>
</li>
<li>
<p><strong>Packet Received: <code>on_rx_done</code></strong></p>
<p>Called when the tranceiver has received a LoRa Packet. (More about this in a while)</p>
</li>
<li>
<p><strong>Transmit Timeout: <code>on_tx_timeout</code></strong></p>
<p>Called if the transceiver is unable to transmit a LoRa Packet.</p>
</li>
<li>
<p><strong>Receive Timeout: <code>on_rx_timeout</code></strong>:</p>
<p>Called if the transceiver doesn't receive any LoRa Packets within a timeout window. (More about this in a while)</p>
</li>
<li>
<p><strong>Receive Error: <code>on_rx_error</code></strong>:</p>
<p>Called if the transceiver encounters an error when receiving a LoRa Packet. (More about this in a while)</p>
</li>
</ul>
<p>Next we call <strong><code>Radio.Init</code> to initialise BL602's SPI Port and the LoRa Transceiver</strong>...</p>
<pre><code class="language-c">    //  Init the SPI Port and the LoRa Transceiver
    Radio.Init(&amp;radio_events);
</code></pre>
<p><code>Radio.Init</code> will set some registers on our LoRa Transceiver (over SPI).</p>
<p>Then we call <strong><code>Radio.SetChannel</code> to set the LoRa Frequency</strong>...</p>
<pre><code class="language-c">    //  Set the LoRa Frequency, which is specific to our region.
    //  For USE_BAND_923: RF_FREQUENCY is set to 923000000.
    Radio.SetChannel(RF_FREQUENCY);
</code></pre>
<p><code>Radio.SetChannel</code> configures the LoRa Frequency by writing to the <strong>Frequency Registers</strong> in our LoRa Transceiver.</p>
<p>We get ready to transmit by calling <strong><code>Radio.SetTxConfig</code></strong>...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for transmitting messages
    Radio.SetTxConfig(
        MODEM_LORA,
        LORAPING_TX_OUTPUT_POWER,
        0,        //  Frequency deviation: Unused with LoRa
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        LORAPING_TX_TIMEOUT_MS
    );
</code></pre>
<p>At the end of the function we call <strong><code>Radio.SetRxConfig</code></strong> to configure the transceiver for receiving LoRa Packets...</p>
<pre><code class="language-c">    //  Configure the LoRa Transceiver for receiving messages
    Radio.SetRxConfig(
        MODEM_LORA,
        LORAPING_BANDWIDTH,
        LORAPING_SPREADING_FACTOR,
        LORAPING_CODINGRATE,
        0,        //  AFC bandwidth: Unused with LoRa
        LORAPING_PREAMBLE_LENGTH,
        LORAPING_SYMBOL_TIMEOUT,
        LORAPING_FIX_LENGTH_PAYLOAD_ON,
        0,        //  Fixed payload length: N/A
        true,     //  CRC enabled
        0,        //  Frequency hopping disabled
        0,        //  Hop period: N/A
        LORAPING_IQ_INVERSION_ON,
        true      //  Continuous receive mode
    );    
}
</code></pre>
<p><em>What's Continuous Receive Mode?</em></p>
<p><strong>Continuous Receive Mode</strong> means that the transceiver will wait forever for incoming packets... Until we tell it to stop.</p>
<p>(We'll stop the transceiver with a BL602 Timer)</p>
<p>But before that, we need to tell the transceiver to begin receiving packets. That's coming up next...</p>
<p>(The code in this article is based on the <a href="https://github.com/apache/mynewt-core/blob/master/apps/loraping/src/main.c">LoRa Ping</a> program from Mynewt OS. <a href="https://lupyuen.github.io/articles/lora#appendix-porting-lora-driver-from-mynewt-to-bl602">More about this</a>)</p>
<h1 id="receive-lora-packet" class="section-header"><a href="#receive-lora-packet">3 Receive LoRa Packet</a></h1>
<p>We're creating a <strong>battery-powered</strong> IoT Sensor with LoRa.</p>
<p>To conserve battery power, we don't listen for incoming LoRa Packets all the time... We <strong>listen for 5 seconds</strong> then go to sleep.</p>
<p>This is how we do it: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L207-L213"><code>demo.c</code></a></p>
<pre><code class="language-c">/// LoRa Receive Timeout in 5 seconds
#define LORAPING_RX_TIMEOUT_MS 5000  //  Milliseconds

/// Command to receive a LoRa message. Assume that SX1276 / RF96 driver has been initialised.
/// Assume that create_task has been called to init the Event Queue.
static void receive_message(char *buf, int len, int argc, char **argv) {
    //  Receive a LoRa message within 5 seconds
    Radio.Rx(LORAPING_RX_TIMEOUT_MS);
}
</code></pre>
<p>The <strong><code>receive_message</code></strong> command calls <strong><code>Radio.Rx</code></strong> (from the SX1276 Driver) to receive a LoRa Packet within 5 seconds.</p>
<h2 id="receive-callback" class="section-header"><a href="#receive-callback">3.1 Receive Callback</a></h2>
<p>Upon receiving the LoRa Packet, the SX1276 Driver calls the Callback Function <strong><code>on_rx_done</code></strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L355-L381"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when a LoRa message has been received
static void on_rx_done(
    uint8_t *payload,  //  Buffer containing received LoRa message
    uint16_t size,     //  Size of the LoRa message
    int16_t rssi,      //  Signal strength
    int8_t snr) {      //  Signal To Noise ratio

    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();
</code></pre>
<p>At the start of <code>on_rx_done</code>, we <strong>power down the LoRa Transceiver</strong> to conserve battery power.</p>
<p>Next we <strong>copy the received packet</strong> into our 64-byte buffer <strong><code>loraping_buffer</code></strong>...</p>
<pre><code class="language-c">    //  Copy the received packet (up to 64 bytes)
    if (size &gt; sizeof loraping_buffer) {
        size = sizeof loraping_buffer;
    }
    loraping_rx_size = size;
    memcpy(loraping_buffer, payload, size);
</code></pre>
<p>At the end of the callback, we <strong>display the contents</strong> of the copied packet...</p>
<pre><code class="language-c">    //  Dump the contents of the received packet
    for (int i = 0; i &lt; loraping_rx_size; i++) {
        printf(&quot;%02x &quot;, loraping_buffer[i]);
    }
    printf(&quot;\r\n&quot;);

    //  Log the signal strength, signal to noise ratio
    loraping_rxinfo_rxed(rssi, snr);
}
</code></pre>
<p><em>Is it really OK to call <code>printf</code> here?</em></p>
<p>Yes because this code runs in the context of the <strong>FreeRTOS Application Task</strong>, not in the context of the Interrupt Handler. We'll learn why in a while.</p>
<p>(This differs from the original <a href="https://github.com/apache/mynewt-core/blob/master/apps/loraping/src/main.c">LoRa Ping</a> program... On Mynewt OS, <code>on_rx_done</code> and other Callback Functions will run in the context of the Interrupt Handler)</p>
<h2 id="timeout-and-error-callbacks" class="section-header"><a href="#timeout-and-error-callbacks">3.2 Timeout and Error Callbacks</a></h2>
<p><em>What happens when we don't receive a LoRa Packet in 5 seconds?</em></p>
<p>The SX1276 Driver calls our Callback Function <strong><code>on_rx_timeout</code></strong> that's defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L398-L412"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when no LoRa messages could be received due to timeout
static void on_rx_timeout(void) {
    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();

    //  Log the timeout
    loraping_stats.rx_timeout++;
    loraping_rxinfo_timeout();
}
</code></pre>
<p>Here we power down the LoRa Transceiver to conserve battery power.</p>
<p>We do the same in the Callback Function <strong><code>on_rx_error</code></strong>, which the SX1276 Driver calls when it hits an error receiving LoRa Packets: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L414-L427"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Callback Function that is called when we couldn't receive a LoRa message due to error
static void on_rx_error(void) {
    //  Log the error
    loraping_stats.rx_error++;

    //  Switch the LoRa Transceiver to low power, sleep mode
    Radio.Sleep();
}
</code></pre>
<h1 id="bl602-gpio-interrupts" class="section-header"><a href="#bl602-gpio-interrupts">4 BL602 GPIO Interrupts</a></h1>
<p>Let's talk about <strong>handling GPIO Interrupts</strong> on BL602...</p>
<p><img src="https://lupyuen.github.io/images/lora2-interrupt.png" alt="BL602 handling GPIO interrupts" /></p>
<ol>
<li>
<p>When our LoRa Transceiver (SX1276) <strong>receives a LoRa Packet</strong>...</p>
</li>
<li>
<p>It shifts the Logic Level of <strong>Pin <code>DIO0</code> from Low to High</strong></p>
</li>
<li>
<p>We shall configure BL602 to detect this shift in the connected GPIO Pin and trigger a <strong>GPIO Interrupt</strong></p>
</li>
<li>
<p>The <strong>GPIO Interrupt Handler</strong> in our firmware code will then process the received LoRa Packet. (And reset <code>DIO0</code> back to Low)</p>
</li>
</ol>
<p>Here's how we configure a GPIO Interrupt Handler on BL602: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L144-L240"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">//  SX1276 DIO0 is connected to BL602 at GPIO 11
#define SX1276_DIO0 11

//  Register GPIO Handler for DIO0
int rc = register_gpio_handler(   //  Register GPIO Handler...
    SX1276_DIO0,                  //  GPIO Pin Number
    SX1276OnDio0Irq,              //  GPIO Handler Function
    GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
    GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
    0,                            //  No pullup
    0                             //  No pulldown
);
assert(rc == 0);
</code></pre>
<p>This call to <strong><code>register_gpio_handler</code></strong> says...</p>
<ol>
<li>
<p>When BL602 detects <strong>GPIO Pin 11</strong> (connected to <code>DIO0</code>) shifting from <strong>Low to High</strong> (Positive Edge)...</p>
</li>
<li>
<p>BL602 will call our GPIO Handler Function <strong><code>SX1276OnDio0Irq</code></strong></p>
</li>
</ol>
<p>We'll cover <code>register_gpio_handler</code> in the next section.</p>
<p>Then to enable GPIO Interrupts we call these functions from the <strong>BL602 Interrupt Hardware Abstraction Layer (HAL)</strong>...</p>
<pre><code class="language-c">//  Register Common Interrupt Handler for GPIO Interrupt
bl_irq_register_with_ctx(
    GPIO_INT0_IRQn,         //  GPIO Interrupt
    handle_gpio_interrupt,  //  Interrupt Handler
    NULL                    //  Argument for Interrupt Handler
);

//  Enable GPIO Interrupt
bl_irq_enable(GPIO_INT0_IRQn);
</code></pre>
<p><strong><code>handle_gpio_interrupt</code></strong> is the low-level <strong>Interrupt Handler</strong> that will be called by the BL602 GPIO HAL when the GPIO Interrupt is triggered.</p>
<p>We'll look inside <code>handle_gpio_interrupt</code> in a while.</p>
<h2 id="register-handler-function" class="section-header"><a href="#register-handler-function">4.1 Register Handler Function</a></h2>
<p>Let's look inside our function <strong><code>register_gpio_handler</code></strong> and learn how it <strong>registers a Handler Function for GPIO</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L341-L403"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Register Handler Function for GPIO. Return 0 if successful.
/// GPIO Handler Function will run in the context of the Application Task, not the Interrupt Handler.
/// Based on bl_gpio_register in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_gpio.c
static int register_gpio_handler(
    uint8_t gpioPin,         //  GPIO Pin Number
    DioIrqHandler *handler,  //  GPIO Handler Function
    uint8_t intCtrlMod,      //  GPIO Interrupt Control Mode (see below)
    uint8_t intTrgMod,       //  GPIO Interrupt Trigger Mode (see below)
    uint8_t pullup,          //  1 for pullup, 0 for no pullup
    uint8_t pulldown) {      //  1 for pulldown, 0 for no pulldown
</code></pre>
<p>Above are the parameters for <code>register_gpio_handler</code>.</p>
<p>The <strong>GPIO Interrupt Control Modes</strong> are...</p>
<ul>
<li>
<p><strong><code>GLB_GPIO_INT_CONTROL_SYNC</code></strong>:  Synchronous Mode</p>
<p>(We never use sync mode)</p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_CONTROL_ASYNC</code></strong>: Asynchronous Mode</p>
<p>(We ALWAYS use async mode)</p>
</li>
</ul>
<p>The BL602 Reference Manual doesn't mention GPIO Interrupt Control modes. But according to the BL602 HAL code, only <strong>Async Mode</strong> should be used. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c#L309">(See this)</a></p>
<p>The <strong>GPIO Interrupt Trigger Mode</strong> specifies how the GPIO should trigger the interrupt...</p>
<ul>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_NEG_PULSE</code></strong>: Negative Edge Pulse Trigger</p>
<p>Trigger the interrupt when the GPIO Logic Level shifts from <strong>High to Low</strong></p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_POS_PULSE</code></strong>: Positive Edge Pulse Trigger</p>
<p>Trigger the interrupt when the GPIO Logic Level shifts from <strong>Low to High</strong></p>
<p>(We use this for SX1276)</p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_NEG_LEVEL</code></strong>: Negative Edge Level Trigger (32k 3T)</p>
<p>Trigger the interrupt when the GPIO Logic Level stays <strong>Low</strong></p>
</li>
<li>
<p><strong><code>GLB_GPIO_INT_TRIG_POS_LEVEL</code></strong>: Positive Edge Level Trigger (32k 3T)</p>
<p>Trigger the interrupt when the GPIO Logic Level stays <strong>High</strong></p>
</li>
</ul>
<p>The GPIO Interrupt Trigger Mode is (partially) documented in the <a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_RM/en">BL602 Reference Manual</a> (Section 3.2.12: &quot;GPIO Interrupt&quot;). <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c#L270-L312">(This BL602 HAL code offers more hints)</a></p>
<p>Our GPIO Handler Function <code>handler</code> shall be triggered through an Event (from the NimBLE Porting Layer). We'll learn why later...</p>
<pre><code class="language-c">    //  Init the Event that will invoke the handler for the GPIO Interrupt
    int rc = init_interrupt_event(
        gpioPin,  //  GPIO Pin Number
        handler   //  GPIO Handler Function that will be triggered by the Event
    );
    assert(rc == 0);
</code></pre>
<p>Next we call <code>GLB_GPIO_Func_Init</code> to configure the pin as a <strong>GPIO Pin</strong>...</p>
<pre><code class="language-c">    //  Configure pin as a GPIO Pin
    GLB_GPIO_Type pins[1];
    pins[0] = gpioPin;
    BL_Err_Type rc2 = GLB_GPIO_Func_Init(
        GPIO_FUN_SWGPIO,  //  Configure as GPIO 
        pins,             //  Pins to be configured
        sizeof(pins) / sizeof(pins[0])  //  Number of pins (1)
    );
    assert(rc2 == SUCCESS);    
</code></pre>
<p><code>GLB_GPIO_Func_Init</code> comes from the BL602 Standard Driver: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_glb.c"><code>bl602_glb.c</code></a></p>
<p>We configure the pin as a <strong>GPIO Input Pin</strong> (instead of GPIO Output)...</p>
<pre><code class="language-c">    //  Configure pin as a GPIO Input Pin
    rc = bl_gpio_enable_input(
        gpioPin,  //  GPIO Pin Number
        pullup,   //  1 for pullup, 0 for no pullup
        pulldown  //  1 for pulldown, 0 for no pulldown
    );
    assert(rc == 0);
</code></pre>
<p>Finally we disable the GPIO Pin Interrupt, configure the <strong>GPIO Interrupt Control and Trigger Modes</strong>, and enable the GPIO Pin Interrupt...</p>
<pre><code class="language-c">    //  Disable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 1);

    //  Configure GPIO Pin for GPIO Interrupt
    bl_set_gpio_intmod(
        gpioPin,     //  GPIO Pin Number
        intCtrlMod,  //  GPIO Interrupt Control Mode (see below)
        intTrgMod    //  GPIO Interrupt Trigger Mode (see below)
    );

    //  Enable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 0);
    return 0;
}
</code></pre>
<p>We're ready to handle GPIO Interrupts triggered by our LoRa Transceiver!</p>
<p><em>There seems to be 2 types of GPIO Interrupts?</em></p>
<p>Yep, earlier we saw this...</p>
<pre><code class="language-c">//  Enable GPIO Interrupt
bl_irq_enable(GPIO_INT0_IRQn);
</code></pre>
<p>This enables the GPIO Interrupt for <strong>ALL GPIO Pins</strong> (by calling the BL602 Interrupt HAL).</p>
<p>Then we saw this...</p>
<pre><code class="language-c">//  Enable GPIO Interrupt for the pin
bl_gpio_intmask(gpioPin, 0);
</code></pre>
<p>This enables the GPIO Interrupt for <strong>ONE Specific GPIO Pin</strong> (by calling the BL602 GPIO HAL).</p>
<p>We need both to make GPIO Interrupts work.</p>
<h2 id="gpio-interrupt-handler" class="section-header"><a href="#gpio-interrupt-handler">4.2 GPIO Interrupt Handler</a></h2>
<p><em>GPIO Interrupt Handler vs GPIO Handler Function... Are these different things?</em></p>
<p>I'm sorry to muddle my dearest readers, they are indeed different things and they work at different levels...</p>
<p><img src="https://lupyuen.github.io/images/lora2-handler.png" alt="GPIO Interrupt Handler vs GPIO Handler Function" /></p>
<ol>
<li>
<p><strong>GPIO Interrupt Handler</strong> (<code>handle_gpio_interrupt</code>) is the low-level <strong>Interrupt Service Routine</strong> that handles the GPIO Interrupt.</p>
<p>This Interrupt Handler (called by BL602 Interrupt HAL) services the GPIO Interrupt that's triggered when SX1276 receives a LoRa Packet.</p>
</li>
<li>
<p><strong>GPIO Handler Function</strong> (like <code>SX1276OnDio0Irq</code>) is the high-level <strong>Application Function</strong> (running in a FreeRTOS Task) that processes the received LoRa Packet.</p>
<p>This Handler Function is invoked (indirectly) by the Interrupt Handler (via an Event from NimBLE Porting Layer).</p>
<p>(What's an Event and why are we using it? We'll learn about the NimBLE Porting Layer in the next chapter)</p>
</li>
</ol>
<p>Let's study the low-level <strong>GPIO Interrupt Handler <code>handle_gpio_interrupt</code></strong> that services all GPIO Interrupts: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L405-L433"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Maximum number of GPIO Pins that can be configured for interrupts
#define MAX_GPIO_INTERRUPTS 6  //  DIO0 to DIO5

/// Array of GPIO Pin Numbers that have been configured for interrupts
static uint8_t gpio_interrupts[MAX_GPIO_INTERRUPTS];

/// Array of Events for the GPIO Interrupts
static struct ble_npl_event gpio_events[MAX_GPIO_INTERRUPTS];

/// Interrupt Handler for GPIO Pins DIO0 to DIO5
static void handle_gpio_interrupt(void *arg) {

    //  Check all GPIO Interrupt Events
    for (int i = 0; i &lt; MAX_GPIO_INTERRUPTS; i++) {

        //  Get the GPIO Pin Number for the Event
        GLB_GPIO_Type gpioPin = gpio_interrupts[i];

        //  Get the GPIO Interrupt Event
        struct ble_npl_event *ev = &amp;gpio_events[i];
</code></pre>
<p>We start the GPIO Interrupt Handler <code>handle_gpio_interrupt</code> by <strong>iterating through the GPIO Interrupts</strong> that we have configured (for <code>DIO0</code> to <code>DIO5</code>).</p>
<p>The configured GPIO Interrupts are stored in arrays <strong><code>gpio_interrupts</code> and <code>gpio_events</code></strong> like so...</p>
<p><img src="https://lupyuen.github.io/images/lora2-events.png" alt="GPIO Interrupts and Events" /></p>
<p>For the first iteration...</p>
<ul>
<li>
<p>Since <code>DIO0</code> is connected to <strong>GPIO Pin 11</strong>...</p>
<p><strong><code>gpioPin</code></strong> shall be set to <strong><code>11</code></strong></p>
<p>(Via <code>gpio_interrupts[0]</code>)</p>
</li>
<li>
<p>Since <code>DIO0</code> is handled by the <strong>GPIO Handler Function <code>SX1276OnDio0Irq</code></strong>...</p>
<p><strong><code>ev</code></strong> shall be set to the Event that points to <strong><code>SX1276OnDio0Irq</code></strong></p>
<p>(Via <code>gpio_events[0]</code>)</p>
<p>(More about <code>gpio_interrupts</code> and <code>gpio_events</code> in the next chapter)</p>
</li>
</ul>
<p>We allow unused GPIO Pins, and we skip them like so...</p>
<pre><code class="language-c">        //  If the Event is unused, skip it
        if (ev-&gt;fn == NULL) { continue; }
</code></pre>
<p>Next we fetch the <strong>Interrupt Status</strong> of the GPIO Pin, to determine whether this GPIO Pin has triggered the interrupt...</p>
<pre><code class="language-c">        //  Get the Interrupt Status of the GPIO Pin
        BL_Sts_Type status = GLB_Get_GPIO_IntStatus(gpioPin);
</code></pre>
<p><code>GLB_Get_GPIO_IntStatus</code> comes from the BL602 Standard Driver: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_glb.c"><code>bl602_glb.c</code></a></p>
<p>If this GPIO Pin has indeed triggered the interrupt, we <strong>enqueue the Event</strong> (containing our GPIO Handler Function) for the Application Task to handle...</p>
<pre><code class="language-c">        //  If the GPIO Pin has triggered an interrupt...
        if (status == SET) {
            //  Forward the GPIO Interrupt to the Application Task to process
            enqueue_interrupt_event(
                gpioPin,  //  GPIO Pin Number
                ev        //  Event that will be enqueued for the Application Task
            );
        }
    }
}
</code></pre>
<p>In summary: Our GPIO Interrupt Handler...</p>
<ol>
<li>
<p>Iterates through all configured GPIO Interrupts (<code>DIO0</code> to <code>DIO5</code>)</p>
</li>
<li>
<p>Hunts for the GPIO Interrupts that have been triggered</p>
</li>
<li>
<p>Enqueues the GPIO Event (and Handler Function) for processing by the Application Task</p>
</li>
</ol>
<p>Let's look at <code>enqueue_interrupt_event</code>...</p>
<h2 id="enqueue-interrupt-event" class="section-header"><a href="#enqueue-interrupt-event">4.3 Enqueue Interrupt Event</a></h2>
<p>The time has come to reveal the final piece of code that handles GPIO Interrupts: <strong><code>enqueue_interrupt_event</code></strong> from <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L435-L469"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Interrupt Counters
int g_dio0_counter, g_dio1_counter, g_dio2_counter, g_dio3_counter, g_dio4_counter, g_dio5_counter, g_nodio_counter;

/// Enqueue the GPIO Interrupt to an Event Queue for the Application Task to process
static int enqueue_interrupt_event(
    uint8_t gpioPin,                //  GPIO Pin Number
    struct ble_npl_event *event) {  //  Event that will be enqueued for the Application Task

    //  Disable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 1);
</code></pre>
<p>We start by disabling the GPIO Interrupt for the pin.</p>
<p>Here's a helpful tip: Never clear the GPIO Interrupt Status by calling <code>bl_gpio_int_clear</code>...</p>
<pre><code class="language-c">    //  Note: DO NOT Clear the GPIO Interrupt Status for the pin!
    //  This will suppress subsequent GPIO Interrupts!
    //  bl_gpio_int_clear(gpioPin, SET);
</code></pre>
<p><code>bl_gpio_int_clear</code> causes <strong>subsequent GPIO Interrupts to be suppressed</strong>. So we should never call it!</p>
<p>We can't <code>printf</code> in an Interrupt Handler (for troubleshooting), but we can <strong>increment some Interrupt Counters</strong> that will be displayed by the <strong><code>spi_result</code></strong> command...</p>
<pre><code class="language-c">    //  Increment the Interrupt Counters
    if (SX1276_DIO0 &gt;= 0 &amp;&amp; gpioPin == (uint8_t) SX1276_DIO0) { g_dio0_counter++; }
    //  Omitted: Increment Interrupt Counters
    //  for DIO1 to DIO4
    ...
    else if (SX1276_DIO5 &gt;= 0 &amp;&amp; gpioPin == (uint8_t) SX1276_DIO5) { g_dio5_counter++; }
    else { g_nodio_counter++; }
</code></pre>
<p>Next we add the Interrupt Event (with the Handler Function inside) to the <strong>Event Queue</strong> (from the NimBLE Porting Layer)...</p>
<pre><code class="language-c">    //  Use Event Queue to invoke Event Handler in the Application Task, 
    //  not in the Interrupt Context
    if (event != NULL &amp;&amp; event-&gt;fn != NULL) {
        extern struct ble_npl_eventq event_queue;
        ble_npl_eventq_put(&amp;event_queue, event);
    }
</code></pre>
<p>(In the next chapter we shall see the <strong>Background Task</strong> that will receive the Event and process the received LoRa Packet)</p>
<p>We finish up by enabling the GPIO Interrupt for the pin...</p>
<pre><code class="language-c">    //  Enable GPIO Interrupt for the pin
    bl_gpio_intmask(gpioPin, 0);
    return 0;
}
</code></pre>
<p>And that's how we handle GPIO Interrupts on BL602!</p>
<h2 id="register-handlers-for-dio0-to-dio5" class="section-header"><a href="#register-handlers-for-dio0-to-dio5">4.4 Register Handlers for DIO0 to DIO5</a></h2>
<p><em>Earlier we registered the GPIO Handler Function for <code>DIO0</code>. What about <code>DIO1</code> to <code>DIO5</code>?</em></p>
<p>Here's how we actually register the GPIO Handler Functions for <code>DIO0</code> to <code>DIO5</code>, in a single shot...</p>
<p>First we define the GPIO Pins for <code>DIO0</code> to <code>DIO5</code>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.h#L48-L53"><code>sx1276.h</code></a></p>
<pre><code class="language-c">#define SX1276_DIO0        11  //  DIO0: Trigger for Packet Received
#define SX1276_DIO1         0  //  DIO1: Trigger for Sync Timeout
#define SX1276_DIO2         5  //  DIO2: Trigger for Change Channel (Spread Spectrum / Frequency Hopping)
#define SX1276_DIO3        12  //  DIO3: Trigger for CAD Done
#define SX1276_DIO4        -1  //  DIO4: Unused (FSK only)
#define SX1276_DIO5        -1  //  DIO5: Unused (FSK only)
</code></pre>
<p>Next we define the GPIO Handler Functions for <code>DIO0</code> to <code>DIO5</code>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L208-L213"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  DIO Handler Functions
DioIrqHandler *DioIrq[] = { 
    SX1276OnDio0Irq, SX1276OnDio1Irq,
    SX1276OnDio2Irq, SX1276OnDio3Irq,
    SX1276OnDio4Irq, NULL };  //  DIO5 not used for LoRa Modulation
</code></pre>
<p>Then we pass the DIO Handler Functions <code>DioIrq</code> to the function <code>SX1276IoIrqInit</code> defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L144-L240"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Register GPIO Interrupt Handlers for DIO0 to DIO5.
/// Based on hal_button_register_handler_with_dts in https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_button.c
void SX1276IoIrqInit(DioIrqHandler **irqHandlers) {

    //  DIO0: Trigger for Packet Received and Packet Transmitted
    if (SX1276_DIO0 &gt;= 0 &amp;&amp; irqHandlers[0] != NULL) {
        int rc = register_gpio_handler(       //  Register GPIO Handler...
            SX1276_DIO0,                  //  GPIO Pin Number
            irqHandlers[0],               //  GPIO Handler Function
            GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
            GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
            0,                            //  No pullup
            0                             //  No pulldown
        );
        assert(rc == 0);
    }
</code></pre>
<p>This is similar to the code we've seen earlier for registering the GPIO Handler Function for <code>DIO0</code>.</p>
<p>The code for <code>DIO1</code> to <code>DIO5</code> looks highly similar...</p>
<pre><code class="language-c">    //  Omitted: Register GPIO Handler Functions
    //  for DIO1 to DIO4
    ...

    //  DIO5: Unused (FSK only)
    if (SX1276_DIO5 &gt;= 0 &amp;&amp; irqHandlers[5] != NULL) {
        int rc = register_gpio_handler(       //  Register GPIO Handler...
            SX1276_DIO5,                  //  GPIO Pin Number
            irqHandlers[5],               //  GPIO Handler Function
            GLB_GPIO_INT_CONTROL_ASYNC,   //  Async Control Mode
            GLB_GPIO_INT_TRIG_POS_PULSE,  //  Trigger when GPIO level shifts from Low to High
            0,                            //  No pullup
            0                             //  No pulldown
        );
        assert(rc == 0);
    }
</code></pre>
<p>To wrap up, we register the GPIO Interrupt Handler and enable GPIO Interrupts (as explained earlier)...</p>
<pre><code class="language-c">    //  Register Common Interrupt Handler for GPIO Interrupt
    bl_irq_register_with_ctx(
        GPIO_INT0_IRQn,         //  GPIO Interrupt
        handle_gpio_interrupt,  //  Interrupt Handler
        NULL                    //  Argument for Interrupt Handler
    );

    //  Enable GPIO Interrupt
    bl_irq_enable(GPIO_INT0_IRQn);
}
</code></pre>
<p>That is all... We register the GPIO Handler Functions for <code>DIO0</code> to <code>DIO5</code> with a single call to <code>SX1276IoIrqInit</code>.</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L421-L458">(Our SX1276 Driver calls <code>SX1276IoIrqInit</code> here)</a></p>
<h1 id="multitask-with-nimble-porting-layer" class="section-header"><a href="#multitask-with-nimble-porting-layer">5 Multitask with NimBLE Porting Layer</a></h1>
<p><em>Move Fast OR Break Things... Choose ONE!</em></p>
<p><strong>Handling an interrupt</strong> gets tricky for any Embedded Program...</p>
<ol>
<li>
<p><strong>Interrupts are Time-Sensitive</strong>: We can't take too long to handle an interrupt... Other interrupts may be waiting on us! </p>
<p>(Lag ensues)</p>
</li>
<li>
<p><strong>No Blocking Input / Output</strong>: Suppose our SX1276 Interrupt Handler needs to send an SPI Command to reset <code>DIO0</code>.</p>
<p>That's no-no because our Interrupt Handler would block waiting for the SPI operation to complete. And hold up other interrupts.</p>
</li>
<li>
<p><strong>No Console Output</strong>: Troubleshooting an Interrupt Handler gets challenging because we can't show anything on the console (due to (1) and (2) above).</p>
<p>(Also challenging: Handling errors in an Interrupt Handler)</p>
</li>
</ol>
<p>Hence some chunks of our Interrupt Handling Logic would need to run inside a <strong>higher-level, lower-priority Application Task</strong>. Like this...</p>
<p><img src="https://lupyuen.github.io/images/lora2-handler2.png" alt="Interrupt Handler vs Application Task" /></p>
<p>Our Interrupt Handler (left) would need to signal the Application Task (right) to do some work.</p>
<p><em>We'll do this with FreeRTOS, no?</em></p>
<p>Let's do this with <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/dfu#nimble-stack-for-bluetooth-le-on-pinetime"><strong>NimBLE Porting Layer</strong></a> instead.  It's a library of multitasking functions that's <strong>portable to multiple operating systems</strong>: FreeRTOS, Mynewt, NuttX, RIOT.</p>
<p>(And it looks simpler for folks who are new to FreeRTOS)</p>
<h2 id="background-task" class="section-header"><a href="#background-task">5.1 Background Task</a></h2>
<p>We start by creating the Background Task (right side of above pic) that will process the received LoRa Packets: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L253-L267"><code>demo.c</code></a></p>
<pre><code class="language-c">//  Create a FreeRTOS Task that runs task_callback
nimble_port_freertos_init(
    task_callback  //  Callback Function for the Task
);
</code></pre>
<p>We call <strong><code>nimble_port_freertos_init</code></strong> (from the NimBLE Porting Layer) to start a FreeRTOS Background Task that runs the function <code>task_callback</code>.</p>
<p>The function <strong><code>task_callback</code></strong> loops forever, doing work in the background...</p>
<pre><code class="language-c">/// Task Function that works in the background
static void task_callback(void *arg) {
    //  Loop forever doing work
    for (;;) {
        ...
    }
}
</code></pre>
<p>Let's give it some work to do, by sending an Event...</p>
<p><img src="https://lupyuen.github.io/images/lora2-handler3.png" alt="Event Queue" /></p>
<h2 id="event-queue" class="section-header"><a href="#event-queue">5.2 Event Queue</a></h2>
<p>Our Background Task shall receive <strong>Events</strong> from an <strong>Event Queue</strong> and process them.</p>
<p>We define our Event and Event Queue like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L244-L248"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Event Queue containing Events to be processed
struct ble_npl_eventq event_queue;

/// Event to be added to the Event Queue
struct ble_npl_event event;
</code></pre>
<p>To initialise the Event and Event Queue, we call <strong><code>ble_npl_event_init</code> and <code>ble_npl_eventq_init</code></strong> like this: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L253-L267"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to create a FreeRTOS Task with NimBLE Porting Layer
static void create_task(char *buf, int len, int argc, char **argv) {
    //  Init the Event Queue
    ble_npl_eventq_init(&amp;event_queue);

    //  Init the Event
    ble_npl_event_init(
        &amp;event,        //  Event
        handle_event,  //  Event Handler Function
        NULL           //  Argument to be passed to Event Handler
    );

    //  Create a FreeRTOS Task to process the Event Queue
    nimble_port_freertos_init(task_callback);
}
</code></pre>
<p>This call to <strong><code>ble_npl_event_init</code></strong> says...</p>
<ol>
<li>
<p>When our Background Task <strong>receives the Event</strong>...</p>
</li>
<li>
<p><strong>Execute the function <code>handle_event</code></strong> to process the Event</p>
</li>
</ol>
<p>Here's a bare-bones Event Handler: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L296-L299"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Handle an Event
static void handle_event(struct ble_npl_event *ev) {
    printf(&quot;\r\nHandle an event\r\n&quot;);
}
</code></pre>
<p><strong><code>handle_event</code></strong> processes an Event by printing a message.</p>
<p>Later we'll see a more sophisticated Event Handler for processing received LoRa Packets.</p>
<h2 id="send-event" class="section-header"><a href="#send-event">5.3 Send Event</a></h2>
<p>To <strong>send an Event</strong> into an Event Queue, we call <strong><code>ble_npl_eventq_put</code></strong> like so: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L269-L273"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to enqueue an Event into the Event Queue with NimBLE Porting Layer
static void put_event(char *buf, int len, int argc, char **argv) {
    //  Add the Event to the Event Queue
    ble_npl_eventq_put(
        &amp;event_queue,  //  Event Queue
        &amp;event         //  Event to be added to Event Queue
    );
}
</code></pre>
<p>Our Background Task will...</p>
<ol>
<li>
<p>Wake up</p>
</li>
<li>
<p>Receive the Event</p>
</li>
<li>
<p>Execute the Event Handler (<code>handle_event</code>)</p>
</li>
</ol>
<p>We'll learn how in the next section.</p>
<p><em>Is it OK to call this from an Interrupt Handler?</em></p>
<p>Yep it's perfectly OK to call <code>ble_npl_eventq_put</code> from an Interrupt Handler.</p>
<p>In fact the implementation of <code>ble_npl_eventq_put</code> <strong>differs slightly for Interupt Handlers vs Application Tasks</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/npl_os_freertos.c#L59-L79">(See this)</a></p>
<p>This is another reason for calling NimBLE Porting Layer instead of FreeRTOS... NimBLE Porting Layer <strong>handles the nitty-gritty</strong> on our behalf.</p>
<h2 id="receive-event" class="section-header"><a href="#receive-event">5.4 Receive Event</a></h2>
<p>Here's the code inside our Background Task that receives Events and executes the Event Handlers: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L275-L294"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Task Function that dequeues Events from the Event Queue and processes the Events
static void task_callback(void *arg) {
    //  Loop forever handling Events from the Event Queue
    for (;;) {
        //  Get the next Event from the Event Queue
        struct ble_npl_event *ev = ble_npl_eventq_get(
            &amp;event_queue,  //  Event Queue
            1000           //  Timeout in 1,000 ticks
        );

        //  If no Event due to timeout, wait for next Event
        if (ev == NULL) { continue; }
</code></pre>
<p><strong><code>task_callback</code></strong> loops forever, calling <strong><code>ble_npl_eventq_get</code></strong> to receive Events from our Event Queue.</p>
<p>We've set a <strong>timeout of 1,000 ticks</strong>. (Yes it sounds arbitrary) If we don't receive an Event in 1,000 ticks, we loop and retry.</p>
<p>When we receive an Event...</p>
<ol>
<li>
<p>We call <strong><code>ble_npl_eventq_remove</code></strong> to <strong>remove the Event</strong> from the Event Queue</p>
</li>
<li>
<p>Then we call <strong><code>ble_npl_event_run</code></strong> to <strong>execute the Event Handler</strong> (like <code>handle_event</code>)</p>
</li>
</ol>
<pre><code class="language-c">        //  Remove the Event from the Event Queue
        ble_npl_eventq_remove(&amp;event_queue, ev);

        //  Trigger the Event Handler Function (handle_event)
        ble_npl_event_run(ev);
    }
}
</code></pre>
<p>And that's how we process an Event Queue with a Background Task!</p>
<p><em>This Background Task looks so simple and generic... Will it work for all types of Events?</em></p>
<p>Yes! Remember that we can <strong>configure the Event Handler</strong> for our Event...</p>
<pre><code class="language-c">//  Set the Event handler for the Event
ble_npl_event_init(   //  Init the Event for...
    ev,               //  Event
    handler,          //  Event Handler Function
    NULL              //  Argument to be passed to Event Handler
);
</code></pre>
<p>In the next section we'll learn to use <strong>multiple Events</strong> (with different Event Handlers) to process LoRa Packets.</p>
<h2 id="lora-events" class="section-header"><a href="#lora-events">5.5 LoRa Events</a></h2>
<p>Earlier we have defined the <strong>GPIO Handler Functions</strong> that will process the interrupts from our LoRa Transceiver (<code>DIO0</code> to <code>DIO5</code>)...</p>
<pre><code class="language-c">//  DIO Handler Functions
DioIrqHandler *DioIrq[] = { 
    SX1276OnDio0Irq, SX1276OnDio1Irq,
    SX1276OnDio2Irq, SX1276OnDio3Irq,
    SX1276OnDio4Irq, NULL };  //  DIO5 not used for LoRa Modulation
</code></pre>
<p><em>How shall we trigger these GPIO Handler Functions... From our GPIO Interrupt Handler?</em></p>
<p>Easy: We use an <strong>Array of Events</strong>! From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L405-L433"><code>sx1276-board.c</code></a></p>
<pre><code class="language-c">/// Maximum number of GPIO Pins that can be configured for interrupts
#define MAX_GPIO_INTERRUPTS 6  //  DIO0 to DIO5

/// Array of GPIO Pin Numbers that have been configured for interrupts
static uint8_t gpio_interrupts[MAX_GPIO_INTERRUPTS];

/// Array of Events for the GPIO Interrupts
static struct ble_npl_event gpio_events[MAX_GPIO_INTERRUPTS];
</code></pre>
<p>Our Event Array <strong><code>gpio_events</code></strong> points to the GPIO Handler Functions (via the Event Handler)...</p>
<p><img src="https://lupyuen.github.io/images/lora2-events.png" alt="GPIO Interrupts and Events" /></p>
<p>As explained earlier, our GPIO Interrupt Handler calls <strong><code>enqueue_interrupt_event</code></strong> to enqueue the Events from <code>gpio_events</code> into the Event Queue. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L435-L469">(See this)</a></p>
<p><em>How are the arrays <code>gpio_interrupts</code> and <code>gpio_events</code> populated?</em></p>
<p>We call <strong><code>init_interrupt_event</code></strong> to initialise the <code>gpio_interrupts</code> and <code>gpio_events</code> arrays. <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276-board.c#L471-L498">(See this)</a></p>
<h2 id="timer" class="section-header"><a href="#timer">5.6 Timer</a></h2>
<p>Remember that our LoRa SX1276 Transceiver will <strong>listen 5 seconds for incoming packets</strong>... Then we stop it to conserve battery power?</p>
<p>We do that with a <strong>Callout Timer</strong> from the NimBLE Porting Layer. Here's how we <strong>initialise a Callout Timer</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L227-L247"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  Define the Callout Timer
struct ble_npl_callout timer;

//  Init the Callout Timer with the Callback Function
ble_npl_callout_init(
    &amp;timer,        //  Callout Timer
    &amp;event_queue,  //  Event Queue that will handle the Callout upon timeout
    f,             //  Callback Function
    arg            //  Argument to be passed to Callback Function
);
</code></pre>
<p>When the Callout Timer expires, the Callback Function <strong><code>f</code></strong> will be called by our Background Task (via the Event Queue).</p>
<p>Here's how we <strong>set the Callout Timer</strong> to expire in <code>microsecs</code> microseconds: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L264-L289"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  Assume that Callout Timer has been stopped.
//  Convert microseconds to ticks.
ble_npl_time_t ticks = ble_npl_time_ms_to_ticks32(
    microsecs / 1000  //  Duration in milliseconds
);

//  Wait at least 1 tick
if (ticks == 0) { ticks = 1; }

//  Trigger the Callout Timer after the elapsed ticks
ble_npl_error_t rc = ble_npl_callout_reset(
    &amp;timer,  //  Callout Timer
    ticks    //  Number of ticks
);
assert(rc == 0);
</code></pre>
<p>To <strong>stop a Callout Timer</strong> (and cancel the pending callback), we do this: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L249-L262"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  If Callout Timer is still running...
if (ble_npl_callout_is_active(&amp;timer)) {
    //  Stop the Callout Timer
    ble_npl_callout_stop(&amp;timer);
}
</code></pre>
<p>Sometimes we need to suspend the current task and <strong>wait a short while</strong>. (Maybe to ponder our life choices) Here's how: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/sx1276.c#L291-L307"><code>sx1276.c</code></a></p>
<pre><code class="language-c">//  Convert microseconds to ticks
ble_npl_time_t ticks = ble_npl_time_ms_to_ticks32(
    microsecs / 1000  //  Duration in milliseconds
);

//  Wait at least 1 tick
if (ticks == 0) { ticks = 1; }

//  Wait for the ticks
ble_npl_time_delay(ticks);
</code></pre>
<h2 id="source-files" class="section-header"><a href="#source-files">5.7 Source Files</a></h2>
<p><em>How do we add the NimBLE Porting Layer to our own BL602 programs?</em></p>
<p>Copy these source files from the BL602 LoRa Firmware to your program...</p>
<ol>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/nimble_npl.h"><strong><code>nimble_npl.h</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/nimble_npl_os.h"><strong><code>nimble_npl_os.h</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/nimble_port.h"><strong><code>nimble_port.h</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/nimble_port_freertos.c"><strong><code>nimble_port_freertos.c</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/nimble_port_freertos.h"><strong><code>nimble_port_freertos.h</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/npl_freertos.h"><strong><code>npl_freertos.h</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/npl_os_freertos.c"><strong><code>npl_os_freertos.h</code></strong></a></p>
</li>
</ol>
<p>Be sure to <strong>Enable Assertion Failure Messages</strong> by adding this function to <code>main.c</code> (or <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L324-L335"><code>demo.c</code></a>)...</p>
<pre><code class="language-c">/// TODO: We now show assertion failures in development.
/// For production, comment out this function to use the system default,
/// which loops forever without messages.
void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
{
    //  Show the assertion failure, file, line, function name
	printf(&quot;Assertion Failed \&quot;%s\&quot;: file \&quot;%s\&quot;, line %d%s%s\r\n&quot;,
        failedexpr, file, line, func ? &quot;, function: &quot; : &quot;&quot;,
        func ? func : &quot;&quot;);
	//  Loop forever, do not pass go, do not collect $200
	for (;;) {}
}
</code></pre>
<p>The above source files were ported from the <a href="https://github.com/apache/mynewt-nimble"><strong>Apache NimBLE project</strong></a> with minor changes...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/commit/72e2cb44a40f9faf91c87ee8d421ed8eb4adb571#diff-c13b2cc976e41c4bc4d3fd967aefc40cccfb76bc14c7210001f675f371a14818">Detect Interrupt Service Routine</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/commit/41a07867dceb5541439ff3f05129941647b9341f#diff-c13b2cc976e41c4bc4d3fd967aefc40cccfb76bc14c7210001f675f371a14818">Rename <code>vPortEnterCritical</code> and <code>vPortExitCritical</code> to <code>taskENTER_CRITICAL</code> and <code>taskEXIT_CRITICAL</code></a></p>
</li>
</ul>
<h1 id="start-the-rakwireless-wisblock-transmitter" class="section-header"><a href="#start-the-rakwireless-wisblock-transmitter">6 Start the RAKwireless WisBlock Transmitter</a></h1>
<p>Today we shall install <strong>RAKwireless WisBlock</strong> to transmit LoRa Packets to BL602 for testing.</p>
<p><img src="https://lupyuen.github.io/images/wisblock-title.jpg" alt="RAKwireless WisBlock LPWAN Module mounted on WisBlock Base Board" /></p>
<p><em>RAKwireless WisBlock LPWAN Module mounted on WisBlock Base Board</em></p>
<h2 id="connect-wisblock" class="section-header"><a href="#connect-wisblock">6.1 Connect WisBlock</a></h2>
<p>Connect the following components according to the pic above...</p>
<ol>
<li>
<p><strong>WisBlock LPWAN Module</strong>: This is the <strong>Nordic nRF52840 Microcontroller</strong> with <strong>Semtech SX1262 LoRa Transceiver</strong>. <a href="https://docs.rakwireless.com/Product-Categories/WisBlock/RAK4631/Overview/">(More about this)</a></p>
<p>Mount the LPWAN Module onto the WisBlock Base Board.</p>
<p>(The LPWAN Module is already mounted when get the WisBlock Connected Box)</p>
</li>
<li>
<p><strong>WisBlock Base Board</strong>: This provides power to the LPWAN Module and exposes the USB and I/O ports. <a href="https://docs.rakwireless.com/Product-Categories/WisBlock/RAK5005-O/Overview/">(More about this)</a></p>
<p>The LPWAN Module should be mounted on the Base Board.</p>
</li>
<li>
<p><strong>LoRa Antenna</strong>: Connect the LoRa Antenna to the LPWAN Module.</p>
<p>(That's the black rod. Use the Antenna Adapter Cable)</p>
</li>
<li>
<p><strong>Bluetooth LE Antenna</strong>: Connect the Bluetooth LE Antenna to the LPWAN Module.</p>
<p>(The stringy flappy thingy)</p>
</li>
</ol>
<p><a href="https://electronics.stackexchange.com/questions/335912/can-i-break-a-radio-tranceiving-device-by-operating-it-with-no-antenna-connected"><strong>CAUTION: Always connect the LoRa Antenna and Bluetooth LE Antenna before Powering On... Or the LoRa and Bluetooth Transceivers may get damaged! See this</strong></a></p>
<p>The above components are shipped in the <a href="https://store.rakwireless.com/products/wisblock-connected-box"><strong>WisBlock Connected Box</strong></a>. (Which includes many more goodies!)</p>
<h2 id="install-vscode-and-platformio" class="section-header"><a href="#install-vscode-and-platformio">6.2 Install VSCode and PlatformIO</a></h2>
<ol>
<li>
<p>Follow the instructions in this excellent article to install <strong>VSCode and PlatformIO</strong>...</p>
<ul>
<li><a href="https://docs.rakwireless.com/Knowledge-Hub/Learn/Board-Support-Package-Installation-in-PlatformIO/"><strong>Installation of Board Support Package in PlatformIO</strong></a></li>
</ul>
</li>
<li>
<p>Remember to install the <strong>LoRa Library <code>SX126x-Arduino</code></strong> according to the steps above.</p>
<p>(We may skip the LoRaWAN OTAA Example)</p>
</li>
<li>
<p>Find out which <strong>LoRa Frequency</strong> we should use for your region...</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>We'll set the LoRa Frequency in a while.</p>
</li>
</ol>
<h2 id="build-the-firmware" class="section-header"><a href="#build-the-firmware">6.3 Build the firmware</a></h2>
<ol>
<li>
<p>Enter this at the command line...</p>
<pre><code class="language-bash"># Download the wisblock-lora-transmitter source code
git clone --recursive https://github.com/lupyuen/wisblock-lora-transmitter
</code></pre>
</li>
<li>
<p>In VSCode, click <strong><code>File ‚Üí Open Folder</code></strong></p>
<p>Select the folder that we have just downloaded: <strong><code>wisblock-lora-transmitter</code></strong></p>
</li>
<li>
<p>Edit the file <a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp"><strong><code>src/main.cpp</code></strong></a></p>
<p>Look for this code...</p>
<pre><code class="language-c">// Define LoRa parameters.
// TODO: Change RF_FREQUENCY for your region
#define RF_FREQUENCY 923000000  // Hz
</code></pre>
<p>Change <strong><code>923</code></strong> to the LoRa Frequency for your region: <code>434</code>, <code>780</code>, <code>868</code>, <code>915</code> or <code>923</code></p>
</li>
<li>
<p>Modify the <strong>LoRa Parameters</strong> in <a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp"><strong><code>src/main.cpp</code></strong></a> so that they match those in our BL602 LoRa Firmware</p>
</li>
<li>
<p><strong>Build the LoRa Firmware</strong> by clicking the <strong><code>Build</code></strong> icon at the lower left...</p>
<p><img src="https://lupyuen.github.io/images/wisblock-bar1.png" alt="Build Icon" /></p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text">Processing wiscore_rak4631 (platform: nordicnrf52; board: wiscore_rak4631; framework: arduino)
...
Building in release mode
Checking size .pio/build/wiscore_rak4631/firmware.elf
Advanced Memory Usage is available via &quot;PlatformIO Home &gt; Project Inspect&quot;
RAM:   [          ]   3.1% (used 7668 bytes from 248832 bytes)
Flash: [=         ]   7.3% (used 59800 bytes from 815104 bytes)
=========================== [SUCCESS] Took 4.49 seconds ===========================
</code></pre>
</li>
</ol>
<h2 id="flash-the-firmware" class="section-header"><a href="#flash-the-firmware">6.4 Flash the firmware</a></h2>
<ol>
<li>
<p><strong>Connect WisBlock</strong> to our computer's USB port</p>
</li>
<li>
<p><strong>Flash the LoRa Firmware</strong> to WisBlock by clicking the <strong><code>Upload</code></strong> icon...</p>
<p><img src="https://lupyuen.github.io/images/wisblock-bar2.png" alt="Upload Icon" /></p>
</li>
<li>
<p>We should see this...</p>
<p><img src="https://lupyuen.github.io/images/wisblock-flash.png" alt="Firmware flashed successfully" /></p>
</li>
<li>
<p>If we see the message...</p>
<pre><code class="language-text">Timed out waiting for acknowledgement from device
</code></pre>
<p>Then disconnect WisBlock from the USB port, reconnect and flash again.</p>
<p><img src="https://lupyuen.github.io/images/wisblock-flash2.png" alt="Firmware flashing failed" /></p>
</li>
</ol>
<h2 id="run-the-firmware" class="section-header"><a href="#run-the-firmware">6.5 Run the firmware</a></h2>
<ol>
<li>
<p><strong>Run the LoRa Firmware</strong> by clicking the <strong><code>Monitor</code></strong> icon...</p>
<p><img src="https://lupyuen.github.io/images/wisblock-bar3.png" alt="Monitor Icon" /></p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text">&gt; Executing task: platformio device monitor &lt;
--- Miniterm on /dev/cu.usbmodem14201  9600,8,N,1 ---
--- Quit: Ctrl+C | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
...
OnTxDone
OnTxDone
OnTxDone
</code></pre>
</li>
<li>
<p>WisBlock is now transmitting a LoRa Packet (<code>&quot;Hello&quot;</code>) every 5 seconds. <a href="https://github.com/lupyuen/wisblock-lora-transmitter/blob/main/src/main.cpp#L104-L128">(See this)</a></p>
</li>
<li>
<p>If we sniff the airwaves with a <strong>Software Defined Radio</strong>, we will see the distinctive <a href="https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio"><strong>LoRa Chirp</strong></a>...</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=USqStub3KC0"><strong>RAKwireless WisBlock‚Äã LoRa‚Äã Transmitter Sniffed by Airspy R2 SDR</strong></a></li>
</ul>
</li>
</ol>
<h1 id="build-and-run-the-bl602-lora-firmware" class="section-header"><a href="#build-and-run-the-bl602-lora-firmware">7 Build and Run the BL602 LoRa Firmware</a></h1>
<p>Let's run the LoRa Demo Firmware for BL602 to receive the LoRa Packets transmitted by RAKwireless WisBlock.</p>
<p>Find out which <strong>LoRa Frequency</strong> we should use for your region...</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html"><strong>LoRa Frequencies by Country</strong></a></li>
</ul>
<p>Download the Firmware Binary File <strong><code>sdk_app_lora.bin</code></strong> for your LoRa Frequency...</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v7.0.4"><strong>434 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v7.0.5"><strong>780 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v7.0.6"><strong>868 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v7.0.7"><strong>915 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/releases/tag/v7.0.3"><strong>923 MHz <code>sdk_app_lora</code> Binary</strong></a></p>
</li>
</ul>
<p>Alternatively, we may build the Firmware Binary File <code>sdk_app_lora.bin</code> from the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/lorarecv/customer_app/sdk_app_lora">source code</a>...</p>
<pre><code class="language-bash"># Download the lorarecv branch of lupyuen's bl_iot_sdk
git clone --recursive --branch lorarecv https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_lora

# TODO: Set the LoRa Frequency in sdk_app_lora/demo.c. 
# Edit the file and look for the line...
#   #define USE_BAND_923
# Change 923 to the LoRa Frequency for your region: 
#   434, 780, 868, 915 or 923 MHz
# See https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html

# TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602
make

# TODO: Change ~/blflash to the full path of blflash
cp build_out/sdk_app_lora.bin ~/blflash
</code></pre>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<p>(Remember to use the <strong><code>lorarecv</code></strong> branch, not the default <strong><code>master</code></strong> branch)</p>
<h2 id="flash-the-firmware-1" class="section-header"><a href="#flash-the-firmware-1">7.1 Flash the firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>...</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>&quot;Install rustup&quot;</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>&quot;Download and build blflash&quot;</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>sdk_app_lora.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>sdk_app_lora.bin</code> to BL602 over UART...</p>
<pre><code class="language-bash"># TODO: Change ~/blflash to the full path of blflash
cd ~/blflash

# For Linux:
sudo cargo run flash sdk_app_lora.bin \
    --port /dev/ttyUSB0

# For macOS:
cargo run flash sdk_app_lora.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 Serial Port
cargo run flash sdk_app_lora.bin --port COM5
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-the-firmware-1" class="section-header"><a href="#run-the-firmware-1">7.2 Run the firmware</a></h2>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board...</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602's UART Port at 2 Mbps like so...</p>
<p><strong>For Linux:</strong></p>
<pre><code class="language-bash">sudo screen /dev/ttyUSB0 2000000
</code></pre>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
<h2 id="enter-lora-commands" class="section-header"><a href="#enter-lora-commands">7.3 Enter LoRa commands</a></h2>
<p>Let's enter some commands to transmit a LoRa Packet!</p>
<ol>
<li>
<p>Press Enter to reveal the command prompt.</p>
</li>
<li>
<p>Enter <code>help</code> to see the available commands...</p>
<pre><code class="language-text"># help
====User Commands====
create_task              : Create a task
put_event                : Add an event
init_driver              : Init LoRa driver
send_message             : Send LoRa message
receive_message          : Receive LoRa message
read_registers           : Read registers
spi_result               : Show SPI counters
blogset                  : blog pri set level
blogdump                 : blog info dump
bl_sys_time_now          : sys time now
</code></pre>
</li>
<li>
<p>First we <strong>create the Background Task</strong> that will process received LoRa Packets.</p>
<p>Enter this command...</p>
<pre><code class="language-text"># create_task
</code></pre>
<p>This command calls the function <code>create_task</code>, which we have seen earlier.</p>
</li>
<li>
<p>Then we <strong>initialise our LoRa Transceiver</strong>. </p>
<p>Enter this command...</p>
<pre><code class="language-text"># init_driver
</code></pre>
<p>This command calls the function <code>init_driver</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># init_driver
SX1276 init
SX1276 interrupt init
SX1276 register handler: GPIO 11
SX1276 register handler: GPIO 0
SX1276 register handler: GPIO 5
SX1276 register handler: GPIO 12
</code></pre>
<p>This says that <code>register_gpio_handler</code> has <strong>registered the GPIO Handler Functions</strong> for <code>DIO0</code> to <code>DIO3</code>. (<code>DIO4</code> and <code>DIO5</code> are unused)</p>
<p>Our SX1276 Driver is now <strong>listening for GPIO Interrupts</strong> and handling them.</p>
</li>
<li>
<p>Then the <strong>GPIO Interrupt for <code>DIO3</code></strong> gets triggered automatically...</p>
<pre><code class="language-text">SX1276 DIO3: Channel activity detection    
</code></pre>
<p>(We're not sure why this always happens when we initialise the driver... But it's harmless)</p>
</li>
<li>
<p>Next we <strong>receive a LoRa Packet</strong>...</p>
<pre><code class="language-text"># receive_message
</code></pre>
<p>This command calls the function <code>receive_message</code>, which we have seen earlier.</p>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text"># receive_message
...
SX1276 DIO0: Packet received
Rx done: RadioEvents.RxDone
</code></pre>
<p>This says that the SX1276 Driver has <strong>received a LoRa Packet.</strong></p>
<p>And the packet contains <code>&quot;Hello&quot;</code>...</p>
<pre><code class="language-text">Rx done: 48 65 6c 6c 6f 
</code></pre>
<p><a href="https://youtu.be/3TSvo0dwwnQ"><strong>Watch the receive video on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/9bd7e7daa2497e8352d2cffec4be444d"><strong>Check out the receive log</strong></a></p>
</li>
</ol>
<h2 id="receive-timeout" class="section-header"><a href="#receive-timeout">7.4 Receive Timeout</a></h2>
<p>Remember that our SX1276 Transceiver will <strong>listen 5 seconds for incoming packets</strong>... Then it goes to sleep to conserve battery power?</p>
<p>Here's what happens when then SX1276 Driver doesn't receive any LoRa Packets within 5 seconds...</p>
<pre><code class="language-text"># receive_message
...
SX1276 receive timeout
Rx timeout
</code></pre>
<p>Our <strong>BL602 Timer is triggered automatically</strong> after 5 seconds to put the SX1276 Transceiver to sleep.</p>
<p><a href="https://www.youtube.com/watch?v=6qqZVcqN_rg"><strong>Watch the receive timeout video on YouTube</strong></a></p>
<p><a href="https://gist.github.com/lupyuen/ce578fd561ca050d4680c1750984ffd4"><strong>Check out the receive timeout log</strong></a></p>
<h1 id="troubleshoot-lora" class="section-header"><a href="#troubleshoot-lora">8 Troubleshoot LoRa</a></h1>
<p><em>What could go wrong with our BL602 LoRa Receiver?</em></p>
<p>Sorry to sound so down... But many things can go wrong with our BL602 LoRa Receiver!</p>
<p>Here's a <strong>BL602 LoRa troubleshooting guide</strong>...</p>
<p><img src="https://lupyuen.github.io/images/lora2-troubleshoot.png" alt="LoRa troubleshooting" /></p>
<ol>
<li>
<p>BL602 <strong>not receiving</strong> any LoRa Packets?</p>
<p>Sniff the airwaves with a <strong>Spectrum Analyser or Software Defined Radio</strong>. (See below)</p>
</li>
<li>
<p>SX1276 <strong>not responding</strong>, or returning strange data?</p>
<p>Verify the SPI Connection by <strong>Reading the SX1276 Registers</strong>. (See below)</p>
</li>
<li>
<p>SX1276 <strong>still not receiving</strong> LoRa Packets?</p>
<p>Turn on <strong>SPI Tracing</strong> and check the SPI Commands. (See below)</p>
</li>
<li>
<p>SX1276 <strong>not triggering interrupts</strong> when LoRa Packets are received?</p>
<p>Check the <strong>SX1276 Interrupt Counters</strong>. (See below)</p>
</li>
<li>
<p>Background Task <strong>not processing the interrupts</strong>?</p>
<p>Test the <strong>Event Queue</strong> by sending an Event. (See below)</p>
</li>
<li>
<p>BL602 <strong>hitting a RISC-V Exception</strong>?</p>
<p>Turn on <strong>Stack Trace</strong>. (See below)</p>
</li>
<li>
<p>BL602 <strong>Stack Trace not helpful</strong>?</p>
<p>Do a <strong>Stack Dump</strong>. (See below)</p>
</li>
</ol>
<p>Let's go into the details.</p>
<h2 id="sniff-lora-packets" class="section-header"><a href="#sniff-lora-packets">8.1 Sniff LoRa Packets</a></h2>
<p>It helps to validate that the LoRa Packets that we're about to receive... Are <strong>actually in the airwaves</strong>!</p>
<p>Sniff the airwaves with a <strong>Spectrum Analyser or Software Defined Radio</strong>. Check that the LoRa Packets are centered at the right LoRa Frequency.</p>
<p>LoRa Packets have this distinctive shape, called a <strong>LoRa Chirp</strong>...</p>
<p><img src="https://lupyuen.github.io/images/lora-sdr5.png" alt="LoRa Packet" /></p>
<p><a href="https://www.youtube.com/watch?v=USqStub3KC0"><strong>Watch the video on YouTube</strong></a></p>
<p>More about sniffing LoRa Packets...</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#troubleshoot-lora"><strong>&quot;Troubleshoot LoRa with Spectrum Analyser&quot;</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lora#visualise-lora-with-software-defined-radio"><strong>&quot;Visualise LoRa with Software Defined Radio&quot;</strong></a></p>
</li>
</ul>
<h2 id="read-registers" class="section-header"><a href="#read-registers">8.2 Read Registers</a></h2>
<p>Verify the SPI Connection between BL602 and SX1276 by entering the command <strong><code>read_registers</code></strong>...</p>
<pre><code class="language-text"># read_registers
Register 0x02 = 0x1a
Register 0x03 = 0x0b
Register 0x04 = 0x00
Register 0x05 = 0x52
</code></pre>
<p>This command reads the SX1276 Registers over the SPI Connections.</p>
<p>If there's a fault in the SPI wiring, we will see incorrect register values.</p>
<p>More about <code>read_registers</code>...</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora#troubleshoot-lora"><strong>&quot;Troubleshoot LoRa with read_registers&quot;</strong></a></li>
</ul>
<h2 id="trace-spi-requests" class="section-header"><a href="#trace-spi-requests">8.3 Trace SPI Requests</a></h2>
<p>To enable SPI Tracing:</p>
<ol>
<li>
<p>Edit <a href="https://github.com/lupyuen/bl_iot_sdk/blob/fe9bbabdddb05fc4961b8f52784305046a413505/components/hal_drv/bl602_hal/hal_spi.c#L57"><code>components/hal_drv/ bl602_hal/hal_spi.c</code></a></p>
</li>
<li>
<p>Set <strong><code>HAL_SPI_DEBUG</code></strong> to <strong><code>(1)</code></strong> like so...</p>
<pre><code class="language-c">//  Enable SPI Tracing
#define HAL_SPI_DEBUG (1)
</code></pre>
</li>
<li>
<p>Rebuild the firmware: <code>make clean</code> then <code>make</code></p>
</li>
</ol>
<p>We will see all SPI DMA Requests sent by BL602 to SX1276...</p>
<pre><code class="language-text">hal_spi_transfer = 1
transfer xfer[0].len = 1
Tx DMA src=0x4200cc58, dest=0x4000a288, size=1, si=1, di=0, i=1
Rx DMA src=0x4000a28c, dest=0x4200cc54, size=1, si=0, di=1, i=1
recv all event group.
</code></pre>
<p>More about SPI Tracing messages...</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lora#enter-lora-commands"><strong>&quot;Run LoRa Firmware with SPI Tracing&quot;</strong></a></li>
</ul>
<h2 id="show-interrupt-counters" class="section-header"><a href="#show-interrupt-counters">8.4 Show Interrupt Counters</a></h2>
<p>We may check the number of GPIO and SPI Interrupts triggered by SX1276 by entering the <strong><code>spi_result</code></strong> command...</p>
<pre><code class="language-text"># spi_result
DIO0 Interrupts: 1
DIO3 Interrupts: 1
Tx Interrupts:   302
Rx Interrupts:   302
</code></pre>
<p>This demo video explains the Interrupt Counters...</p>
<ul>
<li>
<p><a href="https://youtu.be/3TSvo0dwwnQ"><strong>Watch the receive video on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://gist.github.com/lupyuen/9bd7e7daa2497e8352d2cffec4be444d"><strong>Check out the receive log</strong></a></p>
</li>
</ul>
<h2 id="test-event-queue" class="section-header"><a href="#test-event-queue">8.5 Test Event Queue</a></h2>
<p>To check whether our Event Queue and Background Task (from the NimBLE Porting Layer) are OK, do this...</p>
<ol>
<li>
<p>If the Background Task has NOT been started, enter this command...</p>
<pre><code class="language-text"># create_task
</code></pre>
<p>(<code>create_task</code> should only be run once)</p>
</li>
<li>
<p>Then enter this command to enqueue an Event into our Event Queue...</p>
<pre><code class="language-text"># put_event
</code></pre>
</li>
<li>
<p>We should see this...</p>
<pre><code class="language-text">Handle an event
</code></pre>
<p>This means that our Event Queue and Background Task are ready to handle Interrupt Events triggered by SX1276.</p>
</li>
</ol>
<h2 id="bl602-stack-trace" class="section-header"><a href="#bl602-stack-trace">8.6 BL602 Stack Trace</a></h2>
<p>TODO</p>
<pre><code class="language-text">Exception Entry---&gt;&gt;&gt;
mcause 38000001, mepc 00000000, mtval 00000000
Exception code: 1
  msg: Instruction access fault
</code></pre>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/proj_config.mk#L40-L43"><code>sdk_app_lora/proj_config.mk</code></a></p>
<pre><code class="language-text"># Show Stack Trace when we hit a RISC-V Exception, 
# by enabling the Stack Frame Pointer.
# After setting this flag, do &quot;make clean ; make&quot;
CONFIG_ENABLE_FP:=1
</code></pre>
<p>TODO</p>
<ol>
<li>Rebuild the firmware: <code>make clean</code> then <code>make</code></li>
</ol>
<pre><code class="language-text">make clean
make
</code></pre>
<p>TODO</p>
<p>From https://gist.github.com/lupyuen/5ddbcdd1054c775521291c3d114f6cee</p>
<pre><code class="language-text">=== backtrace start ===
backtrace_stack: frame pointer=0x42011e70
backtrace: 0x2300ba88 (@ 0x42011e6c)
backtrace: 0x2300a852 (@ 0x42011e9c)
backtrace: 0x00000004   &lt;--- TRAP
backtrace: INVALID!!!
=== backtrace end ===
</code></pre>
<h2 id="bl602-stack-dump" class="section-header"><a href="#bl602-stack-dump">8.7 BL602 Stack Dump</a></h2>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/lorarecv/customer_app/sdk_app_lora/sdk_app_lora/demo.c#L471-L490"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Dump the current stack
void dump_stack(void)
{
    //  For getting the Stack Frame Pointer. Must be first line of function.
    uintptr_t *fp;

    //  Fetch the Stack Frame Pointer. Based on backtrace_riscv from
    //  https://github.com/bouffalolab/bl_iot_sdk/blob/master/components/bl602/freertos_riscv_ram/panic/panic_c.c#L76-L99
    __asm__(&quot;add %0, x0, fp&quot; : &quot;=r&quot;(fp));
    printf(&quot;dump_stack: frame pointer=%p\r\n&quot;, fp);

    //  Dump the stack, starting at Stack Frame Pointer - 1
    printf(&quot;=== stack start ===\r\n&quot;);
    for (int i = 0; i &lt; 128; i++) {
        uintptr_t *ra = (uintptr_t *)*(unsigned long *)(fp - 1);
        printf(&quot;@ %p: %p\r\n&quot;, fp - 1, ra);
        fp++;
    }
    printf(&quot;=== stack end ===\r\n\r\n&quot;);
}
</code></pre>
<p>TODO</p>
<pre><code class="language-text">Exception Handler Stack:
dump_stack: frame pointer=0x42011e70
=== stack start ===
...
@ 0x42011f20: 0x00000000
@ 0x42011f24: 0x00000000
@ 0x42011f28: 0x42011f50
@ 0x42011f2c: 0x23000cd2
@ 0x42011f30: 0x04000000
@ 0x42011f34: 0x00000001
@ 0x42011f38: 0x4000a28c
</code></pre>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/lora2-sketch.jpg" alt="" /></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">9 What's Next</a></h1>
<p>TODO</p>
<p>LoRaWAN Gateway</p>
<p>We have come a loooong way since I first <a href="https://github.com/lupyuen/LoRaArduino"><strong>experimented with LoRa in 2016</strong></a>...</p>
<ul>
<li>
<p><strong>Cheaper Transceivers</strong>: Shipped overnight from Thailand!</p>
</li>
<li>
<p><strong>Mature Networks</strong>: LoRaWAN, The Things Network</p>
</li>
<li>
<p><strong>Better Drivers</strong>: Thanks to Apache Mynewt OS!</p>
</li>
<li>
<p><strong>Powerful Microcontrollers</strong>: Arduino Uno vs RISC-V BL602</p>
</li>
<li>
<p><strong>Awesome Tools</strong>: RAKwireless WisBlock, Airspy SDR, RF Explorer</p>
</li>
</ul>
<p>Now is the <strong>right time to build LoRa gadgets.</strong> Stay tuned for more LoRa Adventures!</p>
<p>Meanwhile there's plenty more code in the <a href="https://github.com/bouffalolab/bl_iot_sdk"><strong>BL602 IoT SDK</strong></a> to be deciphered and documented: <strong>ADC, DAC, WiFi, Bluetooth LE,</strong> ...</p>
<p><a href="https://wiki.pine64.org/wiki/Nutcracker"><strong>Come Join Us... Make BL602 Better!</strong></a></p>
<p>üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read &quot;The RISC-V BL602 Book&quot;</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lora2.md"><code>lupyuen.github.io/src/lora2.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">10 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1370708936739885056?s=20">this Twitter Thread</a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/lora2-vaccine.jpg" alt="Pinebook Pro keeping me company during vaccination (Moderna)... Because bringing a PineCone would look so odd üëç" /></p>
<p><em>Pinebook Pro keeping me company during vaccination (Moderna)... Because bringing a PineCone would look so odd üëç</em></p>

    
</body>
</html>