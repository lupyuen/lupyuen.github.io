<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/avaota-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/avaota.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</h1>
    <nav id="rustdoc"><ul>
<li><a href="#boot-linux-on-our-sbc" title="Boot Linux on our SBC">1 Boot Linux on our SBC</a><ul></ul></li>
<li><a href="#nuttx-kernel-build-for-arm64-qemu" title="NuttX Kernel Build for Arm64 QEMU">2 NuttX Kernel Build for Arm64 QEMU</a><ul></ul></li>
<li><a href="#boot-nuttx-on-our-sbc" title="Boot NuttX on our SBC">3 Boot NuttX on our SBC</a><ul></ul></li>
<li><a href="#print-to-uart-in-arm64-assembly" title="Print to UART in Arm64 Assembly">4 Print to UART in Arm64 Assembly</a><ul></ul></li>
<li><a href="#set-the-start-address" title="Set the Start Address">5 Set the Start Address</a><ul></ul></li>
<li><a href="#uart-driver-for-16550" title="UART Driver for 16550">6 UART Driver for 16550</a><ul></ul></li>
<li><a href="#microsd-multiplexer--smart-power-plug" title="MicroSD Multiplexer + Smart Power Plug">7 MicroSD Multiplexer + Smart Power Plug</a><ul></ul></li>
<li><a href="#arm64-memory-management-unit" title="Arm64 Memory Management Unit">8 Arm64 Memory Management Unit</a><ul></ul></li>
<li><a href="#fix-the-memory-map" title="Fix the Memory Map">9 Fix the Memory Map</a><ul></ul></li>
<li><a href="#arm64-generic-interrupt-controller" title="Arm64 Generic Interrupt Controller">10 Arm64 Generic Interrupt Controller</a><ul></ul></li>
<li><a href="#nuttx-apps-filesystem" title="NuttX Apps Filesystem">11 NuttX Apps Filesystem</a><ul></ul></li>
<li><a href="#fix-the-uart-interrupt" title="Fix the UART Interrupt">12 Fix the UART Interrupt</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">13 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-avaota-a1" title="Appendix: Build NuttX for Avaota-A1">14 Appendix: Build NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#appendix-boot-nuttx-on-avaota-a1" title="Appendix: Boot NuttX on Avaota-A1">15 Appendix: Boot NuttX on Avaota-A1</a><ul></ul></li>
<li><a href="#appendix-upstream-nuttx-for-avaota-a1" title="Appendix: Upstream NuttX for Avaota-A1">16 Appendix: Upstream NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#appendix-sdwire-microsd-multiplexer" title="Appendix: SDWire MicroSD Multiplexer">17 Appendix: SDWire MicroSD Multiplexer</a><ul></ul></li>
<li><a href="#appendix-nuttx-apps-filesystem" title="Appendix: NuttX Apps Filesystem">18 Appendix: NuttX Apps Filesystem</a><ul>
<li><a href="#hostfs-becomes-romfs" title="HostFS becomes ROMFS">18.1 HostFS becomes ROMFS</a><ul></ul></li>
<li><a href="#linker-script" title="Linker Script">18.2 Linker Script</a><ul></ul></li>
<li><a href="#mount-the-romfs" title="Mount the ROMFS">18.3 Mount the ROMFS</a><ul></ul></li>
<li><a href="#copy-the-romfs" title="Copy the ROMFS">18.4 Copy the ROMFS</a><ul></ul></li></ul></li>
<li><a href="#appendix-port-nuttx-to-avaota-a1" title="Appendix: Port NuttX to Avaota-A1">19 Appendix: Port NuttX to Avaota-A1</a><ul>
<li><a href="#memory-map" title="Memory Map">19.1 Memory Map</a><ul></ul></li>
<li><a href="#gic-interrupt-controller" title="GIC Interrupt Controller">19.2 GIC Interrupt Controller</a><ul></ul></li>
<li><a href="#arm64-boot-code" title="Arm64 Boot Code">19.3 Arm64 Boot Code</a><ul></ul></li>
<li><a href="#nuttx-start-code" title="NuttX Start Code">19.4 NuttX Start Code</a><ul></ul></li>
<li><a href="#board-bringup-code" title="Board Bringup Code">19.5 Board Bringup Code</a><ul></ul></li>
<li><a href="#linker-script-1" title="Linker Script">19.6 Linker Script</a><ul></ul></li>
<li><a href="#nuttx-config" title="NuttX Config">19.7 NuttX Config</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>9 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<p><a href="https://youtu.be/XTDw245n5tM"><em>(Watch the Demo on YouTube)</em></a></p>
<p>This article explains how we ported NuttX from <a href="https://github.com/apache/nuttx/blob/master/boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig"><strong>QEMU Arm64 Kernel Build</strong></a> to <a href="https://pine64.com/product/yuzuki-avaota-a1-single-board-computer-4gb-32gb/"><strong>PINE64 Yuzuki Avaota-A1 SBC</strong></a> based on <a href="https://linux-sunxi.org/A523"><strong>Allwinner A527 SoC</strong></a> ‚Ä¶ Completed within <a href="https://github.com/lupyuen2/wip-nuttx/commits/avaota"><strong>24 Hours</strong></a>!</p>
<p><em>Why are we doing this?</em></p>
<ul>
<li>
<p>Anyone porting NuttX from <strong>QEMU to Real SBC</strong>? This walkthrough shall be mighty helpful!</p>
</li>
<li>
<p>Avaota-A1 SBC is <a href="https://github.com/AvaotaSBC/Avaota-A1"><strong>Open Source Hardware</strong></a> <em>(CERN OHL Licensed)</em>. PINE64 sells it today, maybe we‚Äôll see more manufacturers.</p>
</li>
<li>
<p>This could be the First Port of <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629512#MemoryConfigurations-KernelBuild"><strong>Arm64 in NuttX Kernel Build</strong></a>. <em>(NXP i.MX93 might be another?)</em></p>
</li>
<li>
<p>We‚Äôll run it as <a href="https://lupyuen.github.io/articles/testbot3"><strong>PR Test Bot</strong></a> for validating <strong>Arm64 Pull Requests</strong> on Real Hardware. PR Test Bot will be fully automated thanks to the <a href="https://lupyuen.github.io/articles/testbot3"><strong>MicroSD Multiplexer</strong></a>.</p>
</li>
</ul>
<p>We‚Äôre ready for volunteers to build <strong>NuttX Drivers for Avaota-A1 / Allwinner A527</strong> <em>(GPIO, SPI, I2C, MIPI CSI / DSI, Ethernet, WiFi, ‚Ä¶)</em> Please lemme know, maybe we can draw something on the Onboard LCD! üôè</p>
<ul>
<li>
<p><a href="https://linux-sunxi.org/A523"><strong>Sunxi Docs on Allwinner A527</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/File:A527_Datasheet_V0.93.pdf"><strong>Allwinner A527 Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf"><strong>Allwinner A523 User Manual</strong></a> <em>(A527 is similar to A523)</em></p>
</li>
<li>
<p><a href="https://github.com/AvaotaSBC/Avaota-A1/blob/master/hardware/v1.4/01_SCH/SCH_Avaota%20Pi%20A_2024-05-20.pdf"><strong>Avaota-A1 Schematic</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/sun55i-t527-avaota-a1.dts"><strong>Avaota-A1 Device Tree</strong></a></p>
</li>
</ul>
<p><em>(BTW I bought all the hardware covered in this article. Nope, nothing was sponsored: Avaota-A1, SDWire, IKEA TRETAKT)</em></p>
<p><img src="https://lupyuen.org/images/testbot3-uart.jpg" alt="Avaota-A1 SBC connected to USB UART" /></p>
<h1 id="boot-linux-on-our-sbc"><a class="doc-anchor" href="#boot-linux-on-our-sbc">¬ß</a>1 Boot Linux on our SBC</h1>
<p>Nifty Trick for Booting NuttX on <strong>Any Arm64 SBC</strong> (RISC-V too)</p>
<ul>
<li>
<p><strong>Arm64 Bootloader</strong> <em>(U-Boot / SyterKit)</em> will boot Linux by loading the <strong><code>Image</code></strong> file</p>
<p><em>(Containing the Linux Kernel)</em></p>
</li>
<li>
<p>Thus we <strong>‚ÄúHijack‚Äù the <code>Image</code> file</strong>, replace it by <strong>NuttX Kernel</strong></p>
</li>
<li>
<p>Which means <strong>NuttX Kernel</strong> shall look and feel like a <strong>Linux Kernel</strong></p>
</li>
<li>
<p>That‚Äôs why we have a <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L89-L116"><strong>Linux Kernel Header</strong></a> at the top of NuttX</p>
</li>
</ul>
<p>To begin, we observe our SBC and its <em>Natural Behaviour</em>‚Ä¶ How does it <strong>Boot Linux?</strong></p>
<ol>
<li>
<p>Connect a <a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>USB UART Dongle</strong></a> (CH340 or CP2102) to the <strong>UART0 Port</strong> (pic above)</p>
<div><table><thead><tr><th style="text-align: center">Avaota-A1</th><th style="text-align: center">USB UART</th><th style="text-align: center">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center"><em>Yellow</em></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td><td style="text-align: center"><em>Orange</em></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td><td style="text-align: center"><em>Red</em></td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.org/images/avaota-uart.jpg" alt="UART0 Port of Avaota-A1 SBC" /></p>
</li>
<li>
<p><strong>Boot Log</strong> will appear at <em>/dev/ttyUSB0</em>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Allow the user to access the USB UART port
## Logout and login to refresh the permissions
sudo usermod -a -G dialout $USER
logout

## Connect to USB UART Console
screen /dev/ttyUSB0 115200</code></pre></div></li>
<li>
<p>Download the <a href="https://github.com/AvaotaSBC/AvaotaOS/releases"><strong>Latest AvaotaOS Release</strong></a> <em>(Ubuntu Noble GNOME)</em> and uncompress it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>wget https://github.com/AvaotaSBC/AvaotaOS/releases/download/0.3.0.4/AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz
xz -d AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz</code></pre></div></li>
<li>
<p>Write the <strong><code>.img</code></strong> file to a MicroSD with <a href="https://etcher.balena.io/"><strong>Balena Etcher</strong></a>.</p>
</li>
<li>
<p>Insert the MicroSD into our SBC and <a href="https://gist.github.com/lupyuen/dd4beb052ce07c36d41d409631c6d68b"><strong>Boot AvaotaOS</strong></a>. We‚Äôll see the Boot Log‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast</code></pre></div></li>
<li>
<p>Aha! <strong>Kernel Boot Address</strong> <em>0x4080_0000</em> is super important, we‚Äôll use it in a while</p>
</li>
</ol>
<h1 id="nuttx-kernel-build-for-arm64-qemu"><a class="doc-anchor" href="#nuttx-kernel-build-for-arm64-qemu">¬ß</a>2 NuttX Kernel Build for Arm64 QEMU</h1>
<p>Follow these steps to Build and Run NuttX for <a href="https://nuttx.apache.org/docs/latest/platforms/arm64/qemu/boards/qemu-armv8a/index.html"><strong>Arm64 QEMU (Kernel Build)</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX Kernel (NuttX Kernel Build)
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Build NuttX Apps (NuttX Kernel Build)
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Boot NuttX on QEMU
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>Check that it works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

NuttShell (NSH) NuttX-12.8.0
nsh&gt; uname -a
nxposix_spawn_exec: ERROR: exec failed: 2
NuttX 12.8.0 96eb5e7819 Mar 13 2025 15:45:11 arm64 qemu-armv8a

nsh&gt; hello
Hello, World!!

## No worries about `nxposix_spawn_exec`
## To Quit: Press Ctrl-a then x</code></pre></div>
<p>We‚Äôre ready to boot <strong><code>nuttx.bin</code></strong> on our SBC.</p>
<blockquote>
<p><img src="https://lupyuen.org/images/semihost-qemu.jpg" alt="NuttX Kernel Build will call out to HostFS Semihosting" /></p>
</blockquote>
<p><em>What‚Äôs this semihosting business in QEMU?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX on QEMU, needs Semihosting
qemu-system-aarch64 \
  -semihosting ...</code></pre></div>
<p>NuttX Kernel Build will call out to <a href="https://lupyuen.github.io/articles/testbot2#semihosting-breakout"><strong>HostFS Semihosting</strong></a> (pic above) to access NSH Shell and NuttX Apps. We‚Äôll change this for our SBC.</p>
<p><em>Why start with NuttX Kernel Build? Not NuttX Flat Build?</em></p>
<p>Our SBC is a mighty monster with <strong>Eight Arm64 Cores</strong> and plenty of RAM <em>(2 GB)</em>. It makes more sense to boot [<strong>NuttX Kernel Build</strong>]https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629512#MemoryConfigurations-KernelBuild) and run lots of cool powerful NuttX App, thanks to <a href="https://lupyuen.github.io/articles/privilege#nuttx-flat-mode-becomes-kernel-mode"><strong>Virtual Memory</strong></a>.</p>
<p><em>(NuttX Flat Build was created for Simpler Microcontrollers with Limited RAM)</em></p>
<p><img src="https://lupyuen.org/images/testbot3-sbc.jpg" alt="Yuzuki Avaota-A1 SBC with PinePhone MicroSD Extender" /></p>
<h1 id="boot-nuttx-on-our-sbc"><a class="doc-anchor" href="#boot-nuttx-on-our-sbc">¬ß</a>3 Boot NuttX on our SBC</h1>
<p>Remember the <a href="https://lupyuen.github.io/articles/avaota#boot-linux-on-our-sbc"><strong>MicroSD we downloaded</strong></a>? Inside the MicroSD is a 28 MB Linux Kernel, named ‚Äú<strong><code>Image</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -l /media/$USER/YOUR_SD
   78769  bl31.bin
  180233  config-5.15.154-ga464bc4feaff
     512  dtb
     512  extlinux
27783176  Image
  180228  scp.bin
   12960  splash.bin
 5193581  System.map-5.15.154-ga464bc4feaff
 6497300  uInitrd</code></pre></div>
<p>We replace it with NuttX‚Ä¶</p>
<ol>
<li>
<p>Take the NuttX Kernel <strong><code>nuttx.bin</code></strong> from the previous section</p>
<p><em>(Yes the QEMU one)</em></p>
</li>
<li>
<p>Overwrite the <strong><code>Image</code></strong> file by <strong><code>nuttx.bin</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Backup and overwrite `Image` on MicroSD
mv \
  /media/$USER/YOUR_SD/Image \
  /media/$USER/YOUR_SD/Image.old
cp \
  nuttx.bin \
  /media/$USER/YOUR_SD/Image

## `Image` should be a lot smaller now
## Remember to Unmount and prevent filesystem corruption
ls -l /media/$USER/YOUR_SD/Image
umount /media/$USER/YOUR_SD</code></pre></div></li>
<li>
<p>Insert the MicroSD into our SBC. Boot it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast</code></pre></div></li>
</ol>
<p>Nothing happens. We tweak this iteratively, in tiny steps‚Ä¶</p>
<h1 id="print-to-uart-in-arm64-assembly"><a class="doc-anchor" href="#print-to-uart-in-arm64-assembly">¬ß</a>4 Print to UART in Arm64 Assembly</h1>
<p><em>Is NuttX actually booting on our SBC?</em></p>
<p>Let‚Äôs print something. <strong>UART0 Base Address</strong> is here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">UART0</td><td style="text-align: left"><em>0x0250_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>16550 Transmit Register is at <strong>Offset 0</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x0000</em></td><td style="text-align: left">UART_THR <em>(Transmit Holding Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0004</em></td><td style="text-align: left">UART_DLH <em>(Divisor Latch High Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0008</em></td><td style="text-align: left">UART_IIR <em>(Interrupt Identity Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x000C</em></td><td style="text-align: left">UART_LCR <em>(Line Control)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>This says we can <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333"><strong>Print to UART</strong></a> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `123` to UART0
*(volatile uint8_t *) 0x02500000 = &#39;1&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;2&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;3&#39;;</code></pre></div>
<p>But we‚Äôll do it in <strong>Arm64 Assembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/be2f1c55aa24eda9cd8652aa0bf38251335e9d01">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here */
__start:
  add x13, x18, #0x16 /* &quot;MZ&quot;: Magic Number for Linux Kernel Header */
  b   real_start      /* Jump to Executable Code      */
  ...                 /* Omitted: Linux Kernel Header */

/* Executable Code begins here */
/* We print `123` to UART0     */
real_start:

  /* Load UART0 Base Address into Register X15 */
  mov  x15, #0x02500000

  /* Load character `1` into Register W16 */
  mov  w16, #0x31

  /* Store the lower byte from Register W16 (`1`) to UART0 Base Address */
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`2`) to UART0 Base Address */
  mov  w16, #0x32
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`3`) to UART0 Base Address */
  mov  w16, #0x33
  strb w16, [x15]</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sg2000#print-to-uart-in-risc-v-assembly"><em>(RISC-V? Same same)</em></a></p>
<p>Rebuild NuttX and recopy <strong><code>nuttx.bin</code></strong> to MicroSD, overwriting the <strong><code>Image</code></strong> file. NuttX will boot and <a href="https://gist.github.com/lupyuen/14188c44049a14e3581523c593fdf2d8"><strong>print <code>123</code></strong></a>! üéâ</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast
123</code></pre></div>
<p>Indeed NuttX is booting on our SBC, then crashing later. <em>(Ignore the error: opteed_fast)</em></p>
<p><em>Why print in Arm64 Assembly? Why not C?</em></p>
<ol>
<li>
<p>Arm64 Assembly is the <strong>very first thing that boots</strong> when Bootloader starts NuttX</p>
</li>
<li>
<p>This happens <strong>before anything complicated</strong> and crash-prone begins: UART Driver, Memory Management, Task Scheduler, ‚Ä¶</p>
</li>
<li>
<p>The Arm64 Assembly above is <strong>Address-Independent Code</strong>: It will execute at Any Arm64 Address</p>
</li>
</ol>
<p>Next we move our code and make it Address-Dependent‚Ä¶</p>
<h1 id="set-the-start-address"><a class="doc-anchor" href="#set-the-start-address">¬ß</a>5 Set the Start Address</h1>
<p><em>NuttX boots a tiny bit on our SBC. Where‚Äôs the rest?</em></p>
<p>Our SBC boots NuttX at a different address from QEMU. We set the <strong>Start Address</strong> inside NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
123</code></pre></div>
<ol>
<li>
<p>Remember the <a href="https://lupyuen.github.io/articles/avaota#boot-linux-on-our-sbc"><strong>Boot Log</strong></a> from earlier? It says that the <a href="https://github.com/YuzukiHD/SyterKit"><strong>SyterKit Bootloader</strong></a> starts NuttX at <strong>Address <code>0x4080_0000</code></strong>. We set it here: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c38e1f7c014e1af648a33847fc795930ba995bca">ld-kernel.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY {
  /* Previously: QEMU boots at 0x4028_0000 */
  dram (rwx)  : ORIGIN = 0x40800000, LENGTH = 2M

  /* Previously: QEMU Paged Memory is at 0x4028_0000 */
  pgram (rwx) : ORIGIN = 0x40A00000, LENGTH = 4M   /* w/ cache */

  /* Why? Because 0x4080_0000 + 2 MB = 0x40A0_0000 */</code></pre></div>
<p><em>(Note that Paged Memory Pool shifts down)</em></p>
</li>
<li>
<p>Since we changed the <strong>Paged Memory Pool</strong> <em>(pgram)</em>, we update <em>ARCH_PGPOOL_PBASE</em> and <em>VBASE</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/eb33ac06f88dda557bc8ac97bec7d6cbad4ccb86">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Physical Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_PBASE=0x40A00000

## Virtual Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_VBASE=0x40A00000</code></pre></div>
<p><em>(Paged Memory Pool shall be dished out as Virtual Memory to NuttX Apps)</em></p>
</li>
<li>
<p>NuttX QEMU declares the <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45"><strong>RAM Size as 128 MB</strong></a> in <em>RAMBANK1_SIZE</em>. We set <em>RAM_SIZE</em> accordingly: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c8fbc5b86c2bf1dd7b8243b301b0790115c9c4ca">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## RAM Size is a paltry 128 MB
CONFIG_RAM_SIZE=134217728</code></pre></div>
<p><em>(Kinda tiny, but sufficient)</em></p>
</li>
<li>
<p><strong>Linux Kernel Header</strong> has an incorrect <strong>Image Load Offset</strong>. Arm64 Bootloaders don‚Äôt care, we‚Äôll let it be‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here, followed by Linux Kernel Header */
__start:
  ...
  /* Image Load Offset from Start of RAM         */
  /* Boot Address - CONFIG_RAM_START = 0x800000  */
  /* But we won&#39;t change this, since it&#39;s unused */
  .quad 0x800000</code></pre></div></li>
</ol>
<p>With these mods, our C Code in NuttX shall boot correctly. FYI: Boot Address also appears on the Onboard LCD‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot3-lcd.jpg" alt="Avaota-A1 SBC with Onboard LCD" /></p>
<h1 id="uart-driver-for-16550"><a class="doc-anchor" href="#uart-driver-for-16550">¬ß</a>6 UART Driver for 16550</h1>
<p><em>Our C Code can print to UART now?</em></p>
<p>To watch the <strong>Boot Progress</strong> <em>(Sesame Street-style)</em>, we can print primitively to UART like this: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // Init the Memory Tagging Extension

  *(volatile uint8_t *) 0x02500000 = &#39;D&#39;;
  qemu_board_initialize();  // Init the Board

  *(volatile uint8_t *) 0x02500000 = &#39;E&#39;;
  arm64_earlyserialinit();  // Init the Serial Driver

  *(volatile uint8_t *) 0x02500000 = &#39;F&#39;;
  syslog_rpmsg_init_early(...);  // Init the System Logger

  *(volatile uint8_t *) 0x02500000 = &#39;G&#39;;
  up_perf_init(..);  // Init the Performance Counters</code></pre></div>
<p>Beyond Big Bird: We need the <strong>16550 UART Driver</strong>. Based on the <a href="https://lupyuen.github.io/articles/avaota#print-to-uart-in-arm64-assembly"><strong>A527 UART Doc</strong></a>‚Ä¶</p>
<ol>
<li>
<p><strong>NuttX Boot Code</strong> <em>(Arm64 Assembly)</em> will print to UART. We patch it: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-60cebb895326dea641e32d31ff39511acf127a30c9ac8f275590e7524737366e">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address and Baud Rate for 16550 UART
#define UART1_BASE_ADDRESS          0x02500000
#define EARLY_UART_PL011_BAUD_RATE  115200</code></pre></div></li>
<li>
<p><strong>NuttX Boot Code</strong> will drop UART Output, unless we wait for UART Ready: <a href="https://github.com/lupyuen2/wip-nuttx/commit/544323e7c0e66c4df0d1312d4837147d420bc19d">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Wait for 16550 UART to be ready to transmit
* xb: Register that contains the UART Base Address
* wt: Scratch register number */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14] /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20        /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                /* Wait for the UART to be ready (THRE=1) */
.endm</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/uboot#wait-for-uart-ready"><em>(Thanks to PinePhone)</em></a></p>
</li>
<li>
<p>QEMU uses PL011 UART. We switch to <strong>16550 UART</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-aefbee7ddc3221be7383185346b81cff77d382eb6f308ecdccb44466d0437108">qemu_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Switch from PL011 UART (QEMU) to 16550 UART
#include &lt;nuttx/serial/uart_16550.h&gt;

// Enable the 16550 Console UART at Startup
void arm64_earlyserialinit(void) {
  // Previously for QEMU: pl011_earlyserialinit
  u16550_earlyserialinit();
}

// Ditto but not so early
void arm64_serialinit(void) {
  // Previous for QEMU: pl011_serialinit
  u16550_serialinit();
}</code></pre></div></li>
<li>
<p><strong>16550 UART</strong> shall be configured: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x02500000
CONFIG_16550_UART0_CLOCK=198144000
CONFIG_16550_UART0_IRQ=125
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y</code></pre></div></li>
<li>
<p><strong>PL011 UART</strong> shall be removed: <a href="https://github.com/lupyuen2/wip-nuttx/commit/8fc8ed6ba84cfea86184f61d9c4d7c8e21329987">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Remove PL011 UART from NuttX Config:
## CONFIG_UART1_BASE=0x9000000
## CONFIG_UART1_IRQ=33
## CONFIG_UART1_PL011=y
## CONFIG_UART1_SERIAL_CONSOLE=y
## CONFIG_UART_PL011=y</code></pre></div></li>
<li>
<p><strong>16550_UART0_CLOCK</strong> isn‚Äôt quite correct, we‚Äôll <a href="https://lupyuen.github.io/articles/avaota#nuttx-config"><strong>settle later</strong></a>. Meanwhile we disable the <strong>UART Clock Configuration</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// We disable the UART Clock Configuration...
static int u16550_setup(FAR struct uart_dev_s *dev) { ...
#ifdef FIX_LATER  // We&#39;ll fix it later
  // Enter DLAB=1
  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));

  // Omitted: Set the UART Baud Divisor
  // ...

  // Clear DLAB
  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif</code></pre></div></li>
</ol>
<p>Same old drill: Rebuild, recopy and reboot NuttX. We see <a href="https://gist.github.com/lupyuen/563ed00d3f6e9f7fb9b27268d4eae26b"><strong>plenty more debug output</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>OK the <em>repeated rebuilding, recopying and rebooting</em> of NuttX is getting really tiresome. We automate‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot2-flow3.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<h1 id="microsd-multiplexer--smart-power-plug"><a class="doc-anchor" href="#microsd-multiplexer--smart-power-plug">¬ß</a>7 MicroSD Multiplexer + Smart Power Plug</h1>
<p><em>What if we could rebuild-recopy-reboot NuttX‚Ä¶ In One Single Script?</em></p>
<p>Thankfully our Avaota-A1 SBC is connected to <a href="https://lupyuen.github.io/articles/avaota#appendix-sdwire-microsd-multiplexer"><strong>SDWire MicroSD Multiplexer</strong></a> and <a href="https://lupyuen.github.io/articles/testbot#power-up-our-oz64-sbc"><strong>Smart Power Plug</strong></a> (pic above). Our Build Script shall do <strong>everything</strong> for us‚Ä¶</p>
<ol>
<li>
<p>Copy <strong>NuttX to MicroSD</strong></p>
</li>
<li>
<p><strong>Swap the MicroSD</strong> from our Test PC to SBC</p>
</li>
<li>
<p><strong>Power up SBC</strong> and boot NuttX</p>
</li>
<li>
<p><strong>Run OSTest</strong> and verify the result</p>
</li>
<li>
<p>How it looks? <a href="https://youtu.be/XTDw245n5tM"><strong>Watch the Demo</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<p>Here‚Äôs our nifty <strong>Build Script</strong>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX and Apps (NuttX Kernel Build)
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Get the Home Assistant Token
## That we copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
## https://github.com/lupyuen/nuttx-avaota-a1/blob/main/copy-image.sh
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC to finish booting
sleep 30

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://youtu.be/XTDw245n5tM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><img src="https://lupyuen.org/images/avaota-power1.jpg" alt="Smart Power Plug in IKEA App and Google Home" /></p>
<p>This script assumes that we have‚Ä¶</p>
<ul>
<li>
<p>Installed a <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Home Assistant Server</strong></a></p>
<p><em>(Works fine with Docker)</em></p>
</li>
<li>
<p>Added the Smart Power Plug to <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant</strong></a></p>
<p><em>‚ÄúAvaota Power‚Äù (pic above)</em></p>
</li>
<li>
<p>Installed the <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant SDK</strong></a> for Home Assistant</p>
<p><em>(So we don‚Äôt need Zigbee programming)</em></p>
</li>
<li>
<p>Created the <a href="https://lupyuen.github.io/articles/sg2000a#call-the-home-assistant-api"><strong>Power Automation</strong></a> in Home Assistant</p>
<p><em>‚ÄúAvaota Power On‚Äù</em> and <em>‚ÄúAvaota Power Off‚Äù (pic below)</em></p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/avaota-power2.jpg" alt="Smart Power Plug in Home Assistant" /></p>
<p><em>What‚Äôs copy_image.sh?</em></p>
<p>This is the script that copies our NuttX Image to MicroSD, via the <strong>SDWire MicroSD Multiplexer</strong>, explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/avaota#appendix-sdwire-microsd-multiplexer"><strong>‚ÄúSDWire MicroSD Multiplexer‚Äù</strong></a></li>
</ul>
<p><em>Can we automate everything? Including OSTest?</em></p>
<p>Yep we have an <a href="https://github.com/lupyuen/nuttx-build-farm/blob/main/avaota.exp"><strong>Expect Script</strong></a> that will execute and verify <strong>OSTest</strong>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
## https://github.com/lupyuen/nuttx-avaota-a1/blob/main/copy-image.sh
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Boot and Test NuttX with OSTest
## https://github.com/lupyuen/nuttx-build-farm/blob/main/avaota.exp
export AVAOTA_SERVER=thinkcentre
pushd $HOME/nuttx-build-farm
expect ./avaota.exp
popd</code></pre></div><h1 id="arm64-memory-management-unit"><a class="doc-anchor" href="#arm64-memory-management-unit">¬ß</a>8 Arm64 Memory Management Unit</h1>
<p><em>It‚Äôs getting late. Can we get back to NuttX now?</em></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/commits/avaota"><strong>24 Hours</strong></a> is all we need no worries! Earlier we saw NuttX <a href="https://lupyuen.github.io/articles/avaota#uart-driver-for-16550"><strong>stuck at ‚ÄúAB‚Äù</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>Which says that NuttX is stranded inside <strong>arm64_mmu_init</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

// `AB` means that NuttX is stuck inside arm64_mmu_init()
void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  // Stuck above, never came here
  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // Init the Memory Tagging Extension</code></pre></div>
<p><em>What‚Äôs arm64_mmu_init?</em></p>
<p>NuttX calls <strong>arm64_mmu_init</strong> to start the Arm64 <strong>Memory Management Unit (MMU)</strong>. We add some logs inside: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-230f2ffd9be0a8ce48d4c9fb79df8f003b0c31fa0a18b6c0876ede5b4e334bb9">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable Debugging for MMU
#define CONFIG_MMU_ASSERT 1
#define CONFIG_MMU_DEBUG  1
#define trace_printf _info

// We fix the Debug Output, changing `%lux` to `%p`
static void init_xlat_tables(const struct arm_mmu_region *region) {
  ...
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);

// To enable the MMU at Exception Level 1...
static void enable_mmu_el1(unsigned int flags) {
  ...
  // Flush the Cached Data before Enabling MMU
  _info(&quot;UP_MB&quot;);
  UP_MB();

  // Enable the MMU and Data Cache
  _info(&quot;Enable the MMU and data cache&quot;);
  write_sysreg(value | SCTLR_M_BIT | SCTLR_C_BIT, sctlr_el1);

  // Ensure that MMU Enable takes effect immediately
  _info(&quot;UP_ISB&quot;);
  UP_ISB();</code></pre></div>
<p>And we Enable the Logs for <strong>Scheduler and Memory Manager</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Enable Logging for Memory Manager
CONFIG_DEBUG_MM=y
CONFIG_DEBUG_MM_ERROR=y
CONFIG_DEBUG_MM_INFO=y
CONFIG_DEBUG_MM_WARN=y

## Enable Logging for Scheduler
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p>Ah OK we‚Äôre stuck just before <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Enabling the MMU</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Init the MMU Page Translation Tables
init_xlat_tables: mmap: virt 0x7000000    phys 0x7000000    size 0x20000000
init_xlat_tables: mmap: virt 0x40000000   phys 0x40000000   size 0x8000000
init_xlat_tables: mmap: virt 0x4010000000 phys 0x4010000000 size 0x10000000
init_xlat_tables: mmap: virt 0x8000000000 phys 0x8000000000 size 0x8000000000
init_xlat_tables: mmap: virt 0x3eff0000 phys 0x3eff0000 size 0x10000
init_xlat_tables: mmap: virt 0x40800000 phys 0x40800000 size 0x2a000
init_xlat_tables: mmap: virt 0x4082a000 phys 0x4082a000 size 0x6000
init_xlat_tables: mmap: virt 0x40830000 phys 0x40830000 size 0x13000
init_xlat_tables: mmap: virt 0x40a00000 phys 0x40a00000 size 0x400000

## Enable the MMU at Exception Level 1
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/interrupt#exception-levels">(<strong>Exception Level</strong> explained)</a></p>
<p>Something sus about the above <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Mystery Addresses</strong></a>, what are they?</p>
<p>
<div><table><thead><tr><th style="text-align: center">Virtual</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><em>0x0700_0000</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4000_0000</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x40_1000_0000</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x80_0000_0000</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x3EFF_0000</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4080_0000</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: center"><em>0x4082_A000</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: center"><em>0x4083_0000</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: center"><em>0x40A0_0000</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p><img src="https://lupyuen.org/images/avaota-memory.jpg" alt="A527 Memory Map" /></p>
<h1 id="fix-the-memory-map"><a class="doc-anchor" href="#fix-the-memory-map">¬ß</a>9 Fix the Memory Map</h1>
<p><em>Why do we need Arm64 MMU? (Memory Management Unit)</em></p>
<p>We require MMU for‚Ä¶</p>
<ul>
<li>
<p><strong>Memory Protection</strong>: Prevent Applications <em>(and Kernel)</em> from meddling with things <em>(in System Memory)</em> that they‚Äôre not supposed to</p>
</li>
<li>
<p><strong>Virtual Memory</strong>: Allow Applications to access chunks of <em>‚ÄúImaginary Memory‚Äù</em> at Exotic Addresses <em>(0x8000_0000!)</em></p>
<p>But in reality: They‚Äôre System RAM recycled from boring old addresses <em>(like 0x40A0_4000)</em></p>
</li>
</ul>
<p>If we don‚Äôt configure MMU with the correct <strong>Memory Map</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>NuttX Kernel</strong> won‚Äôt boot: <em>‚ÄúHelp! I can‚Äôt access my Kernel Code and Data!‚Äù</em></p>
</li>
<li>
<p><strong>NuttX Apps</strong> won‚Äôt run: <em>‚ÄúWhoops where‚Äôs the App Code and Data that Kernel promised?‚Äù</em></p>
</li>
</ul>
<p><em>Arm64 MMU won‚Äôt turn on. Maybe our Memory Map is incorrect?</em></p>
<p>We verify our <strong>A527 Memory Map</strong> (pic above)</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 40</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Module</strong></td><td style="text-align: left"><strong>Address</strong></td></tr>
<tr><td style="text-align: left">Boot ROM &amp; SRAM</td><td style="text-align: left"><em>0x0000_0000</em> to ‚Ä¶</td></tr>
<tr><td style="text-align: left">PCIE</td><td style="text-align: left"><em>0x2000_0000</em> to <em>0x2FFF_FFFF</em></td></tr>
<tr><td style="text-align: left">DRAM</td><td style="text-align: left"><em>0x4000_0000</em> to ‚Ä¶</td></tr>
</tbody></table>
</div></div>
</p>
<p>How does this compare with NuttX? We do extra <strong>MMU Logging</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/9488ecb5d8eb199bdbe16adabef483cf9cf04843">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Print the Names of the MMU Memory Regions
static void init_xlat_tables(const struct arm_mmu_region *region) { ...
  _info(&quot;name=%s\n&quot;, region-&gt;name);
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);</code></pre></div>
<p>Ah much clearer! Now we see the <strong>Names of Memory Regions</strong> for the MMU‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_CFG</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_MEM</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_IO</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Two Tweaks‚Ä¶</p>
<ul>
<li>
<p><strong>DEVICE_REGION</strong>: This says I/O Memory Space ends at <em>0x2700_0000</em>. Based on the earlier <strong>A527 Memory Map</strong>, we extend this to <em>0x4000_0000 (1 GB)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fix the I/O Memory Space: Base Address and Size
#define CONFIG_DEVICEIO_BASEADDR 0x00000000
#define CONFIG_DEVICEIO_SIZE     MB(1024)

// We don&#39;t need PCI, for now
// #define CONFIG_PCI_CFG_BASEADDR 0x4010000000
// #define CONFIG_PCI_CFG_SIZE     MB(256)
// #define CONFIG_PCI_MEM_BASEADDR 0x8000000000
// #define CONFIG_PCI_MEM_SIZE     GB(512)
// #define CONFIG_PCI_IO_BASEADDR  0x3eff0000
// #define CONFIG_PCI_IO_SIZE      KB(64)</code></pre></div></li>
<li>
<p><strong>PCI</strong>: We remove these for now: <a href="https://github.com/lupyuen2/wip-nuttx/commit/ca273d05e015089a33072997738bf588b899f8e7">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct arm_mmu_region g_mmu_regions[] = {
  ...
  // We don&#39;t need PCI, for now
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_CFG&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_MEM&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_IO&quot;, ...</code></pre></div></li>
</ul>
<p>The rest are hunky dory‚Ä¶</p>
<ul>
<li>
<p><strong>DRAM0_S0</strong> says that RAM Address Space ends at <em>0x4800_0000 (128 MB)</em></p>
<p><em>(Kinda small, but sufficient for now)</em></p>
</li>
<li>
<p><strong>nx_code</strong> <em>(0x4080_0000)</em>: Kernel Code begins here</p>
</li>
<li>
<p><strong>nx_rodata</strong> <em>(0x4082_A000)</em>: Read-Only Data for Kernel</p>
</li>
<li>
<p><strong>nx_data</strong> <em>(0x4083_0000)</em>: Read-Write Data for Kernel</p>
</li>
<li>
<p><strong>nx_pgpool</strong> <em>(0x40A0_0000)</em>: Remember the <a href="https://lupyuen.github.io/articles/avaota#set-the-start-address"><strong>Paged Memory Pool</strong></a>? This shall be dished out as <strong>Virtual Memory</strong> to NuttX Apps</p>
</li>
</ul>
<p>We rebuild, recopy, reboot NuttX. Our Memory Map looks <a href="https://gist.github.com/lupyuen/ad4cec0dee8a21f3f404144be180fa14"><strong>much better now</strong></a>‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0000_0000</td><td style="text-align: center"><em>0x4000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Though it crashes elsewhere‚Ä¶</p>
<h1 id="arm64-generic-interrupt-controller"><a class="doc-anchor" href="#arm64-generic-interrupt-controller">¬ß</a>10 Arm64 Generic Interrupt Controller</h1>
<p><em>Why is NuttX failing with an Undefined Instruction?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>gic_validate_dist_version: No GIC version detect
arm64_gic_initialize: no distributor detected, giving up ret=-19
...
nx_start_application: Starting init task: /system/bin/init
arm64_el1_undef: Undefined instruction at 0x408276e4, dump:
Assertion failed panic: at file: common/arm64_fatal.c:572</code></pre></div>
<p>Yeah this failure is <a href="https://gist.github.com/lupyuen/3a7d1e791ac14905532db2d768ae230f"><strong>totally misleading</strong></a>. Real Culprit: NuttX couldn‚Äôt <strong>Init the GIC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>No GIC version detect
No distributor detected, giving up</code></pre></div>
<p><em>What‚Äôs this GIC?</em></p>
<p>It‚Äôs the Arm64 <a href="https://developer.arm.com/documentation/198123/0302/What-is-a-Generic-Interrupt-Controller-"><strong>Generic Interrupt Controller (GIC)</strong></a>, version 3. GIC shall‚Ä¶</p>
<ul>
<li>
<p>Receive <strong>Input / Output Interrupts</strong></p>
<p><em>(Like keypresses)</em></p>
</li>
<li>
<p>Forward them to a <strong>CPU Core</strong> for processing</p>
<p><em>(Works like RISC-V PLIC)</em></p>
</li>
</ul>
<p>GIC is here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">GIC</td><td style="text-align: left"><em>0x0340_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>Which has these <strong>GIC Registers</strong> inside, handling 8 Arm64 Cores‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x00_0000</em></td><td style="text-align: left">GICD_CTLR  <em>(Distributor Control Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x06_0000</em></td><td style="text-align: left">GICR_CTLR_C0  <em>(Redistributor Control Register, Core 0)</em></td></tr>
<tr><td style="text-align: center"><em>0x08_0000</em></td><td style="text-align: left">GICR_CTLR_C1  <em>(Ditto, Core 1)</em></td></tr>
<tr><td style="text-align: center"><em>0x0A_0000</em></td><td style="text-align: left">GICR_CTLR_C2  <em>(Ditto, Core 2)</em></td></tr>
<tr><td style="text-align: center"><em>0x0C_0000</em></td><td style="text-align: left">GICR_CTLR_C3  <em>(Ditto, Core 3)</em></td></tr>
<tr><td style="text-align: center"><em>0x0E_0000</em></td><td style="text-align: left">GICR_CTLR_C4  <em>(Ditto, Core 4)</em></td></tr>
<tr><td style="text-align: center"><em>0x10_0000</em></td><td style="text-align: left">GICR_CTLR_C5  <em>(Ditto, Core 5)</em></td></tr>
<tr><td style="text-align: center"><em>0x12_0000</em></td><td style="text-align: left">GICR_CTLR_C6  <em>(Ditto, Core 6)</em></td></tr>
<tr><td style="text-align: center"><em>0x14_0000</em></td><td style="text-align: left">GICR_CTLR_C7  <em>(Ditto, Core 7)</em></td></tr>
<tr><td style="text-align: center"><em>0x16_0000</em></td><td style="text-align: left">GICDA_CTLR  <em>(Distributor Control Register A)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>Based on the above, we set the <strong>Addresses of GICD and GICR</strong> <em>(Distributor / Redistributor)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/f3a26dbba69a0714bc91d0c345b8fba5e0835b76">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address of GIC Distributor and Redistributor
#define CONFIG_GICD_BASE   0x3400000
#define CONFIG_GICR_BASE   0x3460000

// Spaced 0x20000 bytes per Arm64 Core
#define CONFIG_GICR_OFFSET 0x20000</code></pre></div>
<p>Remember to <a href="https://github.com/lupyuen2/wip-nuttx/commit/10c7173b142f4a0480d742688c72499b76f66f83"><strong>Disable Memory Manager Logging</strong></a>. NuttX GIC Driver starts correctly and <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>complains no more</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>## SPI = Physical Interrupt Signal (not the typical SPI)
gic_validate_dist_version:
  GICv3 version detect
  GICD_TYPER = 0x7b0408
  256 SPIs implemented</code></pre></div>
<p>We‚Äôll call GIC to handle UART Interrupts. Before that: We need NSH Shell‚Ä¶</p>
<p><img src="https://lupyuen.org/images/avaota-initrd1.jpg" alt="NuttX Apps Filesystem on ROMFS" /></p>
<h1 id="nuttx-apps-filesystem"><a class="doc-anchor" href="#nuttx-apps-filesystem">¬ß</a>11 NuttX Apps Filesystem</h1>
<p><em>Are we done yet?</em></p>
<p>For a <strong>Simple NuttX Port</strong> <em>(Flat Build)</em>: Congrats, just fix the <a href="https://lupyuen.github.io/articles/avaota#fix-the-uart-interrupt"><strong>UART Interrupt</strong></a> and we‚Äôre done!</p>
<p>However we‚Äôre doing <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629512#MemoryConfigurations-KernelBuild"><strong>NuttX Kernel Build</strong></a>. Which <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>needs more work</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nx_start_application:
  Starting init task: /system/bin/init
arm64_el1_undef:
  Undefined instruction at 0x408274a4
Assertion failed panic:
  common/arm64_fatal.c:572</code></pre></div>
<p><em>What‚Äôs /system/bin/init? Why is it failing?</em></p>
<p><em>/system/bin/init</em> is <strong>NSH Shell</strong>. NuttX Kernel Build will load NuttX Apps from a <strong>Local Filesystem</strong>, and it‚Äôs missing right now. <em>(NuttX Flat Build will bind binary Apps directly into Kernel)</em></p>
<p>To solve this: We bundle the NuttX Apps together into a <strong>ROMFS Filesystem</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Generate the Initial RAM Disk
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;</code></pre></div>
<p>Then we package NuttX Kernel + NuttX Apps into a <strong>NuttX Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587">(See the <strong>Build Script</strong>)</a></p>
<p>When NuttX Boots: It will‚Ä¶</p>
<ol>
<li>
<p>Find the <strong>ROMFS Filesystem</strong></p>
</li>
<li>
<p>Mount it as a <strong>RAM Disk</strong></p>
</li>
<li>
<p>Allowing NuttX Kernel to start <strong>NSH Shell</strong></p>
<p><em>(And other NuttX Apps)</em></p>
</li>
</ol>
<p>Everything is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/avaota#appendix-nuttx-apps-filesystem"><strong>‚ÄúNuttX Apps Filesystem‚Äù</strong></a></li>
</ul>
<p>NSH Prompt still missing? It won‚Äôt appear until we handle the UART Interrupt‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot3-port.png" alt="NuttX on Avaota-A1" /></p>
<h1 id="fix-the-uart-interrupt"><a class="doc-anchor" href="#fix-the-uart-interrupt">¬ß</a>12 Fix the UART Interrupt</h1>
<p>One Last Thing: Settle the <strong>UART Interrupt</strong> and we‚Äôre done!</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: center">Page 256</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Interrupt Number</strong></td><td style="text-align: center"><strong>Interrupt Source</strong></td></tr>
<tr><td style="text-align: center">34</td><td style="text-align: center">UART0</td></tr>
</tbody></table>
</div></div>
</p>
<p>This is how we set the <strong>UART0 Interrupt</strong> and watch for keypresses: <a href="https://github.com/lupyuen2/wip-nuttx/commit/cd6da8f5378eb493528e57c61f887b6585ab8eaf#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the UART0 Interrupt to 34
CONFIG_16550_UART0_IRQ=34</code></pre></div>
<p>To Wrap Up: We Disable Logging for <a href="https://github.com/lupyuen2/wip-nuttx/commit/6c5c1a5f9fb1c939d8e75a5e9544b1a5261165ee"><strong>Memory Manager and Scheduler</strong></a>. And <a href="https://github.com/lupyuen2/wip-nuttx/commit/e5c1b0449d3764d63d447eb96eb7186a27f77c88"><strong>Disable MMU Debugging</strong></a>.</p>
<p><strong>NSH Prompt</strong> finally appears and <strong>OSTest completes successfully</strong>. Our NuttX Porting is complete yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt; uname -a
NuttX 12.4.0 6c5c1a5f9f-dirty Mar  8 2025 21:57:02 arm64 qemu-armv8a

nsh&gt; ostest
...
user_main: Exiting
ostest_main: Exiting with status 0</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6">(See the <strong>Complete Log</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/avaota#appendix-port-nuttx-to-avaota-a1">(See the <strong>Final Code</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/avaota#appendix-upstream-nuttx-for-avaota-a1">(Ready for <strong>NuttX Upstreaming</strong>)</a></p>
<p><em>NSH Prompt won‚Äôt appear if UART Interrupt is disabled?</em></p>
<p>That‚Äôs because NSH runs as a <strong>NuttX App in User Space</strong>. When NSH Shell prints this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt;</code></pre></div>
<p>It calls the <strong>Serial Driver</strong>. Which will wait for a <strong>UART Interrupt</strong> to signal that the <strong>Transmit Buffer</strong> is empty and available.</p>
<p>Thus if UART Interrupt is disabled, nothing gets printed in NuttX Apps. <a href="https://lupyuen.github.io/articles/plic#no-console-output-from-nuttx-apps">(Explained here)</a></p>
<p><img src="https://lupyuen.org/images/avaota-cubie.jpg" alt="NuttX might run OK on Radxa Cubie A5E (Allwinner T527)" /></p>
<p><a href="https://arace.tech/products/radxa-cubie-a5e"><em>NuttX might run OK on Radxa Cubie A5E (Allwinner T527)</em></a></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>13 What‚Äôs Next</h1>
<p>Right now we‚Äôre upstreaming Avatoa-A1 SBC to <strong>NuttX Mainline</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/avaota#appendix-port-nuttx-to-avaota-a1"><strong>‚ÄúPort NuttX to Avaota-A1‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/avaota#appendix-upstream-nuttx-for-avaota-a1"><strong>‚ÄúUpstream NuttX for Avaota-A1‚Äù</strong></a></p>
</li>
</ul>
<p>We‚Äôre seeking volunteers to build <strong>NuttX Drivers for Avaota-A1</strong> <em>(GPIO, SPI, I2C, MIPI CSI / DSI, Ethernet, WiFi, ‚Ä¶)</em> Please lemme know, maybe we can draw something on the Onboard LCD!</p>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/avaota.md"><strong>lupyuen.org/src/avaota.md</strong></a></p>
<p><img src="https://lupyuen.org/images/testbot3-sbc.jpg" alt="Yuzuki Avaota-A1 SBC with PinePhone MicroSD Extender" /></p>
<h1 id="appendix-build-nuttx-for-avaota-a1"><a class="doc-anchor" href="#appendix-build-nuttx-for-avaota-a1">¬ß</a>14 Appendix: Build NuttX for Avaota-A1</h1>
<p>To boot <strong>NuttX on Avatoa-A1</strong>: We may download <strong><code>Image</code></strong> from here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/avaota2-1"><strong>NuttX Release for Avatoa-A1 SBC</strong></a></li>
</ul>
<p>Or follow these steps to compile our <em>(Work-In-Progress)</em> <strong>NuttX for Avaota-A1</strong>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download Source Code for NuttX and Apps
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch avaota
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch avaota
cd nuttx

## Build NuttX and Apps (NuttX Kernel Build)
tools/configure.sh qemu-armv8a:knsh
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image</code></pre></div>
<p>Read on to boot the NuttX Image on our SBC‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">(See the <strong>Build Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/testbot3-port.png" alt="NuttX on Avaota-A1" /></p>
<h1 id="appendix-boot-nuttx-on-avaota-a1"><a class="doc-anchor" href="#appendix-boot-nuttx-on-avaota-a1">¬ß</a>15 Appendix: Boot NuttX on Avaota-A1</h1>
<p>Earlier we built <a href="https://lupyuen.github.io/articles/avaota#appendix-build-nuttx-for-avaota-a1"><strong>NuttX for Avaota-A1</strong></a> and created the <strong><code>Image</code></strong> file, containing the NuttX Kernel + NuttX Apps. Let‚Äôs boot it on MicroSD‚Ä¶</p>
<ol>
<li>
<p>Prepare the <strong>AvaotaOS MicroSD</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/avaota#boot-nuttx-kernel-on-our-sbc"><strong>‚ÄúBoot NuttX Kernel on our SBC‚Äù</strong></a></p>
</li>
<li>
<p>Copy the <strong>NuttX Image</strong> to MicroSD‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to AvaotaOS MicroSD
## Overwrite the `Image` file
mv /media/$USER/YOUR_SD/Image /media/$USER/YOUR_SD/Image.old
cp Image /media/$USER/YOUR_SD/Image

## Unmount and boot it on Avaota-A1
ls -l /media/$USER/YOUR_SD/Image
umount /media/$USER/YOUR_SD</code></pre></div></li>
<li>
<p><strong>Boot the MicroSD</strong> on our SBC</p>
</li>
</ol>
<p>We can automate the last two steps with a <a href="https://lupyuen.github.io/articles/avaota#microsd-multiplexer--smart-power-plug"><strong>MicroSD Multiplexer</strong></a> and <a href="https://lupyuen.github.io/articles/avaota#microsd-multiplexer--smart-power-plug"><strong>Smart Power Plug</strong></a>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Get the Home Assistant Token
## That we copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
## https://github.com/lupyuen/nuttx-avaota-a1/blob/main/copy-image.sh
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC to finish testing
echo Press Enter to Power Off
read

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p>Or to <strong>Automate Everything</strong> including <strong>OSTest</strong>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
## https://github.com/lupyuen/nuttx-avaota-a1/blob/main/copy-image.sh
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Boot and Test NuttX with OSTest
## https://github.com/lupyuen/nuttx-build-farm/blob/main/avaota.exp
export AVAOTA_SERVER=thinkcentre
pushd $HOME/nuttx-build-farm
expect ./avaota.exp
popd</code></pre></div>
<p><a href="https://youtu.be/XTDw245n5tM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/avaota#microsd-multiplexer--smart-power-plug">(<strong>copy-image.sh</strong> is explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/avaota#microsd-multiplexer--smart-power-plug">(<strong>Smart Power Plug</strong> also)</a></p>
<p>NuttX boots to NSH Shell. And passes OSTest yay!</p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-text"><code>NOTICE:  BL31: v2.5(debug):9241004a9
NOTICE:  BL31: Built : 13:37:46, Nov 16 2023
NOTICE:  BL31: No DTB found.
NOTICE:  [SCP] :wait arisc ready....
NOTICE:  [SCP] :arisc version: []
NOTICE:  [SCP] :arisc startup ready
NOTICE:  [SCP] :arisc startup notify message feedback
NOTICE:  [SCP] :sunxi-arisc driver is starting
ERROR:   Error initializing runtime service opteed_fast
123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
ABarm64_mmu_init:
setup_page_tables:
enable_mmu_el1:
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache
up_allocate_kheap: CONFIG_RAM_END=0x48000000, g_idle_topstack=0x40847000
qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
board_app_initialize:

NuttShell (NSH) NuttX-12.4.0
nsh&gt; uname -a
NuttX 12.4.0 6c5c1a5f9f-dirty Mar  8 2025 21:57:02 arm64 qemu-armv8a

nsh&gt; free
      total       used       free    maxused    maxfree  nused  nfree name
  125538304      33848  125504456      52992  125484976     58      5 Kmem
    4194304     245760    3948544               3948544               Page

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0008176 0000928  11.3%  Idle_Task
    1     0 192 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  hpwork 0x40834568 0x408345b8
    2     0 100 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  lpwork 0x408344e8 0x40834538
    4     4 100 RR       Task      - Running            0000000000000000 0008128 0002192  26.9%  /system/bin/init

nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-           0 console
 crw-rw-rw-           0 null
 brw-rw-rw-    16777216 ram0
 crw-rw-rw-           0 ttyS0
 crw-rw-rw-           0 zero

nsh&gt; hello
Hello, World!!

nsh&gt; getprime
Set thread priority to 10
Set thread policy to SCHED_RR
Start thread #0
thread #0 started, looking for primes &lt; 10000, doing 10 run(s)
thread #0 finished, found 1230 primes, last one was 9973
Done
getprime took 162 msec

nsh&gt; ostest
...
Final memory usage:
VARIABLE  BEFORE   AFTER
======== ======== ========
arena        a000    26000
ordblks         2        4
mxordblk     6ff8    1aff8
uordblks     27e8     6700
fordblks     7818    1f900
user_main: Exiting
ostest_main: Exiting with status 0
nsh&gt;</code></pre></div></span>
<p><a href="https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6">(See the <strong>NuttX Log</strong>)</a></p>
<p><img src="https://lupyuen.org/images/avaota-pr.png" alt="Upstreaming NuttX for Avaota-A1" /></p>
<h1 id="appendix-upstream-nuttx-for-avaota-a1"><a class="doc-anchor" href="#appendix-upstream-nuttx-for-avaota-a1">¬ß</a>16 Appendix: Upstream NuttX for Avaota-A1</h1>
<p>In this article we ported NuttX QEMU Arm64 (Kernel Build) iteratively to Avaota-A1. What‚Äôs Next: Upstreaming our code to <strong>NuttX Mainline</strong>!</p>
<p>Here‚Äôs how we copy-n-pasted our <a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits"><strong>Modified Files</strong></a> into a proper <strong>NuttX Arch</strong> <em>(Allwinner A527)</em> and <strong>NuttX Board</strong> <em>(Avaota-A1)</em></p>
<span style="font-size:80%">
<ol>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/7de76c10aef43fef010eb002eae9330c4333650a">Copy qemu folders to a527. Copy qemu-armv8a folder to avaota-a1.</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/740f0a0c57439fc39dc216476021fad114f6e6b2">Rename qemu files to a527. Rename qemu-armv8a files to avaota-a1.</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/1011208093b294c36399b7a04a135c08a18b7186">Rewrite ‚Äúqemu-armv8a‚Äù to ‚Äúavaota-a1‚Äù. Rewrite ‚Äúqemu‚Äù to ‚Äúa527‚Äù.</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/ddf662a9036e7cc6742a034a3983f3b0f9b5bf07">Rewrite ‚ÄúA527_ARMV8A‚Äù to ‚ÄúAVAOTA_A1‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/fe65a2d43f896b7eaeb996c463a99d5244a9b67d">Add the Arch and Board</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c">Apply the changes from <em>github.com/lupyuen2/wip-nuttx/pull/98/files</em> <br> OSTest passes yay!</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/837e0478617da7d8c886cbb3291ff90e3fc07c33">Remove the unused NuttX Configs</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/1934b999880c37f67c0dfa456555b160a945145c">Rename knsh to nsh</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/5d9b19fd314a342167948245e9cfb002d82a8802">Add the Arch and Board Docs</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits">And Much More</a></p>
</li>
</ol>
</span>
<p><strong>Upstreaming</strong> becomes lotsa copypasta‚Ä¶</p>
<ol>
<li>
<p>We create a <strong>Staging PR</strong> in our own repo‚Ä¶</p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99"><em>github.com/lupyuen2/wip-nuttx/pull/99</em></a></p>
</li>
<li>
<p>Dump the list of <strong>Modified Files</strong>‚Ä¶</p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-bash"><code>## Change this to our Staging PR
$ pr=https://github.com/lupyuen2/wip-pinephone-nuttx/pull/99
$ curl -L $pr.diff \
  | grep &quot;diff --git&quot; \
  | sort \
  | cut -d&quot; &quot; -f3 \
  | cut -c3-

## Here are the Modified Files for our PR
Documentation/platforms/arm64/a527/boards/avaota-a1/avaota-a1.jpg
Documentation/platforms/arm64/a527/boards/avaota-a1/index.rst
Documentation/platforms/arm64/a527/index.rst
arch/arm64/Kconfig
arch/arm64/include/a527/chip.h
arch/arm64/include/a527/irq.h
arch/arm64/src/a527/CMakeLists.txt
arch/arm64/src/a527/Kconfig
arch/arm64/src/a527/Make.defs
arch/arm64/src/a527/a527_boot.c
arch/arm64/src/a527/a527_boot.h
arch/arm64/src/a527/a527_initialize.c
arch/arm64/src/a527/a527_lowputc.S
arch/arm64/src/a527/a527_serial.c
arch/arm64/src/a527/a527_textheap.c
arch/arm64/src/a527/a527_timer.c
arch/arm64/src/a527/chip.h
boards/Kconfig
boards/arm64/a527/avaota-a1/CMakeLists.txt
boards/arm64/a527/avaota-a1/Kconfig
boards/arm64/a527/avaota-a1/configs/nsh/defconfig
boards/arm64/a527/avaota-a1/include/board.h
boards/arm64/a527/avaota-a1/include/board_memorymap.h
boards/arm64/a527/avaota-a1/scripts/Make.defs
boards/arm64/a527/avaota-a1/scripts/gnu-elf.ld
boards/arm64/a527/avaota-a1/scripts/ld.script
boards/arm64/a527/avaota-a1/src/CMakeLists.txt
boards/arm64/a527/avaota-a1/src/Makefile
boards/arm64/a527/avaota-a1/src/a527_appinit.c
boards/arm64/a527/avaota-a1/src/a527_boardinit.c
boards/arm64/a527/avaota-a1/src/a527_bringup.c
boards/arm64/a527/avaota-a1/src/a527_power.c
boards/arm64/a527/avaota-a1/src/avaota-a1.h</code></pre></div></span>
</li>
<li>
<p>Check <strong>nxstyle</strong> on the Modified Files‚Ä¶</p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-bash"><code>## Run nxstyle on the Modified Files
nxstyle Documentation/platforms/arm64/a527/boards/avaota-a1/avaota-a1.jpg
nxstyle Documentation/platforms/arm64/a527/boards/avaota-a1/index.rst
nxstyle Documentation/platforms/arm64/a527/index.rst
nxstyle arch/arm64/Kconfig
nxstyle arch/arm64/include/a527/chip.h
nxstyle arch/arm64/include/a527/irq.h
nxstyle arch/arm64/src/a527/CMakeLists.txt
nxstyle arch/arm64/src/a527/Kconfig
nxstyle arch/arm64/src/a527/Make.defs
nxstyle arch/arm64/src/a527/a527_boot.c
nxstyle arch/arm64/src/a527/a527_boot.h
nxstyle arch/arm64/src/a527/a527_initialize.c
nxstyle arch/arm64/src/a527/a527_lowputc.S
nxstyle arch/arm64/src/a527/a527_serial.c
nxstyle arch/arm64/src/a527/a527_textheap.c
nxstyle arch/arm64/src/a527/a527_timer.c
nxstyle arch/arm64/src/a527/chip.h
nxstyle boards/Kconfig
nxstyle boards/arm64/a527/avaota-a1/CMakeLists.txt
nxstyle boards/arm64/a527/avaota-a1/Kconfig
nxstyle boards/arm64/a527/avaota-a1/configs/nsh/defconfig
nxstyle boards/arm64/a527/avaota-a1/include/board.h
nxstyle boards/arm64/a527/avaota-a1/include/board_memorymap.h
nxstyle boards/arm64/a527/avaota-a1/scripts/Make.defs
nxstyle boards/arm64/a527/avaota-a1/scripts/gnu-elf.ld
nxstyle boards/arm64/a527/avaota-a1/scripts/ld.script
nxstyle boards/arm64/a527/avaota-a1/src/CMakeLists.txt
nxstyle boards/arm64/a527/avaota-a1/src/Makefile
nxstyle boards/arm64/a527/avaota-a1/src/a527_appinit.c
nxstyle boards/arm64/a527/avaota-a1/src/a527_boardinit.c
nxstyle boards/arm64/a527/avaota-a1/src/a527_bringup.c
nxstyle boards/arm64/a527/avaota-a1/src/a527_power.c
nxstyle boards/arm64/a527/avaota-a1/src/avaota-a1.h</code></pre></div></span>
</li>
<li>
<p>Copy the Arch Files into the <strong>Arch Pull Request</strong></p>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/100"><strong>‚Äúarch/arm64/a527: Add support for Allwinner A527 SoC‚Äù</strong></a></p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-bash"><code>## Download the Branch for Avaota Arch (initially empty)
pushd /tmp 
git clone https://github.com/lupyuen2/wip-nuttx avaota-arch --branch avaota-arch
popd

## Copy the Arch Files from src to dest
function copy_files() {
  src=.
  dest=/tmp/avaota-arch
  for file in \
    Documentation/platforms/arm64/a527/index.rst \
    arch/arm64/Kconfig \
    arch/arm64/include/a527/chip.h \
    arch/arm64/include/a527/irq.h \
    arch/arm64/src/a527/CMakeLists.txt \
    arch/arm64/src/a527/Kconfig \
    arch/arm64/src/a527/Make.defs \
    arch/arm64/src/a527/a527_boot.c \
    arch/arm64/src/a527/a527_boot.h \
    arch/arm64/src/a527/a527_initialize.c \
    arch/arm64/src/a527/a527_lowputc.S \
    arch/arm64/src/a527/a527_serial.c \
    arch/arm64/src/a527/a527_textheap.c \
    arch/arm64/src/a527/a527_timer.c \
    arch/arm64/src/a527/chip.h \

  do
    src_file=$src/$file
    dest_file=$dest/$file
    dest_dir=$(dirname -- &quot;$dest_file&quot;)
    set -x
    mkdir -p $dest_dir
    cp $src_file $dest_file
    set +x
  done
}

## Copy and commit /tmp/avaota-arch
## Remove the &quot;Supported Boards&quot; (toctree) from Arch Doc
copy_files
code /tmp/avaota-arch</code></pre></div></span>
</li>
<li>
<p>Copy the Board Files into the <strong>Board Pull Request</strong></p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-bash"><code>## Download the Branch for Avaota Board (initially empty)
pushd /tmp 
git clone https://github.com/lupyuen2/wip-nuttx avaota-board --branch avaota-board
popd

## Copy the Board Files from src to dest
## Copy the Arch Doc again because we restored the &quot;Supported Boards&quot; 
function copy_files() {
  src=.
  dest=/tmp/avaota-board
  for file in \
    Documentation/platforms/arm64/a527/index.rst \
    Documentation/platforms/arm64/a527/boards/avaota-a1/avaota-a1.jpg \
    Documentation/platforms/arm64/a527/boards/avaota-a1/index.rst \
    boards/Kconfig \
    boards/arm64/a527/avaota-a1/CMakeLists.txt \
    boards/arm64/a527/avaota-a1/Kconfig \
    boards/arm64/a527/avaota-a1/configs/nsh/defconfig \
    boards/arm64/a527/avaota-a1/include/board.h \
    boards/arm64/a527/avaota-a1/include/board_memorymap.h \
    boards/arm64/a527/avaota-a1/scripts/Make.defs \
    boards/arm64/a527/avaota-a1/scripts/gnu-elf.ld \
    boards/arm64/a527/avaota-a1/scripts/ld.script \
    boards/arm64/a527/avaota-a1/src/CMakeLists.txt \
    boards/arm64/a527/avaota-a1/src/Makefile \
    boards/arm64/a527/avaota-a1/src/a527_appinit.c \
    boards/arm64/a527/avaota-a1/src/a527_boardinit.c \
    boards/arm64/a527/avaota-a1/src/a527_bringup.c \
    boards/arm64/a527/avaota-a1/src/a527_power.c \
    boards/arm64/a527/avaota-a1/src/avaota-a1.h \

  do
    src_file=$src/$file
    dest_file=$dest/$file
    dest_dir=$(dirname -- &quot;$dest_file&quot;)
    set -x
    mkdir -p $dest_dir
    cp $src_file $dest_file
    set +x
  done
}

## Copy and commit /tmp/avaota-board
copy_files
code /tmp/avaota-board</code></pre></div></span>
</li>
<li>
<p>Remember to create <a href="https://github.com/lupyuen2/wip-nuttx/pull/100/commits"><strong>Two Commits Per PR</strong></a>: One Commit for Code, Another Commit for Docs</p>
<p><img src="https://lupyuen.org/images/avaota-commit.png" alt="Two Commits Per PR: One Commit for Code, Another Commit for Docs" /></p>
</li>
<li>
<p>Need to <a href="https://lupyuen.github.io/articles/pr#squash-the-commits"><strong>Squash the Commits</strong></a> (or amend them), but another Code or Doc Commit is stuck in between?</p>
<p><img src="https://lupyuen.org/images/avaota-commit2.png" alt="Before Reordering the Commit" /></p>
<p>Try <a href="https://docs.github.com/en/desktop/managing-commits/reordering-commits-in-github-desktop"><strong>Reordering the Commits</strong></a> to the top, before squashing or amending.</p>
<p><img src="https://lupyuen.org/images/avaota-commit3.png" alt="After Reordering the Commit" /></p>
</li>
<li>
<p>Now we‚Äôre finally ready to Submit our Pull Requests!</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/testbot3-mux.jpg" alt="SDWire MicroSD Multiplexer" /></p>
<h1 id="appendix-sdwire-microsd-multiplexer"><a class="doc-anchor" href="#appendix-sdwire-microsd-multiplexer">¬ß</a>17 Appendix: SDWire MicroSD Multiplexer</h1>
<p>Let‚Äôs make our Tweak-Build-Test Cycle quicker for NuttX. We use <strong>SDWire MicroSD Multiplexer</strong> (pic above) to flip our MicroSD between <strong>Test PC and SBC</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/testbot3#sdwire-microsd-multiplexer"><strong>‚ÄúSDWire MicroSD Multiplexer‚Äù</strong></a></li>
</ul>
<p>SDWire needs <a href="https://lupyuen.github.io/articles/testbot3#mount-the-microsd"><strong>Plenty of Sudo Passwords</strong></a> to flip the multiplexer, mount the filesystem, copy to MicroSD. We make it Sudo Password-Less with <a href="https://help.ubuntu.com/community/Sudoers"><strong>visudo</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Wrap all the <strong>Sudo Commands</strong> into a script: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/copy-image.sh">copy-image.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Create a Bash Script: copy-image.sh
## Containing these commands...

set -e  ## Exit when any command fails
set -x  ## Echo commands
whoami  ## I am root!

## Copy /tmp/Image to MicroSD
sd-mux-ctrl --device-serial=sd-wire_02-09 --ts
sleep 5
mkdir -p /tmp/sda1
mount /dev/sda1 /tmp/sda1
cp /tmp/Image /tmp/sda1/
ls -l /tmp/sda1

## Unmount MicroSD and flip it to the Test Device (Avaota-A1)
umount /tmp/sda1
sd-mux-ctrl --device-serial=sd-wire_02-09 --dut</code></pre></div></li>
<li>
<p>Configure <strong>visudo</strong> so that our script will run as <strong>Sudo Without Password</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Make our script executable
## Start the Sudoers Editor
chmod +x /home/user/copy-image.sh
sudo visudo

## Add this line:
user ALL=(ALL) NOPASSWD: /home/user/copy-image.sh</code></pre></div></li>
<li>
<p>Then we can trigger our script remotely via SSH, <strong>Without Sudo Password</strong>: <a href="https://github.com/lupyuen/nuttx-avaota-a1/blob/main/run.sh">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to MicroSD
## No password needed for sudo yay!
scp Image thinkcentre:/tmp/Image
ssh thinkcentre \
  ls -l /tmp/Image
ssh thinkcentre \
  sudo /home/user/copy-image.sh</code></pre></div></li>
<li>
<p>Everything goes into our <a href="https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587"><strong>Build Script for NuttX</strong></a></p>
</li>
</ol>
<p><em>(Actually we could allow anyone in the world to Remotely Build and Test NuttX on our Avaota-A1 hmmm‚Ä¶)</em></p>
<p><img src="https://lupyuen.org/images/avaota-initrd1.jpg" alt="NuttX Apps Filesystem in ROMFS" /></p>
<h1 id="appendix-nuttx-apps-filesystem"><a class="doc-anchor" href="#appendix-nuttx-apps-filesystem">¬ß</a>18 Appendix: NuttX Apps Filesystem</h1>
<p>Earlier we talked about the <strong>ROMFS Filesystem for NuttX Apps</strong> <em>(Initial RAM Disk, pic above)</em></p>
<ul>
<li><a href="https://lupyuen.github.io/articles/avaota#nuttx-apps-filesystem"><strong>‚ÄúNuttX Apps Filesystem‚Äù</strong></a></li>
</ul>
<p>This section explains how we implemented the NuttX Apps Filesystem‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files"><strong>Modified Files</strong> for NuttX Apps Filesystem</a></li>
</ul>
<p>After this implementation, <em>/system/bin/init</em> (NSH Shell) shall <a href="https://gist.github.com/lupyuen/ccb645efa72f6793743c033fade0b3ac"><strong>start successfully</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
nx_start_application: Starting init task: /system/bin/init
nxtask_activate: /system/bin/init pid=4,TCB=0x408469f0
nxtask_exit: AppBringUp pid=3,TCB=0x40846190
board_app_initialize:
nx_start: CPU0: Beginning Idle Loop</code></pre></div><h2 id="hostfs-becomes-romfs"><a class="doc-anchor" href="#hostfs-becomes-romfs">¬ß</a>18.1 HostFS becomes ROMFS</h2>
<p>QEMU uses <a href="https://lupyuen.github.io/articles/testbot2#semihosting-breakout"><strong>Semihosting and HostFS</strong></a> to access the NuttX Apps Filesystem. We change to <strong>ROMFS</strong>‚Ä¶ <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## We added ROMFS...
CONFIG_BOARDCTL_ROMDISK=y
CONFIG_BOARD_LATE_INITIALIZE=y
CONFIG_INIT_MOUNT_TARGET=&quot;/system/bin&quot;

## And removed Semihosting HostFS...
## CONFIG_FS_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS_CACHE_COHERENCE=y
## CONFIG_INIT_MOUNT_DATA=&quot;fs=../apps&quot;
## CONFIG_INIT_MOUNT_FSTYPE=&quot;hostfs&quot;
## CONFIG_INIT_MOUNT_SOURCE=&quot;&quot;
## CONFIG_INIT_MOUNT_TARGET=&quot;/system&quot;</code></pre></div>
<p><em>BOARD_LATE_INITIALIZE</em> is needed because we‚Äôll <strong>Mount the ROMFS Filesystem</strong> inside <em>qemu_bringup()</em>. (See below)</p>
<h2 id="linker-script"><a class="doc-anchor" href="#linker-script">¬ß</a>18.2 Linker Script</h2>
<p>We reserve <strong>16 MB of RAM</strong> for the ROMFS Filesystem that will host the NuttX Apps: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f0706cd747d2f1be1eeb64d50821afb1e25d5bb26e964e2679268a83dcff0afc">ld-kernel.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Linker Script: We added the RAM Disk (16 MB) */
MEMORY {
  dram (rwx)    : ORIGIN = 0x40800000, LENGTH = 2M
  pgram (rwx)   : ORIGIN = 0x40A00000, LENGTH = 4M    /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x40E00000, LENGTH = 16M   /* w/ cache */
}

/* We&#39;ll reference these in our code */
__ramdisk_start = ORIGIN(ramdisk);
__ramdisk_size  = LENGTH(ramdisk);
__ramdisk_end   = ORIGIN(ramdisk) + LENGTH(ramdisk);</code></pre></div><h2 id="mount-the-romfs"><a class="doc-anchor" href="#mount-the-romfs">¬ß</a>18.3 Mount the ROMFS</h2>
<p><strong>At Startup:</strong> We mount the <strong>ROMFS Filesystem</strong> <em>(inside RAM)</em> as <em>/dev/ram0</em>: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f8d388b76b0b37563184a5a174f18970ff6771d6a048e0e792967ab265d6f7eb">qemu_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At NuttX Startup...
int qemu_bringup(void) {
  // We Mount the RAM Disk
  mount_ramdisk();
  ...
}

// Mount a RAM Disk defined in ld.script to /dev/ramX.  The RAM Disk
// contains a ROMFS filesystem with applications that can be spawned at
// runtime.
static int mount_ramdisk(void) {
  struct boardioc_romdisk_s desc;
  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;

  int ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
  if (ret &lt; 0) {
    syslog(LOG_ERR, &quot;Ramdisk register failed: %s\n&quot;, strerror(errno));
    syslog(LOG_ERR, &quot;Ramdisk mountpoint /dev/ram%d\n&quot;,RAMDISK_DEVICE_MINOR);
    syslog(LOG_ERR, &quot;Ramdisk length %lu, origin %lx\n&quot;, (ssize_t)__ramdisk_size, (uintptr_t)__ramdisk_start);
  }
  return ret;
}

// RAM Disk Definition
#define SECTORSIZE   512
#define NSECTORS(b)  (((b) + SECTORSIZE - 1) / SECTORSIZE)
#define RAMDISK_DEVICE_MINOR 0</code></pre></div><h2 id="copy-the-romfs"><a class="doc-anchor" href="#copy-the-romfs">¬ß</a>18.4 Copy the ROMFS</h2>
<p><strong>But Before That:</strong> We safely copy the <strong>ROMFS Filesystem</strong> <em>(Initial RAM Disk)</em> from the NuttX Image into the <strong><code>ramdisk</code> Memory Region</strong>‚Ä¶</p>
<p><img src="https://lupyuen.org/images/avaota-initrd2.jpg" alt="Mounting the ROMFS Filesystem" /></p>
<p>This happens just after Bootloader starts NuttX: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-be208bc5be54608eca3885cf169183ede375400c559700bb423c81d7b2787431">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Needed for the `aligned_data` macro
#include &lt;nuttx/compiler.h&gt;

// Just after Bootloader has started NuttX...
void arm64_chip_boot(void) {

  // We copy the RAM Disk
  qemu_copy_ramdisk();

  // Omitted: Other initialisation (MMU, ...)
  arm64_mmu_init(true);
  ...
}

// Copy the RAM Disk from NuttX Image to RAM Disk Region.
static void qemu_copy_ramdisk(void) {
  const uint8_t aligned_data(8) header[8] = &quot;-rom1fs-&quot;;
  const uint8_t *limit = (uint8_t *)g_idle_topstack + (256 * 1024);
  uint8_t *ramdisk_addr = NULL;
  uint8_t *addr;
  uint32_t size;

  // After Idle Stack Top, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
  // Limit search to 256 KB after Idle Stack Top.
  for (addr = g_idle_topstack; addr &lt; limit; addr += 8) {
      if (memcmp(addr, header, sizeof(header)) == 0) {
        ramdisk_addr = addr;
        break;
      }
  }

  // Stop if RAM Disk is missing
  if (ramdisk_addr == NULL) {
    _err(&quot;Missing RAM Disk. Check the initrd padding.&quot;);
    PANIC();
  }

  // Read the Filesystem Size from the next 4 bytes (Big Endian)
  size = (ramdisk_addr[8] &lt;&lt; 24) + (ramdisk_addr[9] &lt;&lt; 16) +
         (ramdisk_addr[10] &lt;&lt; 8) + ramdisk_addr[11] + 0x1f0;

  // Filesystem Size must be less than RAM Disk Memory Region
  if (size &gt; (size_t)__ramdisk_size) {
    _err(&quot;RAM Disk Region too small. Increase by %lu bytes.\n&quot;, size - (size_t)__ramdisk_size);
    PANIC();
  }

  // Copy the RAM Disk from NuttX Image to RAM Disk Region.
  // __ramdisk_start overlaps with ramdisk_addr + size.
  qemu_copy_overlap(__ramdisk_start, ramdisk_addr, size);
}

// Copy an overlapping memory region.  dest overlaps with src + count.
static void qemu_copy_overlap(uint8_t *dest, const uint8_t *src, size_t count) {
  uint8_t *d = dest + count - 1;
  const uint8_t *s = src + count - 1;
  if (dest &lt;= src) { _err(&quot;dest and src should overlap&quot;); PANIC(); }
  while (count--) {
    volatile uint8_t c = *s;  // Prevent compiler optimization
    *d = c;
    d--;
    s--;
  }
} 

// RAM Disk Region is defined in Linker Script
extern uint8_t __ramdisk_start[];
extern uint8_t __ramdisk_size[];</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-nuttx/blob/71b0ea678c08d9d1390e4d669876f99d93496ecf/arch/arm64/src/a527/a527_boot.c#L69-L170">(Moved here)</a></p>
<p><em>Why the aligned addresses?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Header is aligned to 8 bytes
const uint8_t
  aligned_data(8) header[8] =
  &quot;-rom1fs-&quot;;

// Address is also aligned to 8 bytes
for (
  addr = g_idle_topstack;
  addr &lt; limit;
  addr += 8
) {
  // Otherwise this will hit Alignment Fault
  memcmp(addr, header, sizeof(header));
  ...
}</code></pre></div>
<p>We align our Memory Accesses to <strong>8 Bytes</strong>. Otherwise we‚Äôll hit an <a href="https://gist.github.com/lupyuen/f10af7903461f44689203d0e02fb9949"><strong>Alignment Fault</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Alignment Fault at `memcmp(addr, header, sizeof(header))`
default_fatal_handler:
  (IFSC/DFSC) for Data/Instruction aborts:
  alignment fault</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-nuttx/blob/b92f051e337d095491f8406b2d99fdd2f6fa5b3e/arch/risc-v/src/eic7700x/eic7700x_start.c#L110-L144"><em>(Strangely: This Alignment isn‚Äôt needed for RISC-V)</em></a></p>
<p><img src="https://lupyuen.org/images/avaota-pr2.png" alt="Porting NuttX to Avaota-A1" /></p>
<h1 id="appendix-port-nuttx-to-avaota-a1"><a class="doc-anchor" href="#appendix-port-nuttx-to-avaota-a1">¬ß</a>19 Appendix: Port NuttX to Avaota-A1</h1>
<p>In this article, we took NuttX for <a href="https://nuttx.apache.org/docs/latest/platforms/arm64/qemu/boards/qemu-armv8a/index.html"><strong>Arm64 QEMU Kernel Build</strong></a> <em>(qemu-armv8a:knsh)</em> and changed it slightly for <strong>Avaota-A1 SBC</strong>. To help our PR Reviewers: This section explains the <strong>Modified Code</strong> in our Pull Request‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c"><strong>Modified Files</strong> for Avaota-A1</a></li>
</ul>
<p><strong>Only Seven Files</strong> were modified from QEMU NuttX. All other files were simply copied and renamed, from QEMU NuttX to Avaota-A1. (Pic above)</p>
<h2 id="memory-map"><a class="doc-anchor" href="#memory-map">¬ß</a>19.1 Memory Map</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-90c2e9d244c0b30507a1c22d2374875c4672d39fe84e280f4a73c4935eede8fe"><strong>arch/arm64/include/a527/chip.h</strong></a></p>
<p>We define the <strong>I/O Memory Space</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// I/O Memory Space
#define CONFIG_DEVICEIO_BASEADDR   0x00000000
#define CONFIG_DEVICEIO_SIZE       MB(1024)

// Kernel Boot Address from SBC Bootloader
#define CONFIG_LOAD_BASE           0x40800000</code></pre></div>
<p>Based on the <strong>A527 Memory Map</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 40</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Module</strong></td><td style="text-align: left"><strong>Address</strong></td></tr>
<tr><td style="text-align: left">Boot ROM &amp; SRAM</td><td style="text-align: left"><em>0x0000_0000</em> to ‚Ä¶</td></tr>
<tr><td style="text-align: left">PCIE</td><td style="text-align: left"><em>0x2000_0000</em> to <em>0x2FFF_FFFF</em></td></tr>
<tr><td style="text-align: left">DRAM</td><td style="text-align: left"><em>0x4000_0000</em> to ‚Ä¶</td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://lupyuen.github.io/articles/avaota#fix-the-memory-map">(Explained here)</a></p>
<h2 id="gic-interrupt-controller"><a class="doc-anchor" href="#gic-interrupt-controller">¬ß</a>19.2 GIC Interrupt Controller</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-90c2e9d244c0b30507a1c22d2374875c4672d39fe84e280f4a73c4935eede8fe"><strong>arch/arm64/include/a527/chip.h</strong></a></p>
<p>We set the <strong>GIC Base Addresses</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// GICD and GICD Base Addresses
#define CONFIG_GICD_BASE           0x3400000
#define CONFIG_GICR_BASE           0x3460000</code></pre></div>
<p>Based on the <strong>GIC Doc</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">GIC</td><td style="text-align: left"><em>0x0340_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>And <strong>GIC Registers</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x00_0000</em></td><td style="text-align: left">GICD_CTLR  <em>(Distributor Control Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x06_0000</em></td><td style="text-align: left">GICR_CTLR_C0  <em>(Redistributor Control Register, Core 0)</em></td></tr>
<tr><td style="text-align: center"><em>0x08_0000</em></td><td style="text-align: left">GICR_CTLR_C1  <em>(Ditto, Core 1)</em></td></tr>
<tr><td style="text-align: center"><em>0x0A_0000</em></td><td style="text-align: left">GICR_CTLR_C2  <em>(Ditto, Core 2)</em></td></tr>
<tr><td style="text-align: center"><em>0x0C_0000</em></td><td style="text-align: left">GICR_CTLR_C3  <em>(Ditto, Core 3)</em></td></tr>
<tr><td style="text-align: center"><em>0x0E_0000</em></td><td style="text-align: left">GICR_CTLR_C4  <em>(Ditto, Core 4)</em></td></tr>
<tr><td style="text-align: center"><em>0x10_0000</em></td><td style="text-align: left">GICR_CTLR_C5  <em>(Ditto, Core 5)</em></td></tr>
<tr><td style="text-align: center"><em>0x12_0000</em></td><td style="text-align: left">GICR_CTLR_C6  <em>(Ditto, Core 6)</em></td></tr>
<tr><td style="text-align: center"><em>0x14_0000</em></td><td style="text-align: left">GICR_CTLR_C7  <em>(Ditto, Core 7)</em></td></tr>
<tr><td style="text-align: center"><em>0x16_0000</em></td><td style="text-align: left">GICDA_CTLR  <em>(Distributor Control Register A)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://lupyuen.github.io/articles/avaota#arm64-generic-interrupt-controller">(Explained here)</a></p>
<hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-89d849e89568645806e7cde6f80877786891ed21659d281b9413db67e6eff0c1"><strong>boards/arm64/a527/avaota-a1/configs/nsh/defconfig</strong></a></p>
<p>We set the <strong>UART0 Interrupt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the UART0 Interrupt to 34
CONFIG_16550_UART0_IRQ=34</code></pre></div>
<p>Based on the A527 Doc‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: center">Page 256</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Interrupt Number</strong></td><td style="text-align: center"><strong>Interrupt Source</strong></td></tr>
<tr><td style="text-align: center">34</td><td style="text-align: center">UART0</td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://lupyuen.github.io/articles/avaota#fix-the-uart-interrupt">(Explained here)</a></p>
<h2 id="arm64-boot-code"><a class="doc-anchor" href="#arm64-boot-code">¬ß</a>19.3 Arm64 Boot Code</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-faa554bbda31c1c014a2df5f83ab406dd9e57d39fff982ce45fdb627f63e468d"><strong>arch/arm64/src/a527/a527_lowputc.S</strong></a></p>
<p>We updated the Arm64 Boot Code for <strong>16550 UART Driver</strong>‚Ä¶</p>
<ol>
<li>
<p>We modified the <strong>UART Base Address</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address for 16550 UART
#define UART0_BASE_ADDRESS 0x02500000</code></pre></div></li>
<li>
<p>QEMU was using PL011 UART. We fixed this for 16550 UART, to <strong>Wait for UART Ready</strong> <a href="https://github.com/apache/nuttx/blob/master/arch/arm64/src/a64/a64_lowputc.S#L62-L74">(derived from NuttX A64)</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Wait for 16550 UART to be ready to transmit
* xb: Register that contains the UART Base Address
* wt: Scratch register number */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14] /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20        /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                /* Wait for the UART to be ready (THRE=1) */
.endm</code></pre></div></li>
</ol>
<p><strong>UART Base Address</strong> came from the A527 Doc‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">UART0</td><td style="text-align: left"><em>0x0250_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>With these <strong>UART Registers</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x0000</em></td><td style="text-align: left">UART_THR <em>(Transmit Holding Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0004</em></td><td style="text-align: left">UART_DLH <em>(Divisor Latch High Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0008</em></td><td style="text-align: left">UART_IIR <em>(Interrupt Identity Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x000C</em></td><td style="text-align: left">UART_LCR <em>(Line Control)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p><a href="https://lupyuen.github.io/articles/avaota#print-to-uart-in-arm64-assembly">(Explained here)</a></p>
<p><img src="https://lupyuen.org/images/avaota-initrd2.jpg" alt="Mounting the ROMFS Filesystem containing the NuttX Apps" /></p>
<h2 id="nuttx-start-code"><a class="doc-anchor" href="#nuttx-start-code">¬ß</a>19.4 NuttX Start Code</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/blob/71b0ea678c08d9d1390e4d669876f99d93496ecf/arch/arm64/src/a527/a527_boot.c#L69-L170"><strong>arch/arm64/src/a527/a527_boot.c</strong></a></p>
<p><strong>At NuttX Startup:</strong> We mount the <strong>ROMFS Filesystem</strong> <em>(Initial RAM Disk, pic above)</em> containing the <strong>NuttX Apps</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/avaota#appendix-nuttx-apps-filesystem"><strong>‚ÄúNuttX Apps Filesystem‚Äù</strong></a></li>
</ul>
<p>How? We safely copy the <strong>ROMFS Filesystem</strong> from the NuttX Image into the <strong><code>ramdisk</code> Memory Region</strong>. This code comes from <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/eic7700x/eic7700x_start.c#L72-L183"><strong>NuttX EIC7700X</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Needed for the `aligned_data` macro
#include &lt;nuttx/compiler.h&gt;

// Just after Bootloader has started NuttX...
void arm64_chip_boot(void) {

  // We copy the RAM Disk
  qemu_copy_ramdisk();

  // Omitted: Other initialisation (MMU, ...)
  arm64_mmu_init(true);
  ...
}

// Copy the RAM Disk from NuttX Image to RAM Disk Region.
static void a527_copy_ramdisk(void) {
  const uint8_t aligned_data(8) header[8] = &quot;-rom1fs-&quot;;
  const uint8_t *limit = (uint8_t *)g_idle_topstack + (256 * 1024);
  uint8_t *ramdisk_addr = NULL;
  uint8_t *addr;
  uint32_t size;

  // After Idle Stack Top, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
  // Limit search to 256 KB after Idle Stack Top.
  for (addr = g_idle_topstack; addr &lt; limit; addr += 8) {
      if (memcmp(addr, header, sizeof(header)) == 0) {
        ramdisk_addr = addr;
        break;
      }
  }

  // Stop if RAM Disk is missing
  if (ramdisk_addr == NULL) {
    _err(&quot;Missing RAM Disk. Check the initrd padding.&quot;);
    PANIC();
  }

  // Read the Filesystem Size from the next 4 bytes (Big Endian)
  size = (ramdisk_addr[8] &lt;&lt; 24) + (ramdisk_addr[9] &lt;&lt; 16) +
         (ramdisk_addr[10] &lt;&lt; 8) + ramdisk_addr[11] + 0x1f0;

  // Filesystem Size must be less than RAM Disk Memory Region
  if (size &gt; (size_t)__ramdisk_size) {
    _err(&quot;RAM Disk Region too small. Increase by %lu bytes.\n&quot;, size - (size_t)__ramdisk_size);
    PANIC();
  }

  // Copy the RAM Disk from NuttX Image to RAM Disk Region.
  // __ramdisk_start overlaps with ramdisk_addr + size.
  a527_copy_overlap(__ramdisk_start, ramdisk_addr, size);
}

// Copy an overlapping memory region.  dest overlaps with src + count.
static void a527_copy_overlap(uint8_t *dest, const uint8_t *src, size_t count) {
  uint8_t *d = dest + count - 1;
  const uint8_t *s = src + count - 1;
  if (dest &lt;= src) { _err(&quot;dest and src should overlap&quot;); PANIC(); }
  while (count--) {
    volatile uint8_t c = *s;  // Prevent compiler optimization
    *d = c;
    d--;
    s--;
  }
} 

// RAM Disk Region is defined in Linker Script
extern uint8_t __ramdisk_start[];
extern uint8_t __ramdisk_size[];</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-29f9a5b9711e05525c0f249e0b9096a1e613bbde5783436f448a21b36ced2de0">(Previously here)</a></p>
<p><em>Why the aligned addresses?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Header is aligned to 8 bytes
const uint8_t
  aligned_data(8) header[8] =
  &quot;-rom1fs-&quot;;

// Address is also aligned to 8 bytes
for (
  addr = g_idle_topstack;
  addr &lt; limit;
  addr += 8
) {
  // Otherwise this will hit Alignment Fault
  memcmp(addr, header, sizeof(header));
  ...
}</code></pre></div>
<p>We align our Memory Accesses to <strong>8 Bytes</strong>. Otherwise we‚Äôll hit an <a href="https://gist.github.com/lupyuen/f10af7903461f44689203d0e02fb9949"><strong>Alignment Fault</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Alignment Fault at `memcmp(addr, header, sizeof(header))`
default_fatal_handler:
  (IFSC/DFSC) for Data/Instruction aborts:
  alignment fault</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#appendix-nuttx-apps-filesystem">(Explained here)</a></p>
<h2 id="board-bringup-code"><a class="doc-anchor" href="#board-bringup-code">¬ß</a>19.5 Board Bringup Code</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-5c21dc796c75ebe2ddd15175015333e013d3966e6e779432eda183363ae1d7b2"><strong>boards/arm64/a527/avaota-a1/src/a527_bringup.c</strong></a></p>
<p><strong>At Board Startup:</strong> We mount the <strong>ROMFS Filesystem</strong> <em>(inside RAM)</em> as <em>/dev/ram0</em>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// At NuttX Startup...
int a527_bringup(void) {
  // We Mount the RAM Disk
  mount_ramdisk();
  ...
}

// Mount a RAM Disk defined in ld.script to /dev/ramX.  The RAM Disk
// contains a ROMFS filesystem with applications that can be spawned at
// runtime.
static int mount_ramdisk(void) {
  struct boardioc_romdisk_s desc;
  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;

  int ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
  if (ret &lt; 0) {
    syslog(LOG_ERR, &quot;Ramdisk register failed: %s\n&quot;, strerror(errno));
    syslog(LOG_ERR, &quot;Ramdisk mountpoint /dev/ram%d\n&quot;,RAMDISK_DEVICE_MINOR);
    syslog(LOG_ERR, &quot;Ramdisk length %lu, origin %lx\n&quot;, (ssize_t)__ramdisk_size, (uintptr_t)__ramdisk_start);
  }
  return ret;
}

// RAM Disk Definition
#define SECTORSIZE   512
#define NSECTORS(b)  (((b) + SECTORSIZE - 1) / SECTORSIZE)
#define RAMDISK_DEVICE_MINOR 0</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#mount-the-romfs">(Explained here)</a></p>
<h2 id="linker-script-1"><a class="doc-anchor" href="#linker-script-1">¬ß</a>19.6 Linker Script</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-239ddf89006a4d4e2858b9f3c4fa8165245fd7d21ed0a33a971c70c4deaf9d4a"><strong>boards/arm64/a527/avaota-a1/scripts/ld.script</strong></a></p>
<p>We reserve <strong>16 MB of RAM</strong> for the ROMFS Filesystem that will host the NuttX Apps‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* Linker Script: We moved the Paged Pool and added the RAM Disk (16 MB) */
MEMORY {
  /* Previously: QEMU boots at 0x4028_0000 */
  dram (rwx)  : ORIGIN = 0x40800000, LENGTH = 2M

  /* Previously: QEMU Paged Memory is at 0x4028_0000 */
  /* Why? Because 0x4080_0000 + 2 MB = 0x40A0_0000   */
  pgram (rwx) : ORIGIN = 0x40A00000, LENGTH = 4M   /* w/ cache */

  /* Added the RAM Disk */
  ramdisk (rwx) : ORIGIN = 0x40E00000, LENGTH = 16M   /* w/ cache */
}

/* We&#39;ll reference these in our code */
__ramdisk_start = ORIGIN(ramdisk);
__ramdisk_size  = LENGTH(ramdisk);
__ramdisk_end   = ORIGIN(ramdisk) + LENGTH(ramdisk);</code></pre></div>
<p>Also we moved the <strong>Paged Pool</strong> because the Boot Address has changed to <em>0x4080_0000</em>.</p>
<p><a href="https://lupyuen.github.io/articles/avaota#linker-script">(Explained here)</a></p>
<h2 id="nuttx-config"><a class="doc-anchor" href="#nuttx-config">¬ß</a>19.7 NuttX Config</h2>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-89d849e89568645806e7cde6f80877786891ed21659d281b9413db67e6eff0c1"><strong>boards/arm64/a527/avaota-a1/configs/nsh/defconfig</strong></a></p>
<p>Since we changed the <strong>Paged Memory Pool</strong> <em>(pgram)</em>, we update <em>ARCH_PGPOOL_PBASE</em> and <em>VBASE</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/eb33ac06f88dda557bc8ac97bec7d6cbad4ccb86">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Physical Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_PBASE=0x40A00000

## Virtual Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_VBASE=0x40A00000</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#set-the-start-address">(Explained here)</a></p>
<p>NuttX QEMU declares the <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45"><strong>RAM Size as 128 MB</strong></a> in <em>RAMBANK1_SIZE</em>. We set <em>RAM_SIZE</em> accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## RAM Size is 128 MB
CONFIG_RAM_SIZE=134217728</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#set-the-start-address">(Explained here)</a></p>
<p>Based on the <strong>16550 UART Registers</strong> above: We configured the 16550 UART and removed PL011 UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x02500000
CONFIG_16550_UART0_CLOCK=23040000
CONFIG_16550_UART0_IRQ=125
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#uart-driver-for-16550">(Explained here)</a></p>
<p><strong>16550_UART0_CLOCK</strong> was computed according to <a href="https://lupyuen.github.io/articles/release#appendix-uart-clock-for-jh7110"><strong>these instructions</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttX UART Debug Log shows:
  dlm = 0x00
  dll = 0x0D

We know that:
  dlm = 0x00 = (div &gt;&gt; 8)
  dll = 0x0D = (div &amp; 0xFF)

Which means:
  div = 0x0D

We know that:
  baud = 115200
  div  = (uartclk + (baud &lt;&lt; 3)) / (baud &lt;&lt; 4)

Therefore:
  0x0D    = (uartclk + 921600) / 1843200
  uartclk = (0x0D * 1843200) - 921600
          = 23040000</code></pre></div><hr>
<p><a href="https://github.com/lupyuen2/wip-nuttx/pull/99/commits/61d055d5040e6aee8d99507b00dbfb5b47c6cd3c#diff-7a8c921d26a5ea6904550ec7769d456e91598786ed4f7aacfed2642f53227dc6"><strong>arch/arm64/src/a527/a527_serial.c</strong></a></p>
<p>QEMU was using PL011 UART. We switched the Serial Driver to <strong>16550 UART</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Switch from PL011 UART (QEMU) to 16550 UART
#include &lt;nuttx/serial/uart_16550.h&gt;

// Enable the 16550 Console UART at Startup
void arm64_earlyserialinit(void) {
  // Previously for QEMU: pl011_earlyserialinit
  u16550_earlyserialinit();
}

// Ditto but not so early
void arm64_serialinit(void) {
  // Previous for QEMU: pl011_serialinit
  u16550_serialinit();
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/avaota#uart-driver-for-16550">(Explained here)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>