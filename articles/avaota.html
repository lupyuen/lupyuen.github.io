<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/avaota-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/avaota.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Porting Apache NuttX RTOS to Avaota-A1 SBC (Allwinner A527 SoC)</h1>
    <nav id="rustdoc"><ul>
<li><a href="#boot-linux-on-our-sbc" title="Boot Linux on our SBC">1 Boot Linux on our SBC</a><ul></ul></li>
<li><a href="#nuttx-kernel-build-for-arm64-qemu" title="NuttX Kernel Build for Arm64 QEMU">2 NuttX Kernel Build for Arm64 QEMU</a><ul></ul></li>
<li><a href="#boot-nuttx-kernel-on-our-sbc" title="Boot NuttX Kernel on our SBC">3 Boot NuttX Kernel on our SBC</a><ul></ul></li>
<li><a href="#print-to-uart-in-arm64-assembly" title="Print to UART in Arm64 Assembly">4 Print to UART in Arm64 Assembly</a><ul></ul></li>
<li><a href="#set-the-start-address" title="Set the Start Address">5 Set the Start Address</a><ul></ul></li>
<li><a href="#uart-driver-for-16550" title="UART Driver for 16550">6 UART Driver for 16550</a><ul></ul></li>
<li><a href="#microsd-multiplexer--smart-power-plug" title="MicroSD Multiplexer + Smart Power Plug">7 MicroSD Multiplexer + Smart Power Plug</a><ul></ul></li>
<li><a href="#arm64-memory-management-unit" title="Arm64 Memory Management Unit">8 Arm64 Memory Management Unit</a><ul></ul></li>
<li><a href="#fix-the-memory-map" title="Fix the Memory Map">9 Fix the Memory Map</a><ul></ul></li>
<li><a href="#arm64-generic-interrupt-controller" title="Arm64 Generic Interrupt Controller">10 Arm64 Generic Interrupt Controller</a><ul></ul></li>
<li><a href="#nuttx-apps-filesystem" title="NuttX Apps Filesystem">11 NuttX Apps Filesystem</a><ul></ul></li>
<li><a href="#fix-the-uart-interrupt" title="Fix the UART Interrupt">12 Fix the UART Interrupt</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">13 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-avaota-a1" title="Appendix: Build NuttX for Avaota-A1">14 Appendix: Build NuttX for Avaota-A1</a><ul></ul></li>
<li><a href="#appendix-boot-nuttx-on-avaota-a1" title="Appendix: Boot NuttX on Avaota-A1">15 Appendix: Boot NuttX on Avaota-A1</a><ul></ul></li>
<li><a href="#appendix-sdwire-microsd-multiplexer" title="Appendix: SDWire MicroSD Multiplexer">16 Appendix: SDWire MicroSD Multiplexer</a><ul></ul></li>
<li><a href="#appendix-nuttx-apps-filesystem" title="Appendix: NuttX Apps Filesystem">17 Appendix: NuttX Apps Filesystem</a><ul>
<li><a href="#hostfs-becomes-romfs" title="HostFS becomes ROMFS">17.1 HostFS becomes ROMFS</a><ul></ul></li>
<li><a href="#linker-script" title="Linker Script">17.2 Linker Script</a><ul></ul></li>
<li><a href="#mount-the-romfs" title="Mount the ROMFS">17.3 Mount the ROMFS</a><ul></ul></li>
<li><a href="#copy-the-romfs" title="Copy the ROMFS">17.4 Copy the ROMFS</a><ul></ul></li></ul></li>
<li><a href="#appendix-port-nuttx-to-avaota-a1" title="Appendix: Port NuttX to Avaota-A1">18 Appendix: Port NuttX to Avaota-A1</a><ul></ul></li></ul></nav><p>üìù <em>9 Apr 2025</em></p>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<p><a href="https://youtu.be/PxaMcmMAzlM"><em>(Watch the Demo on YouTube)</em></a></p>
<p>This article explains how we ported NuttX from <a href="TODO"><strong>QEMU Arm64 Kernel Build</strong></a> to <a href="https://pine64.com/product/yuzuki-avaota-a1-single-board-computer-4gb-32gb/"><strong>PINE64 Avaota-A1 SBC</strong></a> based on <a href="https://linux-sunxi.org/A523"><strong>Allwinner A527 SoC</strong></a> ‚Ä¶ Completed within <a href="https://github.com/lupyuen2/wip-nuttx/commits/avaota"><strong>24 Hours</strong></a>!</p>
<p><em>Why are we doing this?</em></p>
<ul>
<li>
<p>Anyone porting NuttX from <strong>QEMU to Real SBC</strong>? This walkthrough shall be mighty helpful!</p>
</li>
<li>
<p>Avaota-A1 SBC is <a href="https://github.com/AvaotaSBC/Avaota-A1"><strong>Open Source Hardware</strong></a> <em>(CERN OHL Licensed)</em>. PINE64 sells it today, maybe we‚Äôll see more manufacturers.</p>
</li>
<li>
<p>This could be the First Port of <a href="TODO"><strong>Arm64 in NuttX Kernel Build</strong></a>. <em>(NXP i.MX93 might be another?)</em></p>
</li>
<li>
<p>We‚Äôll run it as <a href="TODO"><strong>PR Test Bot</strong></a> for validating <strong>Arm64 Pull Requests</strong> on Real Hardware. PR Test Bot will be fully automated thanks to the <a href="https://lupyuen.org/articles/testbot3.html"><strong>MicroSD Multiplexer</strong></a>.</p>
</li>
</ul>
<p>We‚Äôre ready for volunteers to build <strong>NuttX Drivers for Avaota-A1 / Allwinner A527</strong> <em>(GPIO, SPI, I2C, MIPI CSI / DSI, Ethernet, WiFi, ‚Ä¶)</em> Please lemme know! üôè</p>
<ul>
<li>
<p><a href="https://linux-sunxi.org/A523"><strong>Sunxi Docs on Allwinner A527</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/File:A527_Datasheet_V0.93.pdf"><strong>Allwinner A527 Datasheet</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf"><strong>Allwinner A523 User Manual</strong></a> <em>(A527 is similar to A523)</em></p>
</li>
<li>
<p><a href="https://github.com/AvaotaSBC/Avaota-A1/blob/master/hardware/v1.4/01_SCH/SCH_Avaota%20Pi%20A_2024-05-20.pdf"><strong>Avaota-A1 Schematic</strong></a></p>
</li>
</ul>
<p><em>(BTW I bought all the hardware covered in this article. Nope, nothing was sponsored: Avaota-A1, SDWire, IKEA TRETAKT)</em></p>
<p><img src="https://lupyuen.org/images/testbot3-uart.jpg" alt="Avaota-A1 SBC connected to USB UART" /></p>
<h1 id="boot-linux-on-our-sbc"><a class="doc-anchor" href="#boot-linux-on-our-sbc">¬ß</a>1 Boot Linux on our SBC</h1>
<p>Nifty Trick for Booting NuttX on <strong>Any Arm64 SBC</strong> (RISC-V too)</p>
<ul>
<li>
<p><strong>Arm64 Bootloader</strong> <em>(U-Boot / SyterKit)</em> will boot Linux by loading the <strong><code>Image</code></strong> file</p>
<p><em>(Containing the Linux Kernel)</em></p>
</li>
<li>
<p>Thus we <strong>‚ÄúHijack‚Äù the <code>Image</code> File</strong>, replace it by <strong>NuttX Kernel</strong></p>
</li>
<li>
<p>Which means <strong>NuttX Kernel</strong> shall look and feel like a <strong>Linux Kernel</strong></p>
</li>
<li>
<p>That‚Äôs why we have a <a href="TODO"><strong>Linux Kernel Header</strong></a> at the top of NuttX</p>
</li>
</ul>
<p>To begin, we observe our SBC and its <em>Natural Behaviour</em>‚Ä¶ How does it <strong>Boot Linux?</strong></p>
<ol>
<li>
<p>Connect a <a href="https://pine64.com/product/serial-console-woodpecker-edition/"><strong>USB UART Dongle</strong></a> (CH340 or CP2102) to the <strong>UART0 Port</strong> (pic above)</p>
<div><table><thead><tr><th style="text-align: center">Avaota-A1</th><th style="text-align: center">USB UART</th><th style="text-align: center">Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>GND</strong> (Pin 6)</td><td style="text-align: center"><strong>GND</strong></td><td style="text-align: center"><em>Yellow</em></td></tr>
<tr><td style="text-align: center"><strong>TX</strong> (Pin 8)</td><td style="text-align: center"><strong>RX</strong></td><td style="text-align: center"><em>Orange</em></td></tr>
<tr><td style="text-align: center"><strong>RX</strong> (Pin 10)</td><td style="text-align: center"><strong>TX</strong></td><td style="text-align: center"><em>Red</em></td></tr>
</tbody></table>
</div>
<p><strong>Boot Log</strong> will appear at <em>/dev/ttyUSB0</em>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Allow the user to access the USB UART port
## Logout and login to refresh the permissions
sudo usermod -a -G dialout $USER
logout

## Connect to USB UART Console
screen /dev/ttyUSB0 115200</code></pre></div></li>
<li>
<p>Download the <a href="https://github.com/AvaotaSBC/AvaotaOS/releases"><strong>Latest AvaotaOS Release</strong></a> <em>(Ubuntu Noble GNOME)</em> and uncompress it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>wget https://github.com/AvaotaSBC/AvaotaOS/releases/download/0.3.0.4/AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz
xz -d AvaotaOS-0.3.0.4-noble-gnome-arm64-avaota-a1.img.xz</code></pre></div></li>
<li>
<p>Write the <strong><code>.img</code></strong> file to a MicroSD with <a href="https://etcher.balena.io/"><strong>Balena Etcher</strong></a>.</p>
</li>
<li>
<p>Insert the MicroSD into our SBC and <a href="https://gist.github.com/lupyuen/dd4beb052ce07c36d41d409631c6d68b"><strong>Boot AvaotaOS</strong></a>. We‚Äôll see the Boot Log‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast</code></pre></div></li>
<li>
<p><strong>Kernel Boot Address</strong> <em>0x4080_0000</em> is super important, we‚Äôll use it in a while</p>
</li>
</ol>
<h1 id="nuttx-kernel-build-for-arm64-qemu"><a class="doc-anchor" href="#nuttx-kernel-build-for-arm64-qemu">¬ß</a>2 NuttX Kernel Build for Arm64 QEMU</h1>
<p>Follow these steps to Build and Run NuttX for <a href="TODO"><strong>Arm64 QEMU (Kernel Build)</strong></a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX Kernel (NuttX Kernel Build)
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx
tools/configure.sh qemu-armv8a:knsh
make -j

## Build NuttX Apps (NuttX Kernel Build)
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Boot NuttX on QEMU
qemu-system-aarch64 \
  -semihosting \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>Check that it works‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p>We‚Äôre ready to boot <strong><code>nuttx.bin</code></strong> on our SBC!</p>
<p><em>Why start with NuttX Kernel Build? Not NuttX Flat Build?</em></p>
<p>Our SBC is a mighty monster with <strong>Eight Arm64 Cores</strong> and plenty of RAM. It makes more sense to boot <a href="TODO"><strong>NuttX Kernel Build</strong></a> and run lots of cool powerful NuttX Apps with <a href="TODO"><strong>Virtual Memory</strong></a>.</p>
<p><em>(NuttX Flat Build was created for Simpler Microcontrollers with Limited RAM)</em></p>
<h1 id="boot-nuttx-kernel-on-our-sbc"><a class="doc-anchor" href="#boot-nuttx-kernel-on-our-sbc">¬ß</a>3 Boot NuttX Kernel on our SBC</h1>
<p>Remember the <a href="TODO"><strong>MicroSD we downloaded</strong></a>? Inside the MicroSD is a 28 MB Linux Kernel, named ‚Äú<strong><code>Image</code></strong>‚Äù</p>
<div class="example-wrap"><pre class="language-bash"><code>$ ls -l /TODO
total 40261
-rwxr-xr-x 1 root root    78769 Feb 22 01:06 bl31.bin
-rwxr-xr-x 1 root root   180233 Feb 21 22:21 config-5.15.154-ga464bc4feaff
drwxr-xr-x 3 root root      512 Feb 21 22:56 dtb
drwxr-xr-x 2 root root      512 Feb 22 01:06 extlinux
-rwxr-xr-x 1 root root 27783176 Mar  7 21:24 Image
-rwxr-xr-x 1 root root   180228 Feb 22 01:06 scp.bin
-rwxr-xr-x 1 root root    12960 Feb 22 01:06 splash.bin
-rwxr-xr-x 1 root root  5193581 Feb 21 22:21 System.map-5.15.154-ga464bc4feaff
-rwxr-xr-x 1 root root  6497300 Feb 22 01:06 uInitrd</code></pre></div>
<p>Let‚Äôs replace it with NuttX‚Ä¶</p>
<ol>
<li>
<p>Take the NuttX Kernel <strong><code>nuttx.bin</code></strong> from the previous section</p>
<p><em>(Yes the QEMU one)</em></p>
</li>
<li>
<p>Overwrite the <strong><code>Image</code></strong> file by <strong><code>nuttx.bin</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mv /TODO/Image /TODO/Image.old
cp nuttx.bin /TODO/Image
ls -l /TODO/Image
## Should be a lot smaller
umount /TODO</code></pre></div></li>
<li>
<p>Insert the MicroSD into our SBC. Boot it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast</code></pre></div></li>
</ol>
<p>Nothing happens. Let‚Äôs tweak this iteratively, in tiny steps‚Ä¶</p>
<h1 id="print-to-uart-in-arm64-assembly"><a class="doc-anchor" href="#print-to-uart-in-arm64-assembly">¬ß</a>4 Print to UART in Arm64 Assembly</h1>
<p><em>Is NuttX actually booting on our SBC?</em></p>
<p>Let‚Äôs print something. <strong>UART0 Base Address</strong> is here‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">UART0</td><td style="text-align: left"><em>0x0250_0000</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>16550 Transmit Register is at <strong>Offset 0</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 1839</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x0000</em></td><td style="text-align: left">UART_THR <em>(Transmit Holding Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0004</em></td><td style="text-align: left">UART_DLH <em>(Divisor Latch High Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x0008</em></td><td style="text-align: left">UART_IIR <em>(Interrupt Identity Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x000C</em></td><td style="text-align: left">UART_LCR <em>(Line Control)</em></td></tr>
</tbody></table>
</div></div>
</p>
<p>Which means we can <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333"><strong>Print to UART</strong></a> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Print `123` to UART0
*(volatile uint8_t *) 0x02500000 = &#39;1&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;2&#39;;
*(volatile uint8_t *) 0x02500000 = &#39;3&#39;;</code></pre></div>
<p>But let‚Äôs do it in <strong>Arm64 Assembly</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/be2f1c55aa24eda9cd8652aa0bf38251335e9d01">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here */
__start:
  add x13, x18, #0x16 /* &quot;MZ&quot;: Magic Number for Linux Kernel Header */
  b   real_start      /* Jump to Executable Code      */
  ...                 /* Omitted: Linux Kernel Header */

/* Executable Code begins here */
/* We print `123` to UART0     */
real_start:

  /* Load UART0 Base Address into Register X15 */
  mov  x15, #0x02500000

  /* Load character `1` into Register W16 */
  mov  w16, #0x31

  /* Store the lower byte from Register W16 (`1`) to UART0 Base Address */
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`2`) to UART0 Base Address */
  mov  w16, #0x32
  strb w16, [x15]

  /* Load and Store the lower byte from Register W16 (`3`) to UART0 Base Address */
  mov  w16, #0x33
  strb w16, [x15]</code></pre></div>
<p><a href="TODO"><em>(RISC-V? Same same)</em></a></p>
<p>Rebuild NuttX and recopy <strong><code>nuttx.bin</code></strong> to MicroSD, overwriting the <strong><code>Image</code></strong> file. NuttX boot and <a href="https://gist.github.com/lupyuen/14188c44049a14e3581523c593fdf2d8"><strong>prints <code>123</code></strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
BL31: v2.5(debug):9241004a9
sunxi-arisc driver is starting
ERROR: Error initializing runtime service opteed_fast
123</code></pre></div>
<p>(Ignore the error: <em>opteed_fast</em>)</p>
<p><em>Why print in Arm64 Assembly? Why not C?</em></p>
<ol>
<li>
<p>Arm64 Assembly is the <strong>very first thing that boots</strong> when Bootloader starts NuttX</p>
</li>
<li>
<p>This happens <strong>before anything complicated</strong> and crash-prone begins: UART Driver, Memory Management Unit, Task Scheduler, ‚Ä¶</p>
</li>
<li>
<p>The Arm64 Assembly above is <strong>Address-Independent Code</strong>: It will execute at Any Arm64 Address</p>
</li>
</ol>
<p>Next we move our code and make it Address-Dependent‚Ä¶</p>
<h1 id="set-the-start-address"><a class="doc-anchor" href="#set-the-start-address">¬ß</a>5 Set the Start Address</h1>
<p><em>NuttX boots a tiny bit on our SBC. Where‚Äôs the rest?</em></p>
<p>Our SBC boots NuttX at a different address from QEMU. We set the <strong>Start Address</strong> inside NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>read /Image addr=40800000
Kernel addr: 0x40800000
123</code></pre></div>
<ol>
<li>
<p>Remember the <a href="TODO"><strong>Boot Log</strong></a> from earlier? It says that the <a href="https://github.com/YuzukiHD/SyterKit"><strong>SyterKit Bootloader</strong></a> starts NuttX at <strong>Address <code>0x4080_0000</code></strong>. We set it here: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c38e1f7c014e1af648a33847fc795930ba995bca">ld-kernel.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>MEMORY {
  /* Previously: QEMU boots at 0x4028_0000 */
  dram (rwx)  : ORIGIN = 0x40800000, LENGTH = 2M

  /* Previously: QEMU Paged Memory is at 0x4028_0000 */
  pgram (rwx) : ORIGIN = 0x40A00000, LENGTH = 4M   /* w/ cache */

  /* Why? Because 0x4080_0000 + 2 MB = 0x40A0_0000 */</code></pre></div></li>
<li>
<p>Since we changed the <strong>Paged Memory Pool</strong> <em>(pgram)</em>, we update <em>ARCH_PGPOOL_PBASE</em> and <em>VBASE</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/eb33ac06f88dda557bc8ac97bec7d6cbad4ccb86">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Physical Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_PBASE=0x40A00000

## Virtual Address of Paged Memory Pool
## Previously: QEMU Paged Memory is at 0x4028_0000
CONFIG_ARCH_PGPOOL_VBASE=0x40A00000</code></pre></div>
<p><em>(Paged Memory Pool shall be dished out as Virtual Memory to NuttX Apps)</em></p>
</li>
<li>
<p>NuttX QEMU declares the <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45"><strong>RAM Size as 128 MB</strong></a> in <em>RAMBANK1_SIZE</em>. We set <em>RAM_SIZE</em> accordingly: <a href="https://github.com/lupyuen2/wip-nuttx/commit/c8fbc5b86c2bf1dd7b8243b301b0790115c9c4ca">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## RAM Size is a paltry 128 MB
CONFIG_RAM_SIZE=134217728</code></pre></div>
<p><em>(Kinda tiny, but sufficient)</em></p>
</li>
<li>
<p><strong>Linux Kernel Header</strong> needs patching. We set the <strong>Image Load Offset</strong> to <em>0x80_0000</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/be2f1c55aa24eda9cd8652aa0bf38251335e9d01">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Bootloader starts NuttX here, followed by Linux Kernel Header */
__start:
  ...
  /* Image Load Offset from Start of RAM          */
  /* Previously: QEMU set this to 0x480000 (why?) */
  .quad 0x800000</code></pre></div></li>
</ol>
<p>That‚Äôs because‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-nuttx/blob/avaota/boards/arm64/qemu/qemu-armv8a/configs/knsh/defconfig#L85"><strong>Start of RAM</strong></a> is <em>0x4000_0000</em></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_RAM_START=0x40000000</code></pre></div></li>
<li>
<p>Bootloader starts NuttX at <em>0x4080_0000</em></p>
</li>
<li>
<p>Subtract the above to get <strong>Image Load Offset</strong>: <em>0x80_0000</em></p>
</li>
</ul>
<p>With these mods, our C Code in NuttX shall boot correctly. In case we forget: Boot Address also appears on the Onboard LCD‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot3-lcd.jpg" alt="Avaota-A1 SBC with Onboard LCD" /></p>
<h1 id="uart-driver-for-16550"><a class="doc-anchor" href="#uart-driver-for-16550">¬ß</a>6 UART Driver for 16550</h1>
<p><em>Our C Code can print to UART now?</em></p>
<p>To watch the <strong>Boot Progress</strong> <em>(Sesame Street-style)</em>, we can print primitively to UART like this: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // TODO

  *(volatile uint8_t *) 0x02500000 = &#39;D&#39;;
  qemu_board_initialize();  // Init the Board

  *(volatile uint8_t *) 0x02500000 = &#39;E&#39;;
  arm64_earlyserialinit();  // Init the Serial Driver

  *(volatile uint8_t *) 0x02500000 = &#39;F&#39;;
  syslog_rpmsg_init_early(...);  // Init the System Logger

  *(volatile uint8_t *) 0x02500000 = &#39;G&#39;;
  up_perf_init(..);  // Init the Performance Counters</code></pre></div>
<p>Beyond Big Bird: We need the <strong>16550 UART Driver</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>NuttX Boot Code</strong> <em>(Arm64 Assembly)</em> will print to UART. We patch it: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-60cebb895326dea641e32d31ff39511acf127a30c9ac8f275590e7524737366e">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address and Baud Rate for 16550 UART
#define UART1_BASE_ADDRESS          0x02500000
#define EARLY_UART_PL011_BAUD_RATE  115200</code></pre></div></li>
<li>
<p><strong>NuttX Boot Code</strong> will drop UART Output, unless we wait for UART Ready: <a href="https://github.com/lupyuen2/wip-nuttx/commit/544323e7c0e66c4df0d1312d4837147d420bc19d">qemu_lowputc.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Wait for 16550 UART to be ready to transmit
* xb: Register that contains the UART Base Address
* wt: Scratch register number */
.macro early_uart_ready xb, wt
1:
  ldrh  \wt, [\xb, #0x14] /* UART_LSR (Line Status Register) */
  tst   \wt, #0x20        /* Check THRE (TX Holding Register Empty) */
  b.eq  1b                /* Wait for the UART to be ready (THRE=1) */
.endm</code></pre></div>
<p><a href="TODO"><em>(Thanks to PinePhone)</em></a></p>
</li>
<li>
<p>QEMU uses PL011 UART. We switch to <strong>16550 UART</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-aefbee7ddc3221be7383185346b81cff77d382eb6f308ecdccb44466d0437108">qemu_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Switch from PL011 UART (QEMU) to 16550 UART
#include &lt;nuttx/serial/uart_16550.h&gt;

// Enable the 16550 Console UART at Startup
void arm64_earlyserialinit(void) {
  // Previously for QEMU: pl011_earlyserialinit
  u16550_earlyserialinit();
}

// Ditto but not so early
void arm64_serialinit(void) {
  // Previous for QEMU: pl011_serialinit
  u16550_serialinit();
}</code></pre></div></li>
<li>
<p><strong>16550 UART</strong> shall be configured: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>CONFIG_16550_ADDRWIDTH=0
CONFIG_16550_REGINCR=4
CONFIG_16550_UART0=y
CONFIG_16550_UART0_BASE=0x02500000
CONFIG_16550_UART0_CLOCK=198144000
CONFIG_16550_UART0_IRQ=125
CONFIG_16550_UART0_SERIAL_CONSOLE=y
CONFIG_16550_UART=y
CONFIG_16550_WAIT_LCR=y
CONFIG_SERIAL_UART_ARCH_MMIO=y</code></pre></div></li>
<li>
<p><strong>PL011 UART</strong> shall be removed: <a href="https://github.com/lupyuen2/wip-nuttx/commit/8fc8ed6ba84cfea86184f61d9c4d7c8e21329987">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Remove PL011 UART from NuttX Config:
## CONFIG_UART1_BASE=0x9000000
## CONFIG_UART1_IRQ=33
## CONFIG_UART1_PL011=y
## CONFIG_UART1_SERIAL_CONSOLE=y
## CONFIG_UART_PL011=y</code></pre></div></li>
<li>
<p><strong>16550_UART0_CLOCK</strong> isn‚Äôt quite correct, we‚Äôll <a href="TODO"><strong>settle later</strong></a>. Meanwhile we disable the <strong>UART Clock Configuration</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/0cde58d84c16f255cb12e5a647ebeee3b6a8dd5f#diff-f208234edbfb636de240a0fef1c85f9cecb37876d5bc91ffb759f70a1e96b1d1">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// We disable the UART Clock Configuration...
static int u16550_setup(FAR struct uart_dev_s *dev) { ...
#ifdef TODO  // We&#39;ll fix it later
  // Enter DLAB=1
  u16550_serialout(priv, UART_LCR_OFFSET, (lcr | UART_LCR_DLAB));

  // Omitted: Set the UART Baud Divisor
  // ...

  // Clear DLAB
  u16550_serialout(priv, UART_LCR_OFFSET, lcr);
#endif</code></pre></div></li>
</ol>
<p>Same old drill: Rebuild, recopy and reboot NuttX. We see plenty more <a href="https://gist.github.com/lupyuen/563ed00d3f6e9f7fb9b27268d4eae26b"><strong>debug output yay</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>OK the <em>repeated rebuilding, recopying and rebooting</em> of NuttX is getting really tiresome. Let‚Äôs automate‚Ä¶</p>
<p><img src="https://lupyuen.org/images/testbot2-flow3.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<h1 id="microsd-multiplexer--smart-power-plug"><a class="doc-anchor" href="#microsd-multiplexer--smart-power-plug">¬ß</a>7 MicroSD Multiplexer + Smart Power Plug</h1>
<p><em>What if we could rebuild-recopy-reboot NuttX‚Ä¶ In One Single Script?</em></p>
<p>Thankfully our Avaota-A1 SBC is connected to <a href="TODO"><strong>SDWire MicroSD Multiplexer</strong></a> and <a href="https://lupyuen.github.io/articles/testbot#power-up-our-oz64-sbc"><strong>Smart Power Plug</strong></a> (pic above). Our Build Script shall do <strong>everything</strong> for us‚Ä¶</p>
<ol>
<li>
<p>Copy <strong>NuttX to MicroSD</strong></p>
</li>
<li>
<p><strong>Swap the MicroSD</strong> from our Test PC to SBC</p>
</li>
<li>
<p><strong>Power up SBC</strong> and boot NuttX</p>
</li>
</ol>
<p><img src="https://lupyuen.org/images/avaota-title.jpg" alt="Avaota-A1 SBC with SDWire MicroSD Multiplexer and Smart Power Plug" /></p>
<p>Here‚Äôs our nifty <strong>Build Script</strong>: <a href="https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX and Apps (NuttX Kernel Build)
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image

## Get the Home Assistant Token
## That we copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC to finish booting
sleep 30

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://youtu.be/PxaMcmMAzlM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><img src="https://lupyuen.org/images/starpro64-power1.jpg" alt="Smart Power Plug in IKEA App and Google Home" /></p>
<p>This script assumes that we have‚Ä¶</p>
<ul>
<li>
<p>Installed a <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Home Assistant Server</strong></a></p>
<p><em>(Works fine with Docker)</em></p>
</li>
<li>
<p>Added the Smart Power Plug to <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant</strong></a></p>
<p><em>‚ÄúAvaota Power‚Äù (pic above)</em></p>
</li>
<li>
<p>Installed the <a href="https://lupyuen.github.io/articles/sg2000a#ikea-smart-power-plug"><strong>Google Assistant SDK</strong></a> for Home Assistant</p>
<p><em>(So we don‚Äôt need Zigbee programming)</em></p>
</li>
<li>
<p>Created the <a href="https://lupyuen.github.io/articles/sg2000a#call-the-home-assistant-api"><strong>Power Automation</strong></a> in Home Assistant</p>
<p><em>‚ÄúAvaota Power On‚Äù</em> and <em>‚ÄúAvaota Power Off‚Äù (pic below)</em></p>
</li>
</ul>
<p><img src="https://lupyuen.org/images/starpro64-power2.jpg" alt="Smart Power Plug in Home Assistant" /></p>
<p><em>What‚Äôs copy_image.sh?</em></p>
<p>This is the script that copies our NuttX Image to MicroSD, via the <strong>SDWire MicroSD Multiplexer</strong>‚Ä¶</p>
<ul>
<li>TODO: Appendix SDWire</li>
</ul>
<h1 id="arm64-memory-management-unit"><a class="doc-anchor" href="#arm64-memory-management-unit">¬ß</a>8 Arm64 Memory Management Unit</h1>
<p><em>OK can we get back to NuttX now?</em></p>
<p>Of course. Earlier we saw NuttX <a href="TODO"><strong>Stuck at ‚ÄúAB‚Äù</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
AB</code></pre></div>
<p>Which says that NuttX is stranded inside <strong>arm64_mmu_init</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/029056c7e0da092e4d3a211b5f5b22b7014ba333">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// 0x0250_0000 is the UART0 Base Address
void arm64_boot_primary_c_routine(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;A&#39;;
  arm64_chip_boot();
  ...

// `AB` means that NuttX is stuck inside arm64_mmu_init()
void arm64_chip_boot(void) {
  *(volatile uint8_t *) 0x02500000 = &#39;B&#39;;
  arm64_mmu_init(true);  // Init the Memory Mgmt Unit

  // Stuck above, never came here
  *(volatile uint8_t *) 0x02500000 = &#39;C&#39;;
  arm64_enable_mte();    // TODO</code></pre></div>
<p><em>What‚Äôs arm64_mmu_init?</em></p>
<p>NuttX calls <strong>arm64_mmu_init</strong> to start the Arm64 <strong>Memory Management Unit (MMU)</strong>. We add some logs inside: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-230f2ffd9be0a8ce48d4c9fb79df8f003b0c31fa0a18b6c0876ede5b4e334bb9">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Enable Debugging for MMU
#define CONFIG_MMU_ASSERT 1
#define CONFIG_MMU_DEBUG  1
#define trace_printf _info

// We fix the Debug Output, changing `%lux` to `%p`
static void init_xlat_tables(const struct arm_mmu_region *region) {
  ...
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);

// To enable the MMU at Exception Level 1...
static void enable_mmu_el1(unsigned int flags) {
  ...
  // Flush the Cached Data before Enabling MMU
  _info(&quot;UP_MB&quot;);
  UP_MB();

  // Enable the MMU and Data Cache
  _info(&quot;Enable the MMU and data cache&quot;);
  write_sysreg(value | SCTLR_M_BIT | SCTLR_C_BIT, sctlr_el1);

  // Ensure that MMU Enable takes effect immediately
  _info(&quot;UP_ISB&quot;);
  UP_ISB();</code></pre></div>
<p>And we Enable the Logs for <strong>Scheduler and Memory Manager</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/pull/96/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Enable Logging for Memory Manager
CONFIG_DEBUG_MM=y
CONFIG_DEBUG_MM_ERROR=y
CONFIG_DEBUG_MM_INFO=y
CONFIG_DEBUG_MM_WARN=y

## Enable Logging for Scheduler
CONFIG_DEBUG_SCHED=y
CONFIG_DEBUG_SCHED_ERROR=y
CONFIG_DEBUG_SCHED_INFO=y
CONFIG_DEBUG_SCHED_WARN=y</code></pre></div>
<p>Ah OK we‚Äôre stuck just before <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Enabling the MMU</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Init the MMU Page Translation Tables
init_xlat_tables: mmap: virt 0x7000000    phys 0x7000000    size 0x20000000
init_xlat_tables: mmap: virt 0x40000000   phys 0x40000000   size 0x8000000
init_xlat_tables: mmap: virt 0x4010000000 phys 0x4010000000 size 0x10000000
init_xlat_tables: mmap: virt 0x8000000000 phys 0x8000000000 size 0x8000000000
init_xlat_tables: mmap: virt 0x3eff0000 phys 0x3eff0000 size 0x10000
init_xlat_tables: mmap: virt 0x40800000 phys 0x40800000 size 0x2a000
init_xlat_tables: mmap: virt 0x4082a000 phys 0x4082a000 size 0x6000
init_xlat_tables: mmap: virt 0x40830000 phys 0x40830000 size 0x13000
init_xlat_tables: mmap: virt 0x40a00000 phys 0x40a00000 size 0x400000

## Enable the MMU at Exception Level 1
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache</code></pre></div>
<p>Something sus about the above <a href="https://gist.github.com/lupyuen/544a5d8f3fab2ab7c9d06d2e1583f362"><strong>Mystery Addresses</strong></a>, what are they?</p>
<p>
<div><table><thead><tr><th style="text-align: center">Virtual</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: center"><em>0x0700_0000</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4000_0000</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x40_1000_0000</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x80_0000_0000</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x3EFF_0000</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: center"><em>0x4080_0000</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: center"><em>0x4082_A000</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: center"><em>0x4083_0000</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: center"><em>0x40A0_0000</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<h1 id="fix-the-memory-map"><a class="doc-anchor" href="#fix-the-memory-map">¬ß</a>9 Fix the Memory Map</h1>
<p><em>Why do we need Arm64 MMU? (Memory Management Unit)</em></p>
<p>We require MMU for‚Ä¶</p>
<ul>
<li>
<p><strong>Memory Protection</strong>: Prevent Applications <em>(and Kernel)</em> from meddling with things <em>(in System Memory)</em> that they‚Äôre not supposed to</p>
</li>
<li>
<p><strong>Virtual Memory</strong>: Allow Applications to access chunks of <em>‚ÄúImaginary Memory‚Äù</em> at Exotic Addresses <em>(0x8000_0000!)</em></p>
<p>But in reality: They‚Äôre System RAM recycled from boring old addresses <em>(like 0x40A0_4000)</em></p>
<p><em>(Kinda like ‚ÄúThe Matrix‚Äù)</em></p>
</li>
</ul>
<p>If we don‚Äôt configure MMU with the correct <strong>Memory Map</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>NuttX Kernel</strong> won‚Äôt boot: <em>‚ÄúHelp! I can‚Äôt access my Kernel Code and Data!‚Äù</em></p>
</li>
<li>
<p><strong>NuttX Apps</strong> won‚Äôt run: <em>‚ÄúWhoops where‚Äôs the App Code and Data that Kernel promised?‚Äù</em></p>
</li>
</ul>
<p><em>Arm64 MMU won‚Äôt turn on. Maybe our Memory Map is incorrect?</em></p>
<p>Let‚Äôs verify our <strong>A527 Memory Map</strong>‚Ä¶</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: left"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 42</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Module</strong></td><td style="text-align: left"><strong>Address</strong></td></tr>
<tr><td style="text-align: left">Boot ROM &amp; SRAM</td><td style="text-align: left"><em>0x0000_0000</em> to ‚Ä¶</td></tr>
<tr><td style="text-align: left">PCIE</td><td style="text-align: left"><em>0x2000_0000</em> to <em>0x2FFF_FFFF</em></td></tr>
<tr><td style="text-align: left">DRAM</td><td style="text-align: left"><em>0x4000_0000</em> to ‚Ä¶</td></tr>
</tbody></table>
</div></div>
</p>
<p>How does this compare with NuttX? We do extra <strong>MMU Logging</strong>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/9488ecb5d8eb199bdbe16adabef483cf9cf04843">arm64_mmu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Print the Names of the MMU Memory Regions
static void init_xlat_tables(const struct arm_mmu_region *region) { ...
  _info(&quot;name=%s\n&quot;, region-&gt;name);
  sinfo(&quot;mmap: virt %p phys %p size %p\n&quot;, virt, phys, size);</code></pre></div>
<p>Ah much clearer! Now we see the <strong>Names of Memory Regions</strong> for the MMU‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0700_0000</td><td style="text-align: center"><em>0x2000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_CFG</em></td><td style="text-align: center">0x40_1000_0000</td><td style="text-align: center"><em>0x1000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_MEM</em></td><td style="text-align: center">0x80_0000_0000</td><td style="text-align: center"><em>0x80_0000_0000</em></td></tr>
<tr><td style="text-align: left"><em>PCI_IO</em></td><td style="text-align: center">0x3EFF_0000</td><td style="text-align: center"><em>0x0001_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Two Tweaks‚Ä¶</p>
<ul>
<li>
<p><strong>DEVICE_REGION</strong>: This says I/O Memory Space ends at <em>0x2700_0000</em>. Based on the earlier <strong>A527 Memory Map</strong>, we extend this to <em>0x4000_0000 (1 GB)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/005900ef7e1a1480b8df975d0dcd190fbfc60a45">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Fix the I/O Memory Space: Base Address and Size
#define CONFIG_DEVICEIO_BASEADDR 0x00000000
#define CONFIG_DEVICEIO_SIZE     MB(1024)

// We don&#39;t need PCI, for now
// #define CONFIG_PCI_CFG_BASEADDR 0x4010000000
// #define CONFIG_PCI_CFG_SIZE     MB(256)
// #define CONFIG_PCI_MEM_BASEADDR 0x8000000000
// #define CONFIG_PCI_MEM_SIZE     GB(512)
// #define CONFIG_PCI_IO_BASEADDR  0x3eff0000
// #define CONFIG_PCI_IO_SIZE      KB(64)</code></pre></div></li>
<li>
<p><strong>PCI</strong>: Let‚Äôs remove these for now: <a href="https://github.com/lupyuen2/wip-nuttx/commit/ca273d05e015089a33072997738bf588b899f8e7">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct arm_mmu_region g_mmu_regions[] = {
  ...
  // We don&#39;t need PCI, for now
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_CFG&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_MEM&quot;, ...
  // MMU_REGION_FLAT_ENTRY(&quot;PCI_IO&quot;, ...</code></pre></div></li>
</ul>
<p>The rest are hunky dory‚Ä¶</p>
<ul>
<li>
<p><strong>DRAM0_S0</strong> says that RAM Address Space ends at <em>0x4800_0000 (128 MB)</em></p>
<p><em>(Kinda small, but sufficient for now)</em></p>
</li>
<li>
<p><strong>nx_code</strong> <em>(0x4080_0000)</em>: Kernel Code begins here</p>
</li>
<li>
<p><strong>nx_rodata</strong> <em>(0x4082_A000)</em>: Read-Only Data for Kernel</p>
</li>
<li>
<p><strong>nx_data</strong> <em>(0x4083_0000)</em>: Read-Write Data for Kernel</p>
</li>
<li>
<p><strong>nx_pgpool</strong> <em>(0x40A0_0000)</em>: Remember the <a href="TODO"><strong>Paged Memory Pool</strong></a>? This shall be dished out as <strong>Virtual Memory</strong> to NuttX Apps</p>
</li>
</ul>
<p>We rebuild, recopy, reboot NuttX. Our Memory Map looks <a href="https://gist.github.com/lupyuen/ad4cec0dee8a21f3f404144be180fa14"><strong>much better now</strong></a>‚Ä¶</p>
<p>
<div><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: center">Physical</th><th style="text-align: center">Size</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>DEVICE_REGION</em></td><td style="text-align: center">0x0000_0000</td><td style="text-align: center"><em>0x4000_0000</em></td></tr>
<tr><td style="text-align: left"><em>DRAM0_S0</em></td><td style="text-align: center">0x4000_0000</td><td style="text-align: center"><em>0x0800_0000</em></td></tr>
<tr><td style="text-align: left"><em>nx_code</em></td><td style="text-align: center">0x4080_0000</td><td style="text-align: center"><em>0x0002_A000</em></td></tr>
<tr><td style="text-align: left"><em>nx_rodata</em></td><td style="text-align: center">0x4082_A000</td><td style="text-align: center"><em>0x0000_6000</em></td></tr>
<tr><td style="text-align: left"><em>nx_data</em></td><td style="text-align: center">0x4083_0000</td><td style="text-align: center"><em>0x0001_3000</em></td></tr>
<tr><td style="text-align: left"><em>nx_pgpool</em></td><td style="text-align: center">0x40A0_0000</td><td style="text-align: center"><em>0x0040_0000</em></td></tr>
</tbody></table>
</div></p>
<p>Though it crashes elsewhere‚Ä¶</p>
<h1 id="arm64-generic-interrupt-controller"><a class="doc-anchor" href="#arm64-generic-interrupt-controller">¬ß</a>10 Arm64 Generic Interrupt Controller</h1>
<p><em>Why is NuttX failing with an Undefined Instruction?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>gic_validate_dist_version: No GIC version detect
arm64_gic_initialize: no distributor detected, giving up ret=-19
...
nx_start_application: Starting init task: /system/bin/init
arm64_el1_undef: Undefined instruction at 0x408276e4, dump:
Assertion failed panic: at file: common/arm64_fatal.c:572</code></pre></div>
<p>Yeah this failure is <a href="https://gist.github.com/lupyuen/3a7d1e791ac14905532db2d768ae230f"><strong>totally misleading</strong></a>. Real Culprit: NuttX couldn‚Äôt <strong>Init the GIC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>No GIC version detect
No distributor detected, giving up</code></pre></div>
<p><em>What‚Äôs this GIC?</em></p>
<p>It‚Äôs the Arm64 <a href="TODO"><strong>Generic Interrupt Controller (GIC)</strong></a>, version 3. GIC shall‚Ä¶</p>
<ul>
<li>
<p>Receive <strong>Input / Output Interrupts</strong></p>
<p><em>(Like keypresses)</em></p>
</li>
<li>
<p>Forward them to a <strong>CPU Core</strong> for processing</p>
<p><em>(Works like RISC-V PLIC)</em></p>
</li>
</ul>
<p>GIC is here‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Module</strong></td><td style="text-align: left"><strong>Base Address</strong></td></tr>
<tr><td style="text-align: center">GIC</td><td style="text-align: left"><em>0x0340_0000</em></td></tr>
</tbody></table>
</div>
<p>Which has these <strong>GIC Registers</strong> inside, handling 8 Arm64 Cores‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: left">Page 263</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Offset</strong></td><td style="text-align: left"><strong>Register</strong></td></tr>
<tr><td style="text-align: center"><em>0x00_0000</em></td><td style="text-align: left">GICD_CTLR  <em>(Distributor Control Register)</em></td></tr>
<tr><td style="text-align: center"><em>0x06_0000</em></td><td style="text-align: left">GICR_CTLR_C0  <em>(Redistributor Control Register, Core 0)</em></td></tr>
<tr><td style="text-align: center"><em>0x08_0000</em></td><td style="text-align: left">GICR_CTLR_C1  <em>(Ditto, Core 1)</em></td></tr>
<tr><td style="text-align: center"><em>0x0A_0000</em></td><td style="text-align: left">GICR_CTLR_C2  <em>(Ditto, Core 2)</em></td></tr>
<tr><td style="text-align: center"><em>0x0C_0000</em></td><td style="text-align: left">GICR_CTLR_C3  <em>(Ditto, Core 3)</em></td></tr>
<tr><td style="text-align: center"><em>0x0E_0000</em></td><td style="text-align: left">GICR_CTLR_C4  <em>(Ditto, Core 4)</em></td></tr>
<tr><td style="text-align: center"><em>0x10_0000</em></td><td style="text-align: left">GICR_CTLR_C5  <em>(Ditto, Core 5)</em></td></tr>
<tr><td style="text-align: center"><em>0x12_0000</em></td><td style="text-align: left">GICR_CTLR_C6  <em>(Ditto, Core 6)</em></td></tr>
<tr><td style="text-align: center"><em>0x14_0000</em></td><td style="text-align: left">GICR_CTLR_C7  <em>(Ditto, Core 7)</em></td></tr>
<tr><td style="text-align: center"><em>0x16_0000</em></td><td style="text-align: left">GICDA_CTLR  <em>(Distributor Control Register A)</em></td></tr>
</tbody></table>
</div>
<p>Based on the above, we set the <strong>Addresses of GICD and GICR</strong> <em>(Distributor / Redistributor)</em>: <a href="https://github.com/lupyuen2/wip-nuttx/commit/f3a26dbba69a0714bc91d0c345b8fba5e0835b76">qemu/chip.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Address of GIC Distributor and Redistributor
#define CONFIG_GICD_BASE   0x3400000
#define CONFIG_GICR_BASE   0x3460000

// Spaced 0x20000 bytes per Arm64 Core
#define CONFIG_GICR_OFFSET 0x20000</code></pre></div>
<p>Remember to <a href="https://github.com/lupyuen2/wip-nuttx/commit/10c7173b142f4a0480d742688c72499b76f66f83"><strong>Disable Memory Manager Logging</strong></a>. NuttX GIC Driver starts correctly and <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>complains no more</strong></a>!</p>
<div class="example-wrap"><pre class="language-bash"><code>## SPI = Physical Interrupt Signal (not the typical SPI)
gic_validate_dist_version:
  GICv3 version detect
  GICD_TYPER = 0x7b0408
  256 SPIs implemented</code></pre></div><h1 id="nuttx-apps-filesystem"><a class="doc-anchor" href="#nuttx-apps-filesystem">¬ß</a>11 NuttX Apps Filesystem</h1>
<p><em>Are we done yet?</em></p>
<p>For a <strong>Simple NuttX Port</strong> <em>(Flat Build)</em>: Congrats, just fix the <a href="TODO"><strong>UART Interrupt</strong></a> and we‚Äôre done!</p>
<p>However we‚Äôre doing <strong>NuttX Kernel Build</strong>. Which <a href="https://gist.github.com/lupyuen/3c587ac0f32be155c8f9a9e4ca18676c"><strong>needs more work</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>nx_start_application:
  Starting init task: /system/bin/init
arm64_el1_undef:
  Undefined instruction at 0x408274a4
Assertion failed panic:
  common/arm64_fatal.c:572</code></pre></div>
<p><em>What‚Äôs /system/bin/init? Why is it failing?</em></p>
<p><em>/system/bin/init</em> is <strong>NSH Shell</strong>. NuttX Kernel Build will load NuttX Apps from a <strong>Local Filesystem</strong>. <em>(Instead of binding binary Apps into Kernel)</em></p>
<p>We bundle the NuttX Apps together into a <strong>ROMFS Filesystem</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Generate the Initial RAM Disk
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;</code></pre></div>
<p>Then we package NuttX Kernel + NuttX Apps into a <strong>NuttX Image</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image</code></pre></div>
<p><a href="TODO">(See the <strong>Build Script</strong>)</a></p>
<p>When NuttX Boots: It will‚Ä¶</p>
<ol>
<li>
<p>Find the <strong>ROMFS Filesystem</strong></p>
</li>
<li>
<p>Mount it as a <strong>RAM Disk</strong></p>
</li>
<li>
<p>Allowing NuttX Kernel to start <strong>NSH Shell</strong></p>
<p><em>(And other NuttX Apps)</em></p>
</li>
</ol>
<p>Everything is explained here‚Ä¶</p>
<ul>
<li>TODO: Appendix</li>
</ul>
<p>NSH Prompt still missing? It won‚Äôt appear until we handle the UART Interrupt‚Ä¶</p>
<h1 id="fix-the-uart-interrupt"><a class="doc-anchor" href="#fix-the-uart-interrupt">¬ß</a>12 Fix the UART Interrupt</h1>
<p>One Last Thing: Settle the <strong>UART Interrupt</strong> and we‚Äôre done!</p>
<p>
<div style="border: 2px solid #a0a0a0; max-width: fit-content;">
<div><table><thead><tr><th style="text-align: center"><a href="https://linux-sunxi.org/File:A523_User_Manual_V1.1_merged_cleaned.pdf">A523 User Manual</a></th><th style="text-align: center">Page 256</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Interrupt Number</strong></td><td style="text-align: center"><strong>Interrupt Source</strong></td></tr>
<tr><td style="text-align: center">34</td><td style="text-align: center">UART0</td></tr>
</tbody></table>
</div></div>
</p>
<p>This is how we set the <strong>UART0 Interrupt</strong> and watch for keypresses: <a href="https://github.com/lupyuen2/wip-nuttx/commit/cd6da8f5378eb493528e57c61f887b6585ab8eaf#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the UART0 Interrupt to 34
CONFIG_16550_UART0_IRQ=34</code></pre></div>
<p>To Wrap Up: We Disable Logging for <a href="https://github.com/lupyuen2/wip-nuttx/commit/6c5c1a5f9fb1c939d8e75a5e9544b1a5261165ee"><strong>Memory Manager and Scheduler</strong></a>. And <a href="https://github.com/lupyuen2/wip-nuttx/commit/e5c1b0449d3764d63d447eb96eb7186a27f77c88"><strong>Disable MMU Debugging</strong></a>.</p>
<p><strong>NSH Prompt</strong> finally appears. And <strong>OSTest completes successfully</strong> yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>TODO</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6">(See the <strong>Complete Log</strong>)</a></p>
<p>Here are the Modified Source Files for <strong>NuttX on Avatoa-A1 SBC</strong>‚Ä¶</p>
<ul>
<li>TODO</li>
</ul>
<p><em>NSH Prompt won‚Äôt appear if UART Interrupt is disabled?</em></p>
<p>That‚Äôs because NSH runs as a <strong>NuttX App in User Space</strong>. When NSH Shell prints this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt;</code></pre></div>
<p>It calls the <strong>Serial Driver</strong>. Which will wait for a <strong>UART Interrupt</strong> to signal that the <strong>Transmit Buffer</strong> is empty and available.</p>
<p>Thus if UART Interrupt is disabled, nothing gets printed in NuttX Apps. <a href="TODO">(Explained here)</a></p>
<p>TODO: Pic of T527 Cutie</p>
<p><a href="TODO"><em>NuttX might run OK on T527 Cutie</em></a></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>13 What‚Äôs Next</h1>
<p>We‚Äôre seeking volunteers to build <strong>NuttX Drivers for Avaota-A1</strong> <em>(GPIO, SPI, I2C, MIPI CSI / DSI, Ethernet, WiFi, ‚Ä¶)</em> Please lemme know!</p>
<p>Special Thanks to <a href="https://lupyuen.org/articles/sponsor"><strong>My Sponsors</strong></a> for supporting my writing. Your support means so much to me üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.org/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="TODO"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-starpro64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for StarPro64 EIC7700X‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-sg2000"><strong>My Other Project: ‚ÄúNuttX for Oz64 SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/nuttx-ox64"><strong>Older Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://nuttx-forge.org/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.org/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/avaota.md"><strong>lupyuen.org/src/avaota.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-avaota-a1"><a class="doc-anchor" href="#appendix-build-nuttx-for-avaota-a1">¬ß</a>14 Appendix: Build NuttX for Avaota-A1</h1>
<p>Follow these steps to compile our <em>(Work-In-Progress)</em> <strong>NuttX for Avaota-A1</strong>: <a href="https://gist.github.com/lupyuen/a4ac110fb8610a976c0ce2621cbb8587">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download Source Code for NuttX and Apps
git clone https://github.com/lupyuen2/wip-nuttx nuttx --branch avaota
git clone https://github.com/lupyuen2/wip-nuttx-apps apps --branch avaota
cd nuttx

## Build NuttX and Apps (NuttX Kernel Build)
tools/configure.sh qemu-armv8a:knsh
make -j
make -j export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j import
popd

## Generate the Initial RAM Disk
## Prepare a Padding with 64 KB of zeroes
## Append Padding and Initial RAM Disk to the NuttX Kernel
genromfs -f initrd -d ../apps/bin -V &quot;NuttXBootVol&quot;
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image</code></pre></div>
<p>Read on to boot the NuttX Image on our SBC‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/6c0607daa0a8f37bda37cc80e76259ee">(See the <strong>Build Log</strong>)</a></p>
<h1 id="appendix-boot-nuttx-on-avaota-a1"><a class="doc-anchor" href="#appendix-boot-nuttx-on-avaota-a1">¬ß</a>15 Appendix: Boot NuttX on Avaota-A1</h1>
<p>Earlier we built <a href="TODO"><strong>NuttX for Avaota-A1</strong></a> and created the <strong><code>Image</code></strong> file, containing the NuttX Kernel + NuttX Apps. Let‚Äôs boot it on MicroSD‚Ä¶</p>
<ol>
<li>
<p>Prepare the <strong>AvaotaOS MicrosSD</strong>‚Ä¶</p>
<p>TODO</p>
</li>
<li>
<p>Copy the <strong>NuttX Image</strong> to MicroSD‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to AvaotaOS MicroSD
## Overwrite the `Image` file
## Boot it on Avaota-A1
mv /TODO/Image /TODO/Image.old
cp Image /TODO/Image
ls -l /TODO/Image
umount /TODO</code></pre></div></li>
<li>
<p><strong>Boot the MicroSD</strong> on our SBC</p>
</li>
</ol>
<p>We can automate the last two steps with a <a href="TODO"><strong>MicroSD Multiplexer</strong></a> and <a href="TODO"><strong>Smart Power Plug</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Get the Home Assistant Token
## That we copied from http://localhost:8123/profile/security
## export token=xxxx
. $HOME/home-assistant-token.sh

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Copy NuttX Image to MicroSD
## No password needed for sudo, see below
## Change `thinkcentre` to your Test PC
scp Image thinkcentre:/tmp/Image
ssh thinkcentre ls -l /tmp/Image
ssh thinkcentre sudo /home/user/copy-image.sh

## Power On the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_on&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger

## Wait for SBC to finish testing
echo Press Enter to Power Off
read

## Power Off the SBC
curl \
  -X POST \
  -H &quot;Authorization: Bearer $token&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;entity_id&quot;: &quot;automation.avaota_power_off&quot;}&#39; \
  http://localhost:8123/api/services/automation/trigger</code></pre></div>
<p><a href="https://youtu.be/PxaMcmMAzlM">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="TODO">(<strong>copy-image.sh</strong> is explained here)</a></p>
<p><a href="TODO">(<strong>Smart Power Plug</strong> also)</a></p>
<p>NuttX boots to NSH Shell. And passes OSTest yay!</p>
<span style="font-size:60%">
<div class="example-wrap"><pre class="language-text"><code>NOTICE:  BL31: v2.5(debug):9241004a9
NOTICE:  BL31: Built : 13:37:46, Nov 16 2023
NOTICE:  BL31: No DTB found.
NOTICE:  [SCP] :wait arisc ready....
NOTICE:  [SCP] :arisc version: []
NOTICE:  [SCP] :arisc startup ready
NOTICE:  [SCP] :arisc startup notify message feedback
NOTICE:  [SCP] :sunxi-arisc driver is starting
ERROR:   Error initializing runtime service opteed_fast
123
- Ready to Boot Primary CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize
ABarm64_mmu_init:
setup_page_tables:
enable_mmu_el1:
enable_mmu_el1: UP_MB
enable_mmu_el1: Enable the MMU and data cache
up_allocate_kheap: CONFIG_RAM_END=0x48000000, g_idle_topstack=0x40847000
qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
board_app_initialize:

NuttShell (NSH) NuttX-12.4.0
nsh&gt; uname -a
NuttX 12.4.0 6c5c1a5f9f-dirty Mar  8 2025 21:57:02 arm64 qemu-armv8a

nsh&gt; free
      total       used       free    maxused    maxfree  nused  nfree name
  125538304      33848  125504456      52992  125484976     58      5 Kmem
    4194304     245760    3948544               3948544               Page

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK            STACK    USED FILLED COMMAND
    0     0   0 FIFO     Kthread   - Ready              0000000000000000 0008176 0000928  11.3%  Idle_Task
    1     0 192 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  hpwork 0x40834568 0x408345b8
    2     0 100 RR       Kthread   - Waiting  Semaphore 0000000000000000 0008112 0000992  12.2%  lpwork 0x408344e8 0x40834538
    4     4 100 RR       Task      - Running            0000000000000000 0008128 0002192  26.9%  /system/bin/init

nsh&gt; ls -l /dev
/dev:
 crw-rw-rw-           0 console
 crw-rw-rw-           0 null
 brw-rw-rw-    16777216 ram0
 crw-rw-rw-           0 ttyS0
 crw-rw-rw-           0 zero

nsh&gt; hello
Hello, World!!

nsh&gt; getprime
Set thread priority to 10
Set thread policy to SCHED_RR
Start thread #0
thread #0 started, looking for primes &lt; 10000, doing 10 run(s)
thread #0 finished, found 1230 primes, last one was 9973
Done
getprime took 162 msec

nsh&gt; ostest
...
Final memory usage:
VARIABLE  BEFORE   AFTER
======== ======== ========
arena        a000    26000
ordblks         2        4
mxordblk     6ff8    1aff8
uordblks     27e8     6700
fordblks     7818    1f900
user_main: Exiting
ostest_main: Exiting with status 0
nsh&gt;</code></pre></div></span>
<p><a href="https://gist.github.com/lupyuen/c2248e7537ca98333d47e33b232217b6">(See the <strong>NuttX Log</strong>)</a></p>
<h1 id="appendix-sdwire-microsd-multiplexer"><a class="doc-anchor" href="#appendix-sdwire-microsd-multiplexer">¬ß</a>16 Appendix: SDWire MicroSD Multiplexer</h1>
<p>Let‚Äôs make our Tweak-Build-Test Cycle quicker for NuttX. We use <strong>SDWire MicroSD Multiplexer</strong> to flip our MicroSD between <strong>Test PC and SBC</strong>‚Ä¶</p>
<ul>
<li>TODO</li>
</ul>
<p>SDWire needs <a href="TODO"><strong>Plenty of Sudo Passwords</strong></a> to flip the multiplexer, mount the filesystem, copy to MicroSD. Let‚Äôs make it Sudo Password-Less with <a href="https://help.ubuntu.com/community/Sudoers"><strong>visudo</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Wrap all the <strong>Sudo Commands</strong> into a script: <a href="https://gist.github.com/lupyuen/5000c86cbdda0d5e564f244d1d87076a">copy-image.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Create a Bash Script: copy-image.sh
## Containing these commands...

set -e  ## Exit when any command fails
set -x  ## Echo commands
whoami  ## I am root!

## Copy /tmp/Image to MicroSD
sd-mux-ctrl --device-serial=sd-wire_02-09 --ts
sleep 5
mkdir -p /tmp/sda1
mount /dev/sda1 /tmp/sda1
cp /tmp/Image /tmp/sda1/
ls -l /tmp/sda1

## Unmount MicroSD and flip it to the Test Device (PinePhone)
umount /tmp/sda1
sd-mux-ctrl --device-serial=sd-wire_02-09 --dut</code></pre></div></li>
<li>
<p>Configure <strong>visudo</strong> so that our script will run as <strong>Sudo Without Password</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Make our script executable
## Start the Sudoers Editor
chmod +x /home/user/copy-image.sh
sudo visudo

## Add this line:
user ALL=(ALL) NOPASSWD: /home/user/copy-image.sh</code></pre></div></li>
<li>
<p>Then we can trigger our script remotely via SSH, <strong>Without Sudo Password</strong>: <a href="TODO">run.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Image to MicroSD
## No password needed for sudo yay!
scp Image thinkcentre:/tmp/Image
ssh thinkcentre \
  ls -l /tmp/Image
ssh thinkcentre \
  sudo /home/user/copy-image.sh</code></pre></div></li>
<li>
<p>Everything goes into our <a href="TODO"><strong>Build Script for NuttX</strong></a></p>
</li>
</ol>
<h1 id="appendix-nuttx-apps-filesystem"><a class="doc-anchor" href="#appendix-nuttx-apps-filesystem">¬ß</a>17 Appendix: NuttX Apps Filesystem</h1>
<p>Earlier we talked about the NuttX Apps Filesystem‚Ä¶</p>
<ul>
<li>TODO</li>
</ul>
<p>This section explains how we implemented the NuttX Apps Filesystem‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files"><strong>Modified Files</strong> for NuttX Apps Filesystem</a></li>
</ul>
<p>After this implementation, <em>/system/bin/init</em> (NSH Shell) shall <a href="https://gist.github.com/lupyuen/ccb645efa72f6793743c033fade0b3ac"><strong>start successfully</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>qemu_bringup:
mount_ramdisk:
nx_start_application: ret=0
nx_start_application: Starting init task: /system/bin/init
nxtask_activate: /system/bin/init pid=4,TCB=0x408469f0
nxtask_exit: AppBringUp pid=3,TCB=0x40846190
board_app_initialize:
nx_start: CPU0: Beginning Idle Loop</code></pre></div><h2 id="hostfs-becomes-romfs"><a class="doc-anchor" href="#hostfs-becomes-romfs">¬ß</a>17.1 HostFS becomes ROMFS</h2>
<p>QEMU uses <a href="TODO"><strong>Semihosting and HostFS</strong></a> to access the NuttX Apps Filesystem. We change to <strong>ROMFS</strong>‚Ä¶ <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-6adf2d1a1e5d57ee68c7493a2b52c07c4e260e60d846a9ee7b8f8a6df5d8cb64">configs/knsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## We added ROMFS...
CONFIG_BOARDCTL_ROMDISK=y
CONFIG_BOARD_LATE_INITIALIZE=y
CONFIG_INIT_MOUNT_TARGET=&quot;/system/bin&quot;

## And removed Semihosting HostFS...
## CONFIG_FS_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS=y
## CONFIG_ARM64_SEMIHOSTING_HOSTFS_CACHE_COHERENCE=y
## CONFIG_INIT_MOUNT_DATA=&quot;fs=../apps&quot;
## CONFIG_INIT_MOUNT_FSTYPE=&quot;hostfs&quot;
## CONFIG_INIT_MOUNT_SOURCE=&quot;&quot;
## CONFIG_INIT_MOUNT_TARGET=&quot;/system&quot;</code></pre></div>
<p><em>BOARD_LATE_INITIALIZE</em> is needed because we‚Äôll <strong>Mount the ROMFS Filesystem</strong> inside <em>qemu_bringup()</em>. (See below)</p>
<h2 id="linker-script"><a class="doc-anchor" href="#linker-script">¬ß</a>17.2 Linker Script</h2>
<p>We reserve <strong>16 MB of RAM</strong> for the ROMFS Filesystem that will host the NuttX Apps: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f0706cd747d2f1be1eeb64d50821afb1e25d5bb26e964e2679268a83dcff0afc">ld-kernel.script</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* Linker Script: We added the RAM Disk (16 MB) */
MEMORY {
  dram (rwx)    : ORIGIN = 0x40800000, LENGTH = 2M
  pgram (rwx)   : ORIGIN = 0x40A00000, LENGTH = 4M    /* w/ cache */
  ramdisk (rwx) : ORIGIN = 0x40E00000, LENGTH = 16M   /* w/ cache */
}

/* We&#39;ll reference these in our code */
__ramdisk_start = ORIGIN(ramdisk);
__ramdisk_size  = LENGTH(ramdisk);
__ramdisk_end   = ORIGIN(ramdisk) + LENGTH(ramdisk);</code></pre></div><h2 id="mount-the-romfs"><a class="doc-anchor" href="#mount-the-romfs">¬ß</a>17.3 Mount the ROMFS</h2>
<p><strong>At Startup:</strong> We mount the <strong>ROMFS Filesystem</strong> <em>(inside RAM)</em> as <em>/dev/ram0</em>: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-f8d388b76b0b37563184a5a174f18970ff6771d6a048e0e792967ab265d6f7eb">qemu_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At NuttX Startup...
int qemu_bringup(void) {
  // We Mount the RAM Disk
  mount_ramdisk();
  ...
}

// Mount a RAM Disk defined in ld.script to /dev/ramX.  The RAM Disk
// contains a ROMFS filesystem with applications that can be spawned at
// runtime.
static int mount_ramdisk(void) {
  struct boardioc_romdisk_s desc;
  desc.minor    = RAMDISK_DEVICE_MINOR;
  desc.nsectors = NSECTORS((ssize_t)__ramdisk_size);
  desc.sectsize = SECTORSIZE;
  desc.image    = __ramdisk_start;

  int ret = boardctl(BOARDIOC_ROMDISK, (uintptr_t)&amp;desc);
  if (ret &lt; 0) {
    syslog(LOG_ERR, &quot;Ramdisk register failed: %s\n&quot;, strerror(errno));
    syslog(LOG_ERR, &quot;Ramdisk mountpoint /dev/ram%d\n&quot;,RAMDISK_DEVICE_MINOR);
    syslog(LOG_ERR, &quot;Ramdisk length %lu, origin %lx\n&quot;, (ssize_t)__ramdisk_size, (uintptr_t)__ramdisk_start);
  }
  return ret;
}

// RAM Disk Definition
#define SECTORSIZE   512
#define NSECTORS(b)  (((b) + SECTORSIZE - 1) / SECTORSIZE)
#define RAMDISK_DEVICE_MINOR 0</code></pre></div><h2 id="copy-the-romfs"><a class="doc-anchor" href="#copy-the-romfs">¬ß</a>17.4 Copy the ROMFS</h2>
<p><strong>But Before That:</strong> We safely copy the <strong>ROMFS Filesystem</strong> from the NuttX Image into the <strong><code>ramdisk</code> Memory Region</strong>. This happens just after Bootloader starts NuttX: <a href="https://github.com/lupyuen2/wip-nuttx/pull/97/files#diff-be208bc5be54608eca3885cf169183ede375400c559700bb423c81d7b2787431">qemu_boot.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Just after Bootloader has started NuttX...
void arm64_chip_boot(void) {

  // We copy the RAM Disk
  qemu_copy_ramdisk();

  // Omitted: Other initialisation (MMU, ...)
  arm64_mmu_init(true);
  ...
}

// Copy the RAM Disk from NuttX Image to RAM Disk Region.
static void qemu_copy_ramdisk(void) {
  char header[8] __attribute__((aligned(8))) = &quot;-rom1fs-&quot;;
  const uint8_t *limit = (uint8_t *)g_idle_topstack + (256 * 1024);
  uint8_t *ramdisk_addr = NULL;
  uint8_t *addr;
  uint32_t size;

  // After _edata, search for &quot;-rom1fs-&quot;. This is the RAM Disk Address.
  // Limit search to 256 KB after Idle Stack Top.
  for (addr = g_idle_topstack; addr &lt; limit; addr += 8) {
      if (memcmp(addr, header, sizeof(header)) == 0) {
        ramdisk_addr = addr;
        break;
      }
  }

  // Stop if RAM Disk is missing
  if (ramdisk_addr == NULL) {
    _err(&quot;Missing RAM Disk. Check the initrd padding.&quot;);
    PANIC();
  }

  // Read the Filesystem Size from the next 4 bytes (Big Endian)
  size = (ramdisk_addr[8] &lt;&lt; 24) + (ramdisk_addr[9] &lt;&lt; 16) +
         (ramdisk_addr[10] &lt;&lt; 8) + ramdisk_addr[11] + 0x1f0;

  // Filesystem Size must be less than RAM Disk Memory Region
  if (size &gt; (size_t)__ramdisk_size) {
    _err(&quot;RAM Disk Region too small. Increase by %ul bytes.\n&quot;, size - (size_t)__ramdisk_size);
    PANIC();
  }

  // Copy the RAM Disk from NuttX Image to RAM Disk Region.
  // __ramdisk_start overlaps with ramdisk_addr + size.
  qemu_copy_overlap(__ramdisk_start, ramdisk_addr, size);
}

// Copy an overlapping memory region.  dest overlaps with src + count.
static void qemu_copy_overlap(uint8_t *dest, const uint8_t *src, size_t count) {
  uint8_t *d = dest + count - 1;
  const uint8_t *s = src + count - 1;
  if (dest &lt;= src) { _err(&quot;dest and src should overlap&quot;); PANIC(); }
  while (count--) {
    volatile uint8_t c = *s;  // Prevent compiler optimization
    *d = c;
    d--;
    s--;
  }
} 

// Defined in Linker Script
extern uint8_t __ramdisk_start[];
extern uint8_t __ramdisk_size[];</code></pre></div>
<p><em>Why the aligned addresses?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Header is aligned to 8 bytes
char header[8]
  __attribute__((aligned(8))) =
  &quot;-rom1fs-&quot;;

// Address is aligned to 8 bytes
for (
  addr = g_idle_topstack;
  addr &lt; limit;
  addr += 8
) {
  // Otherwise this will hit Alignment Fault
  memcmp(addr, header, sizeof(header));
  ...
}</code></pre></div>
<p>We align our Memory Accesses to <strong>8 Bytes</strong>. Otherwise we‚Äôll hit an <a href="https://gist.github.com/lupyuen/f10af7903461f44689203d0e02fb9949"><strong>Alignment Fault</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Alignment Fault at `memcmp(addr, header, sizeof(header))`
default_fatal_handler:
  (IFSC/DFSC) for Data/Instruction aborts:
  alignment fault</code></pre></div>
<p><a href="TODO"><em>(Strangely: This Alignment isn‚Äôt needed for RISC-V)</em></a></p>
<h1 id="appendix-port-nuttx-to-avaota-a1"><a class="doc-anchor" href="#appendix-port-nuttx-to-avaota-a1">¬ß</a>18 Appendix: Port NuttX to Avaota-A1</h1>
<p>In this article, we took NuttX for <strong>Arm64 QEMU knsh (Kernel Build)</strong> and tweaked it for Avaota-A1 SBC. This section explains the modified code‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/pull/98/files"><strong>Modified Files</strong> for Avaota-A1</a></li>
</ul>
<p>TODO</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>