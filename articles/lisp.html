<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>uLisp and Blockly on PineCone BL602 RISC-V Board</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="uLisp and Blockly on PineCone BL602 RISC-V Board" 
    data-rh="true">
<meta property="og:description" 
    content="Porting the uLisp Interpreter to PineCone BL602 RISC-V Board... And writing graphical programs with Blockly (Scratch)"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lisp-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">uLisp and Blockly on PineCone BL602 RISC-V Board</h1>
    <nav id="TOC"><ul>
<li><a href="#start-with-ulisp">1 Start with uLisp</a><ul></ul></li>
<li><a href="#build-the-bl602-ulisp-firmware">2 Build the BL602 uLisp Firmware</a><ul>
<li><a href="#flash-the-firmware">2.1 Flash the firmware</a><ul></ul></li></ul></li>
<li><a href="#run-the-bl602-ulisp-firmware">3 Run the BL602 uLisp Firmware</a><ul>
<li><a href="#enter-ulisp-commands">3.1 Enter uLisp commands</a><ul></ul></li>
<li><a href="#flip-the-led">3.2 Flip the LED</a><ul></ul></li>
<li><a href="#blinky-function">3.3 Blinky Function</a><ul></ul></li></ul></li>
<li><a href="#now-add-blockly">4 Now add Blockly</a><ul></ul></li>
<li><a href="#run-the-blockly-web-editor">5 Run the Blockly Web Editor</a><ul>
<li><a href="#flip-the-led-1">5.1 Flip the LED</a><ul></ul></li>
<li><a href="#blinky">5.2 Blinky</a><ul></ul></li></ul></li>
<li><a href="#web-browser-controls-bl602-with-web-serial-api">6 Web Browser controls BL602 with Web Serial API</a><ul>
<li><a href="#sending-a-command-to-bl602">6.1 Sending a command to BL602</a><ul></ul></li>
<li><a href="#calling-the-web-serial-api">6.2 Calling the Web Serial API</a><ul></ul></li></ul></li>
<li><a href="#porting-ulisp-to-bl602">7 Porting uLisp to BL602</a><ul>
<li><a href="#missing-ulisp-features">7.1 Missing uLisp Features</a><ul></ul></li></ul></li>
<li><a href="#customise-blockly-for-ulisp">8 Customise Blockly for uLisp</a><ul></ul></li>
<li><a href="#code-generator-for-ulisp">9 Code Generator for uLisp</a><ul>
<li><a href="#missing-code-generators">9.1 Missing Code Generators</a><ul></ul></li></ul></li>
<li><a href="#simulate-bl602-with-ulisp-webassembly">10 Simulate BL602 with uLisp WebAssembly</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li></ul></nav><p>üìù <em>14 May 2021</em></p>
<p>What if we could run <strong>Lisp programs</strong> on the <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a>?</p>
<pre><code class="language-text">( loop
  ( pinmode 11 :output )
  ( digitalwrite 11 :high )
  ( delay 1000 )
  ( pinmode 11 :output )
  ( digitalwrite 11 :low )
  ( delay 1000 )
)
</code></pre>
<p>And create the programs with a <strong>drag-and-drop Web Editor</strong>‚Ä¶ Without typing a single Lisp parenthesis / bracket?</p>
<p><img src="https://lupyuen.github.io/images/lisp-web.png" alt="Blockly for uLisp" /></p>
<p>Today we shall explore <strong>uLisp and Blockly</strong> as an interesting new way to create embedded programs for the <strong>BL602 RISC-V + WiFi SoC</strong>.</p>
<p>(And someday this could become really helpful for <strong>IoT Education</strong>)</p>
<p>The uLisp Firmware in this article will run on <strong>PineCone, Pinenut and Any BL602 Board</strong>.</p>
<ul>
<li><a href="https://youtu.be/LNkmUIv7ZZc"><strong>Watch the demo on YouTube</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lisp-cover.jpg" alt="uLisp and Blockly on PineCone BL602 RISC-V Board" /></p>
<p><em>uLisp and Blockly on PineCone BL602 RISC-V Board</em></p>
<h1 id="start-with-ulisp" class="section-header"><a href="#start-with-ulisp">1 Start with uLisp</a></h1>
<p><em>What is uLisp?</em></p>
<p>From the <a href="http://www.ulisp.com">uLisp Website</a>‚Ä¶</p>
<blockquote>
<p>uLisp¬Æ is a version of the Lisp programming language specifically designed to run on <strong>microcontrollers with a limited amount of RAM</strong>, from the Arduino Uno based on the ATmega328 up to the Teensy 4.0/4.1. You can use exactly the same uLisp program, irrespective of the platform.</p>
</blockquote>
<blockquote>
<p>Because <strong>uLisp is an interpreter</strong> you can type commands in, and see the effect immediately, without having to compile and upload your program. This makes it an ideal environment for <strong>learning to program</strong>, or for setting up simple electronic devices.</p>
</blockquote>
<p><em>Why is uLisp special?</em></p>
<p>Compared with other embedded programming languages, uLisp looks particularly interesting because it has <strong>built-in Arduino-like functions</strong> for GPIO, I2C, SPI, ADC, DAC, ‚Ä¶ Even WiFi!</p>
<p>So this Blinky program runs perfectly fine on uLisp‚Ä¶</p>
<pre><code class="language-text">( loop
  ( pinmode 11 :output )
  ( digitalwrite 11 :high )
  ( delay 1000 )
  ( pinmode 11 :output )
  ( digitalwrite 11 :low )
  ( delay 1000 )
)
</code></pre>
<p>Because <code>pinmode</code> (set the GPIO pin mode) and <code>digitalwrite</code> (set the GPIO pin output) are Arduino-like GPIO functions predefined in uLisp.</p>
<p>(<code>delay</code> is another Arduino-like Timer function predefined in uLisp. It waits for the specified number of milliseconds.)</p>
<p>uLisp makes it possible to write <strong>high-level scripts</strong> with GPIO, I2C, SPI, ADC, DAC and WiFi functions.</p>
<p>And for learners familiar with Arduino, this might be a helpful way to <strong>adapt to modern microcontrollers</strong> like BL602.</p>
<p><em>Why port uLisp to BL602?</em></p>
<p>uLisp is a natural fit for the BL602 RISC-V + WiFi SoC because‚Ä¶</p>
<ol>
<li>
<p>BL602 has a <strong>Command-Line Interface</strong> (and so does uLisp)</p>
<p>Unlike most 32-bit microcontrollers, BL602 was designed to be accessed by embedded developers via a simple Command-Line Interface (over the USB Serial Port).</p>
<p>BL602 doesn‚Äôt have a fancy shell like <code>bash</code>. But uLisp on BL602 could offer some helpful <strong>scripting capability</strong>  for GPIO, I2C, SPI, WiFi, ‚Ä¶</p>
</li>
<li>
<p>uLisp already works on <strong>ESP32</strong> <a href="https://github.com/technoblogy/ulisp-esp">(See this)</a></p>
<p>Since BL602 is a WiFi + Bluetooth LE SoC like ESP32, it might be easy to port the ESP32 version of uLisp to BL602. Including the WiFi functions.</p>
</li>
</ol>
<p><em>I‚Äôm new to Lisp‚Ä¶ Too many brackets, no?</em></p>
<p>In a while we‚Äôll talk about <strong>Blockly for uLisp</strong>‚Ä¶ Drag-and-drop a uLisp program, without typing a single bracket / parenthesis!</p>
<p>(Works just like Scratch, the graphical programming tool)</p>
<p>And we may even upload and run a uLisp program on BL602 through a <strong>Web Browser</strong>‚Ä¶ Thanks to the <strong>Web Serial API</strong>!</p>
<p><em>Porting uLisp from ESP32 to BL602 sounds difficult?</em></p>
<p>Not at all! <a href="https://github.com/technoblogy/ulisp-esp">uLisp for ESP32</a> lives in a single C source file: <a href="https://github.com/technoblogy/ulisp-esp/blob/master/ulisp-esp.ino"><code>ulisp-esp.ino</code></a> ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-source.jpg" alt="uLisp for ESP32" /></p>
<p>(With a few Arduino bits in C++)</p>
<p>Porting uLisp to BL602 (as a C library <a href="https://github.com/lupyuen/ulisp-bl602"><code>ulisp-bl602</code></a>) was quick and easy.</p>
<p>(More about this in a while.)</p>
<p><em>What about porting the Arduino functions like <code>pinmode</code> and <code>digitalwrite</code>?</em></p>
<p>The <a href="https://github.com/lupyuen/bl_iot_sdk/tree/ulisp"><strong>BL602 IoT SDK</strong></a> doesn‚Äôt have these GPIO functions. </p>
<p>So in BL602 uLisp we reimplemented these functions with the <strong>BL602 Hardware Abstraction Layer for GPIO</strong>.</p>
<p>(While exposing the same old names to uLisp programs: <code>pinmode</code> and <code>digitalwrite</code>)</p>
<p><em>Anything else we should know about uLisp?</em></p>
<p>uLisp is still <a href="https://github.com/technoblogy?tab=repositories">actively maintained</a>. It has an <a href="http://forum.ulisp.com/">active online community</a>.</p>
<p><em>It‚Äôs 2021‚Ä¶ Why are we still learning Lisp?</em></p>
<p>Lisp is <strong>Not Dead Yet</strong>! (Apologies to Monty Python)</p>
<p>We still see bits of Lisp today in <strong>WebAssembly</strong>‚Ä¶ Like the <strong>Stack Machine and S-Expressions</strong>. <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format">(See this)</a></p>
<p>In fact the uLisp Interpreter looks a little like <strong>Wasm3</strong>, the WebAssembly Interpreter for Microcontrollers. <a href="https://github.com/wasm3/wasm3">(See this)</a></p>
<h1 id="build-the-bl602-ulisp-firmware" class="section-header"><a href="#build-the-bl602-ulisp-firmware">2 Build the BL602 uLisp Firmware</a></h1>
<p>Download and build the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/ulisp/customer_app/sdk_app_ulisp">uLisp Firmware for BL602</a>‚Ä¶</p>
<pre><code class="language-bash"># Download the ulisp branch of lupyuen's bl_iot_sdk
git clone --recursive --branch ulisp https://github.com/lupyuen/bl_iot_sdk

# TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602

# Build the sdk_app_ulisp firmware
cd bl_iot_sdk/customer_app/sdk_app_ulisp
make

# TODO: Change ~/blflash to the full path of blflash
cp build_out/sdk_app_ulisp.bin ~/blflash
</code></pre>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<p>(Remember to use the <strong><code>ulisp</code></strong> branch, not the default <strong><code>master</code></strong> branch)</p>
<h2 id="flash-the-firmware" class="section-header"><a href="#flash-the-firmware">2.1 Flash the firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>sdk_app_ulisp.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>sdk_app_ulisp.bin</code> to BL602 over UART‚Ä¶</p>
<pre><code class="language-bash"># TODO: Change ~/blflash to the full path of blflash
cd ~/blflash

# For Linux:
sudo cargo run flash sdk_app_ulisp.bin \
    --port /dev/ttyUSB0

# For macOS:
cargo run flash sdk_app_ulisp.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

# For Windows: Change COM5 to the BL602 Serial Port
cargo run flash sdk_app_ulisp.bin --port COM5
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h1 id="run-the-bl602-ulisp-firmware" class="section-header"><a href="#run-the-bl602-ulisp-firmware">3 Run the BL602 uLisp Firmware</a></h1>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<pre><code class="language-bash">sudo screen /dev/ttyUSB0 2000000
</code></pre>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
<h2 id="enter-ulisp-commands" class="section-header"><a href="#enter-ulisp-commands">3.1 Enter uLisp commands</a></h2>
<p>Let‚Äôs enter some uLisp commands and test the <strong>BL602 uLisp Interpreter</strong>!</p>
<p><strong>Please Note:</strong> For each uLisp command line we <strong>insert a space ‚Äú ‚Äú after the first bracket ‚Äú<code>(</code>‚Äù</strong>.</p>
<p>That‚Äôs because we programmed the BL602 Command Line to recognise ‚Äú<code>(</code>‚Äù as a <strong>Command Keyword</strong> that will call the uLisp Interpreter.</p>
<ol>
<li>
<p>Enter this to create a <strong>list of numbers</strong>‚Ä¶</p>
<pre><code class="language-text">( list 1 2 3 )
</code></pre>
<p>This returns <strong><code>(1 2 3)</code></strong></p>
</li>
<li>
<p>In Lisp, to <strong><code>car</code></strong> a list is to take the <strong>head of the list</strong>‚Ä¶</p>
<pre><code class="language-text">( car ( list 1 2 3 ) )
</code></pre>
<p>This returns <strong><code>1</code></strong></p>
<p>(It‚Äôs like deshelling a prawn)</p>
</li>
<li>
<p>And to <strong><code>cdr</code></strong> a list is to take the <strong>tail of the list</strong>‚Ä¶</p>
<pre><code class="language-text">( cdr ( list 1 2 3 ) )
</code></pre>
<p>This returns <strong><code>(2 3)</code></strong></p>
<p><a href="https://sumikko-gurashi.fandom.com/wiki/Ebifurai_No_Shippo">(Everything except the head‚Ä¶ like Ebifurai No Shippo)</a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-interpreter.png" alt="uLisp Interpreter" /></p>
<p><a href="http://www.ulisp.com/show?1AC5">(Based on the List Commands from uLisp)</a></p>
<h2 id="flip-the-led" class="section-header"><a href="#flip-the-led">3.2 Flip the LED</a></h2>
<p>Now let‚Äôs <strong>flip the BL602 LED on and off</strong>!</p>
<p>On PineCone BL602 the Blue LED is connected to <strong>GPIO Pin 11</strong>.</p>
<p>(If you‚Äôre using a different BL602 board, please change the GPIO Pin Number accordingly)</p>
<ol>
<li>
<p>We configure <strong>GPIO Pin 11 (Blue LED) for output</strong> (instead of input)‚Ä¶</p>
<pre><code class="language-text">( pinmode 11 :output )
</code></pre>
</li>
<li>
<p>Set <strong>GPIO Pin 11 to High</strong>‚Ä¶</p>
<pre><code class="language-text">( digitalwrite 11 :high )
</code></pre>
<p>The Blue LED switches off.</p>
</li>
<li>
<p>Set <strong>GPIO Pin 11 to Low</strong>‚Ä¶</p>
<pre><code class="language-text">( digitalwrite 11 :low )
</code></pre>
<p>The Blue LED switches on.</p>
</li>
<li>
<p>And we <strong>sleep 1,000 milliseconds</strong> (1 second)‚Ä¶</p>
<pre><code class="language-text">( delay 1000 )
</code></pre>
<p><a href="https://youtu.be/9oLheWjzPcA"><strong>Watch the demo on YouTube</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-led.png" alt="Flip the LED with uLisp" /></p>
<p><a href="http://www.ulisp.com/show?1AEK">(Based on the GPIO Commands from uLisp)</a></p>
<h2 id="blinky-function" class="section-header"><a href="#blinky-function">3.3 Blinky Function</a></h2>
<p>Now the show gets exciting: With uLisp we can define <strong>functions and loops</strong> at the command line‚Ä¶ Just like <code>bash</code>!</p>
<pre><code class="language-text">( defun blinky ()             \
  ( pinmode 11 :output )      \
  ( loop                      \
   ( digitalwrite 11 :high )  \
   ( delay 1000 )             \
   ( digitalwrite 11 :low  )  \
   ( delay 1000 )))
</code></pre>
<p>Here‚Äôs what it means‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-blinky.png" alt="Blinky Function" /></p>
<p>Enter the lines above into the BL602 command line. Note that‚Ä¶</p>
<ol>
<li>
<p>Each line <strong>starts with a bracket ‚Äú<code>(</code>‚Äù followed by a space ‚Äú ‚Äú</strong></p>
<p>(Because ‚Äú<code>(</code>‚Äù is a Command Keyword that will select the uLisp Interpreter)</p>
</li>
<li>
<p>Each line (except the last line) <strong>ends with backslash ‚Äú<code>\</code>‚Äù</strong></p>
<p>(Because each line is a continuation of the previous line)</p>
</li>
<li>
<p>Alternatively, we may merge the lines into a single loooong line, remove the backslashes ‚Äú<code>\</code>‚Äù, and paste the loooong line into the BL602 command line.</p>
</li>
</ol>
<p>We run the <code>blinky</code> function like so‚Ä¶</p>
<pre><code class="language-text">( blinky )
</code></pre>
<p>And the <strong>LED blinks every second!</strong> </p>
<p>(Restart the board to stop it, sorry)</p>
<p><a href="https://youtu.be/TN4OaZNGjOA"><strong>Watch the demo on YouTube</strong></a></p>
<p><a href="http://www.ulisp.com/show?1AEK">(Based on the Blinky function from uLisp)</a></p>
<h1 id="now-add-blockly" class="section-header"><a href="#now-add-blockly">4 Now add Blockly</a></h1>
<p>According to the <a href="https://developers.google.com/blockly/guides/overview">Blockly Overview</a>‚Ä¶</p>
<blockquote>
<p>Blockly is a library that adds a <strong>visual code editor</strong> to web and mobile apps. </p>
</blockquote>
<blockquote>
<p>The Blockly editor uses <strong>interlocking, graphical blocks</strong> to represent code concepts like variables, logical expressions, loops, and more. </p>
</blockquote>
<blockquote>
<p>It allows users to apply programming principles <strong>without having to worry about syntax</strong> or the intimidation of a blinking cursor on the command line.</p>
</blockquote>
<p>In short, Blockly will let us <strong>create uLisp programs through a Web Browser</strong> (with some customisation)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-blockly2.png" alt="Blockly Web Editor" /></p>
<p><a href="https://scratch.mit.edu/developers">(Yep it looks a lot like Scratch)</a></p>
<p><em>Does Blockly require any server-side code?</em></p>
<p>Nope, everything is done in <strong>plain old HTML and JavaScript</strong>, without any server-side code. It runs locally on our computer too.</p>
<p>(Which is great for developers)</p>
<p><em>So we copy and paste the generated uLisp code from Blockly to BL602?</em></p>
<p>Nope we‚Äôre in 2021, everything can be automated!</p>
<p>See the <strong>Run Button [ ‚ñ∂ ]</strong> at top right?</p>
<p>Pressing it will <strong>automatically transfer the uLisp Code from Blockly to BL602</strong>‚Ä¶ Thanks to the <a href="https://web.dev/serial/"><strong>Web Serial API</strong></a>!</p>
<p>Let‚Äôs try it now.</p>
<h1 id="run-the-blockly-web-editor" class="section-header"><a href="#run-the-blockly-web-editor">5 Run the Blockly Web Editor</a></h1>
<p>We shall do two things with Blockly and uLisp on BL602‚Ä¶</p>
<ol>
<li>
<p><strong>Flip the BL602 LED</strong> on and off</p>
</li>
<li>
<p><strong>Blink the BL602 LED</strong> every second</p>
</li>
</ol>
<p>Just by dragging-and-dropping in a Web Browser!</p>
<h2 id="flip-the-led-1" class="section-header"><a href="#flip-the-led-1">5.1 Flip the LED</a></h2>
<ol>
<li>
<p><strong>Close the BL602 serial connection</strong> in <code>screen</code> / CoolTerm / <code>putty</code> / Web Serial Terminal (close the web browser)</p>
</li>
<li>
<p><strong>Disconnect BL602</strong> from our computer, and <strong>reconnect</strong> it to the USB Port.</p>
</li>
<li>
<p>Click this link to run the <strong>Blockly Web Editor for uLisp</strong>‚Ä¶</p>
<ul>
<li><a href="https://appkaki.github.io/blockly-ulisp/demos/code/"><strong><code>blockly-ulisp</code> Web Editor</strong></a></li>
</ul>
<p>(This website contains plain HTML and JavaScript, no server-side code. See <a href="https://github.com/AppKaki/blockly-ulisp"><code>blockly-ulisp</code></a>)</p>
</li>
<li>
<p>Click <strong><code>GPIO</code></strong> in the left bar.</p>
<p>Drag the <strong><code>digital write</code></strong> block to the empty space.</p>
<p>We should see this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit1.png" alt="Blockly Web Editor: Digital Write" /></p>
</li>
<li>
<p>In the <strong><code>digital write</code></strong> block, change <strong><code>11</code></strong> to the GPIO Pin Number for the LED.</p>
<p>For PineCone BL602 Blue LED: Set it to <strong><code>11</code></strong></p>
</li>
<li>
<p>Click the <strong><code>Lisp</code></strong> tab at the top.</p>
<p>We should see this <strong>uLisp code generated by Blockly</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit2.png" alt="Blockly Web Editor: uLisp code for Digital Write" /></p>
</li>
<li>
<p>Click the <strong>Run Button [ ‚ñ∂ ]</strong> at top right.</p>
<p>When prompted, select the USB port for BL602.</p>
<p>(It works on macOS, Windows and probably Linux too)</p>
<p>The <strong>LED switches on!</strong></p>
</li>
<li>
<p>In the <strong><code>digital write</code></strong> block, change <strong><code>LOW</code></strong> to <strong><code>HIGH</code></strong></p>
<p>Click the <strong>Run Button [ ‚ñ∂ ]</strong> at top right.</p>
<p>The <strong>LED switches off!</strong></p>
<p><a href="https://youtu.be/RRhzW4j8BtI"><strong>Watch the demo on YouTube</strong></a></p>
</li>
</ol>
<h2 id="blinky" class="section-header"><a href="#blinky">5.2 Blinky</a></h2>
<p>Now we do the <strong>Blinky Program</strong> the drag-and-drop way with Blockly‚Ä¶</p>
<ol>
<li>
<p>Erase the <strong><code>digital write</code></strong> block from the last section</p>
</li>
<li>
<p>Drag-and-drop this Blockly Program‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit3.png" alt="Blockly Web Editor: Blinky" /></p>
<p>By snapping these blocks together‚Ä¶</p>
<ul>
<li>
<p><strong><code>forever</code></strong> from <strong><code>Loops</code></strong> (left bar)</p>
</li>
<li>
<p><strong><code>digital write</code></strong> from <strong><code>GPIO</code></strong> (left bar)</p>
</li>
<li>
<p><strong><code>wait</code></strong> from <strong><code>Loops</code></strong> (left bar)</p>
</li>
</ul>
<p>Make sure they fit snugly. (Not floaty)</p>
<p><a href="https://youtu.be/LNkmUIv7ZZc">(Stuck? Check the video)</a></p>
</li>
<li>
<p>Set the values for the <strong><code>digital write</code></strong> and <strong><code>wait</code></strong> blocks as shown above.</p>
<p>In the <strong><code>digital write</code></strong> block, change <strong><code>11</code></strong> to the GPIO Pin Number for the LED.</p>
<p>For PineCone BL602 Blue LED: Set it to <strong><code>11</code></strong></p>
</li>
<li>
<p>Click the <strong><code>Lisp</code></strong> tab at the top.</p>
<p>We should see this <strong>uLisp code generated by Blockly</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-edit4.png" alt="Blockly Web Editor: uLisp code for Blinky" /></p>
</li>
<li>
<p>Click the <strong>Run Button [ ‚ñ∂ ]</strong> at top right.</p>
<p>The <strong>LED blinks every second!</strong></p>
<p>(Restart the board to stop it, sorry)</p>
<p><a href="https://youtu.be/LNkmUIv7ZZc"><strong>Watch the demo on YouTube</strong></a></p>
</li>
</ol>
<h1 id="web-browser-controls-bl602-with-web-serial-api" class="section-header"><a href="#web-browser-controls-bl602-with-web-serial-api">6 Web Browser controls BL602 with Web Serial API</a></h1>
<p><em>What is this magic that teleports the uLisp code from Web Browser to BL602?</em></p>
<p>The Blockly Web Editor calls the <a href="https://web.dev/serial/"><strong>Web Serial API</strong></a> (in JavaScript) to transfer the generated uLisp code to BL602 (via the USB Serial Port).</p>
<p>Web Serial API is supported on the newer web browsers. To check whether our web browser supports the Web Serial API, click this link‚Ä¶</p>
<ul>
<li><a href="https://googlechromelabs.github.io/serial-terminal/"><strong>Web Serial Terminal</strong></a></li>
</ul>
<p>We should be able to connect to BL602 via the USB Serial Port‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-terminal.png" alt="Web Serial Terminal" /></p>
<p>(Remember to set the <strong><code>Baud Rate</code></strong> to <strong><code>Custom</code></strong> with value <strong><code>2000000</code></strong>)</p>
<p><em>So the Web Serial API lets us send commands to BL602?</em></p>
<p>Yep it does! Here we send the <strong><code>reboot</code></strong> command to BL602 via a Web Browser with the Web Serial API‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-reboot.jpg" alt="Reboot with Web Serial API" /></p>
<p>But there were two interesting challenges‚Ä¶</p>
<ol>
<li>
<p><strong>When do we stop?</strong></p>
<p>Our JavaScript code might get stuck <strong>waiting forever for a response</strong> from the BL602 command.</p>
<p>For the <code>reboot</code> command we tweaked our JavaScript code to <strong>stop when it detects the special keywords</strong>‚Ä¶</p>
<pre><code class="language-text">Init CLI
</code></pre>
<p>(Which means that BL602 has finished rebooting)</p>
</li>
<li>
<p><strong>How do we clean up?</strong></p>
<p>We use <strong>Async Streams</strong> to transmit and receive BL602 serial data.</p>
<p>Async Streams don‚Äôt close immediately‚Ä¶ We need to <strong><code>await</code> for them to close</strong>.</p>
<p>(Or our serial port will be locked from further access)</p>
</li>
</ol>
<p>The proper way to send a <code>reboot</code> command to BL602 looks like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-reboot2.png" alt="Fixed reboot with Web Serial API" /></p>
<p>Let‚Äôs look at the fixed code in Blockly (our bespoke version) that <strong>sends uLisp Commands to BL602</strong>.</p>
<h2 id="sending-a-command-to-bl602" class="section-header"><a href="#sending-a-command-to-bl602">6.1 Sending a command to BL602</a></h2>
<p>For convenience, we wrap the Web Serial API in a high-level JavaScript Async Function: <strong><code>runWebSerialCommand</code></strong></p>
<p>Here‚Äôs how we call <code>runWebSerialCommand</code> to send the <strong><code>reboot</code> Command</strong> to BL602 and wait for the response <strong>‚Äú<code>Init CLI</code>‚Äù</strong>‚Ä¶</p>
<pre><code class="language-javascript">//  Send the reboot command
await runWebSerialCommand(
  &quot;reboot&quot;,   //  Command
  &quot;Init CLI&quot;  //  Expected Response
);
</code></pre>
<p>(This also sends Enter / Carriage Return after the <code>reboot</code> Command)</p>
<p>We don‚Äôt actually send the <code>reboot</code> Command in Blockly (because it‚Äôs too disruptive).</p>
<p>Instead we send to BL602 an <strong>Empty Command</strong> like so: <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/demos/code/code.js#L644-L673"><code>code.js</code></a></p>
<pre><code class="language-javascript">//  Send an empty command and 
//  check that BL602 responds with &quot;#&quot;
await runWebSerialCommand(
  &quot;&quot;,  //  Command
  &quot;#&quot;  //  Expected Response
);
</code></pre>
<p>This is equivalent to <strong>hitting the Enter key</strong> and checking whether BL602 <strong>responds with the Command Prompt ‚Äú<code>#</code>‚Äù</strong></p>
<p>We do this <strong>before sending each command to BL602</strong>. (Just to be sure that BL602 is responsive)</p>
<p>Now to send an actual command like ‚Äú<code>( pinmode 11 :output )</code>‚Äù, we do this‚Ä¶</p>
<pre><code class="language-javascript">//  Send the actual command but 
//  don't wait for response
await runWebSerialCommand(
  command,  //  Command
  null      //  Don't wait for response
);
</code></pre>
<p><strong>We don‚Äôt wait for the response</strong> from BL602, because some uLisp commands don‚Äôt return a response (<code>loop</code>) or they return a delayed response (<code>delay</code>).</p>
<p>That‚Äôs why we send the Empty Command before the next command, to <strong>check whether the previous command has completed.</strong></p>
<p>(In future we should make this more robust by adding a timeout)</p>
<h2 id="calling-the-web-serial-api" class="section-header"><a href="#calling-the-web-serial-api">6.2 Calling the Web Serial API</a></h2>
<p>Let‚Äôs look inside the <strong><code>runWebSerialCommand</code></strong> function and learn how it sends commands from Web Browser to BL602 via the Web Serial API.</p>
<p><strong><code>runWebSerialCommand</code></strong> accepts 2 parameters‚Ä¶</p>
<ul>
<li>
<p><strong><code>command</code></strong>: The command that will be sent to from the Web Browser to BL602, like‚Ä¶</p>
<pre><code class="language-text">( pinmode 11 :output )
</code></pre>
<p>The function sends a Carriage Return after the command.</p>
</li>
<li>
<p><strong><code>expectedResponse</code></strong>: The expected response from BL602, like ‚Äú<code>#</code>‚Äù.</p>
<p>The function will <strong>wait for the expected response</strong> to be received from BL602 before returning.</p>
<p>If the expected response is null, the function <strong>returns without waiting</strong>.</p>
</li>
</ul>
<p>We start by checking whether the Web Serial API is supported by the web browser: <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/demos/code/code.js#L675-L738"><code>code.js</code></a></p>
<pre><code class="language-javascript">//  Web Serial Port
var serialPort;

//  Run a command on BL602 via Web Serial API and wait for the expectedResponse (if not null)
//  Based on https://web.dev/serial/
async function runWebSerialCommand(command, expectedResponse) {
  //  Check if Web Serial API is supported
  if (!(&quot;serial&quot; in navigator)) { alert(&quot;Web Serial API is not supported&quot;); return; }
</code></pre>
<p>Next we prompt the user to <strong>select the Serial Port</strong>, and we remember the selection‚Ä¶</p>
<pre><code class="language-javascript">  //  Prompt user to select any serial port
  if (!serialPort) { serialPort = await navigator.serial.requestPort(); }
  if (!serialPort) { return; }
</code></pre>
<p>We <strong>open the Serial Port at 2 Mbps</strong>, which is the standard Baud Rate for BL602 Firmware‚Ä¶</p>
<pre><code class="language-javascript">  //  Wait for the serial port to open at 2 Mbps
  await serialPort.open({ baudRate: 2000000 });
</code></pre>
<p>In a while we shall set these to <strong>defer the closing of the Read / Write Streams</strong> for the Serial Port‚Ä¶</p>
<pre><code class="language-javascript">  //  Capture the events for closing the read and write streams
  var writableStreamClosed = null;
  var readableStreamClosed = null;
</code></pre>
<p>Now we‚Äôre ready to send the Command String to the Serial Port‚Ä¶</p>
<ol>
<li>
<p>We <strong>create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoderStream">TextEncoderStream</a></strong> that will convert our Command String into UTF-8 Bytes</p>
</li>
<li>
<p>We <strong>pipe the <code>TextEncoderStream</code> to Serial Port Output</strong></p>
</li>
<li>
<p>We <strong>fetch the <code>writableStreamClosed</code> Promise</strong> that we‚Äôll call to close the Serial Port</p>
</li>
<li>
<p>We <strong>get the <code>writer</code> Stream</strong> for writing our Command String to the Serial Port Output</p>
</li>
</ol>
<pre><code class="language-javascript">  //  Send command to BL602
  {
    //  Open a write stream
    console.log(&quot;Writing to BL602: &quot; + command + &quot;...&quot;);
    const textEncoder = new TextEncoderStream();
    writableStreamClosed = textEncoder.readable.pipeTo(serialPort.writable);
    const writer = textEncoder.writable.getWriter();
</code></pre>
<p>We <strong>write the Command String to the <code>writer</code> Stream</strong> (including the Carriage Return)‚Ä¶</p>
<pre><code class="language-javascript">    //  Write the command
    await writer.write(command + &quot;\r&quot;); 

    //  Close the write stream
    writer.close();
  }
</code></pre>
<p>And we <strong>close the <code>writer</code> Stream</strong> (Serial Port Output).</p>
<p>If we‚Äôre expected to wait for the response from the Serial Port‚Ä¶</p>
<ol>
<li>
<p>We <strong>create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream">TextDecoderStream</a></strong> that will convert the Serial Port input from UTF-8 Bytes into Text Strings</p>
</li>
<li>
<p>We <strong>pipe the Serial Port Input to <code>TextDecoderStream</code></strong></p>
</li>
<li>
<p>We <strong>fetch the <code>readableStreamClosed</code> Promise</strong> that we‚Äôll call to close the Serial Port</p>
</li>
<li>
<p>We <strong>get the <code>reader</code> Stream</strong> for reading response strings from the Serial Port Input</p>
</li>
</ol>
<pre><code class="language-javascript">  //  Read response from BL602
  if (expectedResponse) {
    //  Open a read stream
    console.log(&quot;Reading from BL602...&quot;);
    const textDecoder = new TextDecoderStream();
    readableStreamClosed = serialPort.readable.pipeTo(textDecoder.writable);
    const reader = textDecoder.readable.getReader();
</code></pre>
<p>We loop forever <strong>reading strings from the <code>reader</code> Stream</strong> (Serial Port Input)‚Ä¶</p>
<pre><code class="language-javascript">    //  Listen to data coming from the serial device
    while (true) {
      const { value, done } = await reader.read();
      if (!done) { console.log(value); }
</code></pre>
<p>Until <strong>we find the expected response</strong>‚Ä¶</p>
<pre><code class="language-javascript">      //  If the stream has ended, or the data contains expected response, we stop
      if (done || value.indexOf(expectedResponse) &gt;= 0) { break; }
    }
</code></pre>
<p>And we <strong>close the <code>reader</code> Stream</strong> (Serial Port Input)‚Ä¶</p>
<pre><code class="language-javascript">    //  Close the read stream
    reader.cancel();
  }
</code></pre>
<p>Here‚Äôs the catch (literally)‚Ä¶ Our <strong><code>reader</code> and <code>writer</code> Streams are not actually closed yet!</strong></p>
<p>We need to <strong>wait for the <code>reader</code> and <code>writer</code> Streams to close</strong>‚Ä¶</p>
<pre><code class="language-javascript">  //  Wait for read and write streams to be closed
  if (readableStreamClosed) { await readableStreamClosed.catch(() =&gt; { /* Ignore the error */ }); }
  if (writableStreamClosed) { await writableStreamClosed; }
</code></pre>
<p>Finally it‚Äôs safe to <strong>close the Serial Port</strong>‚Ä¶</p>
<pre><code class="language-javascript">  //  Close the port
  await serialPort.close();
  console.log(&quot;runWebSerial: OK&quot;);
}
</code></pre>
<p>And that‚Äôs how Blockly sends a uLisp command to BL602 with the Web Serial API!</p>
<p><img src="https://lupyuen.github.io/images/lisp-blinky2.png" alt="uLisp Blinky" /></p>
<h1 id="porting-ulisp-to-bl602" class="section-header"><a href="#porting-ulisp-to-bl602">7 Porting uLisp to BL602</a></h1>
<p>Today we‚Äôve seen uLisp on BL602, ported from the <a href="https://github.com/technoblogy/ulisp-esp/blob/master/ulisp-esp.ino">ESP32 Arduino version of uLisp</a>.</p>
<p><em>Porting uLisp from ESP32 Arduino to BL602 sounds difficult?</em></p>
<p>Not at all!</p>
<p>(Wait‚Ä¶ We‚Äôve said this before)</p>
<ol>
<li>
<p><strong>No Heap Memory, just Static Memory</strong></p>
<p>uLisp needs only Static Memory, no Heap Memory. </p>
<p>This makes uLisp highly portable across microcontrollers: <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L193-L194"><code>ulisp.c</code></a></p>
<pre><code class="language-c">#define WORKSPACESIZE     8000  //  Cells (8*bytes)
#define SYMBOLTABLESIZE   1024  //  Bytes

object Workspace[WORKSPACESIZE];
char SymbolTable[SYMBOLTABLESIZE];
</code></pre>
</li>
<li>
<p><strong>Reading from BL602 Flash Memory is simpler</strong></p>
<p>On Arduino we access Flash Memory by calling <code>PSTR</code>. </p>
<p>That‚Äôs not necessary on BL602, so we stub out the Flash Memory functions: <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L9-L11"><code>ulisp.c</code></a></p>
<pre><code class="language-c">#define PGM_P     const char *
#define PROGMEM
#define PSTR(s)   s
</code></pre>
</li>
<li>
<p><strong><code>printf</code> works on BL602</strong></p>
<p>No more <code>Serial.write</code>. (Nice!)</p>
</li>
<li>
<p><strong>Compiles in C, no C++ needed</strong></p>
<p>Because the Arduino C++ bits (like <code>Serial.write</code>) have been converted to C (like <code>printf</code>).</p>
</li>
<li>
<p><strong>GPIO Functions</strong></p>
<p>This GPIO code from the ESP32 Arduino version of uLisp: <a href="https://github.com/technoblogy/ulisp-esp/blob/master/ulisp-esp.ino#L3415-L3425"><code>ulisp-esp.ino</code></a></p>
<pre><code class="language-c">/// Set the GPIO Output to High or Low
object *fn_digitalwrite (object *args, object *env) {
    //  Omitted: Parse the GPIO pin number and High / Low
    ...

    //  Set the GPIO output (from Arduino)
    digitalWrite(pin, mode);
</code></pre>
<p>Was ported to BL602 by calling the <strong>BL602 GPIO Hardware Abstraction Layer</strong>: <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3536-L3554"><code>ulisp.c</code></a></p>
<pre><code class="language-c">/// Set the GPIO Output to High or Low
object *fn_digitalwrite (object *args, object *env) {
    //  Omitted: Parse the GPIO pin number and High / Low
    //  (Same as before)
    ...

    //  Set the GPIO output (from BL602 GPIO HAL)
    int rc = bl_gpio_output_set(
        pin,  //  GPIO pin number
        mode  //  0 for low, 1 for high
    );
    assert(rc == 0);  //  Halt on error
</code></pre>
<p><a href="https://lupyuen.github.io/articles/led#how-it-works-bl602-gpio">(More about BL602 GPIO HAL)</a></p>
</li>
<li>
<p><strong>Delay Function</strong></p>
<p>BL602 runs on a <strong>multitasking operating system (FreeRTOS)</strong>.</p>
<p>Thus we need to be respectful of other Background Tasks that may be running.</p>
<p>Here‚Äôs how we implement the <strong>uLisp <code>delay</code> function</strong> on BL602: <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3593-L3605"><code>ulisp.c</code></a></p>
<pre><code class="language-c">/// Delay for specified number of milliseconds
object *fn_delay (object *args, object *env) {
    (void) env;
    object *arg1 = first(args);

    //  Convert milliseconds to ticks
    int millisec   = checkinteger(DELAY, arg1);
    uint32_t ticks = time_ms_to_ticks32(millisec);

    //  Sleep for the number of ticks
    time_delay(ticks);
    return arg1;
}
</code></pre>
<p><strong><code>time_ms_to_ticks32</code> and <code>time_delay</code></strong> are multitasking functions provided by the <strong>NimBLE Porting Layer</strong>, implemented with FreeRTOS.</p>
<p><a href="https://lupyuen.github.io/articles/lora2#multitask-with-nimble-porting-layer">(More about NimBLE Porting Layer)</a></p>
</li>
<li>
<p><strong>Loop and Yield</strong></p>
<p>The BL602 implementation of the <strong>uLisp <code>loop</code> function</strong> is aware of multitasking too.</p>
<p>We preempt the current task at every iteration of the loop: <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1691-L1705"><code>ulisp.c</code></a></p>
<pre><code class="language-c">/// &quot;loop&quot; implementation in uLisp
object *sp_loop (object *args, object *env) {
    object *start = args;
    for (;;) {
        //  Sleep 100 ticks in each iteration
        time_delay(100);  //  TODO: Tune this
</code></pre>
<p>(This is probably no good for time-sensitive uLisp functions‚Ä¶ We will have to rethink this)</p>
</li>
<li>
<p><strong>BL602 cares about the Command Line</strong></p>
<p>On Arduino we read and parse the Serial Input, byte by byte.</p>
<p>Whereas on BL602, the <strong>BL602 IoT SDK parses the Command Line</strong> for us.</p>
<p>Here‚Äôs how we <strong>define ‚Äú<code>(</code>‚Äù as a Command Keyword</strong> in BL602: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/ulisp/customer_app/sdk_app_ulisp/sdk_app_ulisp/demo.c#L45-L48"><code>demo.c</code></a></p>
<pre><code class="language-c">/// List of commands. STATIC_CLI_CMD_ATTRIBUTE makes this(these) command(s) static
const static struct cli_command cmds_user[] STATIC_CLI_CMD_ATTRIBUTE = {
    {
        &quot;(&quot;,
        &quot;Run the uLisp command&quot;,
        run_ulisp
    },
};          
</code></pre>
<p>When we enter a command like <strong>‚Äú<code>( delay 1000 )</code>‚Äù</strong>, the command-line interface calls our function <code>run_ulisp</code> defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/ulisp/customer_app/sdk_app_ulisp/sdk_app_ulisp/demo.c#L9-L40"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command-Line Buffer that will be passed to uLisp
static char cmd_buf[1024] = { 0 };

/// Run a uLisp command
void run_ulisp(char *buf, int len, int argc, char **argv) {
    //  If the last command line arg is `\`, we expect a continuation
    bool to_continue = false;
    if (strcmp(argv[argc - 1], &quot;\\&quot;) == 0) {
        to_continue = true;
        argc--;   //  Skip the `\`
    }

    //  Concatenate the command line, separated by spaces
    for (int i = 0; i &lt; argc; i++) {
        assert(argv[i] != NULL);
        strncat(cmd_buf, argv[i], sizeof(cmd_buf) - strlen(cmd_buf) - 1);
        strncat(cmd_buf, &quot; &quot;,     sizeof(cmd_buf) - strlen(cmd_buf) - 1);
    }
    cmd_buf[sizeof(cmd_buf) - 1] = 0;

    //  If this the end of the command line...
    if (!to_continue) {
        //  Execute the command line
        execute_ulisp(cmd_buf);

        //  Erase the buffer
        cmd_buf[0] = 0;
    }
}
</code></pre>
<p>The command-line interface splits the command line into multiple arguments (delimited by space), so we need to <strong>merge the arguments back into a single command line</strong>.</p>
<p>(Yeah, not so efficient)</p>
<p>We support <strong>continuation of command lines</strong> when the command line ends with <strong>‚Äú<code>\</code>‚Äù</strong></p>
<p>We pass the merged command line to <strong><code>execute_ulisp</code></strong> defined in <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L5363-L5370"><code>ulisp.c</code></a></p>
<pre><code class="language-c">/// Console input buffer, position and length
const char *input_buf = NULL;
int input_pos = 0;
int input_len = 0;

/// Execute the command line
void execute_ulisp(const char *line) {
    //  Set the console input buffer
    input_buf = line;
    input_pos = 0;
    input_len = strlen(line);

    //  Start the uLisp Interpreter
    loop_ulisp();
}
</code></pre>
<p>Here we <strong>save the merged command line into a buffer</strong> and start the uLisp Interpreter.</p>
<p>Lastly we modified the <strong><code>gserial</code></strong> function in uLisp to read the command line from the buffer (instead of Serial Input): <a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L5085-L5124"><code>ulisp.c</code></a></p>
<pre><code class="language-c">/// Return the next char from the console input buffer
int gserial() {
    if (LastChar) {
        //  Return the previous char
        char temp = LastChar;
        LastChar = 0;
        return temp;
    }  
    if (input_pos &gt;= input_len) {
        //  No more chars to read
        return '\n';
    }
    //  Return next char from the buffer
    return input_buf[input_pos++];
}
</code></pre>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-build.png" alt="Porting uLisp to BL602" /></p>
<h2 id="missing-ulisp-features" class="section-header"><a href="#missing-ulisp-features">7.1 Missing uLisp Features</a></h2>
<p><em>What else needs to be ported to BL602?</em></p>
<p>If the <strong>Community could help</strong> to port the <strong>missing uLisp Features</strong>‚Ä¶ That would be super awesome! üôè üëç</p>
<ol>
<li>
<p><strong>GPIO</strong></p>
<p>Port these uLisp GPIO Functions to BL602 with the <a href="https://lupyuen.github.io/articles/led#how-it-works-bl602-gpio"><strong>BL602 GPIO HAL</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3527-L3534"><strong><code>fn_digitalread</code></strong></a></li>
</ul>
</li>
<li>
<p><strong>I2C</strong></p>
<p>Port these uLisp I2C Functions to BL602 with the <a href="https://lupyuen.github.io/articles/i2c#initialise-i2c-port"><strong>BL602 I2C HAL</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1323-L1329"><strong><code>I2Cinit</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1331-L1336"><strong><code>I2Cread</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1338-L1343"><strong><code>I2Cwrite</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1345-L1357"><strong><code>I2Cstart</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1359-L1367"><strong><code>I2Crestart</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1369-L1374"><strong><code>I2Cstop</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>SPI</strong></p>
<p>Port these uLisp SPI Functions to BL602 with the <a href="https://lupyuen.github.io/articles/spi#bl602-hardware-abstraction-layer-for-spi"><strong>BL602 SPI HAL</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1378-L1383"><strong><code>spiread</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1458-L1463"><strong><code>spiwrite</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L2003-L2040"><strong><code>sp_withspi</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>ADC</strong></p>
<p>Port these uLisp ADC Functions to BL602 with the <a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c#L173-L216"><strong>BL602 ADC HAL</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3556-L3569"><strong><code>fn_analogread</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3571-L3579"><strong><code>fn_analogreadresolution</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>DAC</strong></p>
<p>Port these uLisp DAC Functions to BL602 with the <strong>BL602 DAC HAL</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3581-L3591"><strong><code>fn_analogwrite</code></strong></a></li>
</ul>
</li>
<li>
<p><strong>WiFi</strong></p>
<p>Port these uLisp WiFi Functions to BL602 with the <strong>BL602 WiFi HAL</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L1472-L1477"><strong><code>WiFiwrite</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L2089-L2117"><strong><code>sp_withclient</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3840-L3847"><strong><code>fn_available</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3849-L3856"><strong><code>fn_wifiserver</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3858-L3880"><strong><code>fn_wifisoftap</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3882-L3889"><strong><code>fn_connected</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3891-L3897"><strong><code>fn_wifilocalip</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L3899-L3914"><strong><code>fn_wificonnect</code></strong></a></p>
</li>
</ul>
<p>More about BL602 WiFi HAL‚Ä¶</p>
<ul>
<li>
<p><a href="https://pine64.github.io/bl602-docs/Examples/demo_at/AT.html#wi-fi-at-commands"><strong>WiFi Docs</strong></a></p>
</li>
<li>
<p><a href="https://pine64.github.io/bl602-docs/Examples/demo_wifi/wifi.html"><strong>WiFi Demo</strong></a></p>
</li>
<li>
<p><a href="https://github.com/pine64/bl_iot_sdk/tree/master/customer_app/bl602_demo_wifi"><strong>WiFi Source Code</strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>EPROM</strong></p>
<p>Port these uLisp EPROM Functions to BL602 with the <strong>BL602 Flash Memory HAL</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L509-L515"><strong><code>EpromWriteInt</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L518-L569"><strong><code>saveimage</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L578-L585"><strong><code>EpromReadInt</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L588-L635"><strong><code>loadimage</code></strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/master/src/ulisp.c#L637-L660"><strong><code>autorunimage</code></strong></a></p>
</li>
</ul>
<p>Porting the EPROM functions to BL602 will allow us to <strong>save and load uLisp images to / from Flash Memory</strong>.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-build2.png" alt="uLisp builds OK on BL602" /></p>
<h1 id="customise-blockly-for-ulisp" class="section-header"><a href="#customise-blockly-for-ulisp">8 Customise Blockly for uLisp</a></h1>
<p><em>How did we customise Blockly for uLisp and BL602?</em></p>
<ol>
<li>
<p>We added <strong>Custom Blocks</strong> like <code>forever</code>, <code>digital write</code> and <code>wait</code></p>
<p>All blocks under <strong>GPIO, I2C and SPI</strong> are Custom Blocks. (See pic below)</p>
</li>
<li>
<p>We created a <strong>Code Generator</strong> that generates uLisp code.</p>
<p>(More about this in the next section)</p>
</li>
<li>
<p>We integrated Blockly with <strong>Web Serial API</strong> to transfer the generated uLisp code to BL602</p>
<p>(The Web Serial API code we saw earlier)</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-blockly2.png" alt="Blockly Web Editor" /></p>
<p><em>Which Blockly source files were modified?</em></p>
<p>We modified these Blockly source files to load the Custom Blocks and generate uLisp code‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/demos/code/index.html"><code>demos/code/index.html</code></a> </p>
<p>This is the <strong>HTML source file</strong> for the Blockly Web Editor. (See pic above)</p>
<p><a href="https://github.com/AppKaki/blockly-ulisp/pull/1/files#diff-dcf2ffe98d7d8b4a0dd7b9f769557dbe8c9e0e726236ef229def25c956a43d8f">(See changes)</a></p>
</li>
<li>
<p><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/demos/code/code.js"><code>demos/code/code.js</code></a></p>
<p>This is the main <strong>JavaScript source file</strong> for the Blockly Web Editor.</p>
<p>This file contains the JavaScript function <code>runWebSerialCommand</code> that transfers the generated uLisp code to BL602 via Web Serial API.</p>
<p><a href="https://github.com/AppKaki/blockly-ulisp/pull/1/files#diff-d72873b861dee958e5d443c919726dd856de594bd56b1e73d8948a7719163553">(See changes)</a></p>
</li>
<li>
<p><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/core/workspace_svg.js"><code>core/workspace_svg.js</code></a></p>
<p>This JavaScript file <strong>renders the Blockly Workspace as SVG</strong>, including the Toolbox Bar at left.</p>
<p><a href="https://github.com/AppKaki/blockly-ulisp/pull/1/files#diff-068435ae2521855e9cdbfdf36bea7f06978c9401acede52042702667bb14d49c">(See changes)</a></p>
</li>
</ul>
<p><em>How did we create the Custom Blocks?</em></p>
<p>We used the <strong>Block Exporter</strong> from Blockly to create the Custom Blocks‚Ä¶</p>
<ul>
<li><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_library.xml"><code>generators/lisp/ lisp_library.xml</code></a>: XML for Custom Blocks</li>
</ul>
<p>With Block Explorer and the Custom Blocks XML file, we generated this JavaScript file containing our Custom Blocks‚Ä¶</p>
<ul>
<li><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_blocks.js"><code>generators/lisp/ lisp_blocks.js</code></a>: JavaScript for Custom Blocks</li>
</ul>
<p>Block Exporter and Custom Blocks are explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/overview"><strong>‚ÄúCustom Blocks‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/blockly-developer-tools"><strong>‚ÄúBlockly Developer Tools‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://developers.google.com/blockly/guides/create-custom-blocks/define-blocks"><strong>‚ÄúDefine Blocks‚Äù</strong></a></p>
</li>
</ul>
<p><em>Does Blockly work on Mobile Web Browsers?</em></p>
<p>Yes but the Web Serial API won‚Äôt work for transferring the generated uLisp code to BL602. (Because we can‚Äôt connect BL602 as a USB Serial device)</p>
<p>In future we could use the <a href="https://web.dev/bluetooth/"><strong>Web Bluetooth API</strong></a> instead to transfer the uLisp code to BL602. (Since BL602 supports Bluetooth LE)</p>
<p>Here‚Äôs how it looks on a Mobile Web Browser‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lisp-mobile.png" alt="Blockly on Mobile" /></p>
<p><em>What were we thinking when we designed the Custom Blocks: <code>forever</code>, <code>on_start</code>, <code>digital write</code>, <code>wait</code>, ‚Ä¶</em></p>
<p>The custom blocks were inspired by <strong>MakeCode for BBC micro:bit</strong>‚Ä¶</p>
<ul>
<li><a href="https://makecode.microbit.org/"><strong>MakeCode</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/lisp-generate.png" alt="uLisp Code Generator" /></p>
<h1 id="code-generator-for-ulisp" class="section-header"><a href="#code-generator-for-ulisp">9 Code Generator for uLisp</a></h1>
<p><em>How did we generate uLisp code in Blockly?</em></p>
<p>We created <strong>Code Generators</strong> for uLisp. Our Code Generators are JavaScript Functions that emit uLisp code for each type of Block‚Ä¶</p>
<ul>
<li><a href="https://developers.google.com/blockly/guides/create-custom-blocks/generating-code"><strong>‚ÄúGenerating Code‚Äù</strong></a></li>
</ul>
<p>We started by <strong>copying the Code Generators</strong> from Dart to Lisp into this Blockly folder‚Ä¶</p>
<ul>
<li><a href="https://github.com/AppKaki/blockly-ulisp/tree/master/generators/lisp"><strong><code>generators/lisp</code></strong></a>: Code Generators for uLisp</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lisp-dart.png" alt="Copy code generators from Dart to Lisp" /></p>
<p>Then we added this <strong>Code Generator Interface</strong> for uLisp‚Ä¶</p>
<ul>
<li><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp.js"><code>generators/lisp.js</code></a>: Interface for uLisp Code Generator</li>
</ul>
<p><em>Which Blocks are supported by the uLisp Code Generator?</em></p>
<p>The uLisp Code Generator is <strong>incomplete</strong>.</p>
<p>The only Blocks supported are‚Ä¶</p>
<ol>
<li>
<p><strong><code>forever</code></strong> <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L40-L49">(See this)</a></p>
</li>
<li>
<p><strong><code>on_start</code></strong> <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/app_code.js#L3-L12">(See this)</a></p>
</li>
<li>
<p><strong><code>wait</code></strong> <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L51-L58">(See this)</a></p>
</li>
<li>
<p><strong><code>digital write</code></strong> <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L79-L89">(See this)</a></p>
</li>
</ol>
<p><em>How do we define a uLisp Code Generator?</em></p>
<p>Here‚Äôs how we define the <strong><code>forever</code> Code Generator</strong>: <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L40-L49"><code>lisp_functions.js</code></a></p>
<pre><code class="language-c">//  Emit uLisp code for the &quot;forever&quot; block. 
//  Inspired by MakeCode &quot;forever&quot; and Arduino &quot;loop&quot;.
Blockly.Lisp['forever'] = function(block) {
  //  Convert the code inside the &quot;forever&quot; block into uLisp
  var statements_stmts = Blockly.Lisp.statementToCode(block, 'STMTS');
  var code = statements_stmts;

  //  Wrap the converted uLisp code with &quot;loop&quot;
  code = [
    '( loop  ',
    code + ')',
  ].join('\n');

  //  Return the wrapped code
  return code;
};
</code></pre>
<p>This JavaScript function emits a <strong>uLisp loop</strong> that wraps the code inside the <code>forever</code> block like so‚Ä¶</p>
<pre><code class="language-text">( loop
    ...Code inside the loop block...
)
</code></pre>
<p>And here‚Äôs the <strong><code>digital write</code> Code Generator</strong>: <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L79-L89"><code>lisp_functions.js</code></a></p>
<pre><code class="language-c">//  Emit uLisp code for the &quot;digtial write&quot; block. 
Blockly.Lisp['digital_write_pin'] = function(block) {
  //  Fetch the GPIO Pin Number (e.g. 11)
  var dropdown_pin = block.getFieldValue('PIN');

  //  Fetch the GPIO Output: &quot;:high&quot; or &quot;low&quot;
  var dropdown_value = block.getFieldValue('VALUE');

  //  Compose the uLisp code to set the GPIO Pin mode and output.
  //  TODO: Call init_out only once,
  var code = [
    '( pinmode ' + dropdown_pin + ' :output )',
    '( digitalwrite ' + dropdown_pin + ' ' + dropdown_value + ' )',
    ''
  ].join('\n');  

  //  Return the uLisp code
  return code;
};
</code></pre>
<p>This JavaScript function emits uLisp code that <strong>sets the GPIO Pin mode and output</strong> like so‚Ä¶</p>
<pre><code class="language-text">( pinmode 11 :output )
( digitalwrite 11 :high )
</code></pre>
<h2 id="missing-code-generators" class="section-header"><a href="#missing-code-generators">9.1 Missing Code Generators</a></h2>
<p><em>What about the missing uLisp Code Generators?</em></p>
<p>If the <strong>Community could help</strong> to fill in the <strong>missing uLisp Code Generators</strong>‚Ä¶ That would be incredibly awesome! üôè üëç üòÄ</p>
<ol>
<li>
<p><strong>Expressions</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/math.js#L18-L485"><strong>Expression Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( / ( - 7 1 ) ( - 4 2 ) )
</code></pre>
<p><a href="http://www.ulisp.com/show?1ACY">(From uLisp)</a></p>
</li>
<li>
<p><strong>Strings</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/text.js#L18-L343"><strong>String Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">&quot;This is a string&quot;
</code></pre>
<p><a href="http://www.ulisp.com/show?1LRV">(From uLisp)</a></p>
</li>
<li>
<p><strong>Lists</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lists.js#L18-L447"><strong>List Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( first '( 1 2 3 ) )
</code></pre>
<p><a href="http://www.ulisp.com/show?1AHT">(From uLisp)</a></p>
</li>
<li>
<p><strong>If</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/logic.js#L18-L127"><strong>If Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( if ( &lt; ( analogread 0 ) 512 )
    ( digitalwrite 2 t )
    ( digitalwrite 3 t )
)
</code></pre>
<p><a href="http://www.ulisp.com/show?1AJM">(From uLisp)</a></p>
</li>
<li>
<p><strong>For Loops</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/loops.js#L62-L169"><strong>For Loop Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( dotimes ( pin 3 )
    ( digitalwrite pin :high ) 
)
</code></pre>
<p><a href="http://www.ulisp.com/show?2I01">(From uLisp)</a></p>
</li>
<li>
<p><strong>While Loops</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/loops.js#L18-L60"><strong>While Loop Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( loop
    ( unless ( digitalread 8 ) ( return ) )
)
</code></pre>
<p><a href="http://www.ulisp.com/show?2I01">(From uLisp)</a></p>
</li>
<li>
<p><strong>Variables</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/variables.js#L18-L32"><strong>Variable Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( defvar led 11 )

( setq led 11 )

( let* (
    ( led 11 )
    ...
    )
    body
)
</code></pre>
<p><a href="http://www.ulisp.com/show?1AEK">(From uLisp)</a></p>
</li>
<li>
<p><strong>Functions</strong></p>
<p>This <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/procedures.js#L18-L111"><strong>Function Code Generator</strong></a> should emit this uLisp Code‚Ä¶</p>
<pre><code class="language-text">( defun function_name ( ... ) ( ... ) )
</code></pre>
<p><a href="http://www.ulisp.com/show?1AGL">(From uLisp)</a></p>
</li>
<li>
<p><strong>GPIO</strong></p>
<p>The Code Generators for <strong><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L71-L77"><code>digital read</code></a></strong> and <strong><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/generators/lisp/lisp_functions.js#L60-L69"><code>digital toggle</code></a></strong> should emit uLisp Code for‚Ä¶</p>
<ul>
<li>
<p><a href="http://www.ulisp.com/show?3L#pinmode"><strong><code>pinmode</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#digitalread"><strong><code>digitalread</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#digitalwrite"><strong><code>digitalwrite</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>I2C, SPI, ADC, DAC</strong></p>
<p>We need to create <strong>Custom Blocks and Code Generators for I2C, SPI, ADC and DAC</strong> that will emit uLisp Code for‚Ä¶</p>
<ul>
<li>
<p><a href="http://www.ulisp.com/show?3L#withi2c"><strong><code>withi2c</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#restarti2c"><strong><code>restarti2c</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#withspi"><strong><code>withspi</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#analogread"><strong><code>analogread</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#analogreference"><strong><code>analogreference</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#analogreadresolution"><strong><code>analogreadresolution</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?3L#analogwrite"><strong><code>analogwrite</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>WiFi</strong></p>
<p>We need to create <strong>WiFi Custom Blocks and Code Generators</strong> that will emit uLisp Code for‚Ä¶</p>
<ul>
<li>
<p><a href="http://www.ulisp.com/show?2B27#available"><strong><code>available</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#connected"><strong><code>connected</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#wifilocalip"><strong><code>wifilocalip</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#wificonnect"><strong><code>wificonnect</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#wifiserver"><strong><code>wifiserver</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#wifisoftap"><strong><code>wifisoftap</code></strong></a></p>
</li>
<li>
<p><a href="http://www.ulisp.com/show?2B27#withclient"><strong><code>withclient</code></strong></a></p>
</li>
</ul>
</li>
<li>
<p><strong>Storage</strong></p>
<p>Blockly <strong>doesn‚Äôt save our program</strong>‚Ä¶ Refresh the Web Browser and our program disappears.</p>
<p>We could enhance Blockly to <strong>save our program locally with JavaScript Local Storage</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/AppKaki/blockly-ulisp/blob/master/appengine/storage.js"><strong><code>appengine/storage.js</code></strong></a></li>
</ul>
<p>This script is not used in our version of Blockly. But it‚Äôs referenced by our HTML code here: <a href="https://github.com/AppKaki/blockly-ulisp/blob/master/demos/code/index.html#L11"><code>index.html</code></a></p>
</li>
<li>
<p><strong>Copy and paste the XML Code</strong></p>
<p>But in the meantime, we can manually save and restore the program by copying and pasting the contents of the <strong><code>XML</code></strong> tab in Blockly.</p>
</li>
</ol>
<p><em>You sound strangely familiar with Blockly Code Generators?</em></p>
<p>Yes the uLisp Code Generator is based on my earlier project on <strong>Visual Embedded Rust</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/advanced-topics-for-visual-embedded-rust-programming"><strong>‚ÄúAdvanced Topics for Visual Embedded Rust‚Äù</strong></a></li>
</ul>
<p>Generating Rust code in Blockly was highly challenging because we had to do <strong>Type Inference with Procedural Macros</strong>.</p>
<p><strong>uLisp is not Statically Typed</strong> like Rust, so generating uLisp code in Blockly looks a lot simpler.</p>
<p>(Blockly for Visual Embedded Rust is wrapped inside a <a href="https://marketplace.visualstudio.com/items?itemName=LeeLupYuen.visual-embedded-rust">VSCode Extension</a> that allows <strong>local, offline development</strong>. We could do the same for Blockly and uLisp)</p>
<p><img src="https://lupyuen.github.io/images/lisp-rust.png" alt="Visual Embedded Rust" /></p>
<h1 id="simulate-bl602-with-ulisp-webassembly" class="section-header"><a href="#simulate-bl602-with-ulisp-webassembly">10 Simulate BL602 with uLisp WebAssembly</a></h1>
<p>What if we‚Ä¶</p>
<ol>
<li>
<p>Compile the <strong>uLisp Interpreter to WebAssembly</strong>‚Ä¶</p>
</li>
<li>
<p>Use the WebAssembly version of uLisp to <strong>simulate BL602 in a Web Browser</strong>‚Ä¶</p>
<p>(Including GPIO, I2C, SPI, Display Controller, Touch Controller, LoRaWAN‚Ä¶ <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/simulator">Similar to this</a>)</p>
</li>
<li>
<p>Integrate the <strong>BL602 Emulator with Blockly</strong>‚Ä¶</p>
</li>
<li>
<p>To allow embedded developers to <strong>preview their BL602 Blockly Apps in the Web Browser</strong>?</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/lisp-simulator.png" alt="BL602 Simulator with uLisp WebAssembly" /></p>
<p>Let‚Äôs try this out with the <a href="https://github.com/lupyuen/ulisp-bl602/tree/wasm"><strong><code>wasm</code> branch of <code>ulisp-bl602</code></strong></a> ‚Ä¶ Stay tuned!</p>
<ul>
<li>
<p><a href="https://youtu.be/9uegWNcokxY"><strong>Watch the uLisp WebAssembly demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/ulisp-bl602/ulisp.html"><strong>Try uLisp WebAssembly here</strong></a></p>
</li>
<li>
<p><a href="https://appkaki.github.io/blockly-ulisp/demos/simulator/"><strong>Try BL602 Simulator with Blockly and uLisp WebAssembly here</strong></a></p>
</li>
<li>
<p><a href="https://twitter.com/MisterTechBlog/status/1393554618924212224"><strong>Follow the Twitter Thread</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/lisp-wasm.png" alt="uLisp in WebAssembly" /></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>Porting uLisp and Blockly to BL602 has been a fun experience.</p>
<p>But more work needs to be done, I hope the Community can help.</p>
<p>Could this be the better way to learn Embedded Programming on modern microcontrollers?</p>
<p>Let‚Äôs build it and find out! üôè üëç üòÄ</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/nc7gce/ulisp_and_blockly_on_pinecone_bl602_riscv_board/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lisp.md"><code>lupyuen.github.io/src/lisp.md</code></a></p>
<p><img src="https://lupyuen.github.io/images/lisp-wasm2.png" alt="uLisp in WebAssembly" /></p>
<h1 id="notes" class="section-header"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1389783215347429382">this Twitter Thread</a></li>
</ol>

    
</body>
</html>