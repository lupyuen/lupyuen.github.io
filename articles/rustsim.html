<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Simulated with WebAssembly</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Simulated with WebAssembly" 
    data-rh="true">
<meta property="og:description" 
    content="Can we run Rust Firmware for BL602 RISC-V SoC in a Web Browser... Simulated with WebAssembly?"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rustsim-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Simulated with WebAssembly</h1>
    <nav id="TOC"><ul>
<li><a href="#rust-firmware-for-bl602">1 Rust Firmware for BL602</a><ul></ul></li>
<li><a href="#build-bl602-firmware-for-webassembly">2 Build BL602 Firmware for WebAssembly</a><ul>
<li><a href="#compile-rust-firmware-into-webassembly">2.1 Compile Rust Firmware into WebAssembly</a><ul></ul></li>
<li><a href="#link-rust-firmware-with-emscripten">2.2 Link Rust Firmware with Emscripten</a><ul></ul></li>
<li><a href="#copy-the-webassembly-outputs">2.3 Copy the WebAssembly outputs</a><ul></ul></li></ul></li>
<li><a href="#json-stream-of-simulation-events">3 JSON Stream of Simulation Events</a><ul></ul></li>
<li><a href="#generate-simulation-events">4 Generate Simulation Events</a><ul>
<li><a href="#time-delay-event">4.1 Time Delay Event</a><ul></ul></li>
<li><a href="#intercept-calls-to-bl602-iot-sdk">4.2 Intercept Calls to BL602 IoT SDK</a><ul></ul></li>
<li><a href="#what-about-c">4.3 What about C?</a><ul></ul></li></ul></li>
<li><a href="#html-and-javascript-interface">5 HTML and JavaScript Interface</a><ul>
<li><a href="#run-rust-firmware">5.1 Run Rust Firmware</a><ul></ul></li>
<li><a href="#handle-simulation-events">5.2 Handle Simulation Events</a><ul></ul></li></ul></li>
<li><a href="#run-bl602-firmware-in-simulator">6 Run BL602 Firmware in Simulator</a><ul></ul></li>
<li><a href="#easier-embedded-development">7 Easier Embedded Development?</a><ul></ul></li>
<li><a href="#validate-calls-to-bl602-iot-sdk">8 Validate Calls to BL602 IoT SDK</a><ul></ul></li>
<li><a href="#pinedio-stack-bl604">9 PineDio Stack BL604</a><ul></ul></li>
<li><a href="#scripting-for-bl602-simulator">10 Scripting for BL602 Simulator</a><ul>
<li><a href="#drag-and-drop-scripting">10.1 Drag and Drop Scripting</a><ul></ul></li>
<li><a href="#run-scripts-on-bl602">10.2 Run Scripts on BL602</a><ul></ul></li></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-rhai-scripts-on-bl602">13 Appendix: Rhai Scripts on BL602</a><ul></ul></li>
<li><a href="#appendix-rust-simulation-events">14 Appendix: Rust Simulation Events</a><ul></ul></li></ul></nav><p>üìù <em>16 Aug 2021</em></p>
<p>One year ago I pondered‚Ä¶ Can we make <strong>Embedded Programming easier for Learners</strong>?</p>
<p><img src="https://lupyuen.github.io/images/cloud-title.jpg" alt="Fornite vs Embedded Programming" /></p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/cloud">(Source)</a></p>
<p><em>Maybe we need an easier way to build, test and debug our firmware‚Ä¶</em></p>
<p><em>Without using actual embedded hardware?</em></p>
<p>Today we shall explore whether it‚Äôs feasible to run <strong>Rust Firmware for BL602</strong> RISC-V SoC in a <strong>Web Browser</strong>‚Ä¶</p>
<p>By simulating the BL602 SoC with <strong>WebAssembly</strong>!</p>
<p>Read on to find how we created this bare-bones BL602 Simulator in WebAssembly‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/bl602-simulator/"><strong>BL602 Simulator in WebAssembly</strong></a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/pinecone">(More about BL602 RISC-V SoC)</a></p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<h1 id="rust-firmware-for-bl602" class="section-header"><a href="#rust-firmware-for-bl602">1 Rust Firmware for BL602</a></h1>
<p>We start with this <strong>BL602 Rust Firmware <code>sdk_app_rust_gpio</code></strong> that blinks the LED: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/src/lib.rs"><code>sdk_app_rust_gpio/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// This function will be called by the BL602 command-line interface</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>              <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">rust_main</span>(  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware</span>
  <span class="ident">_result</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>,        <span class="comment">//  Result to be returned to command-line interface (char *)</span>
  <span class="ident">_len</span>:  <span class="ident">i32</span>,              <span class="comment">//  Size of result buffer (int)</span>
  <span class="ident">_argc</span>: <span class="ident">i32</span>,              <span class="comment">//  Number of command line args (int)</span>
  <span class="ident">_argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>  <span class="comment">//  Array of command line args (char **)</span>
) {
  <span class="comment">//  Show a message on the serial console</span>
  <span class="ident">puts</span>(<span class="string">&quot;Hello from Rust!&quot;</span>);

  <span class="comment">//  PineCone Blue LED is connected on BL602 GPIO 11</span>
  <span class="kw">const</span> <span class="ident">LED_GPIO</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">11</span>;  <span class="comment">//  `u8` is 8-bit unsigned integer</span>

  <span class="comment">//  Configure the LED GPIO for output (instead of input)</span>
  <span class="ident">gpio::enable_output</span>(<span class="ident">LED_GPIO</span>, <span class="number">0</span>, <span class="number">0</span>)      <span class="comment">//  No pullup, no pulldown</span>
    .<span class="ident">expect</span>(<span class="string">&quot;GPIO enable output failed&quot;</span>);  <span class="comment">//  Halt on error</span>

  <span class="comment">//  Blink the LED 5 times</span>
  <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {  <span class="comment">//  Iterates 10 times from 0 to 9 (`..` excludes 10)</span>

    <span class="comment">//  Toggle the LED GPIO between 0 (on) and 1 (off)</span>
    <span class="ident">gpio::output_set</span>(  <span class="comment">//  Set the GPIO output (from BL602 GPIO HAL)</span>
      <span class="ident">LED_GPIO</span>,        <span class="comment">//  GPIO pin number</span>
      <span class="ident">i</span> <span class="op">%</span> <span class="number">2</span>            <span class="comment">//  0 for low, 1 for high</span>
    ).<span class="ident">expect</span>(<span class="string">&quot;GPIO output failed&quot;</span>);  <span class="comment">//  Halt on error</span>

    <span class="comment">//  Sleep 1 second</span>
    <span class="ident">time_delay</span>(                 <span class="comment">//  Sleep by number of ticks (from NimBLE Porting Layer)</span>
      <span class="ident">time_ms_to_ticks32</span>(<span class="number">1000</span>)  <span class="comment">//  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)</span>
    );
  }
  <span class="comment">//  Return to the BL602 command-line interface</span>
}</pre></div>
<p><em>What are <code>gpio::enable_output</code> and <code>gpio::output_set</code>?</em></p>
<p>They are <strong>BL602 GPIO Functions</strong> defined in the <a href="https://crates.io/crates/bl602-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a>, as explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/adc#rust-wrapper-for-bl602-iot-sdk"><strong>‚ÄúRust Wrapper for BL602 IoT SDK‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk"><strong>‚ÄúGenerating the BL602 Rust Wrapper‚Äù</strong></a></p>
</li>
</ul>
<p><code>time_delay</code> and <code>time_ms_to_ticks32</code> are also defined in the BL602 Rust Wrapper.</p>
<p><em>How do we build, flash and run this BL602 Rust Firmware?</em></p>
<p>To see the blinking BL602 LED, we‚Ä¶</p>
<ol>
<li>
<p><strong>Build</strong> this Rust Firmware</p>
<p><a href="https://lupyuen.github.io/articles/adc#build-the-bl602-rust-firmware">(‚Äú<code>cargo build</code>‚Äù with a Custom Rust Target)</a></p>
</li>
<li>
<p><strong>Link</strong> it with the BL602 IoT SDK</p>
</li>
<li>
<p><strong>Flash</strong> the firmware to BL602</p>
<p><a href="https://lupyuen.github.io/articles/adc#flash-the-bl602-rust-firmware">(With <code>blflash</code>)</a></p>
</li>
<li>
<p><strong>Connect</strong> to BL602 via the USB Serial Port and enter the command‚Ä¶</p>
<pre><code class="language-text">rust_main
</code></pre>
<p><a href="https://lupyuen.github.io/articles/adc#run-the-bl602-rust-firmware">(Similar to this)</a></p>
</li>
</ol>
<p><em>Can we run this BL602 Rust Firmware in a Web Browser? Without any BL602 hardware?</em></p>
<p>Let‚Äôs find out!</p>
<p>First we compile this BL602 Rust Firmware to WebAssembly‚Ä¶</p>
<h1 id="build-bl602-firmware-for-webassembly" class="section-header"><a href="#build-bl602-firmware-for-webassembly">2 Build BL602 Firmware for WebAssembly</a></h1>
<p>We‚Äôve created a <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile"><strong>Makefile</strong></a> that builds the above BL602 Rust Firmware into WebAssembly.</p>
<p>Here‚Äôs how we use it‚Ä¶</p>
<pre><code class="language-bash"># Configure emscripten. See https://emscripten.org/docs/getting_started/downloads.html
# For Windows: emsdk\emsdk_env.bat
. ~/emsdk/emsdk_env.sh

# Download source code
git clone --recursive https://github.com/lupyuen/bl602-simulator
cd bl602-simulator

# Compile the Rust Firmware, Rust Simulator Library and link with Emscripten
make

# Produces outputs in the `docs` folder: wasm.js, wasm.wasm
</code></pre>
<p>This produces the JavaScript and WebAssembly files <strong><code>wasm.js</code> and <code>wasm.wasm</code></strong>, which we‚Äôll run in a Web Browser later.</p>
<p><em>What‚Äôs inside the Makefile?</em></p>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile">Makefile</a> does the following‚Ä¶</p>
<ol>
<li>
<p><strong>Compile</strong> the Rust Firmware into WebAssembly</p>
<p>(‚Äú<code>cargo build</code>‚Äù for target ‚Äú<code>wasm32-unknown-emscripten</code>‚Äù)</p>
</li>
<li>
<p><strong>Link</strong> the Rust Firmware with the Emscripten WebAssembly Runtime</p>
<p>(So that it runs in a Web Browser)</p>
</li>
</ol>
<p>Let‚Äôs go into the details‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-build.png" alt="Compile Rust Firmware into WebAssembly" /></p>
<h2 id="compile-rust-firmware-into-webassembly" class="section-header"><a href="#compile-rust-firmware-into-webassembly">2.1 Compile Rust Firmware into WebAssembly</a></h2>
<p>To compile our <strong>Rust Firmware into WebAssembly</strong>, our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L57-L58">Makefile</a> calls this command‚Ä¶</p>
<pre><code class="language-bash"># Compile the Rust Firmware and Rust Simulator Library into WebAssembly
cargo build --target wasm32-unknown-emscripten
</code></pre>
<p>This compiles three <strong>Rust Projects</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Rust Firmware:</strong> </p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/sdk_app_rust_gpio"><code>bl602-simulator/sdk_app_rust_gpio/rust</code></a></p>
<p>(The Rust Firmware we‚Äôve seen earlier. Should be portable across BL602 and WebAssembly)</p>
</li>
<li>
<p><strong>Rust Simulator Library:</strong> </p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-simulator"><code>bl602-simulator/bl602-simulator</code></a></p>
<p>(Simulates the BL602 IoT SDK. We‚Äôll see this in a while)</p>
</li>
<li>
<p><strong>Rust Scripting Library:</strong></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-script"><code>bl602-simulator/bl602-script</code></a></p>
<p>(More about this later)</p>
</li>
</ol>
<p>‚Äú<code>cargo build</code>‚Äù downloads the <a href="https://crates.io/crates/bl602-sdk"><strong>BL602 Rust Wrapper</strong></a> automagically from <code>crates.io</code> ‚Ä¶</p>
<pre><code class="language-text">...
Compiling bl602-macros v0.0.2
Compiling bl602-sdk v0.0.6
Compiling app v0.0.1 (bl602-simulator/sdk_app_rust_gpio/rust)
Compiling bl602-simulator v0.0.1 (bl602-simulator/bl602-simulator)
Finished dev [unoptimized + debuginfo] target(s) in 1m 43s
</code></pre>
<p><a href="https://github.com/lupyuen/bl602-simulator#build-log">See the complete log</a></p>
<p>(Great that BL602 Rust Wrapper builds OK for WebAssembly! Yep our WSL machine is slow)</p>
<p>However our Rust Firmware needs a slight tweak at the top to <strong>build correctly</strong> under WebAssembly: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/src/lib.rs#L3-L7"><code>sdk_app_rust_gpio/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// TODO: For BL602:</span>
<span class="comment">// #![no_std]  //  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems</span>

<span class="comment">// TODO: For WebAssembly:</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">libc</span>)]</span>  <span class="comment">//  Allow C Standard Library, which will be mapped by emscripten to JavaScript</span></pre></div>
<p>We change <strong><code>no_std</code></strong> to <strong><code>feature(libc)</code></strong> for the build to succeed.</p>
<p>Probably because the Emscripten Runtime behaves more like the <strong>Standard C Runtime</strong>.</p>
<p>(Someday we might use <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><strong><code>build.rs</code></strong></a> to apply this mod automatically during compilation)</p>
<p><img src="https://lupyuen.github.io/images/rustsim-libc.png" alt="Changing no_std to feature(libc)" /></p>
<p><em>What are the outputs for ‚Äú<code>cargo build</code>‚Äù?</em></p>
<p>‚Äú<code>cargo build</code>‚Äù produces two <strong>Static Libraries</strong> (Rust Firmware and Rust Simulator)‚Ä¶</p>
<pre><code class="language-text">target/wasm32-unknown-emscripten/debug/libapp.a
target/wasm32-unknown-emscripten/debug/libbl602_simulator.a
</code></pre>
<p>Which we shall link with Emscripten‚Äôs WebAssembly Runtime.</p>
<p><em>Why did ‚Äú<code>cargo build</code>‚Äù emit Static Libraries? Instead of the default Rust Libraries?</em></p>
<p>Because we specified <strong><code>staticlib</code></strong> in <code>Cargo.toml</code> for the <a href="https://github.com/lupyuen/bl602-simulator/blob/main/sdk_app_rust_gpio/rust/Cargo.toml">Rust Firmware</a> and <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/Cargo.toml">Rust Simulator</a>‚Ä¶</p>
<pre><code class="language-text"># Build this module as a Static Library.
[lib]
name       = &quot;app&quot;          # Output will be named `libapp.a`
crate-type = [&quot;staticlib&quot;]  # And will be a Static Library
</code></pre>
<p><strong>Rust Libraries won‚Äôt link</strong> with Emscripten‚Äôs WebAssembly Runtime. </p>
<p>That‚Äôs why we switched to <strong>Static Libraries</strong>.</p>
<h2 id="link-rust-firmware-with-emscripten" class="section-header"><a href="#link-rust-firmware-with-emscripten">2.2 Link Rust Firmware with Emscripten</a></h2>
<p>We‚Äôre nearly ready to run our Rust Firmware in WebAssembly! We need a <strong>WebAssembly Runtime</strong> that will‚Ä¶</p>
<ol>
<li>
<p>Let our Rust Firmware interact with <strong>HTML and JavaScript</strong></p>
<p>(To render the Web Browser UI)</p>
</li>
<li>
<p>And <strong>print messages</strong>, errors and exceptions to the Web Browser</p>
</li>
</ol>
<p>We‚Äôll use the <a href="https://emscripten.org/"><strong>Emscripten WebAssembly Runtime</strong></a>.</p>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L60-L65">Makefile</a> links the <strong>Rust Firmware with Emscripten</strong> like so‚Ä¶</p>
<pre><code class="language-text"># Link the Rust Firmware and Rust Simulator Library with Emscripten
emcc -o wasm/wasm.html \
  target/wasm32-unknown-emscripten/debug/libapp.a \
  target/wasm32-unknown-emscripten/debug/libbl602_simulator.a \
  wasm/wasm.o \
  -g \
  -s WASM=1 \
  -s DISABLE_EXCEPTION_CATCHING=0 \
  -s &quot;EXPORTED_FUNCTIONS=[ '_rust_main', '_clear_simulation_events', '_get_simulation_events' ]&quot; \
  -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[ 'cwrap', 'allocate', 'intArrayFromString', 'UTF8ToString' ]&quot;
</code></pre>
<p><a href="https://emscripten.org/docs/getting_started/downloads.html">How to install Emscripten</a></p>
<p><em>What are the <code>EXPORTED_FUNCTIONS</code>?</em></p>
<p>These Rust Functions will be <strong>called from JavaScript</strong>‚Ä¶</p>
<ul>
<li>
<p><code>_rust_main</code> is the Rust Function that blinks the LED</p>
<p>(We‚Äôve seen this earlier)</p>
</li>
<li>
<p><code>_clear_simulation_events</code> and <code>_get_simulation_events</code> are functions from the Rust Simulator Library that will manage the <strong>JSON Stream of Simulation Events</strong></p>
<p>(More about this later)</p>
</li>
</ul>
<p><em>What are the <code>EXTRA_EXPORTED_RUNTIME_METHODS</code>?</em></p>
<p>These Emscripten Runtime Functions will be exported to JavaScript to allow <strong>strings to be passed</strong> between JavaScript and our Rust Firmware‚Ä¶</p>
<ul>
<li><code>cwrap</code>, <code>allocate</code>, <code>intArrayFromString</code>, <code>UTF8ToString</code></li>
</ul>
<h2 id="copy-the-webassembly-outputs" class="section-header"><a href="#copy-the-webassembly-outputs">2.3 Copy the WebAssembly outputs</a></h2>
<p><em>What are the outputs emitted by Emscripten?</em></p>
<p>Emscripten produces these files after linking our Rust Firmware‚Ä¶</p>
<ul>
<li>
<p><strong><code>wasm.wasm</code></strong>: WebAssembly binary file</p>
</li>
<li>
<p><strong><code>wasm.js</code></strong>: JavaScript that loads the WebAssembly binary file into the Web Browser</p>
</li>
<li>
<p><strong><code>wasm.html</code></strong>: HTML page that loads the above JavaScript to execute the WebAssembly binary</p>
</li>
</ul>
<p>Our <a href="https://github.com/lupyuen/bl602-simulator/blob/main/Makefile#L67-L69">Makefile</a> copies the <strong>JavaScript and WebAssembly</strong> outputs to the <strong><code>docs</code></strong> folder‚Ä¶</p>
<pre><code class="language-text"># Copy the WebAssembly outputs to the docs folder for GitHub Pages
cp wasm/wasm.js   docs
cp wasm/wasm.wasm docs
</code></pre>
<p>So that we may test the WebAssembly outputs with a Local Web Server.</p>
<p><em>What about the HTML file <code>wasm.html</code>?</em></p>
<p>We‚Äôre using a <strong>customised version</strong> of <code>wasm.html</code> in the <code>docs</code> folder.</p>
<p>It renders a <strong>Simulated BL602 Board</strong>, as we shall soon see.</p>
<p><em>Why did we use the Emscripten WebAssembly Runtime? Instead of the <a href="https://rustwasm.github.io/docs/book/">Rust WebAssembly Runtime</a>?</em></p>
<p>Because we copied the code from an earlier (non-Rust) WebAssembly project‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/wasm"><strong>‚ÄúSimulate RISC-V BL602 with WebAssembly, uLisp and Blockly‚Äù</strong></a></li>
</ul>
<h1 id="json-stream-of-simulation-events" class="section-header"><a href="#json-stream-of-simulation-events">3 JSON Stream of Simulation Events</a></h1>
<p>Our story so far‚Ä¶</p>
<ol>
<li>
<p>We have compiled our <strong>Rust Firmware into WebAssembly</strong></p>
</li>
<li>
<p>Our firmware runs in a <strong>Web Browser</strong> and it‚Äôs capable of interacting with <strong>HTML and JavaScript</strong></p>
<p>(Thanks to Emscripten)</p>
</li>
<li>
<p>But our firmware <strong>won‚Äôt blink any LEDs</strong></p>
<p>(Because the <strong>BL602 IoT SDK is missing</strong> from WebAssembly)</p>
</li>
</ol>
<p><em>What if we simulate the LED with HTML and JavaScript?</em></p>
<p>Yep we could build a <strong>BL602 Simulator</strong> in HTML and JavaScript.</p>
<p>And we can make our Rust Firmware talk to the BL602 Simulator‚Ä¶</p>
<p>By emitting a <strong>JSON Stream of BL602 Simulation Events</strong>!</p>
<p><img src="https://lupyuen.github.io/images/rust-simulator.jpg" alt="JSON Stream of BL602 Simulation Events" /></p>
<p><em>What‚Äôs a BL602 Simulation Event?</em></p>
<p>When our firmware needs to <strong>set the GPIO Output</strong> to High or Low (to flip an LED On/Off)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Switch the LED On</span>
<span class="ident">gpio::output_set</span>(  <span class="comment">//  Set the GPIO output for...</span>
  <span class="number">11</span>,              <span class="comment">//  GPIO pin number</span>
  <span class="number">0</span>                <span class="comment">//  0 for On, 1 for Off</span>
)...</pre></div>
<p>It sends a <strong>Simulation Event</strong> to the BL602 Simulator (in JSON format)‚Ä¶</p>
<pre><code class="language-json">{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;:  11, 
  &quot;value&quot;: 0 
} }
</code></pre>
<p>Which will be handled by the BL602 Simulator to <strong>flip the Simulated LED</strong> on or off.</p>
<p><em>Is our firmware directly controlling the BL602 Simulator?</em></p>
<p>Not quite. Our firmware is <strong>indirectly controlling the BL602 Simulator</strong> by sending Simulation Events.</p>
<p><a href="https://lupyuen.github.io/articles/wasm#why-simulate-a-stream-of-events">(More about this Inversion of Control)</a></p>
<p><em>What about time delays?</em></p>
<p>Our firmware shall generate <strong>Simulation Events for time delays</strong>.</p>
<p>To handle such events, our <strong>BL602 Simulator pauses</strong> for the specified duration.</p>
<p>(It‚Äôs like playing a MIDI Stream)</p>
<p>Hence this firmware code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Sleep 1,000 milliseconds (or 1 second)</span>
<span class="ident">time_delay</span>(<span class="number">1000</span>);</pre></div>
<p>Shall generate this <strong>Time Delay</strong> Simulation Event‚Ä¶</p>
<pre><code class="language-json">{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre>
<p><em>What‚Äôs inside the JSON Stream of Simulation Events?</em></p>
<p>To simulate our firmware on the BL602 Simulator, we shall transmit an <strong>array of Simulation Events</strong> (in JSON format) from our firmware to the BL602 Simulator.</p>
<p>Thus our Rust Blinky Firmware shall generate this <strong>JSON Stream of Simulation Events</strong>‚Ä¶</p>
<pre><code class="language-json">[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 0 } }, 
  { &quot;time_delay&quot;:      { &quot;ticks&quot;: 1000 } }, 

  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;:      { &quot;ticks&quot;: 1000 } }, 
  ... 
]
</code></pre>
<p>That will simulate a <strong>blinking BL602 LED</strong>.</p>
<p>Let‚Äôs generate the Simulation Events now.</p>
<h1 id="generate-simulation-events" class="section-header"><a href="#generate-simulation-events">4 Generate Simulation Events</a></h1>
<p><em>How shall we generate this <strong>JSON Simulation Event</strong>‚Ä¶</em></p>
<pre><code class="language-json">{ &quot;gpio_output_set&quot;: { 
  &quot;pin&quot;:  11, 
  &quot;value&quot;: 0 
} }
</code></pre>
<p><em>When we call this Rust Function?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Switch the LED On</span>
<span class="ident">gpio::output_set</span>(  <span class="comment">//  Set the GPIO output for...</span>
  <span class="number">11</span>,              <span class="comment">//  GPIO pin number</span>
  <span class="number">0</span>                <span class="comment">//  0 for On, 1 for Off</span>
)...</pre></div>
<p>We start by defining the <strong>Enum Type</strong> for the Simulation Event: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L3-L21"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Import the serde crate for JSON Serialization</span>
<span class="kw">use</span> <span class="ident">serde</span>::{<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>};

<span class="doccomment">/// Event to be simulated by the BL602 Simulator</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>, <span class="ident">Deserialize</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">enum</span> <span class="ident">SimulationEvent</span> {
  <span class="doccomment">/// GPIO Set Output:</span>
  <span class="doccomment">/// `{ &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 }`</span>
  <span class="ident">gpio_output_set</span> {
    <span class="ident">pin</span>:   <span class="ident">u8</span>,
    <span class="ident">value</span>: <span class="ident">u8</span>,
  },
}</pre></div>
<p>To represent a stream of events, we create a <strong>Vector of Simulation Events</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create a vector of simulation events (i.e. event array)</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">simulation_events</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">SimulationEvent</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::new</span>();</pre></div>
<p>Here‚Äôs how we create a Simulation Event for <strong>GPIO Set Output</strong> and add it to the stream‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create a GPIO Set Output event</span>
<span class="kw">let</span> <span class="ident">ev</span> <span class="op">=</span> <span class="ident">SimulationEvent::gpio_output_set</span> { 
  <span class="ident">pin</span>:  <span class="number">11</span>,
  <span class="ident">value</span>: <span class="number">0</span>,
};

<span class="comment">// Add the event to the vector</span>
<span class="ident">simulation_events</span>.<span class="ident">push</span>(<span class="ident">ev</span>);</pre></div>
<p>Thanks to the <a href="https://serde.rs/"><strong>Serde Crate</strong></a>, we may serialize the Vector of Simulation Events like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Convert vector of events to a JSON string</span>
<span class="kw">let</span> <span class="ident">serialized</span> <span class="op">=</span> <span class="ident">serde_json::to_string</span>(<span class="kw-2">&amp;</span><span class="ident">simulation_events</span>)
  .<span class="ident">unwrap</span>();

<span class="comment">// Print the serialized JSON events</span>
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">serialized</span>);</pre></div>
<p>The result is a <strong>JSON Array</strong> of Simulation Events‚Ä¶</p>
<pre><code class="language-text">[{&quot;gpio_output_set&quot;:{&quot;pin&quot;:11,&quot;value&quot;:0}}]
</code></pre>
<p>Exactly what we need!</p>
<h2 id="time-delay-event" class="section-header"><a href="#time-delay-event">4.1 Time Delay Event</a></h2>
<p><em>What about the Time Delay Event?</em></p>
<pre><code class="language-json">{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
</code></pre>
<p>We add <strong>Time Delay</strong> to our Enum Type like so: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L3-L21"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Event to be simulated by the BL602 Simulator</span>
<span class="kw">enum</span> <span class="ident">SimulationEvent</span> {
    <span class="doccomment">/// Omitted: GPIO Set Output</span>
    ...
    <span class="doccomment">/// Time Delay:</span>
    <span class="doccomment">/// `{ &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }`</span>
    <span class="ident">time_delay</span> {
        <span class="ident">ticks</span>: <span class="ident">u32</span>,
    },
}</pre></div>
<p>And we create the <strong>Time Delay Event</strong> like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Create a Time Delay event</span>
<span class="kw">let</span> <span class="ident">ev</span> <span class="op">=</span> <span class="ident">SimulationEvent::time_delay</span> { 
  <span class="ident">ticks</span>: <span class="number">1000</span>,
};

<span class="comment">// Add the event to the vector</span>
<span class="ident">simulation_events</span>.<span class="ident">push</span>(<span class="ident">ev</span>);</pre></div>
<p><a href="https://serde.rs/"><strong>Serde Crate</strong></a> does the rest!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events.png" alt="Generating Simulation Events in Rust" /></p>
<p><a href="https://gist.github.com/lupyuen/cec1a423062556263a7ba02971862001">(Source)</a></p>
<h2 id="intercept-calls-to-bl602-iot-sdk" class="section-header"><a href="#intercept-calls-to-bl602-iot-sdk">4.2 Intercept Calls to BL602 IoT SDK</a></h2>
<p>We‚Äôve just figured out how to <strong>compose the JSON Stream</strong> of Simulation Events.</p>
<p>Now let‚Äôs do this <strong>inside the calls</strong> to BL602 IoT SDK‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Switch the LED On</span>
<span class="ident">gpio::output_set</span>(  <span class="comment">//  Set the GPIO output for...</span>
  <span class="number">11</span>,              <span class="comment">//  GPIO pin number</span>
  <span class="number">0</span>                <span class="comment">//  0 for On, 1 for Off</span>
)...</pre></div>
<p><em>Where is the Rust Wrapper Function <code>gpio::output_set</code> defined?</em></p>
<p>From the previous article we see that the Wrapper Function is generated by <code>bindgen</code> and <code>safe_wrap</code>: <a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/logs/sdk-expanded.rs#L649-L662"><code>sdk-expanded.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// BL602 Rust Wrapper Function that sets the GPIO output</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BlResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">//  Import the C function from BL602 IoT SDK</span>
  <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">::cty::c_int</span>;
  }
  <span class="kw">unsafe</span> {
    <span class="comment">//  Call the BL602 IoT SDK</span>
    <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span>);
    <span class="comment">//  Return the result</span>
    <span class="kw">match</span> <span class="ident">res</span> { <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(()), <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">BlError::from</span>(<span class="ident">res</span>)), }
  }
}</pre></div>
<p><a href="https://lupyuen.github.io/articles/adc#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">(More about this)</a></p>
<p>This code calls <strong><code>bl_gpio_output_set</code></strong>, which is defined in the <strong>BL602 IoT SDK</strong>.</p>
<p><em>But <code>bl_gpio_output_set</code> won‚Äôt work on WebAssembly right?</em></p>
<p>Correcto! Because BL602 IoT SDK <strong>doesn‚Äôt exist on WebAssembly</strong>!</p>
<p>To fix this we introduce the <a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-simulator"><strong>Rust Simulator Library</strong></a>, which pretends to be the <strong>BL602 IoT SDK for WebAssembly</strong>.</p>
<p>Here‚Äôs how it works: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L116-L136"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Set the output value of a GPIO Pin. See `bl_gpio_output_set` in &quot;Read and Write GPIO&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span> {
  <span class="comment">//  Omitted: If the GPIO Pin has not been configured for Output, halt</span>
  ...
  <span class="comment">//  Create a GPIO Set Output event</span>
  <span class="kw">let</span> <span class="ident">ev</span> <span class="op">=</span> <span class="ident">SimulationEvent::gpio_output_set</span> { 
    <span class="ident">pin</span>,
    <span class="ident">value</span>,
  };
  <span class="comment">//  Add the event to the JSON Stream of Simulation Events.</span>
  <span class="comment">//  Unsafe because `SIMULATION_EVENTS` is a Static Variable.</span>
  <span class="kw">unsafe</span> {
    <span class="ident">SIMULATION_EVENTS</span>.<span class="ident">push</span>(<span class="ident">ev</span>);
  }
  <span class="comment">//  Return OK</span>
  <span class="number">0</span>
}</pre></div>
<p>See what we did there? To <strong>flip the LED</strong> on / off‚Ä¶</p>
<ol>
<li>
<p>Our Rust Firmware calls <strong><code>gpio::output_set</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">gpio::output_set</span>(<span class="number">11</span>, <span class="number">0</span>)</pre></div>
</li>
<li>
<p>Which is a wrapper function that calls <strong><code>bl_gpio_output_set</code></strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BlResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
  <span class="comment">//  Call the BL602 IoT SDK</span>
  <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span>);</pre></div>
</li>
<li>
<p>Which adds the <strong>Set GPIO Output</strong> event to the JSON Stream of Simulation Events</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span> {
  <span class="comment">//  Create a GPIO Set Output event</span>
  <span class="kw">let</span> <span class="ident">ev</span> <span class="op">=</span> <span class="ident">SimulationEvent::gpio_output_set</span> { <span class="ident">pin</span>, <span class="ident">value</span> };
  <span class="comment">//  Add the event to the JSON Stream of Simulation Events</span>
  <span class="ident">SIMULATION_EVENTS</span>.<span class="ident">push</span>(<span class="ident">ev</span>);</pre></div>
</li>
</ol>
<p>And that‚Äôs how we <strong>intercept calls to BL602 IoT SDK</strong>‚Ä¶ To emit a JSON Stream of Simulation Events!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events3.png" alt="Generating Simulation Events in Rust" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L94-L151">(Source)</a></p>
<h2 id="what-about-c" class="section-header"><a href="#what-about-c">4.3 What about C?</a></h2>
<p><em>Could we have done this in C instead of Rust?</em></p>
<p>Yep but it‚Äôs gonna get messy when we <strong>compose JSON in C</strong>.</p>
<p>Here‚Äôs the original <strong>implementation in C</strong> before converting to Rust‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-events2.png" alt="Generating Simulation Events in C" /></p>
<p><a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/wasm/wasm.c">(Source)</a></p>
<h1 id="html-and-javascript-interface" class="section-header"><a href="#html-and-javascript-interface">5 HTML and JavaScript Interface</a></h1>
<p>We‚Äôve done the Top Half of this pic: Emitting a <strong>JSON Stream of BL602 Simulation Events</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust-simulator.jpg" alt="JSON Stream of BL602 Simulation Events" /></p>
<p>Now we do the Bottom Half: <strong>Web Browser Interface in HTML and JavaScript</strong>!</p>
<p>First we save this sketchy pic of a PineCone BL602 Board as a <strong>PNG file: <a href="https://github.com/lupyuen/ulisp-bl602/blob/wasm/docs/pinecone.png"><code>pinecone.png</code></a></strong></p>
<p><img src="https://lupyuen.github.io/images/wasm-photoshop.png" alt="Creating the BL602 simulator image" /></p>
<p>We <strong>load the PNG file</strong> in our web page: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L8-L14"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">/// Wait for emscripten to be initialised
Module.onRuntimeInitialized = function() {
  // Load the simulator pic and render it
  const image = new Image();
  image.onload = renderSimulator;  //  Draw when image has loaded
  image.src = 'pinecone.png';      //  Image to be loaded
};
</code></pre>
<p>When the pic has been loaded, <strong><code>renderSimulator</code></strong> renders the pic: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L16-L28"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">/// Render the simulator pic. Based on https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
function renderSimulator() {
  //  Get the HTML canvas and context
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  //  Resize the canvas
  canvas.width  = 400;
  canvas.height = 300;

  //  Draw the image to fill the canvas
  ctx.drawImage(this, 0, 0, canvas.width, canvas.height);
}
</code></pre>
<p><em>What‚Äôs the <code>canvas</code>?</em></p>
<p>Emscripten has helpfully generated a <strong>HTML Canvas</strong> in <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/wasm.html#L1238-L1240"><code>wasm.html</code></a> ‚Ä¶</p>
<pre><code class="language-html">&lt;canvas id=&quot;canvas&quot; class=&quot;emscripten&quot; oncontextmenu=&quot;event.preventDefault()&quot; tabindex=-1&gt;&lt;/canvas&gt;
</code></pre>
<p><code>renderSimulator</code> renders our BL602 pic to the HTML Canvas like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<p><em>What about the LED?</em></p>
<p>To simulate the LED switching on <em>(or off)</em>, let‚Äôs draw a <strong>blue rectangle</strong> <em>(or grey rectangle)</em> onto the HTML Canvas: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L121-L144"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">//  Get the HTML Canvas Context
const ctx = document.getElementById('canvas').getContext('2d');

//  For LED On: Set the fill colour to Blue
ctx.fillStyle = '#B0B0FF';  //  Blue

//  For LED Off: Set the fill colour to Grey
//  ctx.fillStyle = '#CCCCCC';  //  Grey

//  Draw the LED colour
ctx.fillRect(315, 116, 35, 74);
</code></pre>
<h2 id="run-rust-firmware" class="section-header"><a href="#run-rust-firmware">5.1 Run Rust Firmware</a></h2>
<p>Watch what happens when we click the <strong>‚ÄúRun‚Äù Button</strong> in our BL602 Simulator: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L30-L81"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">/// Run the command in the input box
function runScript() {
  //  Omitted: Read the command from input box and convert to a function (like `rust_main`)
  ...
  //  Clear the JSON Stream of Simulation Events in WebAssembly
  Module._clear_simulation_events();
</code></pre>
<p>We start by <strong>clearing the JSON Stream</strong> of Simulation Events.</p>
<p>(More about this in the Appendix)</p>
<p>Next we call the <strong><code>rust_main</code></strong> function from our Rust Firmware‚Ä¶</p>
<pre><code class="language-javascript">  //  Execute the WebAssembly Function defined in Rust.
  //  TODO: Pass the command-line args
  Module._rust_main();  //  Omitted: Checking whether `rust_main` exists
</code></pre>
<p>(Yep that‚Äôs a Quantum Leap from JavaScript to WebAssembly to Rust and back!)</p>
<p>Remember: Our Rust Firmware <strong>doesn‚Äôt run in Real Time</strong>.</p>
<p>Our Rust Firmware completes in an instant and <strong>emits a stream of events</strong>. (Including Time Delays)</p>
<p>We <strong>fetch the stream of events</strong> emitted by our Rust Firmware‚Ä¶</p>
<pre><code class="language-javascript">  //  Get the JSON string of Simulation Events from WebAssembly. Looks like...
  //  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  //    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
  const json_ptr = Module._get_simulation_events();
</code></pre>
<p>(More about this in the Appendix)</p>
<p>And convert it from <strong>WebAssembly to JSON</strong>‚Ä¶</p>
<pre><code class="language-javascript">  //  Convert the JSON string from WebAssembly to JavaScript
  const json = Module.UTF8ToString(json_ptr);

  //  Parse the JSON Stream of Simulation Events
  simulation_events = JSON.parse(json);
</code></pre>
<p>Inside <strong><code>simulation_events</code></strong> we have a JSON Stream of Simulation Events, ready for processing!</p>
<h2 id="handle-simulation-events" class="section-header"><a href="#handle-simulation-events">5.2 Handle Simulation Events</a></h2>
<p>Our JavaScript code has <strong>received the JSON Stream</strong> of Simulation Events from the Rust Firmware‚Ä¶</p>
<pre><code class="language-json">[ 
  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } },
  ...
]
</code></pre>
<p>Let‚Äôs <strong>process the events</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L83-L119"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">/// Simulate the BL602 Simulation Events recorded in simulate_events, which contains...
///  [ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, 
///    { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, ... ]
function simulateEvents() {
  //  Take the first event and update the queue
  if (simulation_events.length == 0) { return; }
  const event = simulation_events.shift();
  //  event looks like:
  //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }

  //  Get the event type and parameters
  const event_type = Object.keys(event)[0];
  const args = event[event_type];

  //  Timeout in milliseconds to the next event
  let timeout = 1;
</code></pre>
<p>Here we take the <strong>first event</strong> from the stream.</p>
<p>Then we <strong>handle the event</strong>: Set GPIO Output or Time Delay‚Ä¶</p>
<pre><code class="language-javascript">  //  Handle each event type
  switch (event_type) {

    //  Set GPIO output
    //  { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
    case &quot;gpio_output_set&quot;: timeout += gpio_output_set(args.pin, args.value); break;

    //  Delay
    //  { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }
    case &quot;time_delay&quot;: timeout += time_delay(args.ticks); break;

    //  Unknown event type
    default: throw new Error(&quot;Unknown event type: &quot; + event_type);
  }
</code></pre>
<p>We use a timer to <strong>iterate through the events</strong> in the stream‚Ä¶</p>
<pre><code class="language-javascript">  //  Simulate the next event
  if (simulation_events.length &gt; 0) {
    window.setTimeout(&quot;simulateEvents()&quot;, timeout);
  }
}
</code></pre>
<p><em>What happens inside <code>gpio_output_set</code>, the event handler for Set GPIO Output?</em></p>
<p><code>gpio_output_set</code> renders the <strong>Simulated BL602 LED</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/docs/simulator.js#L121-L144"><code>simulator.js</code></a></p>
<pre><code class="language-javascript">/// Simulate setting GPIO pin output to value 0 (Low) or 1 (High):
/// { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }
function gpio_output_set(pin, value) {
  //  Get the HTML Canvas Context
  const ctx = document.getElementById('canvas').getContext('2d');

  //  Set the simulated LED colour depending on value
  switch (value) {
    //  Set GPIO to Low (LED on)
    case 0: ctx.fillStyle = '#B0B0FF'; break;  //  Blue

    //  Set GPIO to High (LED off)
    case 1: ctx.fillStyle = '#CCCCCC'; break;  //  Grey

    //  Unknown value
    default: throw new Error(&quot;Unknown gpio_output_set value: &quot; + args.value);
  }

  //  Draw the LED colour
  ctx.fillRect(315, 116, 35, 74);

  //  Simulate next event in 0 milliseconds
  return 0;
}
</code></pre>
<p>(Yep we‚Äôve seen this code earlier)</p>
<p>That‚Äôs how we <strong>blink the Simulated LED</strong> through the stream of simulation events!</p>
<p><em>What about <code>time_delay</code>, the event handler for Time Delays?</em></p>
<p><code>time_delay</code> is explained here: <a href="https://lupyuen.github.io/articles/wasm#simulate-delays">‚ÄúSimulate Delays‚Äù</a></p>
<p>(Hint: It simulates Time Delays by calling the JavaScript Timer that we‚Äôve seen earlier)</p>
<h1 id="run-bl602-firmware-in-simulator" class="section-header"><a href="#run-bl602-firmware-in-simulator">6 Run BL602 Firmware in Simulator</a></h1>
<p>Try the <strong>BL602 Rust Firmware Simulator</strong> for yourself!</p>
<ul>
<li><a href="https://lupyuen.github.io/bl602-simulator/"><strong>BL602 Simulator in WebAssembly</strong></a></li>
</ul>
<p>Click the <strong><code>Run</code></strong> Button and watch the LED blink!</p>
<p><img src="https://lupyuen.github.io/images/adc-simulator2.png" alt="BL602 Simulator in WebAssembly" /></p>
<p>To run the BL602 Simulator on our computer (Linux, macOS and Windows)‚Ä¶</p>
<ol>
<li>
<p>Build the <strong>BL602 Rust Firmware</strong> and the BL602 Simulator</p>
<p><a href="https://lupyuen.github.io/articles/rustsim#build-bl602-firmware-for-webassembly">(Instructions here)</a></p>
</li>
<li>
<p>Start a <strong>Local Web Server</strong>, because WebAssembly won‚Äôt run from a filesystem</p>
<p><a href="https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb/overview">(Web Server for Chrome works fine)</a></p>
</li>
<li>
<p>Browse to <strong><code>docs/wasm.html</code></strong></p>
</li>
<li>
<p>Click <strong><code>Run</code></strong></p>
</li>
</ol>
<h1 id="easier-embedded-development" class="section-header"><a href="#easier-embedded-development">7 Easier Embedded Development?</a></h1>
<p><em>Is this easier than building and testing firmware on Real BL602 Hardware?</em></p>
<p>BL602 Simulator could potentially shorten the <strong>Code - Build - Flash - Test Cycle</strong> for Embedded Development‚Ä¶</p>
<ol>
<li>
<p><strong>Code</strong> the firmware in Rust</p>
</li>
<li>
<p><strong>Build</strong> the firmware for WebAssembly</p>
<p>(With a single ‚Äú<code>make</code>‚Äù command on Linux / macOS / Windows)</p>
</li>
<li>
<p><strong>Test and Debug</strong> the firmware in the Simulator</p>
<p>(No BL602 hardware needed, just a Web Browser)</p>
</li>
<li>
<p><strong>Repeat</strong> until the firmware is hunky dory</p>
</li>
<li>
<p><strong>Flash</strong> the firmware to BL602</p>
<p>(Remember: Flashing BL602 via UART is kinda cumbersome)</p>
</li>
</ol>
<p><em>But not all firmware can be simulated right?</em></p>
<p>True, there are limits to what we can simulate.</p>
<p><a href="https://lupyuen.github.io/articles/adc">(Might be tricky to simulate Analog Inputs‚Ä¶ Do we draw a graph?)</a></p>
<p>Even so, the simulator could be really helpful for learners who are <strong>building basic firmware</strong>.</p>
<p>(Maybe attract more Embedded Learners too!)</p>
<p><em>What about the Embedded Pros?</em></p>
<p>Someday BL602 Simulator might also be helpful for Embedded Pros who are <strong>building complex firmware</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Automated Testing</strong> of BL602 Firmware</p>
<p>Remember that our firmware emits a <strong>JSON Stream</strong> of Simulation Events?</p>
<p>This JSON Stream is perfect for checking whether our firmware is <strong>behaving as expected</strong>‚Ä¶ Just <strong>‚Äú<code>diff</code>‚Äù the Expected and Actual</strong> JSON Streams!</p>
</li>
<li>
<p><strong>Tracing Calls to BL602 IoT SDK</strong> for debugging</p>
<p>(Like an embedded ‚Äú<code>strace</code>‚Äù)</p>
</li>
<li>
<p><strong>Validating Calls to BL602 IoT SDK</strong></p>
<p>(More about this in the next chapter)</p>
</li>
</ol>
<p><em>Can we simulate C Firmware? (Instead of Rust Firmware)</em></p>
<p>We could probably <strong>simulate C Firmware</strong> if we‚Ä¶</p>
<ol>
<li>
<p>Tweak the BL602 C Firmware to <strong>build with Emscripten</strong></p>
<p>(By modding the C Header Files and Makefiles)</p>
</li>
<li>
<p>And link the compiled C Firmware with our <strong>Rust Simulator Library</strong></p>
</li>
</ol>
<p>Remember that the BL602 Stub Functions in our Rust Simulator Library are declared <strong>‚Äú<code>extern C</code>‚Äù</strong>?</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span> { ...</pre></div>
<p>Yep this means they can be <strong>called from C Firmware</strong>!</p>
<p>And the BL602 Stub Functions will <strong>emit simulation events</strong>‚Ä¶ Our C Firmware will work exactly like Rust Firmware!</p>
<h1 id="validate-calls-to-bl602-iot-sdk" class="section-header"><a href="#validate-calls-to-bl602-iot-sdk">8 Validate Calls to BL602 IoT SDK</a></h1>
<p><em>What if the Embedded HAL (like BL602 IoT SDK) could tell us how to fix our code?</em></p>
<p>(Wouldn‚Äôt that be great, especially for learners?)</p>
<p>Yep we can help Embedded Learners when we catch <strong>BL602 SDK Calling Errors</strong> and <strong>explain the errors</strong> in a friendly way.</p>
<p>Watch what happens when set the output for a GPIO Pin <strong>without configuring the GPIO</strong> for Output‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-validate2.png" alt="Simulator halts with a friendly message" /></p>
<p>Our simulator <strong>halts with a friendly message</strong>‚Ä¶ And explains how we can fix it!</p>
<p><em>How does our simulator validate calls to BL602 IoT SDK?</em></p>
<p>BL602 Simulator remembers the <strong>configuration of every GPIO Pin</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L33-L45"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Configuration for a BL602 GPIO Pin</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">enum</span> <span class="ident">GpioConfig</span> {
  <span class="doccomment">/// GPIO Pin is unconfigured</span>
  <span class="ident">Unconfigured</span>,
  <span class="doccomment">/// GPIO Pin is configured for Input</span>
  <span class="ident">Input</span>,
  <span class="doccomment">/// GPIO Pin is configured for Output</span>
  <span class="ident">Output</span>,
}

<span class="doccomment">/// Configurations for all BL602 GPIO Pins</span>
<span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">GPIO_CONFIGS</span>: [<span class="ident">GpioConfig</span>; <span class="number">32</span>] <span class="op">=</span> [<span class="ident">GpioConfig::Unconfigured</span>; <span class="number">32</span>];</pre></div>
<p>We <strong>update the GPIO Configuration</strong> whenever the GPIO is configured for Input or Output: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L105-L114"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in &quot;Enable GPIO&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">_pullup</span>: <span class="ident">u8</span>, <span class="ident">_pulldown</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span> {
  <span class="comment">//  Remember that the GPIO Pin has been configured for Output</span>
  <span class="ident">GPIO_CONFIGS</span>[<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">usize</span>] <span class="op">=</span> <span class="ident">GpioConfig::Output</span>;</pre></div>
<p>While setting the GPIO output value, we <strong>raise an error</strong> if the GPIO Configuration is incorrect: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L116-L136"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Set the output value of a GPIO Pin. See `bl_gpio_output_set` in &quot;Read and Write GPIO&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">c_int</span> {
  <span class="comment">//  If the GPIO Pin has not been configured for Output, halt</span>
  <span class="macro">assert!</span>(
    <span class="ident">GPIO_CONFIGS</span>[<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">usize</span>] <span class="op">=</span><span class="op">=</span> <span class="ident">GpioConfig::Output</span>,
    <span class="string">&quot;GPIO {} is {:?}, unable to set the GPIO Output Value. Please configure the GPIO for Output with `gpio::enable_output(pin, pullup, pulldown)` or `bl_gpio_enable_output(pin, pullup, pulldown)`. See \&quot;Enable GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;&quot;</span>,
    <span class="ident">pin</span>, <span class="ident">GPIO_CONFIGS</span>[<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">usize</span>]
  );</pre></div>
<p>That‚Äôs how we make BL602 Simulator a little more helpful for Embedded Learners‚Ä¶ By validating the calls to BL602 IoT SDK!</p>
<p><img src="https://lupyuen.github.io/images/rustsim-validate3.png" alt="Validate Calls to BL602 IoT SDK" /></p>
<h1 id="pinedio-stack-bl604" class="section-header"><a href="#pinedio-stack-bl604">9 PineDio Stack BL604</a></h1>
<p><em>Simulating a plain BL602 board (like PineCone BL602) is pointless, innit?</em></p>
<p>Yep simulating a <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> ain‚Äôt particularly exciting because it only has‚Ä¶</p>
<ol>
<li>
<p>One <strong>RGB LED</strong></p>
</li>
<li>
<p>One <strong>Jumper</strong> (GPIO 8)</p>
</li>
<li>
<p>And everything else needs to be wired to the <strong>GPIO Pins</strong></p>
<p>(Which makes it harder to simulate actually)</p>
</li>
</ol>
<p>Compare this with the <a href="https://www.pine64.org/2021/08/15/introducing-the-pinenote/"><strong>PineDio Stack BL604</strong></a> which has‚Ä¶</p>
<ol>
<li>
<p><strong>SPI Display</strong> (with LVGL Graphics Library)</p>
</li>
<li>
<p><strong>LoRa SX1262 Transceiver</strong></p>
</li>
<li>
<p><strong>Motion Sensor</strong></p>
</li>
<li>
<p><strong>Heart Rate Sensor</strong></p>
</li>
<li>
<p><strong>Battery Charging Chip</strong> </p>
</li>
</ol>
<p>All this in a compact 3.5 cm¬≤ form factor!</p>
<p>It makes a lot more sense to <strong>simulate the PineDio Stack</strong>, because it‚Äôs a super interesting gadget for Embedded Learners.</p>
<p>Stay tuned for an updated simulator with support for <strong>LVGL, LoRa and LoRaWAN!</strong></p>
<p><img src="https://lupyuen.github.io/images/rustsim-pinedio.png" alt="PineDio Stack Schematic" /></p>
<h1 id="scripting-for-bl602-simulator" class="section-header"><a href="#scripting-for-bl602-simulator">10 Scripting for BL602 Simulator</a></h1>
<p>To make BL602 Simulator even more useful for Embedded Learners, we‚Äôre adding the <a href="https://rhai.rs/book/"><strong>Rhai Scripting Engine</strong></a> to the simulator‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rustsim-script2.png" alt="Rhai Scripting for BL602 Simulator" /></p>
<p><a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-script/src/lib.rs">(Source)</a></p>
<p>Thus we‚Äôll allow BL602 Simulator to be used in two ways‚Ä¶</p>
<ol>
<li>
<p><strong>The Traditional Way:</strong></p>
<p>Code the program in Rust. Compile to WebAssembly. Test with Simulator.</p>
<p><em>‚Ä¶OR‚Ä¶</em></p>
</li>
<li>
<p><strong>The Scripted REPL Way:</strong></p>
<p>Code the program in <strong>Rhai Script</strong>. (Which looks like Rust)</p>
<p>Type the Rhai Script <strong>directly into the Web Browser</strong>. (No compiler needed)</p>
<p>Test with Simulator.</p>
</li>
</ol>
<p><em>Why would we need The Scripted REPL Way?</em></p>
<p>Because Scripted REPL platforms like <strong>uLisp</strong> and <strong>MicroPython</strong> are still popular with Embedded Learners.</p>
<p>For BL602, perhaps learners could <strong>start with (Rust-like) Rhai Script</strong>‚Ä¶ </p>
<p>And <strong>upgrade to Rust</strong> (or C) when they‚Äôre ready.</p>
<h2 id="drag-and-drop-scripting" class="section-header"><a href="#drag-and-drop-scripting">10.1 Drag and Drop Scripting</a></h2>
<p><em>I sense another upcoming enhancement?</em></p>
<p>Yes! Since we‚Äôre adding a <strong>Scripting Engine</strong> to the simulator‚Ä¶</p>
<p>Why not make it super easy to create scripts: The <strong>Drag-and-Drop Way</strong>!</p>
<p><img src="https://lupyuen.github.io/images/wasm-title.png" alt="BL602 Simulator with Visual Programming" /></p>
<p>(We‚Äôll change the box at lower right to Rust-like Rhai Script)</p>
<p><em>Can we do this through a Desktop App? (Instead of Web Browser)</em></p>
<p>Possibly, if we wrap the Web Browser Interface into a <strong>Desktop App with Tauri</strong>. <a href="https://tauri.studio/en/">(See this)</a></p>
<h2 id="run-scripts-on-bl602" class="section-header"><a href="#run-scripts-on-bl602">10.2 Run Scripts on BL602</a></h2>
<p><em>Rhai Scripts run OK on our simulator with WebAssembly. But will the scripts run on Real BL602 Hardware?</em></p>
<p>Sadly no. Rhai Scripting Engine is <strong>too heavy for BL602</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/adc/customer_app/sdk_app_rust_script">(See this)</a></p>
<p>But we could auto-convert / <strong>transcode Rhai Script to uLisp</strong>, which runs fine on BL602.</p>
<p>(More about Rhai Transcoding in the Appendix)</p>
<p><em>Can we transmit uLisp to BL602 from the Web Browser?</em></p>
<p>Yes, we may automagically transmit the transcoded uLisp from Web Browser to BL602 with the <strong>Web Serial API</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/lisp#web-browser-controls-bl602-with-web-serial-api">(More about Web Serial API)</a></p>
<p>Which means our learners will‚Ä¶</p>
<ol>
<li>
<p>Use a Web Browser to <strong>drag and drop</strong> the blocks to create a visual program</p>
</li>
<li>
<p>Which will <strong>auto-generate the Rhai Script</strong> for the visual program</p>
</li>
<li>
<p>And the Rhai Script will be <strong>auto-transmitted to BL602</strong> for execution</p>
<p>(After the Rhai Script has been transcoded to uLisp)</p>
</li>
</ol>
<p><em>You sound pretty confident about Drag-and-Drop Scripting. Have we done this before?</em></p>
<p>Yep we‚Äôve previously experimented with <strong>Blockly (Scratch), uLisp and Rust</strong>.</p>
<p>Now that we‚Äôre switching to <strong>Rhai Script</strong>, things might get simpler‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lisp"><strong>‚ÄúuLisp and Blockly on PineCone BL602 RISC-V Board‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/wasm"><strong>‚ÄúSimulate RISC-V BL602 with WebAssembly, uLisp and Blockly‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/visual-embedded-rust-programming-with-visual-studio-code"><strong>‚ÄúVisual Embedded Rust Programming with Visual Studio Code‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/advanced-topics-for-visual-embedded-rust-programming"><strong>‚ÄúAdvanced Topics for Visual Embedded Rust Programming‚Äù</strong></a></p>
</li>
</ul>
<p>(In the last article above we did some complicated Type Inference in Rust. Thankfully that‚Äôs no longer necessary for Rhai Script)</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>We have a lot of work coming up!</p>
<ol>
<li>
<p><strong>Rhai Scripting Engine</strong> <a href="https://github.com/lupyuen/bl602-simulator/tree/main/bl602-script">(See this)</a></p>
</li>
<li>
<p><strong>Drag-and-Drop Scripting</strong> <a href="https://github.com/lupyuen2/blockly-bl602">(with Blockly)</a></p>
</li>
<li>
<p><strong>Transcoding Rhai Script to uLisp</strong></p>
</li>
<li>
<p><strong>Integrating uLisp with BL602 IoT SDK</strong> <a href="https://github.com/lupyuen/ulisp-bl602/tree/sdk">(See this)</a></p>
</li>
</ol>
<p><a href="https://twitter.com/MisterTechBlog/status/1427758328004759552"><strong>(Follow the updates in this Twitter Thread)</strong></a></p>
<p>And soon we shall test all this on <a href="https://www.pine64.org/2021/08/15/introducing-the-pinenote/"><strong>PineDio Stack BL604 with LoRa SX1262</strong></a>‚Ä¶ As we explore whether it‚Äôs feasible to teach <strong>Rust (or Rhai) as a Safer Way</strong> to create firmware for BL602 and BL604.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/comments/p5shdi/rust_on_riscv_bl602_simulated_with_webassembly/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rustsim.md"><code>lupyuen.github.io/src/rustsim.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">12 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1423169766080933891">this Twitter Thread</a></p>
</li>
<li>
<p><strong>Mbed OS</strong> has a simulator based on C++ and Emscripten. <a href="https://os.mbed.com/blog/entry/introducing-mbed-simulator/">(See this)</a></p>
</li>
</ol>
<h1 id="appendix-rhai-scripts-on-bl602" class="section-header"><a href="#appendix-rhai-scripts-on-bl602">13 Appendix: Rhai Scripts on BL602</a></h1>
<p><em>We can run Rhai Scripts in our Web Browser thanks to WebAssembly‚Ä¶</em></p>
<p><em>How will we run Rhai Scripts on Real BL602 Hardware?</em></p>
<p>Sadly Rhai Scripting Engine is <strong>too heavy for BL602</strong>. <a href="https://github.com/lupyuen/bl_iot_sdk/tree/adc/customer_app/sdk_app_rust_script">(See this)</a></p>
<p>But we could auto-convert / <strong>transcode Rhai Script to uLisp</strong>, which runs fine on BL602.</p>
<p>We‚Äôll do the <strong>transcoding in the Web Browser</strong> with WebAssembly, since it has a lot more RAM than BL602.</p>
<p><em>Why uLisp?</em></p>
<p>Because uLisp is a <strong>tiny Lisp Interpreter</strong> (coded in C) that runs well on BL602 with little RAM.</p>
<p><a href="https://lupyuen.github.io/articles/lisp">(More about uLisp on BL602)</a></p>
<p>Transcoded uLisp will be in the <strong>S-Expression Format</strong>. (Which looks a little like WebAssembly)</p>
<p>Hence this Rust-like <strong>Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">gpio::output_set</span>(<span class="number">11</span>, <span class="number">0</span>);</pre></div>
<p>Shall be transcoded to this <strong>uLisp S-Expression</strong>‚Ä¶</p>
<pre><code class="language-text">( bl_gpio_output_set 11 0 )
</code></pre>
<p><em>But will uLisp let us call C functions defined in BL602 IoT SDK?</em></p>
<p>Yep uLisp lets us <strong>expose a C function</strong> from BL602 IoT SDK like so: <a href="https://github.com/lupyuen/ulisp-bl602/blob/sdk/src/ulisp.c#L4164-L4186"><code>ulisp.c</code></a></p>
<pre><code class="language-c">//  Expose the C function `bl_gpio_output_set` to uLisp:
//  `int bl_gpio_output_set(uint8_t pin, uint8_t value)`
object *fn_bl_gpio_output_set(object *args, object *env) {
  //  Fetch the `pin` parameter from uLisp
  assert(args != NULL);
  int pin = checkinteger(BL_GPIO_OUTPUT_SET, car(args));
  args = cdr(args);

  //  Fetch the `value` parameter from uLisp
  assert(args != NULL);
  int value = checkinteger(BL_GPIO_OUTPUT_SET, car(args));
  args = cdr(args);

  //  No more parameters
  assert(args == NULL);

  //  Call the C function `bl_gpio_output_set`
  int result = bl_gpio_output_set(pin, value);

  //  Return the result to uLisp
  return number(result);
}
</code></pre>
<p>Which will be <strong>called from uLisp</strong> like so‚Ä¶</p>
<pre><code class="language-text">( bl_gpio_output_set 11 0 )
</code></pre>
<p><a href="http://www.ulisp.com/show?19Q4">(More about this)</a></p>
<p><em>How shall we transcode Rhai Script to uLisp?</em></p>
<p>The Rhai Scripting Engine compiles Rhai Script into an <strong>Abstract Syntax Tree</strong>. <a href="https://rhai.rs/book/engine/compile.html">(See this)</a></p>
<p>We shall <strong>traverse the nodes</strong> in the tree and <strong>emit uLisp S-Expressions</strong>.</p>
<p>Thus this <strong>Rhai Script</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">gpio::output_set</span>(<span class="number">11</span>, <span class="number">0</span>);</pre></div>
<p>Shall emit this <strong>uLisp S-Expression</strong>‚Ä¶</p>
<pre><code class="language-text">( bl_gpio_output_set 11 0 )
</code></pre>
<p>The transcoding implementation will probably look similar to‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/ast"><strong>‚ÄúAuto Convert Go to Dart with an Abstract Syntax Tree‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><strong><code>safe_wrap</code> Procedural Macro</strong></a></p>
</li>
</ul>
<p><em>Why are we doing this in Rust?</em></p>
<p>Because thanks to <code>bindgen</code>, we have complete info on the <strong>BL602 IoT SDK interfaces</strong> (functions, parameters, return types).</p>
<p>Which lets us <strong>manipulate the BL602 SDK interfaces</strong> and do cool things like‚Ä¶</p>
<ol>
<li>
<p><strong>Generate the uLisp Stubs</strong> for BL602 IoT SDK</p>
</li>
<li>
<p><strong>Generate the Rhai Stubs</strong> for BL602 IoT SDK</p>
</li>
<li>
<p><strong>Transcode Rhai Calls</strong> (BL602 IoT SDK) into uLisp</p>
</li>
<li>
<p><strong>Generate the Rust Wrapper</strong> for BL602 IoT SDK</p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs">(Via the <code>safe_wrap</code> Procedural Macro)</a></p>
</li>
</ol>
<h1 id="appendix-rust-simulation-events" class="section-header"><a href="#appendix-rust-simulation-events">14 Appendix: Rust Simulation Events</a></h1>
<p><em>How is the JSON Stream of Simulation Events accessed via the Rust Simulator Library?</em></p>
<p>Remember that we maintain a <strong>Vector of Simulation Events</strong> in Rust: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L23-L31"><code>bl602-simulator/lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Vector of Simulation Events (i.e. event array)</span>
<span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">SIMULATION_EVENTS</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">SimulationEvent</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::new</span>();</pre></div>
<p>But we can‚Äôt expose this Rust Vector to WebAssembly and JavaScript.</p>
<p>Thus we define an <strong>Event Buffer</strong> that exposes the vector as a JSON String‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// String Buffer that returns the JSON Stream of Simulation Events:</span>
<span class="doccomment">/// `[ { &quot;gpio_output_set&quot;: { &quot;pin&quot;: 11, &quot;value&quot;: 1 } }, </span>
<span class="doccomment">///   { &quot;time_delay&quot;: { &quot;ticks&quot;: 1000 } }, </span>
<span class="doccomment">///   ... </span>
<span class="doccomment">/// ]`</span>
<span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">EVENT_BUFFER</span>: [<span class="ident">u8</span>; <span class="number">1024</span>] <span class="op">=</span> [<span class="number">0</span>; <span class="number">1024</span>];</pre></div>
<p>When our JavaScript code calls <code>get_simulation_events</code> to fetch the Simulation Events, we <strong>convert the Rust Vector to JSON</strong> and <strong>copy it into the Event Buffer</strong>: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L58-L92"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Return the JSON Stream of Simulation Events</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">get_simulation_events</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> {
    <span class="comment">//  Convert vector of events to a JSON string</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">serialized</span> <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="ident">serde_json::to_string</span>(<span class="kw-2">&amp;</span><span class="ident">SIMULATION_EVENTS</span>)
    }.<span class="ident">unwrap</span>();

    <span class="comment">//  Terminate the JSON string with null, since we will be returning to C</span>
    <span class="ident">serialized</span>.<span class="ident">push</span>(<span class="string">&#39;\0&#39;</span>);

    <span class="comment">//  Check that JSON string fits into the Event Buffer</span>
    <span class="macro">assert!</span>(<span class="ident">serialized</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">EVENT_BUFFER</span>.<span class="ident">len</span>() });

    <span class="comment">//  Copy the JSON string to the Event Buffer</span>
    <span class="kw">unsafe</span> {                            <span class="comment">//  Unsafe because we are copying raw memory</span>
        <span class="ident">std::ptr::copy</span>(                 <span class="comment">//  Copy the memory...</span>
            <span class="ident">serialized</span>.<span class="ident">as_ptr</span>(),        <span class="comment">//  From Source (JSON String)</span>
            <span class="ident">EVENT_BUFFER</span>.<span class="ident">as_mut_ptr</span>(),  <span class="comment">//  To Destination (mutable pointer to Event Buffer)</span>
            <span class="ident">serialized</span>.<span class="ident">len</span>()            <span class="comment">//  Number of Items (each item is 1 byte)</span>
        );    
    }
      
    <span class="comment">//  Return the Event Buffer</span>
    <span class="kw">unsafe</span> {
        <span class="ident">EVENT_BUFFER</span>.<span class="ident">as_ptr</span>()
    }
}</pre></div>
<p>Yep it‚Äôs possible that our serialized vector <strong>won‚Äôt fit into the Event Buffer</strong>.</p>
<p>To mitigate this, we ought to <strong>check the serialized vector size</strong> whenever we add an event‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Add an Simulation Event</span>
<span class="kw">fn</span> <span class="ident">add_event</span>(<span class="ident">ev</span>: <span class="ident">SimulationEvent</span>) {
    <span class="comment">//  Add the event to the vector</span>
    <span class="ident">SIMULATION_EVENTS</span>.<span class="ident">push</span>(<span class="ident">ev</span>);

    <span class="comment">//  Convert vector of events to a JSON string</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">serialized</span> <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="ident">serde_json::to_string</span>(<span class="kw-2">&amp;</span><span class="ident">SIMULATION_EVENTS</span>)
    }.<span class="ident">unwrap</span>();

    <span class="comment">//  If the JSON string doesn&#39;t fit into the Event Buffer...</span>
    <span class="kw">if</span> (<span class="ident">serialized</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="number">1</span> <span class="op">&gt;</span> <span class="kw">unsafe</span> { <span class="ident">EVENT_BUFFER</span>.<span class="ident">len</span>() }) {
        <span class="comment">//  Remove the event from the vector and stop the simulation</span></pre></div>
<p>Here‚Äôs how we <strong>initialise the Vector of Simulation Events</strong> before use: <a href="https://github.com/lupyuen/bl602-simulator/blob/main/bl602-simulator/src/lib.rs#L47-L56"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Clear the JSON Stream of Simulation Events</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">clear_simulation_events</span>() {
    <span class="comment">//  Clear the vector of Simulation Events</span>
    <span class="kw">unsafe</span> {
        <span class="ident">SIMULATION_EVENTS</span>.<span class="ident">clear</span>();
    }
    <span class="comment">//  Show Rust Backtrace on error</span>
    <span class="ident">std::env::set_var</span>(<span class="string">&quot;RUST_BACKTRACE&quot;</span>, <span class="string">&quot;full&quot;</span>);
}</pre></div>

    
</body>
</html>