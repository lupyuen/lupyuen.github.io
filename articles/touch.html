<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX Touch Panel Driver for PineDio Stack BL604</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX Touch Panel Driver for PineDio Stack BL604" 
    data-rh="true">
<meta property="og:description" 
    content="How we created the Apache NuttX RTOS Driver for Hynitron CST816S I2C Touch Panel... For PineDio Stack BL604 RISC-V Board"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/touch-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX Touch Panel Driver for PineDio Stack BL604</h1>
    <nav id="TOC"><ul>
<li><a href="#cst816s-touch-panel">1 CST816S Touch Panel</a><ul>
<li><a href="#cst816s-pins">1.1 CST816S Pins</a><ul></ul></li></ul></li>
<li><a href="#nuttx-touchscreen-drivers">2 NuttX Touchscreen Drivers</a><ul>
<li><a href="#touch-data">2.1 Touch Data</a><ul></ul></li>
<li><a href="#read-touch-data">2.2 Read Touch Data</a><ul></ul></li></ul></li>
<li><a href="#load-the-driver">3 Load The Driver</a><ul></ul></li>
<li><a href="#initialise-driver">4 Initialise Driver</a><ul></ul></li>
<li><a href="#gpio-interrupt">5 GPIO Interrupt</a><ul>
<li><a href="#test-gpio-interrupt">5.1 Test GPIO Interrupt</a><ul></ul></li></ul></li>
<li><a href="#fetch-touch-data">6 Fetch Touch Data</a><ul>
<li><a href="#get-i2c-touch-data">6.1 Get I2C Touch Data</a><ul></ul></li>
<li><a href="#is-data-ready">6.2 Is Data Ready?</a><ul></ul></li></ul></li>
<li><a href="#run-the-driver">7 Run The Driver</a><ul>
<li><a href="#read-touch-data-1">7.1 Read Touch Data</a><ul></ul></li>
<li><a href="#trigger-gpio-interrupt">7.2 Trigger GPIO Interrupt</a><ul></ul></li>
<li><a href="#touch-down-event">7.3 Touch Down Event</a><ul></ul></li>
<li><a href="#touch-down-event-again">7.4 Touch Down Event Again</a><ul></ul></li>
<li><a href="#touch-up-event">7.5 Touch Up Event</a><ul></ul></li>
<li><a href="#screen-calibration-result">7.6 Screen Calibration Result</a><ul></ul></li></ul></li>
<li><a href="#screen-is-sideways">8 Screen Is Sideways</a><ul></ul></li>
<li><a href="#i2c-quirks">9 I2C Quirks</a><ul>
<li><a href="#i2c-sub-address">9.1 I2C Sub Address</a><ul></ul></li>
<li><a href="#i2c-logging">9.2 I2C Logging</a><ul></ul></li></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li></ul></nav><p>üìù <em>21 Apr 2022</em></p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><em>Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board</em></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> is Pine64‚Äôs newest microcontroller board, based on <a href="https://lupyuen.github.io/articles/pinecone"><strong>Bouffalo Lab‚Äôs BL604</strong></a> RISC-V + WiFi + Bluetooth LE SoC.</p>
<p>(Available any day now!)</p>
<p>PineDio Stack is super interesting for an IoT Gadget‚Ä¶</p>
<p>It comes with a <strong>Colour LCD Touchscreen!</strong> (240 x 240 pixels)</p>
<ul>
<li><a href="https://www.youtube.com/shorts/2Nzjrlp5lcE"><strong>Watch the demo on YouTube</strong></a></li>
</ul>
<p>Today we‚Äôll talk about PineDio Stack‚Äôs <strong>Hynitron CST816S I2C Touch Panel</strong> and the driver we created for <a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/cst816s-nuttx"><strong>lupyuen/cst816s-nuttx</strong></a></li>
</ul>
<p>Which was inspired by JF‚Äôs CST816S Driver for PineDio Stack‚Ä¶ (Thanks JF!)</p>
<ul>
<li><a href="https://codeberg.org/JF002/pinedio-stack-selftest/src/branch/master/drivers/cst816s.c"><strong>pinedio-stack-selftest/drivers/cst816s.c</strong></a></li>
</ul>
<p>Let‚Äôs go inside the driver‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-inside.jpg" alt="Touch Panel is connected in the middle, between the connectors for the Heart Rate Sensor (bottom left) and ST7789 Display (top left)" /></p>
</blockquote>
<blockquote>
<p><em>Touch Panel is connected in the middle, between the connectors for the Heart Rate Sensor (bottom left) and ST7789 Display (top left)</em></p>
</blockquote>
<h1 id="cst816s-touch-panel"><a href="#cst816s-touch-panel">1 CST816S Touch Panel</a></h1>
<p><em>What is CST816S? Where is it used?</em></p>
<p>Inside PineDio Stack is <strong>CST816S</strong>, an <strong>I2C Capacitive Touch Panel</strong> by Hynitron‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/CST816S_DS_V1.3.pdf"><strong>Hynitron CST816S Datasheet</strong></a></li>
</ul>
<p>We don‚Äôt have the detailed docs for CST816S, but we have a <strong>Reference Driver</strong> for the Touch Panel‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/hynitron_i2c_cst0xxse"><strong>Hynitron Reference Driver</strong></a></li>
</ul>
<p>This is the same Touch Panel used in Pine64‚Äôs <strong>PineTime Smartwatch</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/building-a-rust-driver-for-pinetimes-touch-controller"><strong>‚ÄúBuilding a Rust Driver for PineTime‚Äôs Touch Controller‚Äù</strong></a></li>
</ul>
<p>Which explains why we have so many drivers available for CST816S: <a href="https://www.arduino.cc/reference/en/libraries/cst816s/"><strong>Arduino</strong></a>,  <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp"><strong>FreeRTOS</strong></a>, <a href="https://doc.riot-os.org/group__drivers__cst816s.html"><strong>RIOT OS</strong></a>, <a href="https://github.com/tstellanova/cst816s"><strong>Rust</strong></a>, <a href="https://najnesnaj.github.io/pinetime-zephyr/drivers/cst816s.html"><strong>Zephyr OS</strong></a>, ‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-sleep.png" alt="CST816S Operating Modes" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/CST816S_DS_V1.3.pdf">(From CST816S Datasheet)</a></p>
</blockquote>
<p><em>So it works like any other I2C Device?</em></p>
<p>CST816S is a peculiar I2C Device‚Ä¶ It won‚Äôt respond to I2C Commands until we <strong>tap the screen and wake it up</strong>!</p>
<p>That‚Äôs because it tries to conserve power: It powers off the I2C Interface when it‚Äôs not in use. (Pic above)</p>
<p>So be careful when scanning for CST816S at its <strong>I2C Address <code>0x15</code></strong>. It might seem elusive until we tap the screen.</p>
<p>The I2C Address of CST816S is defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L102-L107">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_INPUT_CST816S
/* I2C Address of CST816S Touch Controller */
#define CST816S_DEVICE_ADDRESS 0x15
#include &lt;nuttx/input/cst816s.h&gt;
#endif /* CONFIG_INPUT_CST816S */</code></pre></div>
<blockquote>
<p><img src="https://lupyuen.github.io/images/pinedio2-touch.png" alt="PineDio Stack Touch Panel" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/lupyuen/pinedio-stack-nuttx/blob/main/pinedio_stack_v1_0-2021_09_15-a.pdf">(From PineDio Stack Schematic)</a></p>
</blockquote>
<h2 id="cst816s-pins"><a href="#cst816s-pins">1.1 CST816S Pins</a></h2>
<p><em>How is CST816S wired to PineDio Stack?</em></p>
<p>According to the schematic above, CST816S is wired to PineDio Stack like so‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL604 Pin</th><th style="text-align: left">CST816S Pin</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: left"><code>SDA</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: left"><code>SCL</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 9</code></strong></td><td style="text-align: left"><code>Interrupt</code></td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 18</code></strong></td><td style="text-align: left"><code>Reset</code></td></tr>
</tbody></table>
</div>
<p>(We won‚Äôt use the <strong>Reset</strong> pin in our driver)</p>
<p>The <strong>CST816S Pins</strong> are defined in <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/include/board.h#L92-L131">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | GPIO_PIN2)
#define BOARD_I2C_SDA (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | GPIO_PIN1)
...
#ifdef CONFIG_INPUT_CST816S
/* CST816S Touch Controller for PineDio Stack: GPIO Interrupt */
#define BOARD_TOUCH_INT (GPIO_INPUT | GPIO_FLOAT | GPIO_FUNC_SWGPIO | GPIO_PIN9)
#endif  /* CONFIG_INPUT_CST816S */</code></pre></div>
<p><em>What‚Äôs the Interrupt Pin?</em></p>
<p>When we touch the screen, CST816S triggers a <strong>GPIO Interrupt</strong> and activates the I2C Interface (for a short while).</p>
<p>Note that CST816S <strong>doesn‚Äôt trigger an interrupt</strong> when the screen is <strong>no longer touched</strong>.</p>
<p>We‚Äôll handle this in our CST816S Driver.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-device.png" alt="NuttX Touchscreen Device" /></p>
</blockquote>
<h1 id="nuttx-touchscreen-drivers"><a href="#nuttx-touchscreen-drivers">2 NuttX Touchscreen Drivers</a></h1>
<p><em>How do Touchscreen Drivers work on NuttX?</em></p>
<ul>
<li>
<p>At NuttX Startup, Touchscreen Drivers register themselves as ‚Äú<strong>/dev/input0</strong>‚Äù</p>
<p>(Pic above)</p>
</li>
<li>
<p>NuttX Apps will open ‚Äú<strong>/dev/input0</strong>‚Äù and call <strong><code>read()</code></strong> to fetch <strong>Touch Data Samples</strong> from the driver</p>
<p>(More about this in the next section)</p>
</li>
<li>
<p>NuttX Apps may call <strong><code>poll()</code></strong> to wait for available data</p>
<p>(Which blocks on a NuttX Semaphore until the data is available)</p>
</li>
</ul>
<p>Touchscreen Drivers are documented here‚Ä¶</p>
<ul>
<li><a href="https://nuttx.apache.org/docs/latest/components/drivers/character/touchscreen.html"><strong>NuttX Touchscreen Drivers</strong></a></li>
</ul>
<p>We learnt more by inspecting these Touchscreen Drivers‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/cypress_mbr3108.c"><strong>NuttX I2C Driver for Cypress MBR3108</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/max11802.c"><strong>NuttX SPI Driver for Maxim MAX11802</strong></a></p>
</li>
</ul>
<p>The MBR3108 Driver looks structurally similar to our CST816S Driver (since both are I2C). So we copied the code as we built our CST816S Driver.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/drivers/input/max11802.c#L824-L952">(We copied the MAX11802 Driver for reading Touch Data Samples)</a></p>
<p>Let‚Äôs talk about the data format‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-code3a.jpg" alt="NuttX Touch Data" /></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L113-L148">(Source)</a></p>
<h2 id="touch-data"><a href="#touch-data">2.1 Touch Data</a></h2>
<p><em>How are Touch Data Samples represented in NuttX?</em></p>
<p>NuttX defines a standard data format for <strong>Touch Data Samples</strong> that are returned by Touchscreen Drivers‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* The typical touchscreen driver is a read-only, input character device
 * driver.the driver write() method is not supported and any attempt to
 * open the driver in any mode other than read-only will fail.
 *
 * Data read from the touchscreen device consists only of touch events and
 * touch sample data.  This is reflected by struct touch_sample_s.  This
 * structure is returned by either the driver read method.
 *
 * On some devices, multiple touchpoints may be supported. So this top level
 * data structure is a struct touch_sample_s that &quot;contains&quot; a set of touch
 * points.  Each touch point is managed individually using an ID that
 * identifies a touch from first contact until the end of the contact.
 */
struct touch_sample_s
{
  int npoints;                   /* The number of touch points in point[] */
  struct touch_point_s point[1]; /* Actual dimension is npoints */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L130-L148">(Source)</a></p>
<p>For our driver, we‚Äôll return only <strong>one Touch Point</strong>.</p>
<p>Here‚Äôs the NuttX Definition of a <strong>Touch Point</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/* This structure contains information about a single touch point.
 * Positional units are device specific.
 */
struct touch_point_s
{
  uint8_t  id;        /* Unique identifies contact; Same in all reports for the contact */
  uint8_t  flags;     /* See TOUCH_* definitions above */
  int16_t  x;         /* X coordinate of the touch point (uncalibrated) */
  int16_t  y;         /* Y coordinate of the touch point (uncalibrated) */
  int16_t  h;         /* Height of touch point (uncalibrated) */
  int16_t  w;         /* Width of touch point (uncalibrated) */
  uint16_t gesture;   /* Gesture of touchscreen contact */
  uint16_t pressure;  /* Touch pressure */
  uint64_t timestamp; /* Touch event time stamp, in microseconds */
};</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L109-L128">(Source)</a></p>
<p>Our driver returns the first 4 fields‚Ä¶</p>
<ul>
<li>
<p><strong>id</strong>: Always 0, since we detect one Touch Point</p>
</li>
<li>
<p><strong>flags</strong>: We return a combination of these flags‚Ä¶</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L94"><strong>TOUCH_ID_VALID</strong></a>: Touch Point ID is always valid</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L91"><strong>TOUCH_DOWN</strong></a> or <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L93"><strong>TOUCH_UP</strong></a>: Touch Down or Up</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/include/nuttx/input/touchscreen.h#L95"><strong>TOUCH_POS_VALID</strong></a>: If Touch Coordinates are valid</p>
<p>(Touch Coordinates are valid for Touch Down, not Touch Up)</p>
</li>
<li>
<p><strong>x</strong>: X Coordinate of the Touch Point (0 to 239)</p>
</li>
<li>
<p><strong>y</strong>: Y Coordinate of the Touch Point (0 to 239)</p>
</li>
</ul>
<p>And sets the remaining fields to 0.</p>
<p><em>What about Touch Gestures? Like swiping and scrolling?</em></p>
<p><strong>Touch Gestures</strong> are supported in the CST816S Driver for PineTime InfiniTime. <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp#L80-L94">(See this)</a></p>
<p>Someday we might support Touch Gestures in our NuttX Driver.</p>
<h2 id="read-touch-data"><a href="#read-touch-data">2.2 Read Touch Data</a></h2>
<p>NuttX Apps will open ‚Äú<strong>/dev/input0</strong>‚Äù and call <strong><code>read()</code></strong> repeatedly to fetch <strong>Touch Data Samples</strong> from the driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Open &quot;/dev/input0&quot;
int fd = open(&quot;/dev/input0&quot;, O_RDONLY | O_NONBLOCK);

//  Read one sample
struct touch_sample_s sample;
int nbytes = read(fd, &amp;sample, sizeof(struct touch_sample_s));</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L62-L132">(Source)</a></p>
<p>This populates a <strong>touch_sample_s</strong> struct, which we‚Äôve seen earlier.</p>
<p>The code above comes from the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>, which we‚Äôll run later to test our driver.</p>
<p>(Calling <strong><code>read()</code></strong> repeatedly might be bad for performance, instead we should call <strong><code>poll()</code></strong> to block until touch data is available)</p>
<h1 id="load-the-driver"><a href="#load-the-driver">3 Load The Driver</a></h1>
<p>Before we cover the internals of our driver, let‚Äôs <strong>load the CST816S Driver</strong> at NuttX Startup: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/src/bl602_bringup.c#L829-L846">bl602_bringup.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_INPUT_CST816S
//  I2C Address of CST816S Touch Controller
#define CST816S_DEVICE_ADDRESS 0x15
#include &lt;nuttx/input/cst816s.h&gt;
#endif  //  CONFIG_INPUT_CST816S
...
#ifdef CONFIG_INPUT_CST816S
int bl602_bringup(void) {
  ...
  //  Init I2C bus for CST816S
  struct i2c_master_s *cst816s_i2c_bus = bl602_i2cbus_initialize(0);
  if (!cst816s_i2c_bus) {
    _err(&quot;ERROR: Failed to get I2C%d interface\n&quot;, 0);
  }

  //  Register the CST816S driver
  ret = cst816s_register(
    &quot;/dev/input0&quot;,          //  Device Path
    cst816s_i2c_bus,        //  I2C Bus
    CST816S_DEVICE_ADDRESS  //  I2C Address
  );
  if (ret &lt; 0) {
    _err(&quot;ERROR: Failed to register CST816S\n&quot;);
  }
#endif  //  CONFIG_INPUT_CST816S</code></pre></div>
<p>This initialises our CST816S Driver and registers it at ‚Äú<strong>/dev/input0</strong>‚Äù.</p>
<p><strong>cst816s_register</strong> comes from our CST816S Driver, let‚Äôs dive in‚Ä¶</p>
<h1 id="initialise-driver"><a href="#initialise-driver">4 Initialise Driver</a></h1>
<p>At NuttX Startup, we call <strong>cst816s_register</strong> to initialise our CST816S Driver. The function is defined below: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L638-L706">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Initialise the CST816S Driver
int cst816s_register(FAR const char *devpath, FAR struct i2c_master_s *i2c_dev, uint8_t i2c_devaddr) {

  //  Allocate the Device Struct
  struct cst816s_dev_s *priv = kmm_zalloc(
    sizeof(struct cst816s_dev_s)
  );
  if (!priv) {
    ierr(&quot;Memory allocation failed\n&quot;);
    return -ENOMEM;
  }</code></pre></div>
<p>We begin by allocating the <strong>Device Struct</strong> that will remember the state of our driver.</p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L73-L90">(Device Struct <strong>cst816s_dev_s</strong> is defined here)</a></p>
<p>We populate the Device Struct and initialise the <strong>Poll Semaphore</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init the Device Struct
  priv-&gt;addr = i2c_devaddr;  //  I2C Address
  priv-&gt;i2c  = i2c_dev;      //  I2C Bus

  //  Init the Poll Semaphore
  nxsem_init(&amp;priv-&gt;devsem, 0, 1);</code></pre></div>
<p>(Which will be used for blocking callers to <strong><code>poll()</code></strong>)</p>
<p>Next we <strong>register the driver</strong> with NuttX at ‚Äú<strong>/dev/input0</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Register the driver at &quot;/dev/input0&quot;
  int ret = register_driver(
    devpath,             //  Device Path
    &amp;g_cst816s_fileops,  //  File Operations
    0666,                //  Permissions
    priv                 //  Device Struct
  );
  if (ret &lt; 0) {
    kmm_free(priv);
    ierr(&quot;Driver registration failed\n&quot;);
    return ret;
  }</code></pre></div>
<p>(We‚Äôll see <strong>g_cst816s_fileops</strong> later)</p>
<p>Remember that CST816S will trigger <strong>GPIO Interrupts</strong> when we touch the screen.</p>
<p>We attach our <strong>Interrupt Handler</strong> that will handle the GPIO Interrupts‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Configure GPIO interrupt to be triggered on falling edge
  DEBUGASSERT(bl602_expander != NULL);
  IOEXP_SETOPTION(
    bl602_expander,  //  BL602 GPIO Expander
    gpio_pin,        //  GPIO Pin
    IOEXPANDER_OPTION_INTCFG,            //  Configure interrupt trigger
    (FAR void *) IOEXPANDER_VAL_FALLING  //  Trigger on falling edge
  );

  //  Attach GPIO interrupt handler
  handle = IOEP_ATTACH(
    bl602_expander,                //  BL602 GPIO Expander
    (ioe_pinset_t) 1 &lt;&lt; gpio_pin,  //  GPIO Pin converted to Pinset
    cst816s_isr_handler,  //  GPIO Interrupt Handler
    priv                  //  Callback argument
  );
  if (handle == NULL) {
    kmm_free(priv);
    ierr(&quot;Attach interrupt failed\n&quot;);
    return -EIO;
  }</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#attach-interrupt-handler">(<strong>IOEXP_SETOPTION</strong> and <strong>IOEP_ATTACH</strong> are from the GPIO Expander)</a></p>
<p>And that‚Äôs how we initialise our CST816S Driver at startup!</p>
<p><em>What‚Äôs g_cst816s_fileops?</em></p>
<p><strong>g_cst816s_fileops</strong> defines the <strong>NuttX File Operations</strong> <em>(open, close, read, poll)</em> that will be supported by our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L109-L123">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  File Operations exposed to NuttX Apps
static const struct file_operations g_cst816s_fileops = {
  cst816s_open,   //  open
  cst816s_close,  //  close
  cst816s_read,   //  read
  NULL,           //  write
  NULL,           //  seek
  NULL,           //  ioctl
  cst816s_poll    //  poll
#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
  , NULL          //  unlink
#endif
};</code></pre></div>
<p>We‚Äôll see the File Operations in a while.</p>
<p><img src="https://lupyuen.github.io/images/touch-code2a.png" alt="Initialise the CST816S Driver at startup" /></p>
<h1 id="gpio-interrupt"><a href="#gpio-interrupt">5 GPIO Interrupt</a></h1>
<p><em>What happens when a GPIO Interrupt is triggered on touch?</em></p>
<p>Our <strong>GPIO Interrupt Handler</strong> does the following‚Ä¶</p>
<ul>
<li>
<p>Set the <strong>Pending Flag</strong> to true</p>
<p>(We‚Äôll see why in a while)</p>
</li>
<li>
<p>Notify all callers to <strong><code>poll()</code></strong> that the Touch Data is ready</p>
<p>(So they will be unblocked and can proceed to read the data)</p>
</li>
</ul>
<p>Below is <strong>cst816s_isr_handler</strong>, our GPIO Interrupt Handler: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L591-L613">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Handle GPIO Interrupt triggered by touch
static int cst816s_isr_handler(FAR struct ioexpander_dev_s *dev, ioe_pinset_t pinset, FAR void *arg) {
  //  Get the Device Struct from the handler argument
  FAR struct cst816s_dev_s *priv = (FAR struct cst816s_dev_s *) arg;

  //  Enter a Critical Section
  irqstate_t flags = enter_critical_section();

  //  Set the Pending Flag to true
  priv-&gt;int_pending = true;

  //  Leave the Critical Section
  leave_critical_section(flags);

  //  Notify all poll() callers that data is ready
  cst816s_poll_notify(priv);
  return 0;
}</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L493-L519">(<strong>cst816s_poll_notify</strong> is defined here)</a></p>
<p>We use a <strong>Critical Section</strong> to protect the Pending Flag from being modified by multiple threads.</p>
<h2 id="test-gpio-interrupt"><a href="#test-gpio-interrupt">5.1 Test GPIO Interrupt</a></h2>
<p><em>Our GPIO Interrupt Handler‚Ä¶ Does it really work?</em></p>
<p>Let‚Äôs test it! Follow these steps to <strong>build, flash and run NuttX</strong> on PineDio Stack (with CST816S logging enabled)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#appendix-nuttx-logging"><strong>‚ÄúNuttX Logging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to <strong>list all devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div>
<p>We should see our CST816S Driver loaded at ‚Äú<strong>/dev/input0</strong>‚Äù‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/touch-device.png" alt="NuttX Touchscreen Device" /></p>
</blockquote>
<p>Tap the screen on PineDio Stack. We should see the <strong>GPIO Interrupt</strong> handled by our driver‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt!
bl602_expander_interrupt: Call callback
cst816s_poll_notify:</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#test-gpio-interrupt">(See the Complete Log)</a></p>
<p>Yep our CST816S Driver correctly handles the GPIO Interrupt!</p>
<p><img src="https://lupyuen.github.io/images/touch-run1a.png" alt="GPIO Interrupt" /></p>
<h1 id="fetch-touch-data"><a href="#fetch-touch-data">6 Fetch Touch Data</a></h1>
<p>We‚Äôve handled the GPIO Interrupt, now comes the exciting part of our CST816S Driver‚Ä¶ Fetching the <strong>Touch Data over I2C</strong>!</p>
<p><em>Why bother with GPIO Interrupts anyway? Can‚Äôt we read the data directly over I2C?</em></p>
<p>Ah but the Touch Panel <strong>won‚Äôt respond to I2C Commands</strong> until the screen is tapped! (Which triggers the GPIO Interrupt)</p>
<p>That‚Äôs why we need to <strong>monitor for GPIO Interrupts</strong> (via the Pending Flag) and determine whether the Touch Panel‚Äôs I2C Interface is active.</p>
<p><em>What can we read from CST816S over I2C?</em></p>
<p>Here‚Äôs the Touch Data that we can read from <strong>I2C Registers <code>0x02</code> to <code>0x06</code></strong> on CST816S‚Ä¶</p>
<ul>
<li>
<p><strong>Touch Points:</strong> Number of Touch Points (always 1)</p>
<p>(Bits 0-3 of Register <code>0x02</code>)</p>
</li>
<li>
<p><strong>Touch Event:</strong> <code>0</code> = Touch Down, <code>1</code> = Touch Up, <code>2</code> = Contact</p>
<p>(Bits 6-7 of Register <code>0x03</code>)</p>
</li>
<li>
<p><strong>X Coordinate:</strong> 0 to 239</p>
<p>(High Byte: Bits 0-3 of Register <code>0x03</code>)</p>
<p>(Low Byte: Bits 0-7 of Register <code>0x04</code>)</p>
</li>
<li>
<p><strong>Y Coordinate:</strong> 0 to 239</p>
<p>(High Byte: Bits 0-3 of Register <code>0x05</code>)</p>
<p>(Low Byte: Bits 0-7 of Register <code>0x06</code>)</p>
</li>
<li>
<p><strong>Touch ID:</strong> Identifies the Touch Point (always 0)</p>
<p>(Bits 4-7 of Register <code>0x05</code>)</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen/hynitron_i2c_cst0xxse/blob/master/cst0xx_core.c#L407-L466">(Derived from Hynitron‚Äôs Reference Driver)</a></p>
<p><strong>Touch Gestures</strong> (like swiping and scrolling) might also be supported, according to the CST816S Driver for PineTime InfiniTime. <a href="https://github.com/InfiniTimeOrg/InfiniTime/blob/develop/src/drivers/Cst816s.cpp#L80-L94">(See this)</a></p>
<p><em>Any gotchas for the Touch Data?</em></p>
<p>If the Touch Event is <strong><code>0</code> (Touch Down)</strong>, all Touch Data is hunky dory.</p>
<p>But if the Touch Event is <strong><code>1</code> (Touch Up)</strong>, all the other fields are <strong>invalid</strong>!</p>
<p>Our driver fixes this by remembering and returning the <strong>last valid Touch Data</strong>.</p>
<p><em>What about Touch Event <code>2</code> (Contact)?</em></p>
<p>We haven‚Äôt seen this during our testing. Thus our driver ignores the event.</p>
<p><strong>UPDATE:</strong> Our driver now handles the <strong>Contact Event</strong>. <a href="https://github.com/lupyuen/cst816s-nuttx/commit/568e5524ef9b84d696bdefb5a2fe9030321338a9">(See this)</a></p>
<p>Let‚Äôs check out our driver code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-code4a.jpg" alt="Getting I2C Touch Data" /></p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">(Source)</a></p>
<h2 id="get-i2c-touch-data"><a href="#get-i2c-touch-data">6.1 Get I2C Touch Data</a></h2>
<p>This is how we read the <strong>Touch Data over I2C</strong> in our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read I2C Register 0x00 onwards
#define CST816S_REG_TOUCHDATA 0x00

//  Read Touch Data over I2C
static int cst816s_get_touch_data(FAR struct cst816s_dev_s *dev, FAR void *buf) {

  //  Read the Raw Touch Data over I2C
  uint8_t readbuf[7];
  int ret = cst816s_i2c_read(
    dev,                    //  Device Struct
    CST816S_REG_TOUCHDATA,  //  Read I2C Register 0x00 onwards
    readbuf,                //  Buffer for Touch Data
    sizeof(readbuf)         //  Read 7 bytes
  );
  if (ret &lt; 0) {
    iinfo(&quot;Read touch data failed\n&quot;);
    return ret;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L136-L220">(<strong>cst816s_i2c_read</strong> is defined here)</a></p>
<p>The function begins by reading <strong>I2C Registers <code>0x00</code> to <code>0x06</code></strong>.</p>
<p>Then it <strong>decodes the Touch Data</strong> (as described in the last section)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Interpret the Raw Touch Data
  uint8_t id = readbuf[5] &gt;&gt; 4;
  uint8_t touchpoints = readbuf[2] &amp; 0x0f;
  uint8_t xhigh = readbuf[3] &amp; 0x0f;
  uint8_t xlow  = readbuf[4];
  uint8_t yhigh = readbuf[5] &amp; 0x0f;
  uint8_t ylow  = readbuf[6];
  uint8_t event = readbuf[3] &gt;&gt; 6;  //  0 = Touch Down, 1 = Touch Up, 2 = Contact */
  uint16_t x  = (xhigh &lt;&lt; 8) | xlow;
  uint16_t y  = (yhigh &lt;&lt; 8) | ylow;</code></pre></div>
<p>For <strong>Touch Up Events</strong>: The Touch Coordinates are invalid, so we substitute the data from the <strong>last Touch Down Event</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  If touch coordinates are invalid,
  //  return the last valid coordinates
  bool valid = true;
  if (x &gt;= 240 || y &gt;= 240) {
    //  Quit if we have no last valid coordinates
    if (last_event == 0xff) { return -EINVAL; }

    //  Otherwise substitute the last valid coordinates
    valid = false;
    id = last_id;
    x  = last_x;
    y  = last_y;
  }</code></pre></div>
<p>We remember the <strong>Touch Event</strong> and the Touch Data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Remember the last valid touch data
  last_event = event;
  last_id    = id;
  last_x     = x;
  last_y     = y;</code></pre></div>
<p>NuttX expects the Touch Data to be returned as a <strong>touch_sample_s</strong> struct. <a href="https://lupyuen.github.io/articles/touch#touch-data">(See this)</a></p>
<p>We <strong>assign the Touch Data</strong> to the struct‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the Touch Data fields
  struct touch_sample_s data;
  memset(&amp;data, 0, sizeof(data));
  data.npoints     = 1;   //  Number of Touch Points
  data.point[0].id = id;  //  Touch ID
  data.point[0].x  = x;   //  X Coordinate
  data.point[0].y  = y;   //  Y Coordinate</code></pre></div>
<p>Now we tell NuttX whether it‚Äôs a <strong>Touch Down Event</strong> (with valid or invalid coordinates)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Set the Touch Flags for...
  //  Touch Down Event
  if (event == 0) {
    if (valid) {
      //  Touch coordinates were valid
      data.point[0].flags  = TOUCH_DOWN | TOUCH_ID_VALID | TOUCH_POS_VALID;
    } else {
      //  Touch coordinates were invalid
      data.point[0].flags  = TOUCH_DOWN | TOUCH_ID_VALID;
    }</code></pre></div>
<p>Or a <strong>Touch Up Event</strong> (with valid or invalid coordinates)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Touch Up Event
  } else if (event == 1) {
    if (valid) {
      //  Touch coordinates were valid
      data.point[0].flags  = TOUCH_UP | TOUCH_ID_VALID | TOUCH_POS_VALID;
    } else {
      //  Touch coordinates were invalid
      data.point[0].flags  = TOUCH_UP | TOUCH_ID_VALID;
    }</code></pre></div>
<p>We ignore all <strong>Contact Events</strong> (because we‚Äôve never seen one)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Reject Contact Event
  } else {
    return -EINVAL;
  }</code></pre></div>
<p>Finally we <strong>return the struct</strong> to the caller‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Return the touch data
  memcpy(buf, &amp;data, sizeof(data));
  return sizeof(data);
}</code></pre></div>
<p>That‚Äôs how we read and decode the Touch Data from CST816S over I2C!</p>
<p><img src="https://lupyuen.github.io/images/touch-code5a.jpg" alt="Returning I2C Touch Data" /></p>
<p><a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L213-L302">(Source)</a></p>
<h2 id="is-data-ready"><a href="#is-data-ready">6.2 Is Data Ready?</a></h2>
<p><em>Who calls cst816s_get_touch_data to fetch the Touch Data over I2C?</em></p>
<p><strong>cst816s_get_touch_data</strong> is called by the <strong><code>read()</code></strong> File Operation of our driver: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L334-L388">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Implements the read() File Operation for the driver
static ssize_t cst816s_read(FAR struct file *filep, FAR char *buffer, size_t buflen) {
  ...
  //  Wait for semaphore to prevent concurrent reads
  int ret = nxsem_wait(&amp;priv-&gt;devsem);

  //  Read the touch data, only if 
  //  screen has been touched or if 
  //  we&#39;re waiting for touch up
  ret = -EINVAL;
  if ((priv-&gt;int_pending || last_event == 0) 
    &amp;&amp; buflen &gt;= outlen) {
    ret = cst816s_get_touch_data(priv, buffer);
  }

  //  Clear the Pending Flag with critical section
  flags = enter_critical_section();
  priv-&gt;int_pending = false;
  leave_critical_section(flags);

  //  Release semaphore and allow next read
  nxsem_post(&amp;priv-&gt;devsem);</code></pre></div>
<p>(Which means that this code will run when a NuttX App reads <em>‚Äú/dev/input0‚Äù</em>)</p>
<p>Note that we <strong>fetch the Touch Data</strong> over I2C only if‚Ä¶</p>
<ul>
<li>
<p>Screen has <strong>just been touched</strong></p>
<p>(Indicated by the Pending Flag <strong>int_pending</strong>)</p>
</li>
<li>
<p>Or if the <strong>last event was Touch Down</strong></p>
<p>(And we‚Äôre waiting for Touch Up)</p>
</li>
</ul>
<p><em>Why check the Pending Flag?</em></p>
<p>Recall that the Pending Flag is set when the <strong>screen is touched</strong>. (Which triggers a GPIO Interrupt)</p>
<p>The Pending Flag tells us when the Touch Panel‚Äôs I2C Interface is active. And there‚Äôs <strong>valid Touch Data</strong> to be fetched.</p>
<p>Thus this check <strong>prevents unnecessary I2C Reads</strong>, until the Touch Data is available for reading.</p>
<p><em>Why check if the last event was Touch Down?</em></p>
<p>When we‚Äôre no longer touching the screen, the Touch Panel <strong>doesn‚Äôt trigger a GPIO Interrupt</strong>.</p>
<p>Thus to catch the <strong>Touch Up Event</strong>, we must allow the Touch Data to be fetched over I2C.  And we stop fetching thereafter. (Until the screen is touched again)</p>
<p>This causes a few redundant I2C Reads, but it shouldn‚Äôt affect performance.</p>
<p>(Unless we touch the screen for a very long time!)</p>
<h1 id="run-the-driver"><a href="#run-the-driver">7 Run The Driver</a></h1>
<p>For our final demo today, let‚Äôs run our CST816S Driver and test the Touch Panel!</p>
<p>Follow these steps to <strong>build, flash and run NuttX</strong> on PineDio Stack (with CST816S logging enabled)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#appendix-nuttx-logging"><strong>‚ÄúNuttX Logging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to run the <a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lvgltest</code></pre></div>
<p>We should see the <strong>Touch Calibration</strong> screen‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p>When prompted, <strong>tap the 4 corners</strong> of the screen‚Ä¶</p>
<ul>
<li>
<p><a href="https://www.youtube.com/shorts/2Nzjrlp5lcE"><strong>Watch the demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#test-touch-data"><strong>See the Debug Log</strong></a></p>
</li>
</ul>
<p>Yep our CST816S Driver responds correctly to touch! üéâ</p>
<p><em>The touchscreen looks laggy?</em></p>
<p>The ST7789 Display feels laggy because of <strong>inefficient SPI Data Transfer</strong>. The SPI Driver polls the SPI Port when transferring data. <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_spi.c#L805-L855">(See this)</a></p>
<p>That‚Äôs why we need to implement <a href="https://lupyuen.github.io/articles/spi#spi-with-direct-memory-access"><strong>SPI Direct Memory Access (DMA)</strong></a> so that PineDio Stack can do other tasks (like handling the Touch Panel) while painting the ST7789 Display.</p>
<p>We‚Äôll port to NuttX this implementation of SPI DMA from <strong>BL MCU SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_mcu_sdk/blob/master/drivers/bl602_driver/std_drv/src/bl602_dma.c"><strong>bl602_dma.c</strong></a></li>
</ul>
<p>More about SPI DMA on BL602 / BL604‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/spi#spi-with-direct-memory-access"><strong>‚ÄúSPI with Direct Memory Access‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/spi#lli_list_init-create-dma-linked-list"><strong>‚ÄúCreate DMA Linked List‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/spi#hal_spi_dma_trans-execute-spi-transfer-with-dma"><strong>‚ÄúExecute DMA Linked List‚Äù</strong></a></p>
</li>
</ul>
<p><strong>UPDATE:</strong> SPI DMA is now supported on BL602 NuttX‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#appendix-spi-dma-on-bl602-nuttx"><strong>‚ÄúSPI DMA on BL602 NuttX‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs inspect the log‚Ä¶</p>
<p>(<strong>TODO:</strong> We should <a href="https://docs.lvgl.io/7.11/get-started/quick-overview.html#button-with-label">add a button</a> and <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L185-L197">a message box</a> to the <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L110-L198">LVGL Test App</a> to demo the touchscreen)</p>
<h2 id="read-touch-data-1"><a href="#read-touch-data-1">7.1 Read Touch Data</a></h2>
<p><em>Nothing appears in the log until we touch the screen. Why so?</em></p>
<p>Recall that the LVGL Test App <strong>calls <code>read()</code> repeatedly</strong> on our CST816S Driver to get Touch Data. <a href="https://lupyuen.github.io/articles/touch#read-touch-data">(See this)</a></p>
<p>But <strong><code>read()</code></strong> won‚Äôt fetch any Touch Data over I2C <strong>until the screen is touched</strong>. <a href="https://lupyuen.github.io/articles/touch#is-data-ready">(See this)</a></p>
<p>Thus we have successfully eliminated most of the unnecessary I2C Reads!</p>
<p>Now watch what happens when we touch the screen‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/touch-code6a.jpg" alt="LVGL Test App calls read() repeatedly" /></p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L100-L199">(Source)</a></p>
<h2 id="trigger-gpio-interrupt"><a href="#trigger-gpio-interrupt">7.2 Trigger GPIO Interrupt</a></h2>
<p>During the calibration process, we touch the screen. This triggers a <strong>GPIO Interrupt</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bl602_expander_interrupt: Interrupt!
bl602_expander_interrupt: Call callback
cst816s_poll_notify:</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#trigger-gpio-interrupt">(See the Complete Log)</a></p>
<p>The <strong>Interrupt Handler</strong> in our driver sets the <strong>Pending Flag</strong> to true. <a href="https://lupyuen.github.io/articles/touch#gpio-interrupt">(See this)</a></p>
<p>Then it calls <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L493-L519"><strong>cst816s_poll_notify</strong></a> to notify all callers to <strong><code>poll()</code></strong> that Touch Data is now available.</p>
<p>(The LVGL Test App doesn‚Äôt <strong><code>poll()</code></strong> our driver, so this has no effect)</p>
<h2 id="touch-down-event"><a href="#touch-down-event">7.3 Touch Down Event</a></h2>
<p>The LVGL Test App is still calling <strong><code>read()</code></strong> repeatedly to get Touch Data from our driver.</p>
<p>Now that the <strong>Pending Flag</strong> is true, our driver proceeds to call <a href="https://lupyuen.github.io/articles/touch#is-data-ready"><strong>cst816s_get_touch_data</strong></a> and fetch the Touch Data over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_transfer: subflag=0, subaddr=0x0, sublen=0
bl602_i2c_transfer: i2c transfer success
bl602_i2c_recvdata: count=7, temp=0x500
bl602_i2c_recvdata: count=3, temp=0x1700de</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#touch-down-event">(See the Complete Log)</a></p>
<p>Our driver has <strong>fetched the Touch Data</strong> over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data: DOWN: id=0,touch=0, x=222, y=23</code></pre></div>
<p>Which gets returned directly to the app as a <strong>Touch Down Event</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>Our driver clears the <strong>Pending Flag</strong> and remembers that we‚Äôre expecting a <strong>Touch Up Event</strong>. <a href="https://lupyuen.github.io/articles/touch#get-i2c-touch-data">(See this)</a></p>
<p><img src="https://lupyuen.github.io/images/touch-run2a.jpg" alt="Our driver returns a Touch Down Event" /></p>
<h2 id="touch-down-event-again"><a href="#touch-down-event-again">7.4 Touch Down Event Again</a></h2>
<p>We‚Äôre not done with Touch Down Events yet!</p>
<p>Because our driver remembers that we‚Äôre expecting a Touch Up Event, all calls to <strong><code>read()</code></strong> will continue to <strong>fetch the Touch Data</strong> over I2C. <a href="https://lupyuen.github.io/articles/touch#is-data-ready">(Here‚Äôs why)</a></p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: DOWN: id=0, touch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23

cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: DOWN: id=0, touch=0, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   19
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#touch-down-event-again">(See the Complete Log)</a></p>
<p>Our driver <strong>returns the same data twice</strong> to the app. (Until it sees the Touch Up Event)</p>
<p>(<strong>TODO:</strong> Perhaps we should ignore duplicate Touch Down Events? Might reduce the screen lag)</p>
<h2 id="touch-up-event"><a href="#touch-up-event">7.5 Touch Up Event</a></h2>
<p>When we‚Äôre no longer longer touching the screen, <a href="https://lupyuen.github.io/articles/touch#get-i2c-touch-data"><strong>cst816s_get_touch_data</strong></a> receives a <strong>Touch Up Event</strong> over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#touch-up-event">(See the Complete Log)</a></p>
<p><em>This doesn‚Äôt look right: x=639, y=1688. Our screen is only 240 x 240 pixels!</em></p>
<p>We said earlier that Touch Up Events have <strong>invalid Touch Coordinates</strong>. <a href="https://lupyuen.github.io/articles/touch#fetch-touch-data">(Right here)</a></p>
<p>Hence we substitute the Touch Coordinates with the data from the <strong>last Touch Down Event</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>cst816s_get_touch_data: UP: id=0, touch=2, x=222, y=23
cst816s_get_touch_data:   id:      0
cst816s_get_touch_data:   flags:   0c
cst816s_get_touch_data:   x:       222
cst816s_get_touch_data:   y:       23</code></pre></div>
<p>And we return the valid coordinates to the app.</p>
<p>The <strong>Pending Flag</strong> is now clear, and we‚Äôre no longer expecting a <strong>Touch Up Event</strong>.</p>
<p>All calls to <strong><code>read()</code></strong> will no longer fetch the Touch Data over I2C. (Until we touch the screen again)</p>
<p><img src="https://lupyuen.github.io/images/touch-run4a.png" alt="Patching the Touch Coordinates" /></p>
<h2 id="screen-calibration-result"><a href="#screen-calibration-result">7.6 Screen Calibration Result</a></h2>
<p>After we have touched the 4 corners of the screen, the LVGL Test App displays the result of the <strong>Screen Calibration</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>tp_cal result
offset x:23, y:24
range x:194, y:198
invert x/y:1, x:0, y:1</code></pre></div>
<p>Which will be used to tweak the Touch Coordinates later in the app.</p>
<p>And we‚Äôre done with the app!</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<h1 id="screen-is-sideways"><a href="#screen-is-sideways">8 Screen Is Sideways</a></h1>
<p>If we look closely at the screen above, the <strong>Touch Coordinates seem odd</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: right"></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Top Left</strong> <br> <em>x=181, y=12</em></td><td style="text-align: right"><strong>Top Right</strong> <br> <em>x=230, y=212</em></td></tr>
<tr><td style="text-align: left"><strong>Bottom Left</strong> <br> <em>x=9, y=10</em></td><td style="text-align: right"><strong>Bottom Right</strong> <br> <em>x=19, y=202</em></td></tr>
</tbody></table>
</div>
<p>But we expect the Touch Coordinates to run <strong>left to right, top to bottom</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: right"></th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Top Left</strong> <br> <em>x=0, y=0</em></td><td style="text-align: right"><strong>Top Right</strong> <br> <em>x=239, y=0</em></td></tr>
<tr><td style="text-align: left"><strong>Bottom Left</strong> <br> <em>x=0, y=239</em></td><td style="text-align: right"><strong>Bottom Right</strong> <br> <em>x=239, y=239</em></td></tr>
</tbody></table>
</div>
<p><strong>Try this:</strong> Tilt your head to the left and stare at the pic. You‚Äôll see the Expected Touch Coordinates!</p>
<p>That‚Äôs right‚Ä¶ Our screen is <strong>rotated sideways</strong>!</p>
<p>So be careful when mapping the Touch Coordinates to the rendered screen.</p>
<p><em>Can we fix this?</em></p>
<p>We can rotate the display in the <strong>ST7789 Display Driver</strong>. </p>
<p>(Portrait Mode vs Landscape Mode)</p>
<p>But first we need to agree <strong>which way is ‚Äúup‚Äù</strong>‚Ä¶</p>
<ul>
<li>
<p>Should we rotate the ‚Äúchin‚Äù to the bottom?</p>
</li>
<li>
<p>If PineDio Stack works like a ‚ÄúChonky Watch‚Äù, the button should be at the side. Right?</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/touch-button.jpg" alt="Which way is up?" /></p>
<h1 id="i2c-quirks"><a href="#i2c-quirks">9 I2C Quirks</a></h1>
<p><em>Is there anything peculiar about I2C on BL602 and BL604?</em></p>
<p>We need to handle two <strong>I2C Quirks</strong> on NuttX for BL602 / BL604‚Ä¶</p>
<ul>
<li>
<p><strong>I2C Register ID</strong> must be sent as <strong>I2C Sub Address</strong></p>
</li>
<li>
<p><strong>I2C Warnings</strong> must be turned on</p>
</li>
</ul>
<p>Let‚Äôs go into the details‚Ä¶</p>
<h2 id="i2c-sub-address"><a href="#i2c-sub-address">9.1 I2C Sub Address</a></h2>
<p>When we read an I2C Register, we must send the I2C Register ID as an <strong>I2C Sub Address</strong>: <a href="https://github.com/lupyuen/cst816s-nuttx/blob/main/cst816s.c#L136-L220">cst816s.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Read from I2C device
static int cst816s_i2c_read(FAR struct cst816s_dev_s *dev, uint8_t reg,uint8_t *buf, size_t buflen) {

  //  Compose I2C Request to read I2C Registers
  struct i2c_msg_s msgv[2] = { {

    //  First I2C Message: Send the Register ID
    .frequency = CONFIG_CST816S_I2C_FREQUENCY,
    .addr      = dev-&gt;addr,
#ifdef CONFIG_BL602_I2C0
    //  For BL602: We must send Register ID as I2C Sub Address
    .flags     = I2C_M_NOSTART,
#else
    //  Otherwise we send the Register ID normally
    .flags     = 0,
#endif  //  CONFIG_BL602_I2C0
    .buffer    = &amp;reg,
    .length    = 1
  }, {

    //  Second I2C Message: Receive the Register Data
    .frequency = CONFIG_CST816S_I2C_FREQUENCY,
    .addr      = dev-&gt;addr,
    .flags     = I2C_M_READ,
    .buffer    = buf,
    .length    = buflen
  } };</code></pre></div>
<p>We do this by specifying the <strong>I2C_M_NOSTART</strong> flag (shown above).</p>
<p>This article explains why‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280#set-i2c-sub-address"><strong>‚ÄúSet I2C Sub Address‚Äù</strong></a></li>
</ul>
<h2 id="i2c-logging"><a href="#i2c-logging">9.2 I2C Logging</a></h2>
<p>During development we discovered that <a href="https://lupyuen.github.io/articles/touch#get-i2c-touch-data"><strong>cst816s_get_touch_data</strong></a> won‚Äôt return any valid Touch Data unless we <strong>enable these two I2C Warnings</strong> in the BL602 I2C Driver: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinedio/arch/risc-v/src/bl602/bl602_i2c.c#L739-L765">bl602_i2c.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static int bl602_i2c_transfer(struct i2c_master_s *dev, struct i2c_msg_s *msgs, int count) {
  ...
  priv-&gt;msgid = i;
#ifdef CONFIG_INPUT_CST816S
  //  I2C Workaround #1 of 2 for CST816S: https://github.com/lupyuen/cst816s-nuttx#i2c-logging
  i2cwarn(&quot;subflag=%d, subaddr=0x%lx, sublen=%d\n&quot;, priv-&gt;subflag, priv-&gt;subaddr, priv-&gt;sublen);
#endif /* CONFIG_INPUT_CST816S */
  bl602_i2c_start_transfer(priv);
  ...  
  if (priv-&gt;i2cstate == EV_I2C_END_INT) {

#ifdef CONFIG_INPUT_CST816S
    //  I2C Workaround #2 of 2 for CST816S: https://github.com/lupyuen/cst816s-nuttx#i2c-logging
    i2cwarn(&quot;i2c transfer success\n&quot;);
#endif  //  CONFIG_INPUT_CST816S</code></pre></div>
<p>That‚Äôs why we must always <strong>enable I2C Warnings</strong> in our NuttX Build‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx#appendix-nuttx-logging"><strong>‚ÄúNuttX Logging‚Äù</strong></a></li>
</ul>
<p>(I2C Warnings are already enabled for PineDio Stack)</p>
<p><em>What happens if we don‚Äôt enable I2C Warnings?</em></p>
<p>If we disable I2C Warnings, we‚Äôll <strong>never receive the Touch Down Event</strong> over I2C‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open:

bl602_expander_interrupt: Interrupt!
bl602_expander_interrupt: Call callback
cst816s_poll_notify:

cst816s_get_touch_data:
cst816s_i2c_read:
cst816s_get_touch_data: Invalid touch data: id=9, touch=2, x=639, y=1688
cst816s_get_touch_data: Can&#39;t return touch data: id=9, touch=2, x=639, y=1688</code></pre></div>
<p><a href="https://github.com/lupyuen/cst816s-nuttx#i2c-logging">(See the Complete Log)</a></p>
<p>We‚Äôll only get the <strong>Touch Up Event</strong> (with invalid Touch Coordinates).</p>
<p><em>Why would I2C Logging affect the fetching of Touch Data over I2C?</em></p>
<p>We‚Äôre not sure. This could be due to an <strong>I2C Timing Issue</strong> or a <strong>Race Condition</strong>.</p>
<p>Or perhaps our <strong>I2C Read is done too soon</strong> after the Touch Interrupt, and we need to wait a while?</p>
<p>(We might probe the I2C Bus with a Logic Analyser and learn more)</p>
<p><em>Is it OK to enable logging for everything in NuttX?</em></p>
<p>Not really. If we enable ‚ÄúInformational Debug Output‚Äù (<strong>CONFIG_DEBUG_INFO</strong>) in NuttX, we‚Äôll get so much Debug Output that the <a href="https://github.com/lupyuen/lorawan_test"><strong>LoRaWAN Test App</strong></a> will fail.</p>
<p>(Because LoRaWAN Timers are time-critical)</p>
<p>Hence we should enable NuttX Info Logging only when needed for troubleshooting.</p>
<p>(<strong>TODO:</strong> <a href="https://github.com/lupyuen/lorawan_test">LoRaWAN Test App</a>, <a href="https://github.com/lupyuen/LoRaMac-node-nuttx">LoRaWAN Library</a>, <a href="https://github.com/lupyuen/lora-sx1262/tree/lorawan">SX1262 Library</a>, <a href="https://github.com/lupyuen/nimble-porting-nuttx">NimBLE Porting Layer</a> and <a href="https://github.com/lupyuen/incubator-nuttx/tree/pinedio/drivers/rf">SPI Test Driver</a> should have their own flags for logging)</p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>I hope this article has provided everything you need to get started on creating <strong>your own Touchscreen Apps</strong> on PineDio Stack.</p>
<p>Lemme know what you‚Äôre building with PineDio Stack!</p>
<p>In the next article we shall tackle the (happy) problem of <strong>too many GPIOs</strong> on PineDio Stack‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#gpio-expander"><strong>‚ÄúBL604 GPIO Expander‚Äù</strong></a></li>
</ul>
<p>Stay Tuned!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/u7rnyt/nuttx_touch_panel_driver_for_pinedio_stack_bl604/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/touch.md"><strong><code>lupyuen.github.io/src/touch.md</code></strong></a></p>
<h1 id="notes"><a href="#notes">11 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1514049092388745219"><strong>this Twitter Thread</strong></a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/touch-title2.jpg" alt="Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><em>Touch Panel Calibration for Pine64 PineDio Stack BL604 RISC-V Board</em></p>

    
</body>
</html>