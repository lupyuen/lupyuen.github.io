<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Build an IoT App with Zig and LoRaWAN</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Build an IoT App with Zig and LoRaWAN" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a complex IoT App with Zig and LoRaWAN... And run it on RISC-V BL602 with Apache NuttX RTOS"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/iot-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Build an IoT App with Zig and LoRaWAN</h1>
    <nav id="TOC"><ul>
<li><a href="#lorawan-network-stack">1 LoRaWAN Network Stack</a><ul></ul></li>
<li><a href="#import-lorawan-library">2 Import LoRaWAN Library</a><ul></ul></li>
<li><a href="#main-function">3 Main Function</a><ul></ul></li>
<li><a href="#convert-integer-type">4 Convert Integer Type</a><ul></ul></li>
<li><a href="#transmit-data-packet">5 Transmit Data Packet</a><ul></ul></li>
<li><a href="#logging">6 Logging</a><ul></ul></li>
<li><a href="#compile-zig-app">7 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">8 Run Zig App</a><ul></ul></li>
<li><a href="#safety-checks">9 Safety Checks</a><ul></ul></li>
<li><a href="#zig-outcomes">10 Zig Outcomes</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-handle-lorawan-events">13 Appendix: Handle LoRaWAN Events</a><ul></ul></li>
<li><a href="#appendix-logging">14 Appendix: Logging</a><ul></ul></li>
<li><a href="#appendix-panic-handler">15 Appendix: Panic Handler</a><ul></ul></li>
<li><a href="#appendix-zig-compiler-as-drop-in-replacement-for-gcc">16 Appendix: Zig Compiler as Drop-In Replacement for GCC</a><ul></ul></li>
<li><a href="#appendix-lorawan-library-for-nuttx">17 Appendix: LoRaWAN Library for NuttX</a><ul></ul></li>
<li><a href="#appendix-lorawan-app-for-nuttx">18 Appendix: LoRaWAN App for NuttX</a><ul></ul></li>
<li><a href="#appendix-auto-translate-lorawan-app-to-zig">19 Appendix: Auto-Translate LoRaWAN App to Zig</a><ul></ul></li>
<li><a href="#appendix-opaque-type-error">20 Appendix: Opaque Type Error</a><ul></ul></li>
<li><a href="#appendix-fix-opaque-type">21 Appendix: Fix Opaque Type</a><ul></ul></li>
<li><a href="#appendix-macro-error">22 Appendix: Macro Error</a><ul></ul></li>
<li><a href="#appendix-struct-initialisation-error">23 Appendix: Struct Initialisation Error</a><ul></ul></li></ul></nav><p>üìù <em>15 Jun 2022</em></p>
<p><img src="https://lupyuen.github.io/images/iot-title.jpg" alt="Pine64 PineDio Stack BL604 RISC-V Board (left) talking LoRaWAN on Zig to RAKwireless WisGate LoRaWAN Gateway (right)" /></p>
<p><em>Pine64 PineDio Stack BL604 RISC-V Board (left) talking LoRaWAN on Zig to RAKwireless WisGate LoRaWAN Gateway (right)</em></p>
<p>In our last article we learnt to run barebones <strong>Zig on a Microcontroller</strong> (RISC-V BL602) with a <strong>Real-Time Operating System</strong> (Apache NuttX RTOS)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><em>But can we do something way more sophisticated with Zig?</em></p>
<p>Yes we can! Today we shall run a complex <strong>IoT Application</strong> with <strong>Zig and LoRaWAN</strong>‚Ä¶</p>
<ul>
<li>
<p>Join a <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN Wireless Network</strong></a></p>
</li>
<li>
<p>Transmit a <strong>Data Packet</strong> to the LoRaWAN Network at regular intervals</p>
</li>
</ul>
<p>Which is the typical firmware we would run on <strong>IoT Sensors</strong>.</p>
<p><em>Will this run on any device?</em></p>
<p>We‚Äôll do this on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> RISC-V Board.</p>
<p>But the steps should be similar for BL602, ESP32-C3, Arm Cortex-M and other 32-bit microcontrollers supported by Zig.</p>
<p><em>Why are we doing this?</em></p>
<p>I always dreaded maintaining and extending complex <strong>IoT Apps in C</strong>. <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c">(Like this one)</a></p>
<p>Will Zig make this a little less painful? Let‚Äôs find out!</p>
<p>This is the Zig source code that we‚Äôll study today‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/zig-bl602-nuttx"><strong>lupyuen/zig-bl602-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="Pine64 PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left). This works too!" /></p>
<p><a href="https://lupyuen.github.io/articles/spi2"><em>Pine64 PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left). This works too!</em></a></p>
<h1 id="lorawan-network-stack"><a href="#lorawan-network-stack">1 LoRaWAN Network Stack</a></h1>
<p><em>What‚Äôs a LoRaWAN Network Stack?</em></p>
<p>To talk to a LoRaWAN Wireless Network, our IoT Gadget needs 3 things‚Ä¶</p>
<ul>
<li>
<p><strong>LoRa Radio Transceiver</strong></p>
<p><a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262">(Like PineDio Stack‚Äôs onboard Semtech SX1262 Transceiver)</a></p>
</li>
<li>
<p><strong>LoRa Driver</strong> that will transmit and receive raw LoRa Packets</p>
<p>(By controlling the LoRa Transceiver over SPI)</p>
</li>
<li>
<p><strong>LoRaWAN Driver</strong> that will join a LoRaWAN Network and transmit LoRaWAN Data Packets</p>
<p>(By calling the LoRa Driver)</p>
</li>
</ul>
<p>Together, the LoRa Driver and LoRaWAN Driver make up the <strong>LoRaWAN Network Stack</strong>.</p>
<p><em>Which LoRaWAN Stack will we use?</em></p>
<p>We‚Äôll use <strong>Semtech‚Äôs Reference Implementation</strong> of the LoRaWAN Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/Lora-net/LoRaMac-node"><strong>Lora-net/LoRaMac-node</strong></a></p>
<p><a href="https://stackforce.github.io/LoRaMac-doc/LoRaMac-doc-v4.6.0/index.html">(LoRaMAC Documentation)</a></p>
</li>
</ul>
<p>That we‚Äôve ported to PineDio Stack BL604 with <strong>Apache NuttX RTOS</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sx1262"><strong>‚ÄúLoRa SX1262 on Apache NuttX OS‚Äù</strong></a></p>
</li>
</ul>
<p>The same LoRaWAN Stack is available on many other platforms, including <a href="https://docs.zephyrproject.org/latest/connectivity/lora_lorawan/index.html"><strong>Zephyr OS</strong></a> and <a href="https://github.com/beegee-tokyo/SX126x-Arduino"><strong>Arduino</strong></a>.</p>
<p><a href="https://codeberg.org/JF002/loramac-node">(My good friend JF is porting the LoRaWAN Stack to Linux)</a></p>
<p><em>But the LoRaWAN Stack is in C! Will it work with Zig?</em></p>
<p>Yep no worries, Zig will happily <strong>import the LoRaWAN Stack from C</strong> without any wrappers or modifications.</p>
<p>And we‚Äôll call the LoRaWAN Stack as though it were a Zig Library.</p>
<p><em>So we‚Äôre not rewriting the LoRaWAN Stack in Zig?</em></p>
<p>Rewriting the LoRaWAN Stack in Zig (or another language) sounds risky because the LoRaWAN Stack is still under <a href="https://github.com/Lora-net/LoRaMac-node/commits/master"><strong>Active Development</strong></a>. It can change at any moment!</p>
<p>We‚Äôll stick with the <strong>C Implementation</strong> of the LoRaWAN Stack so that our Zig IoT App will enjoy the latest LoRaWAN updates and features.</p>
<p><a href="https://lupyuen.github.io/articles/zig#why-zig">(More about this)</a></p>
<p><em>Why is our Zig IoT App so complex anyway?</em></p>
<p>That‚Äôs because‚Ä¶</p>
<ul>
<li>
<p>LoRaWAN Wireless Protocol is <strong>Time-Critical</strong>. If we‚Äôre late by 1 second, LoRaWAN just won‚Äôt work. <a href="https://gist.github.com/lupyuen/1d96b24c6bf5164cba652d903eedb9d1">(See this)</a></p>
</li>
<li>
<p>Our app controls the <strong>LoRa Radio Transceiver</strong> over SPI and GPIO. <a href="https://lupyuen.github.io/articles/sx1262#spi-interface">(See this)</a></p>
</li>
<li>
<p>And it needs to handle <strong>GPIO Interrupts</strong> from the LoRa Transceiver whenever a LoRa Packet is received. <a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt">(See this)</a></p>
</li>
<li>
<p>Which means our app needs to do <strong>Multithreading with Timers and Message Queues</strong> efficiently. <a href="https://lupyuen.github.io/articles/sx1262#multithreading-with-nimble-porting-layer">(See this)</a></p>
</li>
</ul>
<p>Great way to test if Zig can really handle Complex Embedded Apps!</p>
<p><img src="https://lupyuen.github.io/images/iot-code2a.png" alt="Import LoRaWAN Library" /></p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L5-L48">(Source)</a></p>
<h1 id="import-lorawan-library"><a href="#import-lorawan-library">2 Import LoRaWAN Library</a></h1>
<p>Let‚Äôs dive into our Zig IoT App. We import the <a href="https://lupyuen.github.io/articles/zig#import-standard-library"><strong>Zig Standard Library</strong></a> at the top of our app: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L5-L48">lorawan_test.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the Zig Standard Library
const std = @import(&quot;std&quot;);
</code></pre></div>
<p>Then we call <a href="https://ziglang.org/documentation/master/#cImport"><strong>@cImport</strong></a> to import the <strong>C Macros and C Header Files</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LoRaWAN Library from C
const c = @cImport({
  // Define C Macros for NuttX on RISC-V, equivalent to...
  // #define __NuttX__
  // #define NDEBUG
  // #define ARCH_RISCV

  @cDefine(&quot;__NuttX__&quot;,  &quot;&quot;);
  @cDefine(&quot;NDEBUG&quot;,     &quot;&quot;);
  @cDefine(&quot;ARCH_RISCV&quot;, &quot;&quot;);
</code></pre></div>
<p>The code above defines the <strong>C Macros</strong> that will be called by the C Header Files coming up.</p>
<p>Next comes a workaround for a <strong>C Macro Error</strong> that appears on Zig with Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
  @cDefine(&quot;__int_c_join(a, b)&quot;, &quot;a&quot;);  //  Bypass zig/lib/include/stdint.h
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-macro-error">(More about this)</a></p>
<p>We import the <strong>C Header Files</strong> for Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Import the NuttX Header Files from C, equivalent to...
  // #include &lt;arch/types.h&gt;
  // #include &lt;../../nuttx/include/limits.h&gt;
  // #include &lt;stdio.h&gt;

  @cInclude(&quot;arch/types.h&quot;);
  @cInclude(&quot;../../nuttx/include/limits.h&quot;);
  @cInclude(&quot;stdio.h&quot;);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(More about the includes)</a></p>
<p>Followed by the C Header Files for our <strong>LoRaWAN Library</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Import LoRaWAN Header Files from C, based on
  // https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L24-L40
  @cInclude(&quot;firmwareVersion.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/githubVersion.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/boards/utilities.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/mac/region/RegionCommon.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/Commissioning.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandler/LmHandler.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandler/packages/LmhpCompliance.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandler/packages/LmhpClockSync.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandler/packages/LmhpRemoteMcastSetup.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandler/packages/LmhpFragmentation.h&quot;);
  @cInclude(&quot;../libs/liblorawan/src/apps/LoRaMac/common/LmHandlerMsgDisplay.h&quot;);
});
</code></pre></div>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L24-L40">(Based on this C code)</a></p>
<p>The LoRaWAN Library is ready to be called by our Zig App!</p>
<p>This is how we reference the LoRaWAN Library to define our <a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country/"><strong>LoRaWAN Region</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// LoRaWAN Region
const ACTIVE_REGION = c.LORAMAC_REGION_AS923;
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L44-L86">(Source)</a></p>
<p><em>Why the ‚Äú<strong><code>c.</code></strong>‚Äù in <code>c.LORAMAC_REGION_AS923</code>?</em></p>
<p>Remember that we imported the LoRaWAN Library under the <strong>Namespace ‚Äú<code>c</code>‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LoRaWAN Library under Namespace &quot;c&quot;
const c = @cImport({ ... });
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L5-L48">(Source)</a></p>
<p>Hence we use ‚Äú<code>c.something</code>‚Äù to refer to the Constants and Functions defined in the LoRaWAN Library.</p>
<p><em>Why did we define the C Macros like <code>__NuttX__</code>?</em></p>
<p>These C Macros are needed by the <strong>NuttX Header Files</strong>.</p>
<p>Without the macros, the NuttX Header Files won‚Äôt be imported correctly into Zig. <a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(See this)</a></p>
<p><em>Why did we import ‚Äúarch/types.h‚Äù?</em></p>
<p>This fixes a problem with the <strong>NuttX Types</strong>. <a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(See this)</a></p>
<p>Let‚Äôs head over to the Main Function‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/iot-code3a.png" alt="Zig App calls LoRaWAN Library imported from C" /></p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L90-L158">(Source)</a></p>
<h1 id="main-function"><a href="#main-function">3 Main Function</a></h1>
<p>This is the <a href="https://lupyuen.github.io/articles/zig#main-function"><strong>Main Function</strong></a> for our Zig App: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L90-L158">lorawan_test.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function that will be called by NuttX.
/// We call the LoRaWAN Library to join a 
/// LoRaWAN Network and send a Data Packet.
pub export fn lorawan_test_main(
  _argc: c_int, 
  _argv: [*]const [*]const u8
) c_int {
  _ = _argc;
  _ = _argv;

  // Init the Timer Struct at startup
  TxTimer = std.mem.zeroes(c.TimerEvent_t);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-struct-initialisation-error">(We init <strong>TxTimer</strong> here because of this)</a></p>
<p>We begin by computing the randomised <strong>interval between transmissions</strong> of LoRaWAN Data Packets‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Compute the interval between transmissions based on Duty Cycle
  TxPeriodicity = @intCast(u32,  // Cast to u32 because randr() can be negative
    APP_TX_DUTYCYCLE +
    c.randr(
      -APP_TX_DUTYCYCLE_RND,
      APP_TX_DUTYCYCLE_RND
    )
  );
</code></pre></div>
<p>(We‚Äôll talk about <strong>@intCast</strong> in a while)</p>
<p>Our app sends LoRaWAN Data Packets every <strong>40 seconds</strong> (roughly).  <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L52-L59">(See this)</a></p>
<p>Next we show the <strong>App Version</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Show the Firmware and GitHub Versions
  const appVersion = c.Version_t {
    .Value = c.FIRMWARE_VERSION,
  };
  const gitHubVersion = c.Version_t {
    .Value = c.GITHUB_VERSION,
  };
  c.DisplayAppInfo(&quot;Zig LoRaWAN Test&quot;, &amp;appVersion, &amp;gitHubVersion);
</code></pre></div>
<p>Then we <strong>initialise the LoRaWAN Library</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Init LoRaWAN
  if (LmHandlerInit(&amp;LmHandlerCallbacks, &amp;LmHandlerParams)
    != c.LORAMAC_HANDLER_SUCCESS) {
    std.log.err(&quot;LoRaMac wasn&#39;t properly initialized&quot;, .{});

    // Fatal error, endless loop.
    while (true) {}
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L651-L682">(<strong>LmHandlerCallbacks</strong> and <strong>LmHandlerParams</strong> are defined here)</a></p>
<p>(We‚Äôll explain ‚Äú<code>.{}</code>‚Äù in a while)</p>
<p>We set the <strong>Max Tolerated Receive Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set system maximum tolerated rx error in milliseconds
  _ = c.LmHandlerSetSystemMaxRxError(20);
</code></pre></div>
<p>And we load some packages for <strong>LoRaWAN Compliance</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // The LoRa-Alliance Compliance protocol package should always be initialized and activated.
  _ = c.LmHandlerPackageRegister(c.PACKAGE_ID_COMPLIANCE,         &amp;LmhpComplianceParams);
  _ = c.LmHandlerPackageRegister(c.PACKAGE_ID_CLOCK_SYNC,         null);
  _ = c.LmHandlerPackageRegister(c.PACKAGE_ID_REMOTE_MCAST_SETUP, null);
  _ = c.LmHandlerPackageRegister(c.PACKAGE_ID_FRAGMENTATION,      &amp;FragmentationParams);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L684-L709">(<strong>LmhpComplianceParams</strong> and <strong>FragmentationParams</strong> are defined here)</a></p>
<p>Everything is hunky dory! We can now transmit a LoRaWAN Request to <strong>join the LoRaWAN Network</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Init the Clock Sync and File Transfer status
  IsClockSynched     = false;
  IsFileTransferDone = false;

  // Join the LoRaWAN Network
  c.LmHandlerJoin();
</code></pre></div>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/peripherals/soft-se/se-identity.h">(LoRaWAN Keys and EUIs are defined here)</a></p>
<p>We start the <strong>Transmit Timer</strong> that will send a LoRaWAN Data Packet at periodic intervals (right after we join the LoRaWAN Network)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set the Transmit Timer
  StartTxProcess(LmHandlerTxEvents_t.LORAMAC_HANDLER_TX_ON_TIMER);
</code></pre></div>
<p>Finally we loop forever handling <strong>LoRaWAN Events</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Handle LoRaWAN Events
  handle_event_queue();  //  Never returns
  return 0;
}
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-handle-lorawan-events">(<strong>handle_event_queue</strong> is explained in the Appendix)</a></p>
<p>That‚Äôs all for the Main Function of our Zig App!</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-flow.jpg" alt="Our LoRaWAN Zig App" /></p>
<p><em>Wait‚Ä¶ Our Zig Code looks familiar?</em></p>
<p>Yep our Zig Code is largely identical to the <strong>C Code in the Demo App</strong> for the LoRaWAN Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L314-L390"><strong>LoRaMac/fuota-test-01/main.c</strong></a></p>
<p>(Pic below)</p>
</li>
</ul>
<p><strong>Converting C Code to Zig</strong> looks rather straightforward. In a while we‚Äôll talk about the tricky parts we encountered during the conversion.</p>
<p><em>Why did we call <strong>LmHandlerInit</strong> instead of <strong>c.LmHandlerInit</strong>?</em></p>
<p>That‚Äôs one of the tricky parts of our C-to-Zig conversion, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#appendix-fix-opaque-type"><strong>‚ÄúFix Opaque Type‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/iot-code1a.png" alt="Demo App for the LoRaWAN Stack" /></p>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L314-L390">(Source)</a></p>
<h1 id="convert-integer-type"><a href="#convert-integer-type">4 Convert Integer Type</a></h1>
<p>Earlier we saw this computation of the randomised <strong>interval between transmissions</strong> of LoRaWAN Data Packets: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L106-L113">lorawan_test.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// In Zig: Compute the interval between transmissions based on Duty Cycle.
// TxPeriodicity is an unsigned integer (32-bit).
// We cast to u32 because randr() can be negative.
TxPeriodicity = @intCast(u32,
  APP_TX_DUTYCYCLE +
  c.randr(
    -APP_TX_DUTYCYCLE_RND,
    APP_TX_DUTYCYCLE_RND
  )
);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L52-L59">(Roughly 40 seconds)</a></p>
<p>Let‚Äôs find out why <a href="https://ziglang.org/documentation/master/#intCast"><strong>@intCast</strong></a> is needed.</p>
<p>In the Original C Code we compute the interval <strong>without any Explicit Type Conversion</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// In C: Compute the interval between transmissions based on Duty Cycle.
// TxPeriodicity is an unsigned integer (32-bit).
// Remember that randr() can be negative.
TxPeriodicity = 
  APP_TX_DUTYCYCLE + 
  randr( 
    -APP_TX_DUTYCYCLE_RND, 
    APP_TX_DUTYCYCLE_RND 
  );
</code></pre></div>
<p><a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L330-L333">(Source)</a></p>
<p><em>What happens if we compile this in Zig?</em></p>
<p>Zig Compiler shows this error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>unsigned 32-bit int cannot represent 
all possible signed 32-bit values
</code></pre></div>
<p><em>What does it mean?</em></p>
<p>Well <strong>TxPeriodicity</strong> is an <strong>Unsigned Integer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Random interval between transmissions
var TxPeriodicity: u32 = 0;
</code></pre></div>
<p>But <a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/boards/utilities.h#L94-L101"><strong>randr()</strong></a> returns a <strong>Signed Integer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>/// Computes a random number between min and max
int32_t randr(int32_t min, int32_t max);
</code></pre></div>
<p>Mixing <strong>Signed and Unsigned Integers</strong> is a Bad Sign (pun intended)‚Ä¶</p>
<p><strong>randr()</strong> could potentially cause <strong>TxPeriodicity</strong> to underflow!</p>
<p><em>How does @intCast fix this?</em></p>
<p>When we write this with <a href="https://ziglang.org/documentation/master/#intCast"><strong>@intCast</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>TxPeriodicity = @intCast(u32,
  APP_TX_DUTYCYCLE +
  c.randr(
    -APP_TX_DUTYCYCLE_RND,
    APP_TX_DUTYCYCLE_RND
  )
);
</code></pre></div>
<p>We‚Äôre telling the Zig Compiler to convert the <strong>Signed Result to an Unsigned Integer</strong>.</p>
<p><a href="https://ziglang.org/documentation/master/#intCast">(More about <strong>@intCast</strong>)</a></p>
<p><em>What happens if there‚Äôs an underflow?</em></p>
<p>The Signed-to-Unsigned Conversion fails and we‚Äôll see a <strong>Runtime Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>!ZIG PANIC!
attempt to cast negative value to unsigned integer
Stack Trace:
0x23016dba
</code></pre></div>
<p>Great to have Zig watching our backs‚Ä¶ When we do risky things! üëç</p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-panic-handler">(How we implemented a Custom Panic Handler)</a></p>
<h1 id="transmit-data-packet"><a href="#transmit-data-packet">5 Transmit Data Packet</a></h1>
<p>Back to our Zig App: This is how we <strong>transmit a Data Packet</strong> to the LoRaWAN Network: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L163-L205">lorawan_test.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Prepare the payload of a Data Packet 
/// and transmit it
fn PrepareTxFrame() void {

  // If we haven&#39;t joined the LoRaWAN Network...
  if (c.LmHandlerIsBusy()) {
    // Try again later
    return;
  }
</code></pre></div>
<p>LoRaWAN won‚Äôt let us transmit data unless we‚Äôve <strong>joined the LoRaWAN Network</strong>. So we check this first.</p>
<p>Next we prepare the <strong>message to be sent</strong> <em>(‚ÄúHi NuttX‚Äù)</em>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Message to be sent to LoRaWAN
  const msg: []const u8 = &quot;Hi NuttX\x00&quot;;  // 9 bytes including null
  debug(&quot;PrepareTxFrame: Transmit to LoRaWAN ({} bytes): {s}&quot;, .{ 
    msg.len, msg 
  });
</code></pre></div>
<p>(We‚Äôll talk about <strong>debug</strong> in a while)</p>
<p>That‚Äôs <strong>9 bytes</strong>, including the Terminating Null.</p>
<p><em>Why so smol?</em></p>
<p>The first LoRaWAN message needs to be <strong>11 bytes</strong> or smaller, subsequent messages can be up to <strong>53 bytes</strong>.</p>
<p>This depends on the <strong>LoRaWAN Data Rate</strong> and the LoRaWAN Region. <a href="https://lupyuen.github.io/articles/lorawan3#message-size">(See this)</a></p>
<p>Then we copy the message into the <strong>LoRaWAN Buffer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Copy message into LoRaWAN buffer
  std.mem.copy(
    u8,              // Type
    &amp;AppDataBuffer,  // Destination
    msg              // Source
  );
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/std/#std;mem.copy">(<strong>std.mem.copy</strong> is documented here)</a></p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L732-L737">(<strong>AppDataBuffer</strong> is defined here)</a></p>
<p>We compose the <strong>LoRaWAN Transmit Request</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Compose the transmit request
  var appData = c.LmHandlerAppData_t {
    .Buffer     = &amp;AppDataBuffer,
    .BufferSize = msg.len,
    .Port       = 1,
  };
</code></pre></div>
<p>Remember that the <a href="https://lupyuen.github.io/articles/lorawan3#message-size"><strong>Max Message Size</strong></a> depends on the LoRaWAN Data Rate and the LoRaWAN Region?</p>
<p>This is how we <strong>validate the Message Size</strong> to make sure that our message isn‚Äôt too large‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Validate the message size and check if it can be transmitted
  var txInfo: c.LoRaMacTxInfo_t = undefined;
  const status = c.LoRaMacQueryTxPossible(
    appData.BufferSize,  // Message Size
    &amp;txInfo              // Unused
  );
  assert(status == c.LORAMAC_STATUS_OK);
</code></pre></div>
<p>Finally we <strong>transmit the message</strong> to the LoRaWAN Network‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Transmit the message
  const sendStatus = c.LmHandlerSend(
    &amp;appData,                      // Transmit Request
    LmHandlerParams.IsTxConfirmed  // False (No acknowledge required)
  );
  assert(sendStatus == c.LORAMAC_HANDLER_SUCCESS);
  debug(&quot;PrepareTxFrame: Transmit OK&quot;, .{});
}
</code></pre></div>
<p>And that‚Äôs how <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L163-L205"><strong>PrepareTxFrame</strong></a> transmits a Data Packet over LoRaWAN.</p>
<p><em>How is PrepareTxFrame called?</em></p>
<p>After we have joined the LoRaWAN Network, our LoRaWAN Event Loop calls <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L222-L232"><strong>UplinkProcess</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// LoRaWAN Event Loop that dequeues Events from 
/// the Event Queue and processes the Events
fn handle_event_queue() void {

  // Loop forever handling Events from the Event Queue
  while (true) {
    // Omitted: Handle the next Event from the Event Queue
    ...

    // If we have joined the network, do the uplink
    if (!c.LmHandlerIsBusy()) {
      UplinkProcess();
    }
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L451-L492">(Source)</a></p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L222-L232"><strong>UplinkProcess</strong></a> then calls <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L163-L205"><strong>PrepareTxFrame</strong></a> to transmit a Data Packet, when the Transmit Timer has expired.</p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L222-L232">(<strong>UplinkProcess</strong> is defined here)</a></p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-handle-lorawan-events">(<strong>handle_event_queue</strong> is explained in the Appendix)</a></p>
<p><img src="https://lupyuen.github.io/images/lorawan3-chirpstack6.png" alt="ChirpStack LoRaWAN Gateway receives Data Packet from our Zig App" /></p>
<p><em>ChirpStack LoRaWAN Gateway receives Data Packet from our Zig App</em></p>
<h1 id="logging"><a href="#logging">6 Logging</a></h1>
<p>Earlier we saw this code for printing a <strong>Debug Message</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Message to be sent
const msg: []const u8 = &quot;Hi NuttX\x00&quot;;  // 9 bytes including null

// Print the message
debug(&quot;Transmit to LoRaWAN ({} bytes): {s}&quot;, .{ 
  msg.len, msg 
});
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L170-L176">(Source)</a></p>
<p>The code above prints this <strong>Formatted Message</strong> to the console‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Transmit to LoRaWAN (9 bytes): Hi NuttX
</code></pre></div>
<p>The <strong>Format Specifiers</strong> <code>{}</code> and <code>{s}</code> embedded in the Format String are explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://ziglearn.org/chapter-2/#formatting"><strong>Zig Formatting</strong></a></p>
</li>
<li>
<p><a href="https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig#L27-L72"><strong>Format Specifiers</strong></a></p>
</li>
</ul>
<p><em>What‚Äôs <code>.{ ... }</code>?</em></p>
<p><code>.{ ... }</code> creates an <a href="https://ziglearn.org/chapter-1/#anonymous-structs"><strong>Anonymous Struct</strong></a> with a variable number of arguments that will be passed to the <strong>debug</strong> function for formatting.</p>
<p><em>And if we have no arguments?</em></p>
<p>Then we do this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Print the message without formatting
debug(&quot;Transmit to LoRaWAN&quot;, .{});
</code></pre></div>
<p>We discuss the implementation of <strong>Zig Logging</strong> in the Appendix‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#appendix-logging"><strong>‚ÄúAppendix: Logging‚Äù</strong></a></li>
</ul>
<h1 id="compile-zig-app"><a href="#compile-zig-app">7 Compile Zig App</a></h1>
<p>Now that we understand the code, we‚Äôre ready to <strong>compile our LoRaWAN Zig App</strong>!</p>
<p>First we download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>Apache NuttX RTOS</strong> for PineDio Stack BL604‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></li>
</ul>
<p>Before compiling NuttX, configure the <strong>LoRaWAN App Key, Device EUI and Join EUI</strong> in the LoRaWAN Library‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3#device-eui-join-eui-and-app-key"><strong>‚ÄúDevice EUI, Join EUI and App Key‚Äù</strong></a></li>
</ul>
<p>After building NuttX, we download and compile our <strong>LoRaWAN Zig App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Download our LoRaWAN Zig App for NuttX
git clone --recursive https://github.com/lupyuen/zig-bl602-nuttx
cd zig-bl602-nuttx

##  TODO: Edit lorawan_test.zig and set the LoRaWAN Region...
##  const ACTIVE_REGION = c.LORAMAC_REGION_AS923;

##  Compile the Zig App for BL602
##  (RV32IMACF with Hardware Floating-Point)
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/examples/lorawan_test&quot; \
  lorawan_test.zig
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b29186ad4ad870bcaaace704fd3def7d">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App with <strong>Apache NuttX RTOS.</strong></p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Patch the ELF Header of `lorawan_test.o` 
##  from Soft-Float ABI to Hard-Float ABI
xxd -c 1 lorawan_test.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - lorawan_test2.o
cp lorawan_test2.o lorawan_test.o
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Copy the compiled app to NuttX and overwrite `lorawan_test.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp lorawan_test.o $HOME/nuttx/apps/examples/lorawan_test/*lorawan_test.o

##  Build NuttX to link the Zig Object from `lorawan_test.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

##  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>We‚Äôre ready to run our Zig App!</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-flow.jpg" alt="Running our LoRaWAN Zig App" /></p>
<h1 id="run-zig-app"><a href="#run-zig-app">8 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lorawan_test
</code></pre></div>
<p>Our Zig App starts and transmits a LoRaWAN Request to <strong>join the LoRaWAN Network</strong> (by controlling the LoRa Transceiver over SPI)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Application name   : Zig LoRaWAN Test
###### =========== MLME-Request ============ ######
######               MLME_JOIN               ######
###### ===================================== ######
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/0871ac515b18d9d68d3aacf831fd0f5b">(See the complete log)</a></p>
<p>5 seconds later, our app receives the <strong>Join Accept Response</strong> from our ChirpStack LoRaWAN Gateway (by handling the GPIO Interrupt triggered by the LoRa Transceiver)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>###### =========== MLME-Confirm ============ ######
STATUS      : OK
###### ===========   JOINED     ============ ######
OTAA
DevAddr     :  00D803AB
DATA RATE   : DR_2
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/0871ac515b18d9d68d3aacf831fd0f5b">(Source)</a></p>
<p>We have successfully joined the LoRaWAN Network!</p>
<p>Every 40 seconds, our app transmits a <strong>Data Packet</strong> <em>(‚ÄúHi NuttX‚Äù)</em> to the LoRaWAN Network‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>PrepareTxFrame: Transmit to LoRaWAN (9 bytes): Hi NuttX
###### =========== MCPS-Confirm ============ ######
STATUS      : OK
###### =====   UPLINK FRAME        1   ===== ######
CLASS       : A
TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00
DATA RATE   : DR_3
U/L FREQ    : 923200000
TX POWER    : 0
CHANNEL MASK: 0003
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/0871ac515b18d9d68d3aacf831fd0f5b">(Source)</a></p>
<p>The Data Packet appears in our <strong>LoRaWAN Gateway</strong> (ChirpStack), like in the pic below.</p>
<p>Yep our LoRaWAN Zig App has successfully transmitted a Data Packet to the LoRaWAN Network! üéâ</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-chirpstack6.png" alt="ChirpStack LoRaWAN Gateway receives Data Packet from our Zig App" /></p>
<p><em>Can we test our app without a LoRaWAN Gateway?</em></p>
<p>Our app will work fine with <a href="https://lupyuen.github.io/articles/ttn"><strong>The Things Network</strong></a>, the worldwide free-to-use LoRaWAN Network.</p>
<p>Check the Network Coverage here‚Ä¶</p>
<ul>
<li><a href="https://www.thethingsnetwork.org/map"><strong>The Things Network Coverage Map</strong></a></li>
</ul>
<p>And set the <a href="https://lupyuen.github.io/articles/lorawan3#device-eui-join-eui-and-app-key"><strong>LoRaWAN Parameters</strong></a> like so‚Ä¶</p>
<ul>
<li>
<p><strong>LORAWAN_DEVICE_EUI</strong>: Set this to the <strong>DevEUI</strong> from The Things Network</p>
</li>
<li>
<p><strong>LORAWAN_JOIN_EUI</strong>: Set this to <code>{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }</code></p>
</li>
<li>
<p><strong>APP_KEY, NWK_KEY</strong>: Set both to the <strong>AppKey</strong> from The Things Network</p>
</li>
</ul>
<p>To get the <strong>DevEUI</strong> and <strong>AppKey</strong> from The Things Network‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/ttn#add-device-to-the-things-network"><strong>‚ÄúAdd Device to The Things Network‚Äù</strong></a></li>
</ul>
<p>(I don‚Äôt think <strong>NWK_KEY</strong> is used)</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-ttn.png" alt="The Things Network receives Data Packet from our LoRaWAN App" /></p>
<p><em>The Things Network receives Data Packet from our LoRaWAN App</em></p>
<h1 id="safety-checks"><a href="#safety-checks">9 Safety Checks</a></h1>
<p><em>Our IoT App is now in Zig instead of C. Do we gain anything with Zig?</em></p>
<p>We claimed earlier that <strong>Zig is watching our backs</strong> (in case we do something risky)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#convert-integer-type"><strong>‚ÄúConvert Integer Type‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs dig for more evidence that Zig really tries to protect our programs‚Ä¶</p>
<p>This <strong>C Code</strong> (from the original LoRaWAN Demo) copies an array, byte by byte‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static int8_t FragDecoderWrite(uint32_t addr, uint8_t *data, uint32_t size) {
  for (uint32_t i = 0; i &lt; size; i++ ) {
    UnfragmentedData[addr + i] = data[i];
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c#L539-L550">(Source)</a></p>
<p>Our Zig Compiler has a fascinating feature: It can <strong>translate C programs into Zig</strong>!</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#appendix-auto-translate-lorawan-app-to-zig"><strong>‚ÄúAuto-Translate LoRaWAN App from C to Zig‚Äù</strong></a></li>
</ul>
<p>When we feed the above C Code into Zig‚Äôs Auto-Translator, it produces this functionally-equivalent <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub fn FragDecoderWrite(addr: u32, data: [*c]u8, size: u32) callconv(.C) i8 {
  var i: u32 = 0;
  while (i &lt; size) : (i +%= 1) {
    UnfragmentedData[addr +% i] = data[i];
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L4335-L4349">(Source)</a></p>
<p><em>Hmmm something looks different?</em></p>
<p>Yep the <strong>Array Indexing</strong> in C‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>//  Array Indexing in C...
UnfragmentedData[addr + i]
</code></pre></div>
<p>Gets translated to this in Zig‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>//  Array Indexing in Zig...
UnfragmentedData[addr +% i]
</code></pre></div>
<p>‚Äú<strong><code>+</code></strong>‚Äù in C becomes ‚Äú<strong><code>+%</code></strong>‚Äù in Zig!</p>
<p><em>What‚Äôs ‚Äú<code>+%</code>‚Äù in Zig?</em></p>
<p>That‚Äôs the Zig Operator for <a href="https://ziglang.org/documentation/master/#Wrapping-Operations"><strong>Wraparound Addition</strong></a>.</p>
<p>Which means that the result <strong>wraps back to 0</strong> (and beyond) if the addition overflows the integer.</p>
<p><em>Exactly how we expect C to work right?</em></p>
<p>Yep the Zig Compiler has faithfully translated the Wraparound Addition from C to Zig.</p>
<p>But this isn‚Äôt what we intended, since we don‚Äôt expect the addition to overflow.</p>
<p>That‚Äôs why in our final converted Zig code, we <strong>revert ‚Äú<code>+%</code>‚Äù back to ‚Äú<code>+</code>‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>export fn FragDecoderWrite(addr: u32, data: [*c]u8, size: u32) i8 {
  var i: u32 = 0;
  while (i &lt; size) : (i += 1) {
    //  We changed `+%` back to `+`
    UnfragmentedData[addr + i] = data[i];
  }
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L403-L412">(Source)</a></p>
<p><em>But what happens if the addition overflows?</em></p>
<p>We‚Äôll see a Runtime Error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>panic: integer overflow
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Integer-Overflow">(Source)</a></p>
<p>Which is probably a good thing, to ensure that our values are sensible.</p>
<p><em>What if our Array Index goes out of bounds?</em></p>
<p>We‚Äôll get another Runtime Error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>panic: index out of bounds
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Index-out-of-Bounds">(Source)</a></p>
<p>We handle Runtime Errors in our <strong>Custom Panic Handler</strong>, as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#appendix-panic-handler"><strong>‚ÄúZig Panic Handler‚Äù</strong></a></li>
</ul>
<p><em>So Zig watches for underflow / overflow / out-of-bounds errors at runtime. Anything else?</em></p>
<p>Here‚Äôs the list of <strong>Safety Checks</strong> done by Zig at runtime‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>‚ÄúZig Undefined Behavior‚Äù</strong></a></li>
</ul>
<p>Thus indeed, Zig tries very hard to catch all kinds of problems at runtime.</p>
<p>And that‚Äôs super helpful for a complex app like ours.</p>
<p><em>Can we turn off the Safety Checks?</em></p>
<p>If we prefer to live a little recklessly (momentarily), this is how we <strong>disable the Safety Checks</strong>‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/#setRuntimeSafety"><strong>@setRuntimeSafety</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604" /></p>
<h1 id="zig-outcomes"><a href="#zig-outcomes">10 Zig Outcomes</a></h1>
<p><em>Once again‚Ä¶ Why are we doing this in Zig?</em></p>
<p>Let‚Äôs recap: We have a <strong>complex chunk of firmware</strong> that needs to run on an IoT gadget (PineDio Stack)‚Ä¶</p>
<ul>
<li>
<p>It talks SPI to the <strong>LoRa Radio Transceiver</strong> to transmit packets</p>
</li>
<li>
<p>It handles <strong>GPIO Interrupts</strong> from the LoRa Transceiver to receive packets</p>
</li>
<li>
<p>It needs <strong>Multithreading, Timers and Event Queues</strong> because the LoRaWAN Protocol is complicated and time-critical</p>
</li>
</ul>
<p>We wished we could <strong>rewrite the LoRaWAN Stack</strong> in a modern, memory-safe language‚Ä¶ But we can‚Äôt. <a href="https://lupyuen.github.io/articles/zig#why-zig">(Because LoRaWAN changes)</a></p>
<p><em>But we can do this partially in Zig right?</em></p>
<p>Yes it seems the best we can do today is to‚Ä¶</p>
<ul>
<li>
<p>Code the <strong>High-Level Parts in Zig</strong></p>
<p>(Event Loop and Data Transmission)</p>
</li>
<li>
<p>Leave the <strong>Low-Level Parts in C</strong></p>
<p>(LoRaWAN Stack and Apache NuttX RTOS)</p>
</li>
</ul>
<p>And Zig Compiler will do the <strong>Zig-to-C</strong> plumbing for us. (As we‚Äôve seen)</p>
<p><em>Zig Compiler calls Clang to import the C Header Files. But NuttX compiles with GCC. Won‚Äôt we have problems with code compatibility?</em></p>
<p>We have validated Zig Compiler‚Äôs <strong>Clang as a drop-in replacement</strong> for GCC‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc"><strong>‚ÄúZig Compiler as Drop-In Replacement for GCC‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-lorawan-library-for-nuttx"><strong>‚ÄúLoRaWAN Library (compiled with zig cc)‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-lorawan-app-for-nuttx"><strong>‚ÄúLoRaWAN App (compiled with zig cc)‚Äù</strong></a></p>
</li>
</ul>
<p>Hence we‚Äôre confident that <strong>Zig will interoperate correctly</strong> with the LoRaWAN Stack and Apache NuttX RTOS.</p>
<p>(Well for BL602 NuttX at least)</p>
<p><em>Were there problems with Zig-to-C interoperability?</em></p>
<p>We hit some <strong>minor interoperability issues</strong> and we found workarounds‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-opaque-type-error"><strong>‚ÄúOpaque Type Error‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-fix-opaque-type"><strong>‚ÄúFix Opaque Type‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-macro-error"><strong>‚ÄúMacro Error‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-struct-initialisation-error"><strong>‚ÄúStruct Initialisation Error‚Äù</strong></a></p>
</li>
</ul>
<p>No showstoppers, so our Zig App is good to go!</p>
<p><em>Is Zig effective in managing the complexity of our firmware?</em></p>
<p>I think it is! Zig has plenty of <strong>Safety Checks</strong> to help ensure that we‚Äôre doing the right thing‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot#safety-checks"><strong>‚ÄúSafety Checks‚Äù</strong></a></li>
</ul>
<p>Now I feel confident that I can <strong>safely extend</strong> our Zig App to do more meaningful IoT things‚Ä¶</p>
<ul>
<li>
<p>Read BL602‚Äôs <strong>Internal Temperature Sensor</strong> <a href="https://github.com/lupyuen/bl602_adc_test">(Like this)</a></p>
</li>
<li>
<p>Compress the Temperature Sensor Data with <strong>CBOR</strong> <a href="https://lupyuen.github.io/articles/cbor2">(Like this)</a></p>
</li>
<li>
<p>Transmit over LoRaWAN to <strong>The Things Network</strong> <a href="https://lupyuen.github.io/articles/ttn">(Like this)</a></p>
</li>
<li>
<p>Monitor the Sensor Data with <strong>Prometheus and Grafana</strong> <a href="https://lupyuen.github.io/articles/prometheus">(Like this)</a></p>
</li>
</ul>
<p>We‚Äôll extend our Zig App the modular way thanks to <a href="https://zig.news/mattnite/import-and-packages-23mb"><strong>@import</strong></a></p>
<p><img src="https://lupyuen.github.io/images/prometheus-title.jpg" alt="Extending our Zig App with CBOR, The Things Network, Prometheus and Grafana" /></p>
<p><em>Is there anything else that might benefit from Zig?</em></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#nuttx-apps"><strong>LVGL Touchscreen Apps</strong></a> might be easier to maintain when we code them in Zig.</p>
<p>(Since LVGL looks as complicated as LoRaWAN)</p>
<p>Someday I‚Äôll try LVGL on Zig‚Ä¶ And we might possibly combine it with LoRaWAN in a single Zig App! Check the updates here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/pinedio2-title.jpg" alt="LVGL Touchscreen Apps might benefit from Zig" /></p>
<p><em>LVGL Touchscreen Apps might benefit from Zig</em></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>I hope this article has inspired you to create IoT apps in Zig!</p>
<p>In the coming weeks I shall flesh out our Zig App, so that it works like a real <strong>IoT Sensor Device.</strong></p>
<p>(With Temperature Sensor, CBOR Encoding, The Things Network, ‚Ä¶)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sensor"><strong>‚ÄúRead NuttX Sensor Data with Zig‚Äù</strong></a></li>
</ul>
<p>For the next article we‚Äôll take a quick detour and explore <strong>Zig on PinePhone</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinephone"><strong>‚ÄúBuild a PinePhone App with Zig and zgt‚Äù</strong></a></li>
</ul>
<p>And then back to <strong>Zig on Apache NuttX RTOS</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Zig/comments/vbvj9e/build_an_iot_app_with_zig_and_lorawan/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/iot.md"><strong><code>lupyuen.github.io/src/iot.md</code></strong></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1533595486577258496"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>This article was inspired by a question from my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsor</strong></a>: ‚ÄúCan we run Zig on BL602 with Apache NuttX RTOS?‚Äù</p>
</li>
<li>
<p>These articles were super helpful for <strong>Zig-to-C Interoperability</strong>‚Ä¶</p>
<p><a href="https://ziglearn.org/chapter-4/"><strong>‚ÄúWorking with C‚Äù</strong></a></p>
<p><a href="https://zig.news/kristoff/compile-a-c-c-project-with-zig-368j"><strong>‚ÄúCompile a C/C++ Project with Zig‚Äù</strong></a></p>
<p><a href="https://zig.news/kristoff/extend-a-c-c-project-with-zig-55di"><strong>‚ÄúExtend a C/C++ Project with Zig‚Äù</strong></a></p>
<p><a href="https://kristoff.it/blog/maintain-it-with-zig"><strong>‚ÄúMaintain it With Zig‚Äù</strong></a></p>
</li>
<li>
<p>Can we use <a href="https://ziglang.org/documentation/master/#Async-Functions"><strong>Zig Async Functions</strong></a> to simplify our Zig IoT App?</p>
<p>Interesting idea, let‚Äôs explore that! <a href="https://www.reddit.com/r/Zig/comments/vbvj9e/comment/iclmwr9/?utm_source=share&amp;utm_medium=web2x&amp;context=3">(See this)</a></p>
</li>
<li>
<p>I‚Äôm now using <a href="https://ziglang.org/documentation/master/#typeInfo"><strong>Zig Type Reflection</strong></a> to document the internals of the LoRaWAN Library‚Ä¶</p>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx#zig-type-reflection"><strong>‚ÄúZig Type Reflection for LoRaWAN Library‚Äù</strong></a></p>
<p>The LoRaWAN Library is a popular library that runs on many platforms, would be great if Zig can create helpful docs for the complicated multithreaded library.</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-handler.jpg" alt="Handle LoRaWAN Events with NimBLE Porting Layer" /></p>
<h1 id="appendix-handle-lorawan-events"><a href="#appendix-handle-lorawan-events">13 Appendix: Handle LoRaWAN Events</a></h1>
<p>Let‚Äôs look at the <strong>Event Loop</strong> that handles the LoRa and LoRaWAN Events in our app.</p>
<p><em>Our Event Loop looks different from the Original LoRaWAN Demo App?</em></p>
<p>Yep the Original LoRaWAN Demo App handles LoRaWAN Events in a <strong>Busy-Wait Loop</strong>. <a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c#L366-L389">(See this)</a></p>
<p>But since our Zig App runs on a Real-Time Operating System (RTOS), we can use the <strong>Multithreading Features</strong> (Timers and Event Queues) provided by the RTOS.</p>
<p><em>So we‚Äôre directly calling the Timers and Event Queues from Apache NuttX RTOS?</em></p>
<p>Not quite. We‚Äôre calling the Timers and Event Queues provided by <a href="https://lupyuen.github.io/articles/sx1262#multithreading-with-nimble-porting-layer"><strong>NimBLE Porting Layer</strong></a>.</p>
<p>NimBLE Porting Layer is a <a href="https://github.com/apache/mynewt-nimble/tree/master/porting/npl"><strong>Portable Multitasking Library</strong></a> that works on multiple operating systems: FreeRTOS, Linux, Mynewt, NuttX, RIOT.</p>
<p>By calling NimBLE Porting Layer, our modded LoRaWAN Stack will run on all of these operating systems (hopefully).</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#multithreading-with-nimble-porting-layer">(More about NimBLE Porting Layer)</a></p>
<p><em>Alright let‚Äôs see the code!</em></p>
<p>Our Event Loop forever reads LoRa and LoRaWAN Events from an <strong>Event Queue</strong> and handles them.</p>
<p>The Event Queue is created in our LoRa SX1262 Library as explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sx1262#event-queue"><strong>‚ÄúEvent Queue‚Äù</strong></a></li>
</ul>
<p>The Main Function of our LoRaWAN App calls this function to run the <strong>Event Loop</strong>: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L451-L492">lorawan_test.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// LoRaWAN Event Loop that dequeues Events from the Event Queue and processes the Events
fn handle_event_queue() void {

  // Loop forever handling Events from the Event Queue
  while (true) {

    // Get the next Event from the Event Queue
    var ev: [*c]c.ble_npl_event = c.ble_npl_eventq_get(
      &amp;event_queue,           //  Event Queue
      c.BLE_NPL_TIME_FOREVER  //  No Timeout (Wait forever for event)
    );
</code></pre></div>
<p>This code runs in the <strong>Foreground Thread</strong> of our app.</p>
<p>Here we loop forever, <strong>waiting for Events</strong> from the Event Queue.</p>
<p>When we receive an Event, we <strong>remove the Event</strong> from the Event Queue‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // If no Event due to timeout, wait for next Event.
    // Should never happen since we wait forever for an Event.
    if (ev == null) { debug(&quot;handle_event_queue: timeout&quot;, .{}); continue; }
    debug(&quot;handle_event_queue: ev=0x{x}&quot;, .{ @ptrToInt(ev) });

    // Remove the Event from the Event Queue
    c.ble_npl_eventq_remove(&amp;event_queue, ev);
</code></pre></div>
<p>We call the <strong>Event Handler Function</strong> that was registered with the Event‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Trigger the Event Handler Function
    c.ble_npl_event_run(ev);
</code></pre></div>
<ul>
<li>
<p>For SX1262 Interrupts: We call <a href="https://lupyuen.github.io/articles/sx1262#radioondioirq"><strong>RadioOnDioIrq</strong></a> to handle the packet transmitted / received notification</p>
</li>
<li>
<p>For Timer Events: We call the <strong>Timeout Function</strong> defined in the Timer</p>
</li>
</ul>
<p>The rest of the Event Loop handles <strong>LoRaWAN Events</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Process the LoRaMac events
    c.LmHandlerProcess();
</code></pre></div>
<p><strong>LmHandlerProcess</strong> handles <strong>Join Network Events</strong> in the LoRaMAC Layer of our LoRaWAN Library.</p>
<p>If we have joined the LoRaWAN Network, we <strong>transmit data</strong> to the network‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // If we have joined the network, do the uplink
    if (!c.LmHandlerIsBusy()) {
      UplinkProcess();
    }
</code></pre></div>
<p>(<a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L220-L230"><strong>UplinkProcess</strong></a> calls <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L163-L203"><strong>PrepareTxFrame</strong></a> to transmit a Data Packet, which we have seen earlier)</p>
<p>The last part of the Event Loop will handle Low Power Mode in future‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // TODO: CRITICAL_SECTION_BEGIN();
    if (IsMacProcessPending == 1) {
      // Clear flag and prevent MCU to go into low power mode
      IsMacProcessPending = 0;
    } else {
      // The MCU wakes up through events
      // TODO: BoardLowPowerHandler();
    }
    // TODO: CRITICAL_SECTION_END();
  }
}
</code></pre></div>
<p>And we loop back perpetually, waiting for Events and handling them.</p>
<p>That‚Äôs how we handle LoRa and LoRaWAN Events with NimBLE Porting Layer!</p>
<h1 id="appendix-logging"><a href="#appendix-logging">14 Appendix: Logging</a></h1>
<p>We have implemented Zig Debug Logging <strong>std.log.debug</strong> that‚Äôs described here‚Ä¶</p>
<ul>
<li><a href="https://gist.github.com/leecannon/d6f5d7e5af5881c466161270347ce84d"><strong>‚ÄúA simple overview of Zig‚Äôs std.log‚Äù</strong></a></li>
</ul>
<p>Here‚Äôs how we call <strong>std.log.debug</strong> to print a log message‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>//  Create a short alias named `debug`
const debug  = std.log.debug;

//  Message with 8 bytes
const msg: []const u8 = &quot;Hi NuttX&quot;;

//  Print the message
debug(&quot;Transmit to LoRaWAN ({} bytes): {s}&quot;, .{ 
  msg.len, msg 
});

// Prints: Transmit to LoRaWAN (8 bytes): Hi NuttX
</code></pre></div>
<p><code>.{ ... }</code> creates an <a href="https://ziglearn.org/chapter-1/#anonymous-structs"><strong>Anonymous Struct</strong></a> with a variable number of arguments that will be passed to <strong>std.log.debug</strong> for formatting.</p>
<p>Below is our implementation of <strong>std.log.debug</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Called by Zig for `std.log.debug`, `std.log.info`, `std.log.err`, ...
/// https://gist.github.com/leecannon/d6f5d7e5af5881c466161270347ce84d
pub fn log(
  comptime _message_level: std.log.Level,
  comptime _scope: @Type(.EnumLiteral),
  comptime format: []const u8,
  args: anytype,
) void {
  _ = _message_level;
  _ = _scope;

  // Format the message
  var buf: [100]u8 = undefined;  // Limit to 100 chars
  var slice = std.fmt.bufPrint(&amp;buf, format, args)
    catch { _ = puts(&quot;*** log error: buf too small&quot;); return; };
    
  // Terminate the formatted message with a null
  var buf2: [buf.len + 1 : 0]u8 = undefined;
  std.mem.copy(
    u8, 
    buf2[0..slice.len], 
    slice[0..slice.len]
  );
  buf2[slice.len] = 0;

  // Print the formatted message
  _ = puts(&amp;buf2);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L519-L546">(Source)</a></p>
<p>This implementation calls <strong>puts()</strong>, which is supported by Apache NuttX RTOS since it‚Äôs <a href="https://nuttx.apache.org/docs/latest/introduction/inviolables.html#strict-posix-compliance"><strong>POSIX-Compliant</strong></a>.</p>
<h1 id="appendix-panic-handler"><a href="#appendix-panic-handler">15 Appendix: Panic Handler</a></h1>
<p><em>Some debug features don‚Äôt seem to be working? Like <strong>unreachable</strong>, <strong>std.debug.assert</strong> and <strong>std.debug.panic</strong>?</em></p>
<p>That‚Äôs because for Embedded Platforms (like Apache NuttX RTOS) we need to implement our own <strong>Panic Handler</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html"><strong>‚ÄúUsing Zig to Provide Stack Traces on Kernel Panic for a Bare Bones Operating System‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/ziglang/zig/blob/master/lib/std/builtin.zig#L763-L847"><strong>Default Panic Handler: std.debug.default_panic</strong></a></p>
</li>
</ul>
<p>With our own Panic Handler, this Assertion Failure‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>//  Create a short alias named `assert`
const assert = std.debug.assert;

//  Assertion Failure
assert(TxPeriodicity != 0);
</code></pre></div>
<p>Will show this Stack Trace‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>!ZIG PANIC!
reached unreachable code
Stack Trace:
0x23016394
0x23016ce0
</code></pre></div>
<p><em>How do we read the Stack Trace?</em></p>
<p>We need to generate the <strong>RISC-V Disassembly</strong> for our firmware. <a href="https://lupyuen.github.io/articles/auto#disassemble-the-firmware">(Like this)</a></p>
<p>According to our RISC-V Disassembly, the first address <strong><code>23016394</code></strong> doesn‚Äôt look interesting, because it‚Äôs inside the <strong>assert</strong> function‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/home/user/zig-linux-x86_64-0.10.0-dev.2351+b64a1d5ab/lib/std/debug.zig:259
pub fn assert(ok: bool) void {
2301637c:	00b51c63          	bne	a0,a1,23016394 &lt;std.debug.assert+0x2c&gt;
23016380:	a009                j	23016382 &lt;std.debug.assert+0x1a&gt;
23016382:	2307e537          	lui	a0,0x2307e
23016386:	f9850513          	addi	a0,a0,-104 # 2307df98 &lt;__unnamed_4&gt;
2301638a:	4581                li	a1,0
2301638c:	00000097          	auipc	ra,0x0
23016390:	f3c080e7          	jalr	-196(ra) # 230162c8 &lt;panic&gt;
    if (!ok) unreachable; // assertion failure
23016394:	a009                j	23016396 &lt;std.debug.assert+0x2e&gt;
</code></pre></div>
<p>But the second address <strong><code>23016ce0</code></strong> reveals the assertion that failed‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/home/user/nuttx/zig-bl602-nuttx/lorawan_test.zig:95
    assert(TxPeriodicity != 0);
23016ccc:	42013537          	lui	a0,0x42013
23016cd0:	fbc52503          	lw	a0,-68(a0) # 42012fbc &lt;TxPeriodicity&gt;
23016cd4:	00a03533          	snez	a0,a0
23016cd8:	fffff097          	auipc	ra,0xfffff
23016cdc:	690080e7          	jalr	1680(ra) # 23016368 &lt;std.debug.assert&gt;
/home/user/nuttx/zig-bl602-nuttx/lorawan_test.zig:100
    TxTimer = std.mem.zeroes(c.TimerEvent_t);
23016ce0:	42016537          	lui	a0,0x42016
</code></pre></div>
<p>This is our implementation of the <strong>Zig Panic Handler</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Called by Zig when it hits a Panic. We print the Panic Message, Stack Trace and halt. See 
/// https://andrewkelley.me/post/zig-stack-traces-kernel-panic-bare-bones-os.html
/// https://github.com/ziglang/zig/blob/master/lib/std/builtin.zig#L763-L847
pub fn panic(
  message: []const u8, 
  _stack_trace: ?*std.builtin.StackTrace
) noreturn {
  // Print the Panic Message
  _ = _stack_trace;
  _ = puts(&quot;\n!ZIG PANIC!&quot;);
  _ = puts(@ptrCast([*c]const u8, message));

  // Print the Stack Trace
  _ = puts(&quot;Stack Trace:&quot;);
  var it = std.debug.StackIterator.init(@returnAddress(), null);
  while (it.next()) |return_address| {
    _ = printf(&quot;%p\n&quot;, return_address);
  }

  // Halt
  while(true) {}
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L501-L522">(Source)</a></p>
<p><em>How do we tell Zig Compiler to use this Panic Handler?</em></p>
<p>We just need to define this <strong>panic</strong> function in the Root Zig Source File (like lorawan_test.zig), and the Zig Runtime will call it when there‚Äôs a panic.</p>
<h1 id="appendix-zig-compiler-as-drop-in-replacement-for-gcc"><a href="#appendix-zig-compiler-as-drop-in-replacement-for-gcc">16 Appendix: Zig Compiler as Drop-In Replacement for GCC</a></h1>
<p><em>Apache NuttX RTOS calls GCC to compile the BL602 firmware. Will Zig Compiler work as the <a href="https://lupyuen.github.io/articles/zig#why-zig">Drop-In Replacement for GCC</a> for compiling NuttX Modules?</em></p>
<p>Let‚Äôs test it on the <a href="https://lupyuen.github.io/articles/sx1262"><strong>LoRa SX1262 Library</strong></a> for Apache NuttX RTOS.</p>
<p>Here‚Äôs how NuttX compiles the LoRa SX1262 Library with GCC‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  LoRa SX1262 Source Directory
cd $HOME/nuttx/nuttx/libs/libsx1262

##  Compile radio.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/radio.c \
  -o  src/radio.o

##  Compile sx126x.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/sx126x.c \
  -o  src/sx126x.o

##  Compile sx126x-nuttx.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/sx126x-nuttx.c \
  -o  src/sx126x-nuttx.o
</code></pre></div>
<p>(As observed with ‚Äú<strong>make ‚Äìtrace</strong>‚Äù when building NuttX)</p>
<p>We switch GCC to ‚Äú<strong>zig cc</strong>‚Äù by making these changes‚Ä¶</p>
<ul>
<li>
<p>Change ‚Äú<code>riscv64-unknown-elf-gcc</code>‚Äù to ‚Äú<code>zig cc</code>‚Äù</p>
</li>
<li>
<p>Add the target ‚Äú<code>-target riscv32-freestanding-none -mcpu=baseline_rv32-d</code>‚Äù‚Äú</p>
</li>
<li>
<p>Remove ‚Äú<code>-march=rv32imafc</code>‚Äù</p>
</li>
</ul>
<p>After making the changes, we run this to compile the LoRa SX1262 Library with ‚Äú<strong>zig cc</strong>‚Äù and link it with the NuttX Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  LoRa SX1262 Source Directory
cd $HOME/nuttx/nuttx/libs/libsx1262

##  Compile radio.c with zig cc
zig cc \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/radio.c \
  -o  src/radio.o

##  Compile sx126x.c with zig cc
zig cc \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/sx126x.c \
  -o  src/sx126x.o

##  Compile sx126x-nuttx.c with zig cc
zig cc \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/sx126x-nuttx.c \
  -o  src/sx126x-nuttx.o

##  Link Zig Object Files with NuttX after compiling with `zig cc`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make
</code></pre></div>
<p>Zig Compiler shows these errors‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>In file included from src/sx126x-nuttx.c:3:
In file included from nuttx/include/debug.h:39:
In file included from nuttx/include/sys/uio.h:45:
nuttx/include/sys/types.h:119:9: error: unknown type name &#39;_size_t&#39;
typedef _size_t      size_t;
        ^
nuttx/include/sys/types.h:120:9: error: unknown type name &#39;_ssize_t&#39;
typedef _ssize_t     ssize_t;
        ^
nuttx/include/sys/types.h:121:9: error: unknown type name &#39;_size_t&#39;
typedef _size_t      rsize_t;
        ^
nuttx/include/sys/types.h:174:9: error: unknown type name &#39;_wchar_t&#39;
typedef _wchar_t     wchar_t;
        ^
In file included from src/sx126x-nuttx.c:4:
In file included from nuttx/include/stdio.h:34:
nuttx/include/nuttx/fs/fs.h:238:20: error: use of undeclared identifier &#39;NAME_MAX&#39;
  char      parent[NAME_MAX + 1];
                   ^
</code></pre></div>
<p>Which we fix this by including the <strong>right header files</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(__NuttX__) &amp;&amp; defined(__clang__)  //  Workaround for NuttX with zig cc
#include &lt;arch/types.h&gt;
#include &quot;../../nuttx/include/limits.h&quot;
#endif  //  defined(__NuttX__) &amp;&amp; defined(__clang__)
</code></pre></div>
<p>Into these source files‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/radio.c#L23-L26">radio.c</a></li>
<li><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L4-L7">sx126x-nuttx.c</a></li>
<li><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x.c#L23-L26">sx126x.c</a></li>
</ul>
<p><a href="https://github.com/lupyuen/lora-sx1262/commit/8da7e4d7cc8f1455d750bc51d75c640eea221f41">(See the changes)</a></p>
<p>Also we insert this code to tell us (at runtime) whether it was <strong>compiled with Zig Compiler</strong> or GCC‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>void SX126xIoInit( void ) {
#ifdef __clang__
  //  For zig cc
  puts(&quot;SX126xIoInit: Compiled with zig cc&quot;);
#else
#warning Compiled with gcc
  //  For gcc
  puts(&quot;SX126xIoInit: Compiled with gcc&quot;);
#endif  //  __clang__
</code></pre></div>
<p><a href="https://github.com/lupyuen/lora-sx1262/blob/lorawan/src/sx126x-nuttx.c#L119-L127">(Source)</a></p>
<p>We run the <strong>LoRaWAN Test App</strong> (compiled with GCC) that calls the LoRa SX1262 Library (compiled with ‚Äú<strong>zig cc</strong>‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lorawan_test
SX126xIoInit: Compiled with zig cc
...
###### =========== MLME-Confirm ============ ######
STATUS      : OK
###### ===========   JOINED     ============ ######
OTAA
DevAddr     :  000E268C
DATA RATE   : DR_2
...
###### =========== MCPS-Confirm ============ ######
STATUS      : OK
###### =====   UPLINK FRAME        1   ===== ######
CLASS       : A
TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00
DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ada7f83a96eb36ad1b9fe09da4527003">(See the complete log)</a></p>
<p>This shows that the LoRa SX1262 Library compiled with ‚Äú<strong>zig cc</strong>‚Äù works perfectly fine with NuttX!</p>
<p><em>Zig Compiler calls Clang to compile C code. But NuttX compiles with GCC. Won‚Äôt we have problems with code compatibility?</em></p>
<p>Apparently no problemo! The experiment above shows that ‚Äú<strong>zig cc</strong>‚Äù (with Clang) is compatible with GCC (at least for BL602 NuttX).</p>
<p>(Just make sure that we pass the same Compiler Options to both compilers)</p>
<h1 id="appendix-lorawan-library-for-nuttx"><a href="#appendix-lorawan-library-for-nuttx">17 Appendix: LoRaWAN Library for NuttX</a></h1>
<p>In the previous section we took <strong>3 source files</strong> (from LoRa SX1262 Library), compiled them with ‚Äú<strong>zig cc</strong>‚Äù and linked them with Apache NuttX RTOS.</p>
<p><em>But will this work for larger NuttX Libraries?</em></p>
<p>Let‚Äôs attempt to compile the huge (and complicated) <a href="https://lupyuen.github.io/articles/lorawan3"><strong>LoRaWAN Library</strong></a> with ‚Äúzig cc‚Äù.</p>
<p>NuttX compiles the LoRaWAN Library like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  LoRaWAN Source Directory
cd $HOME/nuttx/nuttx/libs/liblorawan

##  Compile mac/LoRaMac.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/mac/LoRaMac.c \
  -o  src/mac/LoRaMac.o
</code></pre></div>
<p>We switch to the Zig Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  LoRaWAN Source Directory
cd $HOME/nuttx/nuttx/libs/liblorawan

##  Compile mac/LoRaMac.c with zig cc
zig cc \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe   src/mac/LoRaMac.c \
  -o  src/mac/LoRaMac.o

##  Link Zig Object Files with NuttX after compiling with `zig cc`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make
</code></pre></div>
<p>We include the right header files into <a href="https://github.com/lupyuen/LoRaMac-node-nuttx/blob/master/src/mac/LoRaMac.c#L33-L36">LoRaMac.c</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(__NuttX__) &amp;&amp; defined(__clang__)  //  Workaround for NuttX with zig cc
#include &lt;arch/types.h&gt;
#include &quot;../../nuttx/include/limits.h&quot;
#endif  //  defined(__NuttX__) &amp;&amp; defined(__clang__)
</code></pre></div>
<p><a href="https://github.com/lupyuen/LoRaMac-node-nuttx/commit/e36b54ea3351fc80f03d13a131527bf6733410ab">(See the changes)</a></p>
<p>The modified <a href="https://github.com/lupyuen/LoRaMac-node-nuttx/blob/master/src/mac/LoRaMac.c">LoRaMac.c</a> compiles without errors with ‚Äúzig cc‚Äù.</p>
<p>Unfortunately we haven‚Äôt completed this experiment, because we have a <a href="https://github.com/lupyuen/LoRaMac-node-nuttx/blob/master/Makefile"><strong>long list of source files</strong></a> in the LoRaWAN Library to compile with ‚Äúzig cc‚Äù.</p>
<p>Instead of rewriting the <a href="https://github.com/lupyuen/LoRaMac-node-nuttx/blob/master/Makefile"><strong>NuttX Makefile</strong></a> to call ‚Äúzig cc‚Äù, we should probably compile with ‚Äú<strong>build.zig</strong>‚Äù instead‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/#Zig-Build-System"><strong>‚ÄúZig Build System‚Äù</strong></a></li>
</ul>
<h1 id="appendix-lorawan-app-for-nuttx"><a href="#appendix-lorawan-app-for-nuttx">18 Appendix: LoRaWAN App for NuttX</a></h1>
<p>Thus far we have tested ‚Äú<strong>zig cc</strong>‚Äù as the <strong>drop-in replacement for GCC</strong> in 2 NuttX Modules‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc"><strong>LoRa SX1262 Library</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-lorawan-library-for-nuttx"><strong>LoRaWAN Library</strong></a> (partially)</p>
</li>
</ul>
<p>Let‚Äôs do one last test: We compile the <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c"><strong>LoRaWAN Test App</strong></a> (in C) with ‚Äúzig cc‚Äù.</p>
<p>NuttX compiles the LoRaWAN App <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c">lorawan_test_main.c</a> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  App Source Directory
cd $HOME/nuttx/apps/examples/lorawan_test/lorawan_test_main.c

##  Compile lorawan_test_main.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -Dmain=lorawan_test_main  lorawan_test_main.c \
  -o  lorawan_test_main.c.home.user.nuttx.apps.examples.lorawan_test.o
</code></pre></div>
<p>We switch GCC to ‚Äú<strong>zig cc</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  App Source Directory
cd $HOME/nuttx/apps/examples/lorawan_test

##  Compile lorawan_test_main.c with zig cc
zig cc \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -Dmain=lorawan_test_main  lorawan_test_main.c \
  -o  *lorawan_test.o

##  Link Zig Object Files with NuttX after compiling with `zig cc`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make
</code></pre></div>
<p>As usual we include the right header files into <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c#L20-L23">lorawan_test_main.c</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(__NuttX__) &amp;&amp; defined(__clang__)  //  Workaround for NuttX with zig cc
#include &lt;arch/types.h&gt;
#include &quot;../../nuttx/include/limits.h&quot;
#endif  //  defined(__NuttX__) &amp;&amp; defined(__clang__)
</code></pre></div>
<p><a href="https://github.com/lupyuen/lorawan_test/commit/3d4a451d44cf36b19ef8d900281a2f8f9590de62">(See the changes)</a></p>
<p>When compiled with ‚Äú<strong>zig cc</strong>‚Äù, the LoRaWAN App runs OK on NuttX yay!</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lorawan_test
lorawan_test_main: Compiled with zig cc
...
###### =========== MLME-Confirm ============ ######
STATUS      : OK
###### ===========   JOINED     ============ ######
OTAA
DevAddr     :  00DC5ED5
DATA RATE   : DR_2
...
###### =========== MCPS-Confirm ============ ######
STATUS      : OK
###### =====   UPLINK FRAME        1   ===== ######
CLASS       : A
TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00
DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/477982242d897771d7a5780c8a9b0910">(See the complete log)</a></p>
<h1 id="appendix-auto-translate-lorawan-app-to-zig"><a href="#appendix-auto-translate-lorawan-app-to-zig">19 Appendix: Auto-Translate LoRaWAN App to Zig</a></h1>
<p>The Zig Compiler can <strong>auto-translate C code to Zig</strong>. <a href="https://ziglang.org/documentation/master/#C-Translation-CLI">(See this)</a></p>
<p>Here‚Äôs how we auto-translate our LoRaWAN App <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c">lorawan_test_main.c</a> from C to Zig‚Ä¶</p>
<ul>
<li>
<p>Take the ‚Äú<code>zig cc</code>‚Äù command from the previous section</p>
</li>
<li>
<p>Change ‚Äú<code>zig cc</code>‚Äù to ‚Äú<code>zig translate-c</code>‚Äù</p>
</li>
<li>
<p>Surround the C Compiler Options by ‚Äú<code>-cflags</code> ‚Ä¶ <code>--</code>‚Äù</p>
</li>
</ul>
<p>Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  App Source Directory
cd $HOME/nuttx/apps/examples/lorawan_test

##  Auto-translate lorawan_test_main.c from C to Zig
zig translate-c \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -cflags \
    -fno-common \
    -Wall \
    -Wstrict-prototypes \
    -Wshadow \
    -Wundef \
    -Os \
    -fno-strict-aliasing \
    -fomit-frame-pointer \
    -fstack-protector-all \
    -ffunction-sections \
    -fdata-sections \
    -g \
    -mabi=ilp32f \
    -mno-relax \
  -- \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -Dmain=lorawan_test_main  \
  lorawan_test_main.c \
  &gt;lorawan_test_main.zig
</code></pre></div>
<p>Here‚Äôs the original C code: <a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c">lorawan_test_main.c</a></p>
<p>And the auto-translation from C to Zig: <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig">translated/lorawan_test_main.zig</a></p>
<p>Here‚Äôs a snippet from the original C code‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, FAR char *argv[]) {
#ifdef __clang__
    puts(&quot;lorawan_test_main: Compiled with zig cc&quot;);
#else
    puts(&quot;lorawan_test_main: Compiled with gcc&quot;);
#endif  //  __clang__

    //  If we are using Entropy Pool and the BL602 ADC is available,
    //  add the Internal Temperature Sensor data to the Entropy Pool
    init_entropy_pool();

    //  Compute the interval between transmissions based on Duty Cycle
    TxPeriodicity = APP_TX_DUTYCYCLE + randr( -APP_TX_DUTYCYCLE_RND, APP_TX_DUTYCYCLE_RND );

    const Version_t appVersion    = { .Value = FIRMWARE_VERSION };
    const Version_t gitHubVersion = { .Value = GITHUB_VERSION };
    DisplayAppInfo( &quot;lorawan_test&quot;, 
                    &amp;appVersion,
                    &amp;gitHubVersion );

    //  Init LoRaWAN
    if ( LmHandlerInit( &amp;LmHandlerCallbacks, &amp;LmHandlerParams ) != LORAMAC_HANDLER_SUCCESS )
    {
        printf( &quot;LoRaMac wasn&#39;t properly initialized\n&quot; );
        //  Fatal error, endless loop.
        while ( 1 ) {}
    }

    // Set system maximum tolerated rx error in milliseconds
    LmHandlerSetSystemMaxRxError( 20 );

    // The LoRa-Alliance Compliance protocol package should always be initialized and activated.
    LmHandlerPackageRegister( PACKAGE_ID_COMPLIANCE, &amp;LmhpComplianceParams );
    LmHandlerPackageRegister( PACKAGE_ID_CLOCK_SYNC, NULL );
    LmHandlerPackageRegister( PACKAGE_ID_REMOTE_MCAST_SETUP, NULL );
    LmHandlerPackageRegister( PACKAGE_ID_FRAGMENTATION, &amp;FragmentationParams );

    IsClockSynched     = false;
    IsFileTransferDone = false;

    //  Join the LoRaWAN Network
    LmHandlerJoin( );

    //  Set the Transmit Timer
    StartTxProcess( LORAMAC_HANDLER_TX_ON_TIMER );

    //  Handle LoRaWAN Events
    handle_event_queue(NULL);  //  Never returns

    return 0;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lorawan_test/blob/main/lorawan_test_main.c#L271-L323">(Source)</a></p>
<p>And the auto-translated Zig code‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub export fn lorawan_test_main(arg_argc: c_int, arg_argv: [*c][*c]u8) c_int {
    var argc = arg_argc;
    _ = argc;
    var argv = arg_argv;
    _ = argv;
    _ = puts(&quot;lorawan_test_main: Compiled with zig cc&quot;);
    init_entropy_pool();
    TxPeriodicity = @bitCast(u32, @as(c_int, 40000) + randr(-@as(c_int, 5000), @as(c_int, 5000)));
    const appVersion: Version_t = Version_t{
        .Value = @bitCast(u32, @as(c_int, 16908288)),
    };
    const gitHubVersion: Version_t = Version_t{
        .Value = @bitCast(u32, @as(c_int, 83886080)),
    };
    DisplayAppInfo(&quot;lorawan_test&quot;, &amp;appVersion, &amp;gitHubVersion);
    if (LmHandlerInit(&amp;LmHandlerCallbacks, &amp;LmHandlerParams) != LORAMAC_HANDLER_SUCCESS) {
        _ = printf(&quot;LoRaMac wasn&#39;t properly initialized\n&quot;);
        while (true) {}
    }
    _ = LmHandlerSetSystemMaxRxError(@bitCast(u32, @as(c_int, 20)));
    _ = LmHandlerPackageRegister(@bitCast(u8, @truncate(i8, @as(c_int, 0))), @ptrCast(?*anyopaque, &amp;LmhpComplianceParams));
    _ = LmHandlerPackageRegister(@bitCast(u8, @truncate(i8, @as(c_int, 1))), @intToPtr(?*anyopaque, @as(c_int, 0)));
    _ = LmHandlerPackageRegister(@bitCast(u8, @truncate(i8, @as(c_int, 2))), @intToPtr(?*anyopaque, @as(c_int, 0)));
    _ = LmHandlerPackageRegister(@bitCast(u8, @truncate(i8, @as(c_int, 3))), @ptrCast(?*anyopaque, &amp;FragmentationParams));
    IsClockSynched = @as(c_int, 0) != 0;
    IsFileTransferDone = @as(c_int, 0) != 0;
    LmHandlerJoin();
    StartTxProcess(@bitCast(c_uint, LORAMAC_HANDLER_TX_ON_TIMER));
    handle_event_queue(@intToPtr(?*anyopaque, @as(c_int, 0)));
    return 0;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L4535-L4565">(Source)</a></p>
<p><em>Wow the code looks super verbose?</em></p>
<p>Yeah but the Auto-Translated Zig Code is a <strong>valuable reference</strong>!</p>
<p>We referred to the auto-translated code when we created the <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig"><strong>LoRaWAN Zig App</strong></a> for this article.</p>
<p>(Especially the tricky parts for Type Conversion and C Pointers)</p>
<p>We‚Äôll see the auto-translated code in the upcoming sections‚Ä¶</p>
<h1 id="appendix-opaque-type-error"><a href="#appendix-opaque-type-error">20 Appendix: Opaque Type Error</a></h1>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p>When we reference <code>LmHandlerCallbacks</code> in our LoRaWAN Zig App <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L123-L134">lorawan_test.zig</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>_ = &amp;LmHandlerCallbacks;
</code></pre></div>
<p>Zig Compiler will show this <strong>Opaque Type Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>zig-cache/.../cimport.zig:1353:5: 
error: opaque types have unknown size and 
therefore cannot be directly embedded in unions
    Fields: struct_sInfoFields,
    ^
zig-cache/.../cimport.zig:1563:5: 
note: while checking this field
    PingSlot: PingSlotInfo_t,
    ^
zig-cache/.../cimport.zig:1579:5: 
note: while checking this field
    PingSlotInfo: MlmeReqPingSlotInfo_t,
    ^
zig-cache/.../cimport.zig:1585:5: 
note: while checking this field
    Req: union_uMlmeParam,
    ^
zig-cache/.../cimport.zig:2277:5: 
note: while checking this field
    OnMacMlmeRequest: ?fn (LoRaMacStatus_t, [*c]MlmeReq_t, TimerTime_t) callconv(.C) void,
    ^
</code></pre></div>
<p>Opaque Type Error is explained here‚Ä¶</p>
<ul>
<li>
<p><a href="https://ziglang.org/documentation/master/#Translation-failures"><strong>‚ÄúTranslation Failures‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://zig.news/kristoff/extend-a-c-c-project-with-zig-55di"><strong>‚ÄúExtend a C/C++ Project with Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Let‚Äôs trace through our Opaque Type Error, guided by the <a href="https://lupyuen.github.io/articles/iot#appendix-auto-translate-lorawan-app-to-zig"><strong>Auto-Translated Zig Code</strong></a> that we discussed earlier.</p>
<p>We start at the bottom with <strong><code>OnMacMlmeRequest</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>export fn OnMacMlmeRequest(
  status: c.LoRaMacStatus_t,
  mlmeReq: [*c]c.MlmeReq_t, 
  nextTxIn: c.TimerTime_t
) void {
  c.DisplayMacMlmeRequestUpdate(status, mlmeReq, nextTxIn);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L269-L277">(Source)</a></p>
<p>Our function <strong><code>OnMacMlmeRequest</code></strong> has a parameter of type <strong><code>MlmeReq_t</code></strong>, auto-imported by Zig Compiler as‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const MlmeReq_t = struct_sMlmeReq;

pub const struct_sMlmeReq = extern struct {
  Type: Mlme_t,
  Req: union_uMlmeParam,
  ReqReturn: RequestReturnParam_t,
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2132-L2137">(Source)</a></p>
<p>Which contains another auto-imported type <strong><code>union_uMlmeParam</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const union_uMlmeParam = extern union {
  Join: MlmeReqJoin_t,
  TxCw: MlmeReqTxCw_t,
  PingSlotInfo: MlmeReqPingSlotInfo_t,
  DeriveMcKEKey: MlmeReqDeriveMcKEKey_t,
  DeriveMcSessionKeyPair: MlmeReqDeriveMcSessionKeyPair_t,
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2125-L2131">(Source)</a></p>
<p>Which contains an <strong><code>MlmeReqPingSlotInfo_t</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const MlmeReqPingSlotInfo_t = struct_sMlmeReqPingSlotInfo;

pub const struct_sMlmeReqPingSlotInfo = extern struct {
  PingSlot: PingSlotInfo_t,
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2111-L2114">(Source)</a></p>
<p>Which contains a <strong><code>PingSlotInfo_t</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const PingSlotInfo_t = union_uPingSlotInfo;

pub const union_uPingSlotInfo = extern union {
  Value: u8,
  Fields: struct_sInfoFields,
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L1900-L1904">(Source)</a></p>
<p>Which contains a <strong><code>struct_sInfoFields</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>pub const struct_sInfoFields = 
  opaque {};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L1899">(Source)</a></p>
<p>But <strong><code>struct_sInfoFields</code></strong> is an Opaque Type‚Ä¶ Its fields are not known by the Zig Compiler!</p>
<p><em>Why is that?</em></p>
<p>If we refer to the original C code‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>typedef union uPingSlotInfo
{
  /*!
   * Parameter for byte access
   */
  uint8_t Value;
  /*!
   * Structure containing the parameters for the PingSlotInfoReq
   */
  struct sInfoFields
  {
    /*!
     * Periodicity = 0: ping slot every second
     * Periodicity = 7: ping slot every 128 seconds
     */
    uint8_t Periodicity     : 3;
    /*!
     * RFU
     */
    uint8_t RFU             : 5;
  }Fields;
}PingSlotInfo_t;
</code></pre></div>
<p><a href="https://github.com/lupyuen/LoRaMac-node-nuttx/blob/master/src/mac/LoRaMac.h#L312-L333">(Source)</a></p>
<p>We see that <strong><code>sInfoFields</code></strong> contains <strong>Bit Fields</strong>, that the Zig Compiler is unable to translate.</p>
<p>Let‚Äôs fix this error in the next section‚Ä¶</p>
<h1 id="appendix-fix-opaque-type"><a href="#appendix-fix-opaque-type">21 Appendix: Fix Opaque Type</a></h1>
<p>Earlier we saw that this fails to compile in our LoRaWAN Zig App <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L123-L134">lorawan_test.zig</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>_ = &amp;LmHandlerCallbacks;
</code></pre></div>
<p>That‚Äôs because <strong><code>LmHandlerCallbacks</code></strong> references the auto-imported type <strong><code>MlmeReq_t</code></strong>, which contains <strong>Bit Fields</strong> and can‚Äôt be translated by the Zig Compiler.</p>
<p>Let‚Äôs convert <strong><code>MlmeReq_t</code></strong> to an <strong>Opaque Type</strong>, since we won‚Äôt access the fields anyway‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// We use an Opaque Type to represent MLME Request, because it contains Bit Fields that can&#39;t be converted by Zig
const MlmeReq_t = opaque {};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L778-L781">(Source)</a></p>
<p>We convert the <strong><code>LmHandlerCallbacks</code></strong> Struct to use our Opaque Type <strong><code>MlmeReq_t</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Handler Callbacks. Adapted from 
/// https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2818-L2833
pub const LmHandlerCallbacks_t = extern struct {
  GetBatteryLevel: ?fn () callconv(.C) u8,
  GetTemperature: ?fn () callconv(.C) f32,
  GetRandomSeed: ?fn () callconv(.C) u32,
  OnMacProcess: ?fn () callconv(.C) void,
  OnNvmDataChange: ?fn (c.LmHandlerNvmContextStates_t, u16) callconv(.C) void,
  OnNetworkParametersChange: ?fn ([*c]c.CommissioningParams_t) callconv(.C) void,
  OnMacMcpsRequest: ?fn (c.LoRaMacStatus_t, [*c]c.McpsReq_t, c.TimerTime_t) callconv(.C) void,

  /// Changed `[*c]c.MlmeReq_t` to `*MlmeReq_t`
  OnMacMlmeRequest: ?fn (c.LoRaMacStatus_t, *MlmeReq_t, c.TimerTime_t) callconv(.C) void,

  OnJoinRequest: ?fn ([*c]c.LmHandlerJoinParams_t) callconv(.C) void,
  OnTxData: ?fn ([*c]c.LmHandlerTxParams_t) callconv(.C) void,
  OnRxData: ?fn ([*c]c.LmHandlerAppData_t, [*c]c.LmHandlerRxParams_t) callconv(.C) void,
  OnClassChange: ?fn (c.DeviceClass_t) callconv(.C) void,
  OnBeaconStatusChange: ?fn ([*c]c.LoRaMacHandlerBeaconParams_t) callconv(.C) void,
  OnSysTimeUpdate: ?fn (bool, i32) callconv(.C) void,
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L758-L778">(Source)</a></p>
<p>We change all auto-imported <strong><code>MlmeReq_t</code></strong> references from‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>[*c]c.MlmeReq_t
</code></pre></div>
<p>(C Pointer to <code>MlmeReq_t</code>)</p>
<p>To our Opaque Type‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>*MlmeReq_t
</code></pre></div>
<p>(Zig Pointer to <code>MlmeReq_t</code>)</p>
<p>We also change all auto-imported <strong><code>LmHandlerCallbacks_t</code></strong> references from‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>[*c]c.LmHandlerCallbacks_t
</code></pre></div>
<p>(C Pointer to <code>LmHandlerCallbacks_t</code>)</p>
<p>To our converted <strong><code>LmHandlerCallbacks_t</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>*LmHandlerCallbacks_t
</code></pre></div>
<p>(Zig Pointer to <code>LmHandlerCallbacks_t</code>)</p>
<p>Which means we need to import the affected LoRaWAN Functions ourselves‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Changed `[*c]c.MlmeReq_t` to `*MlmeReq_t`. Adapted from
/// https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2905
extern fn DisplayMacMlmeRequestUpdate(
  status:   c.LoRaMacStatus_t, 
  mlmeReq:  *MlmeReq_t, 
  nextTxIn: c.TimerTime_t
) void;

/// Changed `[*c]c.LmHandlerCallbacks_t` to `*LmHandlerCallbacks_t`. Adapted from
/// https://github.com/lupyuen/zig-bl602-nuttx/blob/main/translated/lorawan_test_main.zig#L2835
extern fn LmHandlerInit(
  callbacks:     *LmHandlerCallbacks_t, 
  handlerParams: [*c]c.LmHandlerParams_t
) c.LmHandlerErrorStatus_t;
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L790-L805">(Source)</a></p>
<p>After fixing the Opaque Type, Zig Compiler successfully compiles our LoRaWAN Test App <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig">lorawan_test.zig</a>.</p>
<h1 id="appendix-macro-error"><a href="#appendix-macro-error">22 Appendix: Macro Error</a></h1>
<p><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></p>
<p>While compiling our LoRaWAN Test App <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig">lorawan_test.zig</a>, we see this <strong>Macro Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>zig-cache/o/23409ceec9a6e6769c416fde1695882f/cimport.zig:2904:32: 
error: unable to translate macro: undefined identifier `LL`
pub const __INT64_C_SUFFIX__ = @compileError(&quot;unable to translate macro: undefined identifier `LL`&quot;); 
// (no file):178:9
</code></pre></div>
<p>According to the Zig Docs, this means that the Zig Compiler failed to translate a C Macro‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/#C-Macros"><strong>‚ÄúC Macros‚Äù</strong></a></li>
</ul>
<p>So we define <strong><code>LL</code></strong> ourselves‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LoRaWAN Library from C
const c = @cImport({
  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L14-L18">(Source)</a></p>
<p><strong><code>LL</code></strong> is the ‚Äúlong long‚Äù suffix for C Constants, which is probably not needed when we import C Types and Functions into Zig.</p>
<p>Then Zig Compiler emits this error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>zig-cache/o/83fc6cf7a78f5781f258f156f891554b/cimport.zig:2940:26: 
error: unable to translate C expr: unexpected token &#39;##&#39;
pub const __int_c_join = @compileError(&quot;unable to translate C expr: unexpected token &#39;##&#39;&quot;); 
// /home/user/zig-linux-x86_64-0.10.0-dev.2351+b64a1d5ab/lib/include/stdint.h:282:9
</code></pre></div>
<p>Which refers to this line in <code>stdint.h</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#define __int_c_join(a, b) a ## b
</code></pre></div>
<p>The <strong><code>__int_c_join</code></strong> Macro fails because the <strong><code>LL</code></strong> suffix is now blank and the <strong><code>##</code></strong> Concatenation Operator fails.</p>
<p>We redefine the <strong><code>__int_c_join</code></strong> Macro without the <strong><code>##</code></strong> Concatenation Operator‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LoRaWAN Library from C
const c = @cImport({
  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
  @cDefine(&quot;__int_c_join(a, b)&quot;, &quot;a&quot;);  //  Bypass zig/lib/include/stdint.h
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L14-L18">(Source)</a></p>
<p>Now Zig Compiler successfully compiles our LoRaWAN Test App <a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig">lorawan_test.zig</a></p>
<h1 id="appendix-struct-initialisation-error"><a href="#appendix-struct-initialisation-error">23 Appendix: Struct Initialisation Error</a></h1>
<p><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></p>
<p>When we initialise the <strong>Timer Struct</strong> at startup‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Timer to handle the application data transmission duty cycle
var TxTimer: c.TimerEvent_t = 
  std.mem.zeroes(c.TimerEvent_t);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L742-L755">(Source)</a></p>
<p>Zig Compiler crashes with this error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>TODO buf_write_value_bytes maybe typethread 11512 panic:
Unable to dump stack trace: debug info stripped
</code></pre></div>
<p>So we initialise the Timer Struct in the <strong>Main Function</strong> instead‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Timer to handle the application data transmission duty cycle.
/// Init the timer in Main Function.
var TxTimer: c.TimerEvent_t = undefined;

/// Main Function
pub export fn lorawan_test_main(
  _argc: c_int, 
  _argv: [*]const [*]const u8
) c_int {
  // Init the Timer Struct at startup
  TxTimer = std.mem.zeroes(c.TimerEvent_t);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/lorawan_test.zig#L90-L101">(Source)</a></p>

    
</body>
</html>