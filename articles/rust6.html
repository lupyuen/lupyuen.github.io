<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Early Days of Rust Apps on Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Early Days of Rust Apps on Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content="My student Rushabh Gala has just completed his project for Google Summer of Code, on creating Safer Rust Apps for Apache NuttX RTOS. In this article we walk through Rushabh‚Äôs contributions, and understand how we‚Äôre evolving Rust Apps for NuttX."
    data-rh="true">
<meta name="description" 
    content="My student Rushabh Gala has just completed his project for Google Summer of Code, on creating Safer Rust Apps for Apache NuttX RTOS. In this article we walk through Rushabh‚Äôs contributions, and understand how we‚Äôre evolving Rust Apps for NuttX.">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust6-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/rust6.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Early Days of Rust Apps on Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#blink-the-led" title="Blink The LED">1 Blink The LED</a><ul></ul></li>
<li><a href="#test-on-qemu-emulator" title="Test on QEMU Emulator">2 Test on QEMU Emulator</a><ul></ul></li>
<li><a href="#handle-errors-safely" title="Handle Errors Safely">3 Handle Errors Safely</a><ul></ul></li>
<li><a href="#runs-on-linux--macos--windows" title="Runs on Linux / macOS / Windows">4 Runs on Linux / macOS / Windows</a><ul></ul></li>
<li><a href="#main-function-for-rust" title="Main Function for Rust">5 Main Function for Rust</a><ul></ul></li>
<li><a href="#panic-handler-for-rust" title="Panic Handler for Rust">6 Panic Handler for Rust</a><ul></ul></li>
<li><a href="#no-crates-in-nuttx" title="No Crates in NuttX">7 No Crates in NuttX</a><ul></ul></li>
<li><a href="#led-drivers-for-nuttx" title="LED Drivers for NuttX">8 LED Drivers for NuttX</a><ul></ul></li>
<li><a href="#daily-build-and-test" title="Daily Build and Test">9 Daily Build and Test</a><ul></ul></li>
<li><a href="#all-things-considered" title="All Things Considered">10 All Things Considered</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-nuttx-vs-rust-embedded-hal" title="Appendix: NuttX vs Rust Embedded HAL">12 Appendix: NuttX vs Rust Embedded HAL</a><ul></ul></li>
<li><a href="#appendix-daily-test-of-rust-blinky" title="Appendix: Daily Test of Rust Blinky">13 Appendix: Daily Test of Rust Blinky</a><ul></ul></li>
<li><a href="#appendix-daily-test-of-nuttx-qemu-risc-v" title="Appendix: Daily Test of NuttX QEMU RISC-V">14 Appendix: Daily Test of NuttX QEMU RISC-V</a><ul></ul></li>
<li><a href="#appendix-nuttx-qemu-risc-v-fails-on-github-actions" title="Appendix: NuttX QEMU RISC-V fails on GitHub Actions">15 Appendix: NuttX QEMU RISC-V fails on GitHub Actions</a><ul></ul></li></ul></nav><p>üìù <em>19 Aug 2024</em></p>
<p><img src="https://lupyuen.github.io/images/rust6-title.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<p>My student <a href="https://github.com/rushabhvg"><strong>Rushabh Gala</strong></a> has just completed his project for <a href="https://summerofcode.withgoogle.com/"><strong>Google Summer of Code</strong></a>. Rushabh has created <strong>Safer Rust Apps</strong> for <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://rushabhvg.github.io/articles/end_report"><strong>GSoC Final Report</strong></a></p>
</li>
<li>
<p><a href="https://rushabhvg.github.io/articles/mid_term_blog_post"><strong>GSoC Midterm Report</strong></a></p>
</li>
<li>
<p><a href="https://youtu.be/dFOodFieo4M?si=r4-MZWQwKnvqVv3h"><strong>NuttX Workshop Presentation</strong></a></p>
</li>
</ul>
<p>In this article we walk through Rushabh‚Äôs contributions. And understand how we‚Äôre evolving <strong>Rust Apps for NuttX</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Blinking the LED</strong> in Rust</p>
</li>
<li>
<p><strong>Handling Errors</strong> returned by NuttX</p>
</li>
<li>
<p>Testing on <strong>QEMU RISC-V Emulator</strong></p>
</li>
<li>
<p>And maybe <strong>Linux / macOS / Windows</strong></p>
</li>
<li>
<p>But <strong>No Crates Allowed</strong> in NuttX!</p>
</li>
<li>
<p>Be wary of the <strong>Main Function</strong> and <strong>Panic Handler</strong></p>
</li>
<li>
<p>We created <strong>LED Drivers</strong> for QEMU and Ox64 BL808 SBC</p>
</li>
<li>
<p>And we‚Äôre running <strong>Daily Build and Test</strong> of our Rust App</p>
</li>
<li>
<p>Thanks to our <strong>Updated Docker Image</strong> for Continuous Integration</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/rust6-flow2.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="blink-the-led"><a class="doc-anchor" href="#blink-the-led">¬ß</a>1 Blink The LED</h1>
<p>This is how we <strong>Blink the LED</strong> in a NuttX Rust App: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L59-L91">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Main Program Logic. Called by `leds_rust_main`
</span><span class="kw">fn </span>rust_main(_argc: i32, _argv: <span class="kw-2">*const *const </span>u8)  <span class="comment">// Args from NuttX Shell
  </span>-&gt; <span class="prelude-ty">Result</span>&lt;i32, i32&gt; {  <span class="comment">// Return a Result Code (int) or Error Code (int)

  // Open the LED Device
  </span>safe_puts(<span class="string">"Hello, Rust!!"</span>);
  <span class="kw">let </span>fd = safe_open(<span class="string">"/dev/userleds"</span>, O_WRONLY) <span class="question-mark">?</span>;  <span class="comment">// Quit on error

  // Flip LED 1 to On
  </span>safe_ioctl(fd, ULEDIOC_SETALL, <span class="number">1</span>) <span class="question-mark">?</span>;  <span class="comment">// Quit on error
  </span><span class="kw">unsafe </span>{ usleep(<span class="number">500_000</span>); }

  <span class="comment">// Flip LED 1 to Off
  </span>safe_ioctl(fd, ULEDIOC_SETALL, <span class="number">0</span>) <span class="question-mark">?</span>;  <span class="comment">// Quit on error
  </span><span class="kw">unsafe </span>{ close(fd); }

  <span class="comment">// Return successfully with result 0
  </span><span class="prelude-val">Ok</span>(<span class="number">0</span>)
}</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-rust-app/blob/main/app/src/main.rs">(<strong>Mirrored here:</strong> nuttx-rust-app/app/src/main.rs)</a></p>
<p>Our Rust Blinky App looks mighty similar to the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85"><strong>C Version</strong></a>! But with simpler Error Handling than C. (We‚Äôll talk more)</p>
<p><em>What are safe_open and safe_ioctl?</em></p>
<p>They are safer versions of <strong>open</strong> and <strong>ioctl</strong>, from our <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs"><strong>NuttX Module</strong></a>. Inside the NuttX Module we‚Ä¶</p>
<ul>
<li>
<p>Define the Safe Wrappers: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L69-L119"><strong><code>safe_*</code></strong></a></p>
</li>
<li>
<p>Import <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L28-L41"><strong>usleep</strong></a> and <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L28-L41"><strong>close</strong></a> from C</p>
</li>
<li>
<p>Plus the NuttX Constants: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L41-L51"><strong>O_WRONLY</strong></a> and <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L41-L51"><strong>ULEDIOC_SETALL</strong></a></p>
</li>
</ul>
<p>We import the <strong>NuttX Module</strong> into our Rust App like so: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L20-L45">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Comment out these lines for testing on Linux / macOS / Windows
</span><span class="attr">#![no_main]  </span><span class="comment">// For NuttX Only: No Main Function
</span><span class="attr">#![no_std]   </span><span class="comment">// For NuttX Only: Use Rust Core Library (instead of Rust Standard Library)

// Import the NuttX Module
</span><span class="kw">mod </span>nuttx;
<span class="kw">use </span>nuttx::<span class="kw-2">*</span>;</code></pre></div>
<p>And yes this code runs on Linux, macOS and Windows! We‚Äôll come back to this, first we test on QEMU‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-qemu.jpg" alt="Testing Rust Blinky on QEMU Emulator" /></p>
<h1 id="test-on-qemu-emulator"><a class="doc-anchor" href="#test-on-qemu-emulator">¬ß</a>2 Test on QEMU Emulator</h1>
<p>To test Rust Blinky on <strong>QEMU RISC-V Emulator</strong>, follow these steps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Install the NuttX Build Prerequisites, skip the RISC-V Toolchain
## https://lupyuen.github.io/articles/nuttx#install-prerequisites

## TODO: Download the xPack Toolchain for RISC-V
## https://lupyuen.github.io/articles/riscv#appendix-xpack-gnu-risc-v-embedded-gcc-toolchain-for-64-bit-risc-v

## Install the Rust Target for QEMU RISC-V 64-bit
rustup target add riscv64gc-unknown-none-elf

## Install QEMU Emulator for RISC-V
sudo apt install qemu-system-riscv64  ## For Linux
brew install qemu  ## For macOS

## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure the NuttX Build: QEMU RISC-V 64-bit with LED Driver and Rust
tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Boot the NuttX Kernel in QEMU RISC-V 64-bit
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-leds64-rust.yml">(See the <strong>Build Script</strong>)</a></p>
<p>At the NSH Prompt: Enter ‚Äú<strong><code>leds_rust</code></strong>‚Äù (pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; leds_rust
Hello, Rust!!
Opening /dev/userleds

Set LED 1 to 1
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
Sleeping...

Set LED 1 to 0
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0</code></pre></div>
<p>Rust blinks our Simulated LED on NuttX QEMU! Let‚Äôs head back inside the code‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/runs/10396419763/job/28790386663">(See the <strong>NuttX Log</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/rust4#custom-target-for-rust">(QEMU RISC-V 32-bit needs a <strong>Custom Rust Target</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/rust6-title.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="handle-errors-safely"><a class="doc-anchor" href="#handle-errors-safely">¬ß</a>3 Handle Errors Safely</h1>
<p><em>Why the funny question mark? (Pic above)</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>fd = safe_open(  <span class="comment">// Open the LED Device...
  </span><span class="string">"/dev/userleds"</span>,   <span class="comment">// Device Path
  </span>O_WRONLY           <span class="comment">// Open for Write-Only
</span>) <span class="question-mark">?</span>;                 <span class="comment">// Quit on error</span></code></pre></div>
<p>Remember in C we check the <a href="https://github.com/lupyuen2/wip-nuttx-apps/blob/nim/examples/hello/hello_main.c#L46-L64"><strong>Result Value</strong></a> at every call to <strong>open</strong> and <strong>ioctl</strong>‚Ä¶ Now with <strong>safe_open</strong> and <strong>safe_ioctl</strong>, Rust does the checking for us!</p>
<p>If something goes wrong, the code above will exit the function with an <strong>Error Value</strong>. (Like if <em>‚Äú/dev/userleds‚Äù</em> doesn‚Äôt exist)</p>
<p>Our NuttX App becomes a little safer with the <a href="https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html"><strong>Question Mark Operator</strong></a>, by auto-checking the results of System Calls.</p>
<p>(Rust Compiler <strong>will warn us</strong> if we forget the Question Mark)</p>
<p><em>But usleep and close are still unsafe?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Wait a while
</span><span class="kw">unsafe </span>{ usleep(<span class="number">500_000</span>); }
...
<span class="comment">// Close the LED Device
</span><span class="kw">unsafe </span>{ close(fd); }</code></pre></div>
<p>Yeah there‚Äôs not much point in wrapping <strong>usleep</strong> and <strong>close</strong>? Since we don‚Äôt check the Return Values.</p>
<p>(<strong>safe_puts</strong> has a limited <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/nuttx.rs#L104-L119"><strong>Buffer Size</strong></a>)</p>
<p><em>Can we auto-close the File Descriptor when it goes out of scope?</em></p>
<p>Probably, if we do <a href="https://docs.rs/rustix/latest/rustix/fd/struct.OwnedFd.html"><strong>Managed File Descriptors</strong></a>. But that‚Äôs way beyond the size, scope and scale of GSoC.</p>
<p><img src="https://lupyuen.github.io/images/rust6-cargo.jpg" alt="Run Rust Blinky on Linux / macOS / Windows" /></p>
<h1 id="runs-on-linux--macos--windows"><a class="doc-anchor" href="#runs-on-linux--macos--windows">¬ß</a>4 Runs on Linux / macOS / Windows</h1>
<p><em>Will our NuttX App actually run on Linux, macOS and Windows?</em></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Comment out these lines for testing on Linux / macOS / Windows
</span><span class="attr">#![no_main]  </span><span class="comment">// For NuttX Only: No Main Function
</span><span class="attr">#![no_std]   </span><span class="comment">// For NuttX Only: Use Rust Core Library (instead of Rust Standard Library)</span></code></pre></div>
<p>Yep indeed! Just comment out the above lines and our Rust Blinky App will run on <strong>Linux / macOS / Windows</strong> (WSL)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ git clone https://github.com/lupyuen/nuttx-rust-app
$ cd nuttx-rust-app
$ cd app
$ cargo run
Hello, Rust!!
Opening /dev/userleds
ERROR: rust_main() failed with error -1</code></pre></div>
<p>Though it fails (as expected) because <em>‚Äú/dev/userleds‚Äù</em> doesn‚Äôt exist on Linux / macOS / Windows. (Pic above)</p>
<p>This greatly simplifies our NuttX App Development: We could (potentially) compile and run our NuttX App on our <strong>Local Computer</strong>, before testing on NuttX!</p>
<p>(<strong>Rust Analyzer</strong> won‚Äôt work inside NuttX Projects sigh)</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="main-function-for-rust"><a class="doc-anchor" href="#main-function-for-rust">¬ß</a>5 Main Function for Rust</h1>
<p><em>We saw the LED Blinky code in rust_main. Who calls rust_main?</em></p>
<p>Remember that <strong>rust_main</strong> returns a <a href="https://doc.rust-lang.org/rust-by-example/error/result.html"><strong>Result Type</strong></a>: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L59-L91">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `rust_main` accepts the args from NuttX Shell
// And returns a Result Code (int) or Error Code (int)
</span><span class="kw">fn </span>rust_main(_argc: i32, _argv: <span class="kw-2">*const *const </span>u8)
  -&gt; <span class="prelude-ty">Result</span>&lt;i32, i32&gt; { ... }</code></pre></div>
<p>But NuttX expects us to provide a Main Function named <strong>leds_rust_main</strong>. And it shall return an <strong>Integer Result</strong>. (Not a Result Type)</p>
<p>Thus we create an <strong>leds_rust_main</strong> function that calls <strong>rust_main</strong> (pic above) and returns the right result: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L91-L120">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For NuttX: This will be called by NuttX Shell
// For Linux / macOS / Windows: This wil be called by `main`
</span><span class="attr">#[no_mangle]
</span><span class="kw">pub extern </span><span class="string">"C" </span><span class="kw">fn </span>leds_rust_main(argc: i32, argv: <span class="kw-2">*const *const </span>u8)  <span class="comment">// Args from NuttX Shell
  </span>-&gt; i32 {  <span class="comment">// Return a Result Code (0) or Error Code (negative)

  // Call the program logic in Rust Main
  </span><span class="kw">let </span>res = rust_main(argc, argv);

  <span class="comment">// If Rust Main returns an error, print it.
  // We won't wrap `printf`, because it needs VarArgs.
  </span><span class="kw">if let </span><span class="prelude-val">Err</span>(e) = res {
    <span class="kw">unsafe </span>{ printf(<span class="string">b"ERROR: rust_main() failed with error %d\n\0" </span><span class="kw">as </span><span class="kw-2">*const </span>u8, e); }
    e  <span class="comment">// Return the Error Code
  </span>} <span class="kw">else </span>{
    <span class="number">0  </span><span class="comment">// Or return the Result Code 0
  </span>}
}</code></pre></div>
<p><em>What about Linux / macOS / Windows?</em></p>
<p>They expect us to provide a <strong>main</strong> function‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow3.jpg" alt="Main Function for Rust Blinky" /></p>
<p>Thus we do this: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L120-L128">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For Linux / macOS / Windows: Define the Main Function
</span><span class="attr">#[cfg(not(target_os = <span class="string">"none"</span>))]
</span><span class="kw">fn </span>main() {
  <span class="comment">// Call Rust Main without args
  </span>leds_rust_main(
    <span class="number">0</span>,                 <span class="comment">// argc: Zero Args
    </span>core::ptr::null()  <span class="comment">// argv: Null Pointer
  </span>);
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/rust6-flow4.jpg" alt="Panic Handler for Rust Blinky App" /></p>
<h1 id="panic-handler-for-rust"><a class="doc-anchor" href="#panic-handler-for-rust">¬ß</a>6 Panic Handler for Rust</h1>
<p><em>Anything else specific to NuttX?</em></p>
<p>Yep NuttX Apps run on the <a href="https://doc.rust-lang.org/core/"><strong>Rust Core Library</strong></a> (no_std) and require a <a href="https://doc.rust-lang.org/nomicon/panic-handler.html"><strong>Panic Handler</strong></a>.</p>
<p>That‚Äôs why we need this: <a href="https://github.com/apache/nuttx-apps/blob/master/examples/leds_rust/leds_rust_main.rs#L29-L59">leds_rust_main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// For NuttX Only: Import the Panic Type
</span><span class="attr">#[cfg(target_os = <span class="string">"none"</span>)]
</span><span class="kw">use </span>core::{
  panic::PanicInfo,
  result::Result::{<span class="self">self</span>, <span class="prelude-val">Err</span>, <span class="prelude-val">Ok</span>},
};

<span class="comment">// For NuttX Only: Define the Panic Handler for `no_std`
</span><span class="attr">#[cfg(target_os = <span class="string">"none"</span>)]
#[panic_handler]
</span><span class="kw">fn </span>panic(_panic: <span class="kw-2">&amp;</span>PanicInfo&lt;<span class="lifetime">'_</span>&gt;) -&gt; ! {
  <span class="kw">loop </span>{}
}</code></pre></div>
<p>(Sorry <strong>cfg</strong> won‚Äôt work for <strong>no_main</strong> and <strong>no_std</strong>)</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow5.jpg" alt="No Crates allowed in NuttX" /></p>
<h1 id="no-crates-in-nuttx"><a class="doc-anchor" href="#no-crates-in-nuttx">¬ß</a>7 No Crates in NuttX</h1>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487">(<strong>Update:</strong> NuttX now supports <strong>Cargo</strong> and <strong>Tokio</strong>!)</a></p>
<p><em>We‚Äôre coding Rust in a strange way. Why not use crates and cargo?</em></p>
<p>Ah that‚Äôs because NuttX <a href="https://github.com/apache/nuttx/pull/5566#issuecomment-1046963430"><strong>doesn‚Äôt support Rust Crates</strong></a>! We can‚Äôt use <strong>cargo</strong> either, NuttX Build will call <strong>rustc</strong> directly‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Configure the NuttX Project
## for QEMU RISC-V 64-bit including Rust
$ tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Project
## Which calls `rustc`
$ make</code></pre></div>
<p>Which complicates our coding of NuttX Rust Apps. That‚Äôs why we hope to test them first on <a href="https://lupyuen.github.io/articles/rust6#runs-on-linux--macos--windows"><strong>Linux / macOS / Windows</strong></a>.</p>
<p>(<strong>NuttX Module nuttx.rs</strong> should probably live in a Common Source Folder)</p>
<p>(Maybe NuttX will allow some crates, similar to <a href="https://rust-for-linux.com/third-party-crates"><strong>Rust for Linux Kernel</strong></a>)</p>
<p><img src="https://lupyuen.github.io/images/rust6-ox64.jpg" alt="Rust Blinky on Ox64 BL808 SBC" /></p>
<p><a href="https://youtube.com/shorts/t6nxVZWS0Js?feature=share"><em>Rust Blinky on Ox64 BL808 SBC</em></a></p>
<h1 id="led-drivers-for-nuttx"><a class="doc-anchor" href="#led-drivers-for-nuttx">¬ß</a>8 LED Drivers for NuttX</h1>
<p><em>12 weeks of GSoC: What else have we implemented?</em></p>
<p>Remember our Blinky NuttX App in Rust? Well a NuttX App ain‚Äôt really a NuttX App‚Ä¶ Unless it runs <strong>on Real Hardware</strong>!</p>
<p>We tested our Rust Blinky App on <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Ox64 BL808 RISC-V SBC</strong></a> (pic above). Which needs us to create the <strong>GPIO and LED Drivers</strong> for Ox64 SBC‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12571"><strong>‚ÄúAdd GPIO Driver for BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12614"><strong>‚ÄúAdd LED Driver for Ox64‚Äù</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/rust5#appendix-main-function-is-missing">(NuttX Ox64 needs <strong>leds_rust_main</strong> to be renamed as <strong>main</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-flow6.jpg" alt="NuttX LED Drivers for QEMU RISC-V Emulator and Ox64 BL808 SBC" /></p>
<p><em>What about folks without Ox64 SBC?</em></p>
<p>We created the LED Driver for <strong>QEMU RISC-V Emulator</strong>, which will blink a Simulated LED on NuttX. (Pic above)</p>
<p>Everyone can run the <strong>Rust Blinky App</strong> (from above) and reproduce the exact same results, thanks to the QEMU LED Driver‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/nuttx/pull/12762"><strong>‚ÄúAdd LED Driver for QEMU RISC-V‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-daily.png" alt="Daily Build and Test of Rust Blinky App at GitHub Actions" /></p>
<h1 id="daily-build-and-test"><a class="doc-anchor" href="#daily-build-and-test">¬ß</a>9 Daily Build and Test</h1>
<p><em>Our Rust Blinky App: Will it break someday?</em></p>
<p>Yeah it‚Äôs possible that our Rust App will someday <strong>fail to build or execute</strong> correctly‚Ä¶</p>
<ol>
<li>
<p><strong>Rust Compiler</strong> might change and break our app</p>
<p>(Since we‚Äôre not calling it the <strong>cargo</strong> way)</p>
</li>
<li>
<p><strong>NuttX Makefiles</strong> might cause problems for Rust Apps</p>
<p>(Because NuttX is mostly in C, not Rust)</p>
</li>
</ol>
<p>That‚Äôs why we extended the <strong>Continuous Integration</strong> workflow for NuttX‚Ä¶</p>
<p>Every NuttX Pull Request will now trigger a rebuild of our <a href="https://lupyuen.github.io/articles/rust6#blink-the-led"><strong>Rust Blinky App</strong></a>. If anything breaks, we‚Äôll find out right away!</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12854"><strong>‚ÄúFix the Rust and D Builds for QEMU RISC-V‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12858"><strong>‚ÄúAdd Rust Target for QEMU RISC-V 64-bit‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/12862"><strong>‚ÄúAdd Build Config for leds64_rust‚Äù</strong></a></p>
</li>
</ul>
<p><em>Why so complicated?</em></p>
<p>That‚Äôs because the NuttX Continuous Integration (CI) runs inside a <strong>Docker Container</strong>. Which requires delicate modding‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pr#appendix-building-the-docker-image-for-nuttx-ci"><strong>‚ÄúBuilding the Docker Image for NuttX CI‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pr#appendix-downloading-the-docker-image-for-nuttx-ci"><strong>‚ÄúDownloading the Docker Image for NuttX CI‚Äù</strong></a></p>
</li>
</ul>
<p>NuttX CI also compiles <strong>hello_rust</strong> for <a href="https://github.com/apache/nuttx/blob/master/boards/sim/sim/sim/configs/rust/defconfig#L27"><strong>NuttX Simulator</strong></a>. Though it‚Äôs simpler and doesn‚Äôt need a Special Rust Target for the Docker Image.</p>
<p><em>Will we know if the Rust Blinky App fails to execute correctly?</em></p>
<p>Every day through <strong>GitHub Actions</strong>: We‚Äôre testing the Rust Blinky App on QEMU RISC-V Emulator. (Pic above)</p>
<p>If Rust Blinky fails to execute (or produces the wrong output), GitHub Actions will notify us‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-rust-blinky"><strong>‚ÄúDaily Test of Rust Blinky‚Äù</strong></a></li>
</ul>
<p><em>Anything else we‚Äôre testing daily?</em></p>
<p>If something goes wrong: We need to be clear whether it‚Äôs our Rust App Failing vs <strong>NuttX QEMU Failing</strong>. That‚Äôs why we also test NuttX QEMU every day at GitHub Actions‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>‚ÄúDaily Test of NuttX QEMU RISC-V‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/rust6#appendix-nuttx-qemu-risc-v-fails-on-github-actions"><strong>‚ÄúNuttX QEMU RISC-V fails on GitHub Actions‚Äù</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-target.jpg" alt="Adding NuttX as Tier 3 Target to Rust" /></p>
<h1 id="all-things-considered"><a class="doc-anchor" href="#all-things-considered">¬ß</a>10 All Things Considered</h1>
<p><em>Wow that‚Äôs plenty of coding for 12 weeks of GSoC!</em></p>
<p>Indeed, we tracked all Coding Tasks in our <a href="https://docs.google.com/spreadsheets/d/1NzaS7gp2eYhegSA1DsH5Zw-o0tShqL-ewvVhoSSR0UQ/edit?usp=drive_link"><strong>GSoC Task Spreadsheet</strong></a>. And we recorded Daily Updates in the <a href="https://discord.gg/eAz5QudKSQ"><strong>NuttX Discord Channel</strong></a>.</p>
<p><em>Will Rust officially support NuttX?</em></p>
<p>The NuttX Community is now prepping NuttX as <a href="https://lists.apache.org/thread/oqx7p3vb4dcgko4mm2f0vqgqnkorn49p"><strong>Tier 3 Target</strong></a> to Rust. <a href="https://github.com/rust-lang/rust/pull/127755">(First step is <strong>approved</strong>! Pic above)</a></p>
<p><em>Everything in this article‚Ä¶ Becomes redundant?</em></p>
<p>Soon we‚Äôll have lots of <a href="https://github.com/apache/nuttx-apps/pull/2487"><strong>Coding and Testing</strong></a> to implement NuttX as Tier 3 Target, that works with the <a href="https://doc.rust-lang.org/std/index.html"><strong>Rust Standard Library</strong></a>.</p>
<p>Meanwhile, we can call <a href="https://lupyuen.github.io/articles/rust6#handle-errors-safely"><strong>NuttX Safe Wrappers</strong></a> (prescribed in this article) to build Rust Apps for NuttX, the Interim Way.</p>
<p><img src="https://lupyuen.github.io/images/rust6-flow.jpg" alt="Blinking the NuttX LED in Rust" /></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>11 What‚Äôs Next</h1>
<p>These are the <strong>Early Days of Rust Apps</strong> on Apache NuttX RTOS. We talked about‚Ä¶</p>
<ul>
<li>
<p><strong>Blinking the LED</strong> in Rust</p>
<p><strong>Handling Errors</strong> returned by NuttX</p>
</li>
<li>
<p>Testing on <strong>QEMU RISC-V Emulator</strong></p>
<p>And possibly <strong>Linux / macOS / Windows</strong></p>
</li>
<li>
<p>But NuttX <strong>Won‚Äôt Allow Any Crates</strong>!</p>
<p>(Someday it might? Similar to <a href="https://rust-for-linux.com/third-party-crates"><strong>Rust for Linux Kernel</strong></a>)</p>
</li>
<li>
<p>Be wary of the <strong>Main Function</strong> and <strong>Panic Handler</strong>!</p>
<p>(NuttX works differently from Linux / macOS / Windows)</p>
</li>
<li>
<p>Check out the <strong>LED Drivers</strong> we created</p>
<p>(For testing QEMU Emulator and Ox64 BL808 SBC)</p>
</li>
<li>
<p>We‚Äôre running <strong>Daily Build and Test</strong> of our Rust App</p>
<p>(With our <strong>Updated Docker Image</strong> for Continuous Integration)</p>
</li>
</ul>
<p>Many Thanks to my <a href="https://lupyuen.github.io/articles/sponsor"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<p>Special Thanks to <strong>Mr Rushabh Gala</strong>: Sorry it‚Äôs my first GSoC, I could have done better, I‚Äôm grateful for your patience and understanding üôè</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=41289120"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rust6.md"><strong>lupyuen.github.io/src/rust6.md</strong></a></p>
<h1 id="appendix-nuttx-vs-rust-embedded-hal"><a class="doc-anchor" href="#appendix-nuttx-vs-rust-embedded-hal">¬ß</a>12 Appendix: NuttX vs Rust Embedded HAL</h1>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487">(<strong>Update:</strong> NuttX now supports <strong>Cargo</strong> and <strong>Tokio</strong>!)</a></p>
<p><em>Shall we implement Rust Embedded HAL on NuttX?</em></p>
<p>Actually I‚Äôm not too clear if we should stick to the Official Rust Embedded HAL for NuttX. Here‚Äôs why‚Ä¶</p>
<p>To blink an LED in <strong>Rust Embedded HAL</strong>: We fetch the GPIO, then switch it off and on‚Ä¶</p>
<ul>
<li><a href="https://docs.rust-embedded.org/discovery/microbit/05-led-roulette/light-it-up.html"><strong>Rust Embedded HAL: Blink the LED</strong></a></li>
</ul>
<p>But there‚Äôs no need to do this in NuttX! We simply open the LED Device <strong>/dev/userleds</strong>. And control it via <strong>ioctl</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust6#blink-the-led"><strong>Blink the LED (NuttX)</strong></a></li>
</ul>
<p>Rust Embedded HAL feels strange when we force-fit it into NuttX. I2C will have similar issues‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rusti2c#nuttx-embedded-hal"><strong>NuttX Embedded HAL (I2C)</strong></a></li>
</ul>
<p>If we look at <strong>Rust on Zephyr</strong>: They propose to call a Native Zephyr API to <a href="https://github.com/zephyrproject-rtos/zephyr/issues/65837"><strong>blink the LED</strong></a>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Proposed Rust on Zephyr
</span><span class="attr">#![no_std]
#![no_main]

#[zephyr::entry]
</span><span class="kw">fn </span>main() {
  <span class="kw">let </span>dt = zephyr::devicetree::take().unwrap();
  <span class="kw">let </span>led = dt.chosen.led0;
  <span class="kw">loop </span>{
    led.toggle().unwrap();
    zephyr::sys::sleep(<span class="number">1000</span>);
  }
}</code></pre></div>
<p>My gut feel is that we should do it the Zephyr way. But make it POSIX-like. Thus we should drop <strong>nuttx-embedded-hal</strong> altogether :-)</p>
<p><em>What about Rustix?</em></p>
<p>Rustix is kinda heavy I think? It does Owned File Descriptors that will auto-close when they go out of scope. There might be a lot of dependencies inside?</p>
<p>Earlier I <a href="https://lupyuen.github.io/articles/rust6#handle-errors-safely">wrote this</a>‚Ä¶</p>
<blockquote>
<p><em>Can we auto-close the File Descriptor when it goes out of scope?</em>
Probably, if we do <a href="https://docs.rs/rustix/latest/rustix/fd/struct.OwnedFd.html"><strong>Managed File Descriptors</strong></a>. But that‚Äôs way beyond the size, scope and scale of GSoC.</p>
</blockquote>
<p><a href="https://github.com/apache/nuttx-apps/pull/2487">(More discussion here)</a></p>
<p><strong>Update:</strong> We‚Äôre reassessing Rustix for NuttX. Simpler is swell but we‚Äôll run into problems with I/O Safety sigh. Check out the new article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.org/articles/rust7.html"><strong>‚ÄúRust Standard Library on Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/rust6-qemu.jpg" alt="Testing Rust Blinky on QEMU Emulator" /></p>
<h1 id="appendix-daily-test-of-rust-blinky"><a class="doc-anchor" href="#appendix-daily-test-of-rust-blinky">¬ß</a>13 Appendix: Daily Test of Rust Blinky</h1>
<p>Earlier we said that our Rust Blinky App might someday <a href="https://lupyuen.github.io/articles/rust6#daily-build-and-test"><strong>fail to build or execute</strong></a> correctly. That‚Äôs why we‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/rust6#daily-build-and-test"><strong>Trigger a Rebuild</strong></a> of our Rust Blinky App on every NuttX Pull Request</p>
</li>
<li>
<p><strong>Run and Test</strong> our Rust Blinky App every day at GitHub Actions</p>
</li>
</ul>
<p>If anything breaks, we‚Äôll find out right away!</p>
<p><em>How to test our app with GitHub Actions?</em></p>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on QEMU RISC-V (64-bit) and verify the output of ‚Äú<strong><code>leds_rust</code></strong>‚Äù (pic above)</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU Emulator for 64-bit RISC-V
$ spawn qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `leds_rust` and verify the output
NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; leds_rust
Hello, Rust!!
Opening /dev/userleds

Set LED 1 to 1
board_userled: LED 1 set to 1
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0
Sleeping...

Set LED 1 to 0
board_userled: LED 1 set to 0
board_userled: LED 2 set to 0
board_userled: LED 3 set to 0</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-leds64-rust.yml">(See the <strong>GitHub Actions Log</strong>)</a></p>
<p>Here‚Äôs the <strong>GitHub Actions Workflow</strong> (pic below) to build and run Rust Blinky: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-leds64-rust.yml">qemu-riscv-leds64-rust.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Install the Rust Target for QEMU RISC-V 64-bit
rustup target add riscv64gc-unknown-none-elf

## Configure the NuttX Build: QEMU RISC-V 64-bit with LED Driver and Rust
tools/configure.sh rv-virt:leds64_rust

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Install QEMU Emulator for RISC-V
sudo apt install qemu-system-riscv64

## Test NuttX and Rust Blinky with our Expect Script
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-leds64-rust.exp
chmod +x qemu-riscv-leds64-rust.exp
./qemu-riscv-leds64-rust.exp</code></pre></div>
<p>Which calls our <strong>Expect Script</strong> to test Rust Blinky: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/qemu-riscv-leds64-rust.exp">qemu-riscv-leds64-rust.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX Rust Blinky with QEMU Emulator

## Wait at most 10 seconds
set timeout 10

## For every 1 character sent, wait 0.01 milliseconds
set send_slow {1 0.01}

## Start the QEMU Emulator for 64-bit RISC-V
spawn qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -bios none \
  -kernel nuttx \
  -nographic

## Wait for the prompt and enter `leds_rust`
expect &quot;nsh&gt; &quot;
send -s &quot;leds_rust\r&quot;

## Check the response: LEDs 1, 2 and 3 should be Off
expect &quot;board_userled: LED 1 set to 0&quot;
expect &quot;board_userled: LED 2 set to 0&quot;
expect {
  ## If we see this message, continue normally
  &quot;board_userled: LED 3 set to 0&quot; {}

  ## If timeout, exit with an error
  ## And rerminate the session: Ctrl-A x
  timeout { 
    send &quot;\x01x&quot;
    puts &quot;\n===== Error: Test Failed\n&quot;
    exit 1 
  }
}

## Terminate the session: Ctrl-A x
send &quot;\x01x&quot;
puts &quot;\n===== Test OK\n&quot;
exit 0 </code></pre></div>
<p>But our test is incomplete: We need to know if NuttX on QEMU is really OK‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-daily.png" alt="Daily Build and Test of Rust Blinky App at GitHub Actions" /></p>
<h1 id="appendix-daily-test-of-nuttx-qemu-risc-v"><a class="doc-anchor" href="#appendix-daily-test-of-nuttx-qemu-risc-v">¬ß</a>14 Appendix: Daily Test of NuttX QEMU RISC-V</h1>
<p>If something goes wrong with <strong>Rust Blinky</strong>: We need to be clear whether it‚Äôs our Rust App Failing vs <strong>NuttX QEMU Failing</strong>. That‚Äôs why we also test NuttX QEMU every day at GitHub Actions. (Pic above)</p>
<p><strong>NuttX for QEMU RISC-V</strong> comes in Multiple Flavours, we test four of the popular flavours every day‚Ä¶</p>
<ul>
<li>
<p><strong>32-bit RISC-V, Flat Build: <br> <code>rv-virt:nsh</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh.yml">Test Log</a></p>
</li>
<li>
<p><strong>32-bit RISC-V, Kernel Build: <br> <code>rv-virt:knsh</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-knsh.yml">Test Log</a></p>
</li>
<li>
<p><strong>64-bit RISC-V, Flat Build: <br> <code>rv-virt:nsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh64.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh64.yml">Test Log</a></p>
</li>
<li>
<p><strong>64-bit RISC-V, Kernel Build: <br> <code>rv-virt:knsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh64.yml">GitHub Actions Workflow</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-knsh64.yml">Test Log</a></p>
<p><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode">(About <strong>Flat Build</strong> vs <strong>Kernel Build</strong>)</a></p>
</li>
</ul>
<p><em>What‚Äôs inside the GitHub Actions Workflow?</em></p>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on QEMU RISC-V and verify the output of <a href="https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing"><strong>OSTest</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU Emulator for 32-bit RISC-V
$ spawn qemu-system-riscv32 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv32 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `ostest` and verify the output
NuttShell (NSH) NuttX-12.6.0-RC1
nsh&gt; ostest
...
ostest_main: Exiting with status 0</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/actions/workflows/qemu-riscv-nsh.yml">(See the <strong>GitHub Actions Log</strong>)</a></p>
<p>Here‚Äôs the <strong>GitHub Actions Workflow</strong> to build and run NuttX QEMU RISC-V (32-bit): <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh.yml">qemu-riscv-nsh.yml</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Source Code for NuttX Kernel and Apps
git clone https://github.com/apache/nuttx
git clone https://github.com/apache/nuttx-apps apps
cd nuttx

## Configure the NuttX Build: QEMU RISC-V 32-bit (Flat Build)
tools/configure.sh rv-virt:nsh

## Build the NuttX Kernel. Ignore the warning: `nuttx has a LOAD segment with RWX permissions`
make

## Install QEMU Emulator for RISC-V (32-bit)
sudo apt install qemu-system-riscv32

## Test NuttX and OSTest with our Expect Script
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-nsh.exp
chmod +x qemu-riscv-nsh.exp
./qemu-riscv-nsh.exp</code></pre></div>
<p>Which calls our <strong>Expect Script</strong> to boot NuttX and run <a href="https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing"><strong>OSTest</strong></a>: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/qemu-riscv-nsh.exp">qemu-riscv-nsh.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX with QEMU Emulator

## Wait at most 300 seconds
set timeout 300

## For every 1 character sent, wait 0.01 milliseconds
set send_slow {1 0.01}

## Start the QEMU Emulator for 32-bit RISC-V
spawn qemu-system-riscv32 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv32 \
  -bios none \
  -kernel nuttx \
  -nographic

## Wait for the prompt and enter `ostest`
expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;

## Check the response...
expect {
  ## If we see this message, exit normally
  &quot;ostest_main: Exiting with status 0&quot; { 
    ## Terminate the session: Ctrl-A x
    send &quot;\x01x&quot;
    puts &quot;\n===== Test OK\n&quot;
    exit 0 
  }

  ## If timeout, exit with an error
  timeout { 
    ## Terminate the session: Ctrl-A x
    send &quot;\x01x&quot;
    puts &quot;\n===== Error: Test Failed\n&quot;
    exit 1 
  }
}</code></pre></div>
<p>But there‚Äôs a problem: OSTest for <strong>64-bit QEMU RISC-V</strong> fails on GitHub Actions‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/rust6-task.jpg" alt="Running a script on my Home Computer to download the 64-bit Daily Builds and run OSTest locally" /></p>
<h1 id="appendix-nuttx-qemu-risc-v-fails-on-github-actions"><a class="doc-anchor" href="#appendix-nuttx-qemu-risc-v-fails-on-github-actions">¬ß</a>15 Appendix: NuttX QEMU RISC-V fails on GitHub Actions</h1>
<p><strong>Every day at GitHub Actions:</strong> We boot NuttX on <strong>QEMU RISC-V Emulator</strong> (32-bit and 64-bit) and test it with <a href="https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing"><strong>OSTest</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust6#appendix-daily-test-of-nuttx-qemu-risc-v"><strong>‚ÄúDaily Test of NuttX QEMU RISC-V‚Äù</strong></a></li>
</ul>
<p><em>But we have problems?</em></p>
<p>Yeah OSTest for <strong>64-bit QEMU RISC-V</strong> fails on GitHub Actions, wonder why‚Ä¶</p>
<ul>
<li>
<p><strong>64-bit RISC-V Flat Build <br> <code>rv-virt:nsh64</code></strong> crashes with‚Ä¶</p>
<p><em>‚Äúfpu_test: Started task FPU#1  / riscv_exception: Illegal instruction‚Äù</em></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-nsh64.yml#L2">(GitHub Actions Workflow)</a></p>
</li>
<li>
<p><strong>64-bit RISC-V Kernel Build <br> <code>rv-virt:knsh64</code></strong> hangs at‚Ä¶</p>
<p><em>‚Äúostest_main: Started user_main‚Äù</em></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/.github/workflows/qemu-riscv-knsh64.yml#L2">(GitHub Actions Workflow)</a></p>
<p><a href="https://lupyuen.github.io/articles/rust5#nuttx-flat-mode-vs-kernel-mode">(About <strong>Flat Build</strong> vs <strong>Kernel Build</strong>)</a></p>
</li>
</ul>
<p>That‚Äôs why I run a script on my Home Computer to download the 64-bit Daily Builds and <strong>run OSTest locally</strong> (pic above)</p>
<ul>
<li>
<p><strong>64-bit RISC-V Flat Build <br> <code>rv-virt:nsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/task-nsh64.sh">Task Script</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/test-nsh64.sh">Test Script</a></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/upload-nsh64.sh">Upload Script</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/releases/tag/qemu-riscv-nsh64-2024-08-08">Sample Log</a></p>
</li>
<li>
<p><strong>64-bit RISC-V Kernel Build <br> <code>rv-virt:knsh64</code></strong></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/task-knsh64.sh">Task Script</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/test-knsh64.sh">Test Script</a></p>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/upload-knsh64.sh">Upload Script</a> / <a href="https://github.com/lupyuen/nuttx-riscv64/releases/tag/qemu-riscv-knsh64-2024-08-08">Sample Log</a></p>
</li>
</ul>
<p><em>What‚Äôs inside the scripts?</em></p>
<p>Inside our <strong>Task Script</strong>: We wait for the 64-bit <strong>NuttX Daily Build</strong> to be published as a GitHub Release: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/task-nsh64.sh">task-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Background Task: Automated Testing of Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
export BUILD_PREFIX=qemu-riscv-nsh64

## Wait for GitHub Release, then test NuttX
for (( ; ; ))
do
  ## Build Date is today (YYYY-MM-DD)
  BUILD_DATE=$(date +&#39;%Y-%m-%d&#39;)
  test_nuttx $BUILD_DATE

  ## Wait a while
  sleep 600
done

## Wait for GitHub Release, then test NuttX on SBC
function test_nuttx {
  ...
  ## Download the NuttX Build
  local date=$1
  NUTTX_ZIP=/tmp/$BUILD_PREFIX-$date-nuttx.zip
  wget -q \
    https://github.com/lupyuen/nuttx-riscv64/releases/download/$BUILD_PREFIX-$date/nuttx.zip \
    -O $NUTTX_ZIP
  ...
  ## Run the NuttX Test
  test-nsh64.sh \
    &gt;/tmp/release-$BUILD_PREFIX.log \
    2&gt;&amp;1
  ...
  ## Upload the Test Log
  upload-nsh64.sh \
    /tmp/release-$BUILD_PREFIX.tag \
    /tmp/release-$BUILD_PREFIX.log
}</code></pre></div>
<p>Then we call our <strong>Test Script</strong> to boot NuttX on QEMU and verify the output of <a href="https://lupyuen.github.io/articles/tinyemu3#daily-automated-testing"><strong>OSTest</strong></a>: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/test-nsh64.sh">test-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Test Script: Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
BUILD_PREFIX=qemu-riscv-nsh64

## Build Date is today (YYYY-MM-DD)
BUILD_DATE=$(date +&#39;%Y-%m-%d&#39;)

## Download the latest NuttX build
wget -q https://github.com/lupyuen/nuttx-riscv64/releases/download/$BUILD_PREFIX-$BUILD_DATE/nuttx.zip
unzip -o nuttx.zip

## Write the Release Tag for populating the GitHub Release Notes later
echo &quot;$BUILD_PREFIX-$BUILD_DATE&quot; &gt;/tmp/release-$BUILD_PREFIX.tag

## Boot NuttX on QEMU and run OSTest
wget https://raw.githubusercontent.com/lupyuen/nuttx-riscv64/main/qemu-riscv-nsh64.exp
chmod +x qemu-riscv-nsh64.exp
./qemu-riscv-nsh64.exp</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/qemu-riscv-nsh64.exp">(<strong>qemu-riscv-nsh64.exp</strong> is here)</a></p>
<p>Finally our Task Script calls our <strong>Upload Script</strong>, to upload the Test Log into the <strong>GitHub Release Notes</strong>: <a href="https://github.com/lupyuen/nuttx-riscv64/blob/main/task/upload-nsh64.sh">upload-nsh64.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Upload Test Log to GitHub Release Notes of Apache NuttX RTOS for QEMU RISC-V 64-bit Flat Build
## Parameters: Release Tag, Test Log
repo=lupyuen/nuttx-riscv64
tag=$1
log=$2

## Preserve the Auto-Generated GitHub Release Notes.
## Fetch the current GitHub Release Notes and extract the body text.
gh release view \
  `cat $tag` \
  --json body \
  --jq &#39;.body&#39; \
  --repo $repo \
  &gt;/tmp/upload-nsh64.old

## Find the position of the Previous Test Log, starting with &quot;```&quot;
cat /tmp/upload-nsh64.old \
  | grep &#39;```&#39; --max-count=1 --byte-offset \
  | sed &#39;s/:.*//g&#39; \
  &gt;/tmp/upload-nsh64-previous-log.txt
prev=`cat /tmp/upload-nsh64-previous-log.txt`

## If Previous Test Log exists, discard it
if [ &quot;$prev&quot; != &#39;&#39; ]; then
  cat /tmp/upload-nsh64.old \
    | head --bytes=$prev \
    &gt;&gt;/tmp/upload-nsh64.log
else
  ## Else copy the entire Release Notes
  cat /tmp/upload-nsh64.old \
    &gt;&gt;/tmp/upload-nsh64.log
  echo &quot;&quot; &gt;&gt;/tmp/upload-nsh64.log
fi

## Show the Test Status
grep &quot;^===== &quot; $log \
  | colrm 1 6 \
  &gt;&gt;/tmp/upload-nsh64.log

## Enquote the Test Log without Carriage Return and Terminal Control Characters.
## The long pattern for sed doesn&#39;t work on macOS.
echo &#39;```text&#39; &gt;&gt;/tmp/upload-nsh64.log
cat $log \
  | tr -d &#39;\r&#39; \
  | tr -d &#39;\r&#39; \
  | sed &#39;s/\x08/ /g&#39; \
  | sed &#39;s/\x1B(B//g&#39; \
  | sed &#39;s/\x1B\[K//g&#39; \
  | sed &#39;s/\x1B[&lt;=&gt;]//g&#39; \
  | sed &#39;s/\x1B\[[0-9:;&lt;=&gt;?]*[!]*[A-Za-z]//g&#39; \
  | sed &#39;s/\x1B[@A-Z\\\]^_]\|\x1B\[[0-9:;&lt;=&gt;?]*[-!&quot;#$%&amp;&#39;&quot;&#39;&quot;&#39;()*+,.\/]*[][\\@A-Z^_`a-z{|}~]//g&#39; \
  &gt;&gt;/tmp/upload-nsh64.log
echo &#39;```&#39; &gt;&gt;/tmp/upload-nsh64.log

## Upload the Test Log to the GitHub Release Notes
gh release edit \
  `cat $tag` \
  --notes-file /tmp/upload-nsh64.log \
  --repo $repo</code></pre></div>
    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>