<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>NuttX RTOS for PinePhone: Display Driver in Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="NuttX RTOS for PinePhone: Display Driver in Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's build a PinePhone Display Driver in Zig... That will run on Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/dsi2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">NuttX RTOS for PinePhone: Display Driver in Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a><ul></ul></li>
<li><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a><ul></ul></li>
<li><a href="#compose-long-packet">3 Compose Long Packet</a><ul>
<li><a href="#packet-header">3.1 Packet Header</a><ul></ul></li>
<li><a href="#packet-payload">3.2 Packet Payload</a><ul></ul></li>
<li><a href="#packet-footer">3.3 Packet Footer</a><ul></ul></li>
<li><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a><ul></ul></li></ul></li>
<li><a href="#error-correction-code">4 Error Correction Code</a><ul></ul></li>
<li><a href="#compose-short-packet">5 Compose Short Packet</a><ul></ul></li>
<li><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a><ul></ul></li>
<li><a href="#run-mipi-dsi-driver-on-qemu">7 Run MIPI DSI Driver on QEMU</a><ul></ul></li>
<li><a href="#initialise-st7703-lcd-controller">8 Initialise ST7703 LCD Controller</a><ul></ul></li>
<li><a href="#send-mipi-dsi-packet">9 Send MIPI DSI Packet</a><ul></ul></li>
<li><a href="#test-zig-display-driver-for-pinephone">10 Test Zig Display Driver for PinePhone</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-zig-on-pinephone">12 Appendix: Zig on PinePhone</a><ul></ul></li>
<li><a href="#appendix-cyclic-redundancy-check">13 Appendix: Cyclic Redundancy Check</a><ul></ul></li></ul></nav><p>üìù <em>19 Oct 2022</em></p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS rendering something on PinePhone‚Äôs LCD Display" /></p>
<p>In our last article we talked about <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a> (pic above) and its <a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>LCD Display</strong></a>, connected via the (super complicated) <a href="https://lupyuen.github.io/articles/dsi#connector-for-mipi-dsi"><strong>MIPI Display Serial Interface</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></li>
</ul>
<p>Today we shall create a <strong>PinePhone Display Driver in Zig</strong>‚Ä¶ That will run on our fresh new port of <a href="https://lupyuen.github.io/articles/uboot"><strong>Apache NuttX RTOS</strong></a> for PinePhone.</p>
<p>If we‚Äôre not familiar with Zig: No worries! This article will explain the tricky Zig parts with C.</p>
<p><em>Why build the Display Driver in Zig? Instead of C?</em></p>
<p>Sadly some parts of PinePhone‚Äôs <a href="https://lupyuen.github.io/articles/dsi#sitronix-st7703-lcd-controller"><strong>ST7703 LCD Controller</strong></a> and <a href="https://lupyuen.github.io/articles/dsi#initialise-mipi-dsi"><strong>Allwinner A64 SoC</strong></a> are poorly documented. (Sigh)</p>
<p>Thus we‚Äôre building a <strong>Quick Prototype</strong> in Zig to be sure we‚Äôre setting the Hardware Registers correctly.</p>
<p>And while rushing through the reckless coding, it‚Äôs great to have Zig cover our backs and catch <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Common Runtime Problems</strong></a>.</p>
<p>Like Null Pointers, Underflow, Overflow, Array Out Of Bounds, ‚Ä¶</p>
<p><em>Will our final driver be in Zig or C?</em></p>
<p>Maybe Zig, maybe C?</p>
<p>It‚Äôs awfully nice to use Zig to simplify the complicated driver code. Zig‚Äôs <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Runtime Safety Checks</strong></a> are extremely helpful too.</p>
<p>But this driver goes into the <strong>NuttX RTOS Kernel</strong>. So most folks would expect the final driver to be delivered in C?</p>
<p>In any case, Zig and C look highly similar. Converting the Zig Driver to C should be straightforward.</p>
<p>(Minus the Runtime Safety Checks)</p>
<p>Zig or C? Lemme know what you think! üôè</p>
<p>Let‚Äôs continue the journey from our <strong>NuttX Porting Journal</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/dsi-title.jpg" alt="LCD Display on PinePhone Schematic (Page 2)" /></p>
<p><a href="https://files.pine64.org/doc/PinePhone/PinePhone%20v1.2b%20Released%20Schematic.pdf"><em>LCD Display on PinePhone Schematic (Page 2)</em></a></p>
<h1 id="pinephone-lcd-display"><a href="#pinephone-lcd-display">1 PinePhone LCD Display</a></h1>
<p><em>How is the LCD Display connected inside PinePhone?</em></p>
<p>Inside PinePhone is a <strong>XBD599 LCD Panel</strong> by Xingbangda (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#xingbangda-xbd599-lcd-panel"><strong>‚ÄúXingbangda XBD599 LCD Panel‚Äù</strong></a></li>
</ul>
<p>The LCD Display is connected to the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> via a <strong>MIPI Display Serial Interface (DSI)</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/MIPI_Alliance">(MIPI is the <strong>Mobile Industry Processor Interface Alliance</strong>)</a></p>
<p><em>What‚Äôs a MIPI Display Serial Interface?</em></p>
<p>Think of it as SPI, but supercharged with <strong>Multiple Data Lanes</strong>!</p>
<p>PinePhone‚Äôs MIPI Display Serial Interface runs on <strong>4 Data Lanes</strong> that will transmit 4 streams of pixel data concurrently.</p>
<p><a href="https://en.wikipedia.org/wiki/Display_Serial_Interface">(More about Display Serial Interface)</a></p>
<p><em>How do we control PinePhone‚Äôs LCD Display?</em></p>
<p>The XBD599 LCD Panel has a <strong>Sitronix ST7703 LCD Controller</strong> inside‚Ä¶</p>
<ul>
<li><a href="https://files.pine64.org/doc/datasheet/pinephone/ST7703_DS_v01_20160128.pdf"><strong>Sitronix ST7703 LCD Controller Datasheet</strong></a></li>
</ul>
<p>Which means our PinePhone Display Driver shall <strong>send commands to the ST7703 LCD Controller</strong> over the MIPI Display Serial Interface.</p>
<p><em>What commands will our Display Driver send to ST7703?</em></p>
<p>At startup, our driver shall send these 20 <strong>Initialisation Commands</strong> to the ST7703 LCD Controller‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-initialise-lcd-controller"><strong>‚ÄúInitialise LCD Controller‚Äù</strong></a></li>
</ul>
<p>ST7703 Commands can be a single byte, like for <strong>‚ÄúDisplay On‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>29</code></pre></div>
<p>Or a few bytes, like for <strong>‚ÄúEnable User Command‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>B9 F1 12 83</code></pre></div>
<p>And up to <strong>64 bytes</strong> (for ‚ÄúSet Forward GIP Timing‚Äù)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>E9 82 10 06 05 A2 0A A5 
12 31 23 37 83 04 BC 27 
38 0C 00 03 00 00 00 0C 
00 03 00 00 00 75 75 31 
88 88 88 88 88 88 13 88 
64 64 20 88 88 88 88 88 
88 02 88 00 00 00 00 00 
00 00 00 00 00 00 00 00 </code></pre></div>
<p>We‚Äôll send these 20 commands to ST7703 in a specific packet format‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi-packet.png" alt="MIPI DSI Long Packet (Page 203)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Long Packet (Page 203)</em></a></p>
<h1 id="long-packet-for-mipi-dsi"><a href="#long-packet-for-mipi-dsi">2 Long Packet for MIPI DSI</a></h1>
<p>To send a command to the ST7703 LCD Controller, we‚Äôll transmit a <a href="https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi"><strong>MIPI DSI Long Packet</strong></a> in this format (pic above)‚Ä¶</p>
<p><strong>Packet Header</strong> (4 bytes):</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p><strong>Packet Payload:</strong></p>
<ul>
<li>
<p><strong>Data</strong> (0 to 65,541 bytes):</p>
<p>Number of data bytes should match the Word Count (WC)</p>
</li>
</ul>
<p><strong>Packet Footer:</strong></p>
<ul>
<li>
<p><strong>Checksum (CS)</strong> (2 bytes):</p>
<p>16-bit Cyclic Redundancy Check (CCITT CRC)</p>
</li>
</ul>
<p>Let‚Äôs do this in Zig‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code1.png" alt="Compose Long Packet in Zig" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">(Source)</a></p>
<h1 id="compose-long-packet"><a href="#compose-long-packet">3 Compose Long Packet</a></h1>
<p>Now we look at our <strong>Zig Function</strong> that composes a <strong>Long Packet</strong> for MIPI Display Serial Interface: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L111">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Long Packet.
// See https://lupyuen.github.io/articles/dsi#long-packet-for-mipi-dsi
fn composeLongPacket(
  pkt:     []u8,  // Buffer for the Returned Long Packet
  channel: u8,    // Virtual Channel ID
  cmd:     u8,    // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Long Packet
  ...</code></pre></div>
<p>(<strong><code>u8</code></strong> in Zig is the same as <strong><code>uint8_t</code></strong> in C)</p>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> accepts the following parameters‚Ä¶</p>
<ul>
<li>
<p><strong><code>pkt</code></strong>: This is the buffer that we‚Äôll use to write the Long Packet and return it.</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[]u8</code></strong>‚Äù which is a Slice of Bytes, roughly similar to ‚Äú<strong><code>uint8_t *</code></strong>‚Äù in C.</p>
<p>(Except that the Buffer Size is also passed in the Slice)</p>
</li>
<li>
<p><strong><code>channel</code></strong>: MIPI Display Serial Interface supports multiple Virtual Channels, we‚Äôll stick to <strong>Virtual Channel 0</strong> for today</p>
</li>
<li>
<p><strong><code>cmd</code></strong>: Refers to the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>Display Command Set (DCS)</strong></a> that we‚Äôll send over the MIPI Display Serial Interface.</p>
<p>For Long Packets, we‚Äôll send the <a href="https://lupyuen.github.io/articles/dsi#display-command-set-for-mipi-dsi"><strong>DCS Long Write Command</strong></a>. (Which has Data Type <code>0x39</code>)</p>
<p>(Later we‚Äôll see the DCS Short Write Command)</p>
</li>
<li>
<p><strong><code>buf</code></strong>: This is a C Pointer to the <strong>Transmit Buffer</strong> that will be packed inside the Long Packet. (As Packet Payload)</p>
<p>It‚Äôs declared as ‚Äú<strong><code>[*c]const u8</code></strong>‚Äù, which is the same as ‚Äú<strong><code>const uint8_t *</code></strong>‚Äù in C.</p>
<p>(‚Äú<strong><code>[*c]</code></strong>‚Äù means that Zig will handle it as a C Pointer)</p>
</li>
<li>
<p><strong><code>len</code></strong>: Number of bytes in the <strong>Transmit Buffer</strong></p>
</li>
</ul>
<p>Our Zig Function <strong><code>composeLongPacket</code></strong> returns a Slice of Bytes that will contain the Long Packet.</p>
<p>(Declared as ‚Äú<strong><code>[]const u8</code></strong>‚Äù. Yep the returned Slice will be a Sub-Slice of <strong><code>pkt</code></strong>)</p>
<p><em>Why do we mix Slices and Pointers in the Parameters?</em></p>
<p>The parameters <strong><code>buf</code></strong> and <strong><code>len</code></strong> could have been passed as a Byte Slice in Zig‚Ä¶</p>
<p>Instead we‚Äôre passing as an old-school <strong>C Pointer</strong> so that it‚Äôs compatible with the <strong>C Interface</strong> for our function‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// (Eventual) C Interface for our function
ssize_t mipi_dsi_dcs_write(
  const struct device *dev,  // MIPI DSI Device
  uint8_t     channel,  // Virtual Channel ID
  uint8_t     cmd,      // DCS Command
  const void *buf,      // Transmit Buffer
  size_t      len       // Buffer Length
);</code></pre></div>
<p>This C Interface is identical to the implementation of <strong>MIPI DSI in Zephyr OS</strong>. <a href="https://github.com/zephyrproject-rtos/zephyr/blob/main/include/zephyr/drivers/mipi_dsi.h#L325-L337">(See this)</a></p>
<p>Let‚Äôs compose the Packet Header‚Ä¶</p>
<h2 id="packet-header"><a href="#packet-header">3.1 Packet Header</a></h2>
<p>The <strong>Packet Header</strong> (4 bytes) of our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Data Identifier (DI)</strong> (1 byte):</p>
<p>Virtual Channel Identifier (Bits 6 to 7)</p>
<p>Data Type (Bits 0 to 5)</p>
<p>(Data Type is the DCS Command)</p>
</li>
<li>
<p><strong>Word Count (WC)</strong> (2 bytes)Ôºö</p>
<p>Number of bytes in the Packet Payload</p>
</li>
<li>
<p><strong>Error Correction Code (ECC)</strong> (1 byte):</p>
<p>Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header</p>
</li>
</ul>
<p>This is how we compose the <strong>Packet Header</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L47-L81">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>First we populate the <strong>Data Indentifier (DI)</strong> with the Virtual Channel and DCS Command.</p>
<p>Then we convert the 16-bit <strong>Word Count (WC)</strong> to bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Word Count (WC) (2 bytes)Ôºö
  // Number of bytes in the Packet Payload
  const wc: u16 = @intCast(u16, len);
  const wcl: u8 = @intCast(u8, wc &amp; 0xff);
  const wch: u8 = @intCast(u8, wc &gt;&gt; 8);</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/#intCast"><strong><code>@intCast</code></strong></a> will halt with a Runtime Panic if <strong><code>len</code></strong> is too big to be converted into a 16-bit unsigned integer <strong><code>u16</code></strong>)</p>
<p>Next comes the <strong>Error Correction Code (ECC)</strong>. Which we compute based on the Data Identifier and Word Count‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Word Count (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_wc = [3]u8 { di, wcl, wch };

  // Compute Error Correction Code (ECC) for
  // Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_wc);</code></pre></div>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù allocates a 3-byte array from the stack)</p>
<p>We‚Äôll cover <strong><code>computeEcc</code></strong> in a while.</p>
<p>Finally we pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Word Count + Error Correction Code
  const header = [4]u8 { 
    di_wc[0],  // Data Identifier
    di_wc[1],  // Word Count (Low Byte)
    di_wc[2],  // Word Count (High Byte)
    ecc        // Error Correction Code
  };</code></pre></div>
<p>Moving on to the Packet Payload‚Ä¶</p>
<h2 id="packet-payload"><a href="#packet-payload">3.2 Packet Payload</a></h2>
<p>Remember that our <strong>Packet Payload</strong> is passed in as C-style <strong><code>buf</code></strong> (Buffer Pointer) and <strong><code>len</code></strong> (Buffer Length)?</p>
<p>This is how we convert the Packet Payload to a <strong>Byte Slice</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L81-L87">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Payload:
  // Data (0 to 65,541 bytes).
  // Number of data bytes should match the Word Count (WC)
  assert(len &lt;= 65_541);

  // Convert to Byte Slice
  const payload = buf[0..len];</code></pre></div>
<p>We‚Äôll concatenate the Packet Payload with the Header and Footer in a while.</p>
<p>(Packet Header and Footer are also Byte Slices)</p>
<p>From this code it‚Äôs clear that a <a href="https://ziglang.org/documentation/master/#Slices"><strong>Zig Slice</strong></a> is nothing more than a <strong>Pointer</strong> and a <strong>Length</strong>‚Ä¶ It‚Äôs the tidier and safer way to pass buffers in Zig!</p>
<h2 id="packet-footer"><a href="#packet-footer">3.3 Packet Footer</a></h2>
<p>At the end of our Long Packet is the <strong>Packet Footer</strong>: A 16-bit <strong>Cyclic Redundancy Check</strong> (CCITT CRC).</p>
<p>This is how we compute the CRC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L87-L97">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Checksum (CS) (2 bytes):
  // 16-bit Cyclic Redundancy Check (CRC) of the Payload
  // (not the entire packet)
  const cs: u16 = computeCrc(payload);</code></pre></div>
<p>(<strong><code>computeCrc</code></strong> is explained in the Appendix)</p>
<p>The CRC goes into the 2-byte <strong>Packet Footer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Convert CRC to 2 bytes
  const csl: u8 = @intCast(u8, cs &amp; 0xff);
  const csh: u8 = @intCast(u8, cs &gt;&gt; 8);

  // Packet Footer (2 bytes):
  // Checksum (CS)
  const footer = [2]u8 { csl, csh };</code></pre></div>
<p>Finally we‚Äôre ready to put the Header, Payload and Footer together!</p>
<h2 id="combine-header-payload-and-footer"><a href="#combine-header-payload-and-footer">3.4 Combine Header, Payload and Footer</a></h2>
<p>Our Long Packet will contain‚Ä¶</p>
<ul>
<li>
<p><strong>Packet Header</strong> (4 bytes)</p>
</li>
<li>
<p><strong>Packet Payload</strong> (<code>len</code> bytes)</p>
</li>
<li>
<p><strong>Packet Footer</strong> (2 bytes)</p>
</li>
</ul>
<p>Let‚Äôs combine the <strong>Header, Payload and Footer</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L97-L112">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len + len + footer.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size if this fails

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );

  // Copy Payload to Packet Buffer
  // (After the Header)
  std.mem.copy(
    u8,                  // Type
    pkt[header.len..],   // Destination
    payload              // Source (`len` bytes)
  );

  // Copy Footer to Packet Buffer
  // (After the Payload)
  std.mem.copy(
    u8,                  // Type
    pkt[(header.len + len)..],  // Destination
    &amp;footer              // Source (2 bytes)
  );</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.copy"><strong><code>std.mem.copy</code></strong></a> copies one Slice to another. It works like <strong><code>memcpy</code></strong> in C)</p>
<p>And we return the Byte Slice that contains our Long Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>That‚Äôs how we compose a MIPI DSI Long Packet in Zig!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-ecc.png" alt="MIPI DSI Error Correction Code (Page 209)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Error Correction Code (Page 209)</em></a></p>
<h1 id="error-correction-code"><a href="#error-correction-code">4 Error Correction Code</a></h1>
<p>Earlier we talked about computing the <strong>Error Correction Code (ECC)</strong> for the Packet Header‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#packet-header"><strong>‚ÄúPacket Header‚Äù</strong></a></li>
</ul>
<p>The <strong>8-bit ECC</strong> shall be computed with this (magic) formula: <a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf">(Page 209)</a></p>
<div class="example-wrap"><pre class="language-text"><code>ECC[7] = 0
ECC[6] = 0
ECC[5] = D10^D11^D12^D13^D14^D15^D16^D17^D18^D19^D21^D22^D23
ECC[4] = D4^D5^D6^D7^D8^D9^D16^D17^D18^D19^D20^D22^D23
ECC[3] = D1^D2^D3^D7^D8^D9^D13^D14^D15^D19^D20^D21^D23
ECC[2] = D0^D2^D3^D5^D6^D9^D11^D12^D15^D18^D20^D21^D22
ECC[1] = D0^D1^D3^D4^D6^D8^D10^D12^D14^D17^D20^D21^D22^D23
ECC[0] = D0^D1^D2^D4^D5^D7^D10^D11^D13^D16^D20^D21^D22^D23</code></pre></div>
<p>(‚Äú<strong><code>^</code></strong>‚Äù means Exclusive OR)</p>
<p>(<strong><code>D0</code></strong> to <strong><code>D23</code></strong> refer to the pic above)</p>
<p>This is how we compute the ECC: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L170-L211">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Compute the Error Correction Code (ECC) (1 byte):
/// Allow single-bit errors to be corrected and 2-bit errors to be detected in the Packet Header
/// See &quot;12.3.6.12: Error Correction Code&quot;, Page 208 of BL808 Reference Manual:
/// https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf
fn computeEcc(
  di_wc: [3]u8  // Data Identifier + Word Count (3 bytes)
) u8 {
  ...</code></pre></div>
<p>Our Zig Function <strong><code>computeEcc</code></strong> accepts a 3-byte array, containing the first 3 bytes of the Packet Header.</p>
<p>(‚Äú<strong><code>[3]u8</code></strong>‚Äù is equivalent to ‚Äú<strong><code>uint8_t[3]</code></strong>‚Äù in C)</p>
<p>We combine the 3 bytes into a <strong>24-bit word</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Combine DI and WC into a 24-bit word
  var di_wc_word: u32 = 
    di_wc[0] 
    | (@intCast(u32, di_wc[1]) &lt;&lt; 8)
    | (@intCast(u32, di_wc[2]) &lt;&lt; 16);</code></pre></div>
<p>Then we extract the 24 bits into <strong><code>d[0]</code></strong> to <strong><code>d[23]</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 24 bits from the stack,
  // initialised to zeros
  var d = std.mem.zeroes([24]u1);

  // Extract the 24 bits from the word
  var i: usize = 0;
  while (i &lt; 24) : (i += 1) {
    d[i] = @intCast(u1, di_wc_word &amp; 1);
    di_wc_word &gt;&gt;= 1;
  }</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.zeroes"><strong><code>std.mem.zeroes</code></strong></a> allocates an array from the stack, initialised to zeroes)</p>
<p>Note that we‚Äôre working with <strong>Bit Values</strong>‚Ä¶</p>
<ul>
<li>
<p>‚Äú<strong><code>u1</code></strong>‚Äù represents a Single Bit Value</p>
</li>
<li>
<p>‚Äú<strong><code>[24]u1</code></strong>‚Äù is an Array of 24 Bits</p>
</li>
</ul>
<p>We compute the <strong>ECC Bits</strong> according to the Magic Formula‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate an array of 8 bits from the stack,
  // initialised to zeros
  var ecc = std.mem.zeroes([8]u1);

  // Compute the ECC bits
  ecc[7] = 0;
  ecc[6] = 0;
  ecc[5] = d[10] ^ d[11] ^ d[12] ^ d[13] ^ d[14] ^ d[15] ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[21] ^ d[22] ^ d[23];
  ecc[4] = d[4]  ^ d[5]  ^ d[6]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[16] ^ d[17] ^ d[18] ^ d[19] ^ d[20] ^ d[22] ^ d[23];
  ecc[3] = d[1]  ^ d[2]  ^ d[3]  ^ d[7]  ^ d[8]  ^ d[9]  ^ d[13] ^ d[14] ^ d[15] ^ d[19] ^ d[20] ^ d[21] ^ d[23];
  ecc[2] = d[0]  ^ d[2]  ^ d[3]  ^ d[5]  ^ d[6]  ^ d[9]  ^ d[11] ^ d[12] ^ d[15] ^ d[18] ^ d[20] ^ d[21] ^ d[22];
  ecc[1] = d[0]  ^ d[1]  ^ d[3]  ^ d[4]  ^ d[6]  ^ d[8]  ^ d[10] ^ d[12] ^ d[14] ^ d[17] ^ d[20] ^ d[21] ^ d[22] ^ d[23];
  ecc[0] = d[0]  ^ d[1]  ^ d[2]  ^ d[4]  ^ d[5]  ^ d[7]  ^ d[10] ^ d[11] ^ d[13] ^ d[16] ^ d[20] ^ d[21] ^ d[22] ^ d[23];</code></pre></div>
<p>Finally we <strong>merge the ECC Bits</strong> into a single byte and return it‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Merge the ECC bits
  return @intCast(u8, ecc[0])
    | (@intCast(u8, ecc[1]) &lt;&lt; 1)
    | (@intCast(u8, ecc[2]) &lt;&lt; 2)
    | (@intCast(u8, ecc[3]) &lt;&lt; 3)
    | (@intCast(u8, ecc[4]) &lt;&lt; 4)
    | (@intCast(u8, ecc[5]) &lt;&lt; 5)
    | (@intCast(u8, ecc[6]) &lt;&lt; 6)
    | (@intCast(u8, ecc[7]) &lt;&lt; 7);
}</code></pre></div>
<p>And we‚Äôre done with the Error Correction Code!</p>
<p><img src="https://lupyuen.github.io/images/dsi-short.png" alt="MIPI DSI Short Packet (Page 201)" /></p>
<p><a href="https://files.pine64.org/doc/datasheet/ox64/BL808_RM_en_1.0(open).pdf"><em>MIPI DSI Short Packet (Page 201)</em></a></p>
<h1 id="compose-short-packet"><a href="#compose-short-packet">5 Compose Short Packet</a></h1>
<p><em>We‚Äôve seen the Long Packet. Is there a Short Packet?</em></p>
<p>Yep! If we‚Äôre transmitting 1 or 2 bytes to the ST7703 LCD Controller, we may send a <strong>MIPI DSI Short Packet</strong> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi"><strong>‚ÄúShort Packet for MIPI DSI‚Äù</strong></a></li>
</ul>
<p>A MIPI DSI Short Packet (compared with Long Packet)‚Ä¶</p>
<ul>
<li>
<p>Doesn‚Äôt have Packet Payload and Packet Footer (CRC)</p>
</li>
<li>
<p>Instead of Word Count (WC), the Packet Header now has 2 bytes of data</p>
</li>
<li>
<p>DCS Command (Data Type) is‚Ä¶</p>
<p><strong>DCS Short Write Without Parameter (<code>0x05</code>)</strong> for sending 1 byte of data</p>
<p><strong>DCS Short Write With Parameter (<code>0x15</code>)</strong> for sending 2 bytes of data</p>
</li>
<li>
<p>Everything else is the same</p>
</li>
</ul>
<p>This is how we <strong>compose a Short Packet</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L113-L168">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose MIPI DSI Short Packet. 
// See https://lupyuen.github.io/articles/dsi#appendix-short-packet-for-mipi-dsi
fn composeShortPacket(
  pkt:     []u8,    // Buffer for the Returned Short Packet
  channel: u8,      // Virtual Channel ID
  cmd:     u8,      // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) []const u8 {  // Returns the Short Packet
  
  // Short Packet can only have 1 or 2 data bytes
  assert(len == 1 or len == 2);</code></pre></div>
<p><strong><code>composeShortPacket</code></strong> accepts the same parameters as <strong><code>composeLongPacket</code></strong>.</p>
<p>We populate <strong>Data Indentifier (DI)</strong> the same way, with Virtual Channel and DCS Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier (DI) (1 byte):
  // - Virtual Channel Identifier (Bits 6 to 7)
  // - Data Type (Bits 0 to 5)
  assert(channel &lt; 4);
  assert(cmd &lt; (1 &lt;&lt; 6));
  const vc: u8 = channel;
  const dt: u8 = cmd;
  const di: u8 = (vc &lt;&lt; 6) | dt;</code></pre></div>
<p>Our <strong>Packet Header</strong> will include two bytes of data‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data (2 bytes), fill with 0 
  // if Second Byte is missing
  const data = [2]u8 {
    buf[0],                       // First Data Byte
    if (len == 2) buf[1] else 0,  // Second Data Byte
  };</code></pre></div>
<p>We compute the <strong>Error Correction Code (ECC)</strong> based on the Data Identifier and the two Data Bytes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Data Identifier + Data (3 bytes): 
  // For computing Error Correction Code (ECC)
  const di_data = [3]u8 { 
    di,       // Data Identifier
    data[0],  // First Data Byte
    data[1]   // Second Data Byte
  };

  // Compute Error Correction Code (ECC) 
  // for Data Identifier + Word Count
  const ecc: u8 = computeEcc(di_data);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/dsi2#error-correction-code">(<strong><code>computeEcc</code></strong> is explained here)</a></p>
<p>We pack everything into our 4-byte <strong>Packet Header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Packet Header (4 bytes):
  // Data Identifier + Data + Error Correction Code
  const header = [4]u8 { 
    di_data[0],  // Data Identifier
    di_data[1],  // First Data Byte
    di_data[2],  // Second Data Byte
    ecc          // Error Correction Code
  };</code></pre></div>
<p>We <strong>copy the Packet Header</strong> into our Packet Buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Verify the Packet Buffer Length
  const pktlen = header.len;
  assert(pktlen &lt;= pkt.len);  // Increase `pkt` size

  // Copy Header to Packet Buffer
  std.mem.copy(
    u8,                  // Type
    pkt[0..header.len],  // Destination
    &amp;header              // Source (4 bytes)
  );</code></pre></div>
<p>And we return the Byte Slice that contains our Short Packet, sized accordingly‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the packet
  const result = pkt[0..pktlen];
  return result;
}</code></pre></div>
<p>We‚Äôre done with Long and Short Packets for MIPI DSI, let‚Äôs test them‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-test.png" alt="Test Case for MIPI DSI Driver" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L997-L1036">(Source)</a></p>
<h1 id="test-mipi-dsi-driver"><a href="#test-mipi-dsi-driver">6 Test MIPI DSI Driver</a></h1>
<p><em>How will we know if our Long and Short Packets are created correctly?</em></p>
<p>Let‚Äôs write a <strong>Test Case</strong> to verify that our MIPI DSI Packets are constructed correctly: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L965-L987">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Test Compose Short Packet (With Parameter)
const short_pkt_param = [_]u8 {
  0xbc, 0x4e,
};</code></pre></div>
<p>We‚Äôll compose a Short Packet that will pack the 2 bytes above.</p>
<p>(We write ‚Äú<strong><code>[_]u8</code></strong>‚Äù to declare a Byte Array in Zig)</p>
<p>First we allocate a <strong>Packet Buffer</strong> from the Stack, initialised to zeroes‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Allocate Packet Buffer of 128 bytes
var pkt_buf = std.mem.zeroes([128]u8);</code></pre></div>
<p>(‚Äú<strong><code>[128]u8</code></strong>‚Äù is equivalent to ‚Äú<strong><code>uint8_t[128]</code></strong>‚Äù in C)</p>
<p>Then we call <strong><code>composeShortPacket</code></strong> to construct the Short Packet‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Compose a Short Packet (With Parameter)</span>
<span class="kw">const</span> <span class="ident">short_pkt_param_result</span> <span class="op">=</span> <span class="ident">composeShortPacket</span>(
  <span class="kw-2">&amp;</span><span class="ident">pkt_buf</span>,  <span class="comment">//  Packet Buffer</span>
  <span class="number">0</span>,         <span class="comment">//  Virtual Channel</span>
  <span class="ident">MIPI_DSI_DCS_SHORT_WRITE_PARAM</span>, <span class="comment">// DCS Command: 0x15</span>
  <span class="kw-2">&amp;</span><span class="ident">short_pkt_param</span>,    <span class="comment">// Transmit Buffer</span>
  <span class="ident">short_pkt_param</span>.<span class="ident">len</span>  <span class="comment">// Buffer Length</span>
);</code></pre></div>
<p>We <strong>dump the contents</strong> of the returned packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Dump the Returned Packet
debug(&quot;Result:&quot;, .{});
dump_buffer(
  &amp;short_pkt_param_result[0],  // Pointer to Packet
  short_pkt_param_result.len   // Length of Packet
);</code></pre></div>
<p>(We‚Äôll talk about <strong><code>dump_buffer</code></strong> in a while)</p>
<p>Finally we verify that the result is ‚Äú<strong><code>15</code> <code>BC</code> <code>4E</code> <code>35</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>//  Verify the Returned Packet
assert(
  std.mem.eql(  // Compare 2 Slices...
    u8,         // Slice Type
    short_pkt_param_result,   // First Slice
    &amp;[_]u8 {                  // Second Slice
      0x15, 0xbc, 0x4e, 0x35  // Expected Data
    }
  )
);</code></pre></div>
<p>(<a href="https://ziglang.org/documentation/master/std/#root;mem.eql"><strong><code>std.mem.eql</code></strong></a> returns True if the two Slices are identical)</p>
<p>The above Test Case shows this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Testing Compose Short Packet (With Parameter)...
composeShortPacket:
  channel=0, cmd=0x15, len=2
Result:
  15 bc 4e 35 </code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#testing-nuttx-zig-driver-for-mipi-dsi-on-qemu">(Source)</a></p>
<p>In the next chapter we‚Äôll learn to run the Test Case on the QEMU Emulator for Arm64.</p>
<p><em>What‚Äôs <code>dump_buffer</code>?</em></p>
<p><strong><code>dump_buffer</code></strong> is a C Function that dumps a packet to the console. We imported the C Function into Zig like so: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L1205-L1206">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import `dump_buffer` Function from C
extern fn dump_buffer(
  data: [*c]const u8,  // C Pointer to Packet
  len: usize           // Length of Packet
) void;                // No Return Value</code></pre></div>
<p><strong><code>dump_buffer</code></strong> is defined here: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/de/examples/hello/hello_main.c#L197-L205">hello_main.c</a></p>
<p><em>What about testing Long Packets?</em></p>
<p>We have <strong>3 Test Cases</strong> for testing the creation of Long and Short Packets‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L931-L955"><strong>Short Packet Without Parameter</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L965-L987"><strong>Short Packet With Parameter</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L997-L1036"><strong>Long Packet</strong></a></p>
</li>
</ul>
<p><em>How did we get the Expected Result for our Test Cases?</em></p>
<p>We ran the <a href="https://gist.github.com/lupyuen/ee3adf76e76881609845d0ab0f768a95"><strong>p-boot Display Code</strong></a> (in C) on Apache NuttX RTOS and captured the Expected Packet Contents.</p>
<p>So we can be sure that our Zig Code will produce the same results as the (poorly documented) C Version.</p>
<p>Let‚Äôs find out how we ran the Test Cases on QEMU Emulator‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-qemu.png" alt="Testing MIPI DSI Driver with QEMU" /></p>
<h1 id="run-mipi-dsi-driver-on-qemu"><a href="#run-mipi-dsi-driver-on-qemu">7 Run MIPI DSI Driver on QEMU</a></h1>
<p><em>Can we test our MIPI DSI code on Apache NuttX RTOS‚Ä¶ Without a PinePhone?</em></p>
<p>Yep! Let‚Äôs test our Zig code on the <a href="https://www.qemu.org/docs/master/system/target-arm.html"><strong>QEMU Emulator for Arm64</strong></a>, running Apache NuttX RTOS.</p>
<p>Follow these steps to build <strong>NuttX RTOS for QEMU Arm64</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx#test-pinephone-mipi-dsi-driver-with-qemu"><strong>‚ÄúTest PinePhone MIPI DSI Driver with QEMU‚Äù</strong></a></li>
</ul>
<p>Then we compile our <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig"><strong>Zig App (display.zig)</strong></a> and link it with NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download the Zig App
git clone --recursive https://github.com/lupyuen/pinephone-nuttx
cd pinephone-nuttx

#  Compile the Zig App for PinePhone 
#  (armv8-a with cortex-a53)
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  -target aarch64-freestanding-none \
  -mcpu cortex_a53 \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  display.zig

#  Copy the compiled app to NuttX and overwrite `null.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp display.o \
  $HOME/nuttx/apps/examples/null/*null.o

#  Build NuttX to link the Zig Object from `null.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#zig-on-pinephone">(Source)</a></p>
<p>We <strong>start QEMU</strong> to boot NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Run GIC v2 with QEMU
qemu-system-aarch64 \
  -smp 4 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=2 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>(We chose <a href="https://lupyuen.github.io/articles/interrupt#allwinner-a64-gic"><strong>GIC Version 2</strong></a> to be consistent with PinePhone)</p>
<p>At the NuttX Shell, enter this command to run our <strong>Zig Test Cases</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>null</code></pre></div>
<p>Our <a href="https://lupyuen.github.io/articles/dsi2#test-mipi-dsi-driver"><strong>Test Cases for Long and Short Packets</strong></a> should complete without Assertion Failures‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-11.0.0-RC2
nsh&gt; null
HELLO ZIG ON PINEPHONE!
Testing Compose Short Packet (Without Parameter)...
composeShortPacket: channel=0, cmd=0x5, len=1
Result:
05 11 00 36 
Testing Compose Short Packet (With Parameter)...
composeShortPacket: channel=0, cmd=0x15, len=2
Result:
15 bc 4e 35 
Testing Compose Long Packet...
composeLongPacket: channel=0, cmd=0x39, len=64
Result:
39 40 00 25 e9 82 10 06 
05 a2 0a a5 12 31 23 37 
83 04 bc 27 38 0c 00 03 
00 00 00 0c 00 03 00 00 
00 75 75 31 88 88 88 88 
88 88 13 88 64 64 20 88 
88 88 88 88 88 02 88 00 
00 00 00 00 00 00 00 00 
00 00 00 00 65 03 
nsh&gt; </code></pre></div>
<p>Yep we have successfully tested our MIPI DSI Code on NuttX RTOS and QEMU Arm64!</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code2.png" alt="Initialising ST7703 LCD Controller" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L494-L859">(Source)</a></p>
<h1 id="initialise-st7703-lcd-controller"><a href="#initialise-st7703-lcd-controller">8 Initialise ST7703 LCD Controller</a></h1>
<p><em>But our MIPI DSI Driver hasn‚Äôt talked to the PinePhone Display!</em></p>
<p>Here comes the tougher (and poorly documented) part‚Ä¶ Accessing the <strong>Hardware Registers</strong> of the Allwinner A64 SoC. So that we can <strong>send MIPI DSI Packets</strong> to PinePhone‚Äôs Display.</p>
<p>Before that, let‚Äôs prepare the MIPI DSI Packets (Long and Short) that we‚Äôll send to the display‚Ä¶</p>
<p>Earlier we talked about the <strong>20 Initialisation Commands</strong> that our Zig Driver will send to the <strong>ST7703 LCD Controller</strong> (over MIPI DSI)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/dsi2#pinephone-lcd-display"><strong>‚ÄúPinePhone LCD Display‚Äù</strong></a></li>
</ul>
<p>This is how we <strong>send the 20 commands</strong>: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L494-L859">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Initialise the ST7703 LCD Controller in Xingbangda XBD599 LCD Panel.
/// See https://lupyuen.github.io/articles/dsi#initialise-lcd-controller
pub export fn nuttx_panel_init() void {

  // Most of these commands are documented in the ST7703 Datasheet:
  // https://files.pine64.org/doc/datasheet/pinephone/ST7703_DS_v01_20160128.pdf

  // Command #1
  writeDcs(&amp;[_]u8 { 
    0xB9,  // SETEXTC (Page 131): Enable USER Command
    0xF1,  // Enable User command
    0x12,  // (Continued)
    0x83   // (Continued)
  });

  // Omitted: Commands #2 to #19
  ...

  // Wait 120 milliseconds
  _ = c.usleep(120 * 1000);

  // Command #20
  writeDcs(&amp;[_]u8 {
    0x29  // Display On (Page 97): Recover from DISPLAY OFF mode (MIPI_DCS_SET_DISPLAY_ON)
  });    
}</code></pre></div>
<p>To send a command to ST7703 Controller, <strong><code>writeDcs</code></strong> executes a <strong>DCS Short Write</strong> or <strong>DCS Long Write</strong> over MIPI DSI, depending on the length of the command: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L296-L321">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Write the DCS Command to MIPI DSI
fn writeDcs(buf: []const u8) void {

  // Do DCS Short Write or Long Write depending on command length
  assert(buf.len &gt; 0);
  const res = switch (buf.len) {

    // If Command Length is 1:
    // DCS Short Write (without parameter)
    1 =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_SHORT_WRITE, 
      &amp;buf[0], buf.len),

    // If Command Length is 2:
    // DCS Short Write (with parameter)
    2 =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_SHORT_WRITE_PARAM, 
      &amp;buf[0], buf.len),

    // If Command Length is 3 or longer:
    // DCS Long Write
    else =&gt; nuttx_mipi_dsi_dcs_write(null, 0, 
      MIPI_DSI_DCS_LONG_WRITE, 
      &amp;buf[0], buf.len),
  };
  assert(res == buf.len);
}</code></pre></div>
<p>Let‚Äôs study our Zig Function that sends Long Packets and Short Packets over MIPI DSI: <strong>nuttx_mipi_dsi_dcs_write</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/dsi2-code3.png" alt="Writing a DCS Command to MIPI DSI" /></p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L296-L321">(Source)</a></p>
<h1 id="send-mipi-dsi-packet"><a href="#send-mipi-dsi-packet">9 Send MIPI DSI Packet</a></h1>
<p>Finally we‚Äôre ready to access the <strong>Hardware Registers</strong> of PinePhone‚Äôs Allwinner A64 SoC, to send MIPI DSI Packets to the display.</p>
<p>We‚Äôll call these Zig Functions to manipulate <strong>A64‚Äôs Hardware Registers</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L479-L483"><strong><code>getreg32</code></strong></a>: Read the Value of the Hardware Register at the specified Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn getreg32(addr: u64) u32</code></pre></div></li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L485-L489"><strong><code>putreg32</code></strong></a>: Set the Value of the Hardware Register at the specified Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn putreg32(val: u32, addr: u64)</code></pre></div>
<p>(Note that the Value comes <strong>before</strong> the Address)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L463-L477"><strong><code>modifyreg32</code></strong></a>: Clear and set the bits of the Hardware Register at the Address</p>
<div class="example-wrap"><pre class="language-zig"><code>fn modifyreg32(
  addr: u64,       // Address to modify
  clearbits: u32,  // Bits to clear, like (1 &lt;&lt; bit)
  setbits: u32     // Bit to set, like (1 &lt;&lt; bit)
)</code></pre></div></li>
</ul>
<p>This is how we <strong>send MIPI DSI Packets</strong> to PinePhone‚Äôs Display: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L323-L430">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Write Packet to MIPI DSI. See https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi
pub export fn nuttx_mipi_dsi_dcs_write(
  dev:     [*c]const mipi_dsi_device,  // MIPI DSI Host Device
  channel: u8,  // Virtual Channel ID
  cmd:     u8,  // DCS Command
  buf:     [*c]const u8,  // Transmit Buffer
  len:     usize          // Buffer Length
) isize {  // On Success: Return number of written bytes. On Error: Return negative error code
  ...</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Allocate Packet Buffer
  var pkt_buf = std.mem.zeroes([128]u8);

  // Compose Short or Long Packet depending on DCS Command
  const pkt = switch (cmd) {

    // For DCS Long Write: Compose Long Packet
    MIPI_DSI_DCS_LONG_WRITE =&gt;
      composeLongPacket(&amp;pkt_buf, channel, cmd, buf, len),

    // For DCS Short Write (with and without parameter):
    // Compose Short Packet
    MIPI_DSI_DCS_SHORT_WRITE,
    MIPI_DSI_DCS_SHORT_WRITE_PARAM =&gt;
      composeShortPacket(&amp;pkt_buf, channel, cmd, buf, len),

    // DCS Command not supported
    else =&gt; unreachable,
  };</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set the following bits to 1 in DSI_CMD_CTL_REG (DSI Low Power Control Register) at Offset 0x200:
  // RX_Overflow (Bit 26): Clear flag for &quot;Receive Overflow&quot;
  // RX_Flag (Bit 25): Clear flag for &quot;Receive has started&quot;
  // TX_Flag (Bit 9): Clear flag for &quot;Transmit has started&quot;
  // All other bits must be set to 0.
  const DSI_CMD_CTL_REG = DSI_BASE_ADDRESS + 0x200;
  const RX_Overflow = 1 &lt;&lt; 26;
  const RX_Flag     = 1 &lt;&lt; 25;
  const TX_Flag     = 1 &lt;&lt; 9;
  putreg32(
    RX_Overflow | RX_Flag | TX_Flag,
    DSI_CMD_CTL_REG
  );</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Write the Long Packet to DSI_CMD_TX_REG 
  // (DSI Low Power Transmit Package Register) at Offset 0x300 to 0x3FC
  const DSI_CMD_TX_REG = DSI_BASE_ADDRESS + 0x300;
  var addr: u64 = DSI_CMD_TX_REG;
  var i: usize = 0;
  while (i &lt; pkt.len) : (i += 4) {
    // Fetch the next 4 bytes, fill with 0 if not available
    const b = [4]u32 {
      pkt[i],
      if (i + 1 &lt; pkt.len) pkt[i + 1] else 0,
      if (i + 2 &lt; pkt.len) pkt[i + 2] else 0,
      if (i + 3 &lt; pkt.len) pkt[i + 3] else 0,
    };

    // Merge the next 4 bytes into a 32-bit value
    const v: u32 =
      b[0]
      + (b[1] &lt;&lt; 8)
      + (b[2] &lt;&lt; 16)
      + (b[3] &lt;&lt; 24);

    // Write the 32-bit value
    assert(addr &lt;= DSI_BASE_ADDRESS + 0x3FC);
    modifyreg32(addr, 0xFFFF_FFFF, v);
    addr += 4;
  }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set Packet Length - 1 in Bits 0 to 7 (TX_Size) of
  // DSI_CMD_CTL_REG (DSI Low Power Control Register) at Offset 0x200
  modifyreg32(DSI_CMD_CTL_REG, 0xFF, @intCast(u32, pkt.len) - 1);</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set DSI_INST_JUMP_SEL_REG (Offset 0x48, undocumented) 
  // to begin the Low Power Transmission (LPTX)
  const DSI_INST_JUMP_SEL_REG = DSI_BASE_ADDRESS + 0x48;
  const DSI_INST_ID_LPDT = 4;
  const DSI_INST_ID_LP11 = 0;
  const DSI_INST_ID_END  = 15;
  putreg32(
    DSI_INST_ID_LPDT &lt;&lt; (4 * DSI_INST_ID_LP11) |
    DSI_INST_ID_END  &lt;&lt; (4 * DSI_INST_ID_LPDT),
    DSI_INST_JUMP_SEL_REG
  );</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Disable DSI Processing then Enable DSI Processing
  disableDsiProcessing();
  enableDsiProcessing();</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Wait for transmission to complete
  const res = waitForTransmit();
  if (res &lt; 0) {
    disableDsiProcessing();
    return res;
  }</code></pre></div>
<p>TODO</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return number of written bytes
  return @intCast(isize, len);
}</code></pre></div>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L432-L449">display.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Wait for transmit to complete. Returns 0 if completed, -1 if timeout.
/// See https://lupyuen.github.io/articles/dsi#transmit-packet-over-mipi-dsi
fn waitForTransmit() isize {
  // Wait up to 5,000 microseconds
  var i: usize = 0;
  while (i &lt; 5_000) : (i += 1) {
    // To check whether the transmission is complete, we poll on Instru_En
    if ((getreg32(DSI_BASIC_CTL0_REG) &amp; Instru_En) == 0) {
      // If Instru_En is 0, then transmission is complete
      return 0;
    }
    // Sleep 1 microsecond
    _ = c.usleep(1);
  }
  // Return Timeout
  std.log.err(&quot;waitForTransmit: timeout&quot;, .{});
  return -1;
}</code></pre></div>
<p>TODO</p>
<h1 id="test-zig-display-driver-for-pinephone"><a href="#test-zig-display-driver-for-pinephone">10 Test Zig Display Driver for PinePhone</a></h1>
<p>TODO</p>
<p><em>Are we really sure that our Zig Driver talks OK to PinePhone‚Äôs MIPI DSI Display?</em></p>
<p>Let‚Äôs test it!</p>
<p>Our NuttX Zig Display Driver powers on the PinePhone Display and works exactly like the C Driver! üéâ</p>
<p><img src="https://lupyuen.github.io/images/dsi2-title.jpg" alt="Apache NuttX RTOS on PinePhone" /></p>
<p><em>Can our driver render graphics on PinePhone Display?</em></p>
<p>Our PinePhone Display Driver isn‚Äôt complete. It handles MIPI DSI (for initialising ST7703) but doesn‚Äôt support Allwinner A64‚Äôs Display Engine (DE) and Timing Controller (TCON), which are needed for rendering graphics.</p>
<p>We‚Äôll implement DE and TCON next.</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>(I took longer to write this article‚Ä¶ Than to code the Zig Driver!)</p>
<p>There‚Äôs plenty to be done for NuttX on PinePhone, please lemme know if you would like to join me üôè</p>
<p>Check out the other articles on <strong>NuttX RTOS for PinePhone</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/arm"><strong>‚ÄúApache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/uboot"><strong>‚ÄúPinePhone boots Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/interrupt"><strong>‚ÄúNuttX RTOS for PinePhone: Fixing the Interrupts‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/serial"><strong>‚ÄúNuttX RTOS for PinePhone: UART Driver‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/dsi"><strong>‚ÄúUnderstanding PinePhone‚Äôs Display (MIPI DSI)‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Current Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/dsi2.md"><strong>lupyuen.github.io/src/dsi2.md</strong></a></p>
<h1 id="appendix-zig-on-pinephone"><a href="#appendix-zig-on-pinephone">12 Appendix: Zig on PinePhone</a></h1>
<p>TODO</p>
<p><code>make --trace</code> shows these GCC Compiler Options when building Nuttx for PinePhone‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>aarch64-none-elf-gcc
  -c
  -fno-common
  -Wall
  -Wstrict-prototypes
  -Wshadow
  -Wundef
  -Werror
  -Os
  -fno-strict-aliasing
  -fomit-frame-pointer
  -g
  -march=armv8-a
  -mtune=cortex-a53
  -isystem &quot;/Users/Luppy/PinePhone/nuttx/nuttx/include&quot;
  -D__NuttX__ 
  -pipe
  -I &quot;/Users/Luppy/PinePhone/nuttx/apps/include&quot;
  -Dmain=hello_main  hello_main.c
  -o  hello_main.c.Users.Luppy.PinePhone.nuttx.apps.examples.hello.o</code></pre></div>
<p>Let‚Äôs run this Zig App: <a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig">display.zig</a></p>
<p>Enable the Null Example App: make menuconfig, select ‚ÄúApplication Configuration‚Äù &gt; ‚ÄúExamples‚Äù &gt; ‚ÄúNull Example‚Äù</p>
<p>Compile the Zig App (based on the above GCC Compiler Options)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>zig build-obj \
  -target aarch64-freestanding-none \
  -mcpu cortex_a53 \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  display.zig

cp display.o \
  $HOME/nuttx/apps/examples/null/*null.o

cd $HOME/nuttx/nuttx
make</code></pre></div>
<p>Run the Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; null
HELLO ZIG ON PINEPHONE!</code></pre></div><h1 id="appendix-cyclic-redundancy-check"><a href="#appendix-cyclic-redundancy-check">13 Appendix: Cyclic Redundancy Check</a></h1>
<p>TODO</p>
<p>This is how our PinePhone Display Driver computes the 16-bit Cyclic Redundancy Check (CCITT) in Zig‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx/blob/main/display.zig#L306-L366">display.zig</a></p>
<p>The Cyclic Redundancy Check is the 2-byte Packet Footer for Long Packets.</p>

    
</body>
</html>