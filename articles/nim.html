<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC" 
    data-rh="true">
<meta property="og:description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta name="description" 
    content="Let's blink an LED on Pine64 Ox64 BL808 64-bit RISC-V Single-Board Computer... With Nim Programming Language and Apache NuttX Real-Time Operating System">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/nim-ox64.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/nim.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Nim on a Real-Time Operating System: Apache NuttX RTOS + Ox64 BL808 SBC</h1>
    <nav id="TOC"><ul>
<li><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a><ul></ul></li>
<li><a href="#blink-an-led">2 Blink an LED</a><ul></ul></li>
<li><a href="#import-nuttx-functions">3 Import NuttX Functions</a><ul></ul></li>
<li><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a><ul></ul></li>
<li><a href="#nim-blinky-on-ox64">5 Nim Blinky on Ox64</a><ul></ul></li>
<li><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a><ul></ul></li>
<li><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a><ul></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">9 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-ox64">10 Appendix: Build NuttX for Ox64</a><ul></ul></li>
<li><a href="#appendix-opensbi-timer-for-nuttx">11 Appendix: OpenSBI Timer for NuttX</a><ul></ul></li></ul></nav><p>üìù <em>7 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!" /></p>
<p>Happy New Year! 2024 is here and we‚Äôre running <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) on Single-Board Computers with <strong>plenty of RAM</strong>‚Ä¶</p>
<p>Like <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Pine64 Ox64 BL808</strong></a> RISC-V SBC with 64 MB RAM! (Pic below)</p>
<p><em>How will we use the Plentiful RAM?</em></p>
<p>In this article, we create a <strong>Blinky LED</strong> app with a Modern, <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage-Collected</strong></a> Language: <a href="https://nim-lang.org"><strong>Nim Programming Language</strong></a>.</p>
<p>Garbage-Collected Languages (like Nim) require <strong>a bit more RAM</strong> than Low-Level Languages (like C). Perfect for our roomy SBC!</p>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>But we need a RISC-V SBC?</em></p>
<p>No worries! We‚Äôll run Nim + NuttX on the <strong>QEMU Emulator</strong> for 64-bit RISC-V. Which works great on Linux, macOS and Windows machines.</p>
<p>Everything that happens on Ox64 SBC, we‚Äôll see the <strong>exact same thing</strong> in QEMU!</p>
<p><a href="TODO">(Except the <strong>blinkenlight</strong>)</a></p>
<p><em>Hmmm Garbage Collection‚Ä¶ Won‚Äôt it run-pause-run-pause?</em></p>
<p>The fine folks at <a href="https://www.wildernesslabs.co/"><strong>Wilderness Labs</strong></a> are running <a href="https://www.wildernesslabs.co/developers"><strong>.NET on NuttX</strong></a> with Garbage Collection. Maybe it‚Äôs not so bad!</p>
<p>(Also check out <strong>TinyGo</strong> and <strong>MicroPython</strong>)</p>
<p><em>How is Nim different from Rust and Zig?</em></p>
<p>We‚Äôve tested <a href="https://lupyuen.github.io/articles/rusti2c"><strong>Rust</strong></a> and <a href="https://lupyuen.github.io/articles/lvgl4"><strong>Zig</strong></a> with NuttX. <strong>Nim is different</strong> because it‚Ä¶</p>
<ul>
<li>
<p><strong>Compiles to C</strong> (instead of Machine Code)</p>
</li>
<li>
<p>Syntax is <strong>Python-like</strong> (but Statically Compiled)</p>
</li>
<li>
<p>Automatic <strong>Garbage Collection</strong> (no Borrow Checker)</p>
</li>
<li>
<p>And it‚Äôs <strong>Memory Safe</strong> (like Rust)</p>
</li>
</ul>
<p>First we say hello to Nim‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/ox64-solder.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Sorry for my substandard soldering)" /></p>
<h1 id="basic-nim-from-scratch"><a href="#basic-nim-from-scratch">1 Basic Nim from scratch</a></h1>
<p><em>(3 languages in a title heh heh)</em></p>
<p>This is the <strong>simplest Nim Program</strong> (that will run on NuttX): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim.
## Will be called by NuttX, so we export to C.
proc hello_nim() {.exportc, cdecl.} =

  ## Print something
  echo &quot;Hello Nim!&quot;

  ## Force the Garbage Collection
  GC_runOrc()
</code></pre></div>
<p>Which looks a lot like Python!</p>
<p><em>What‚Äôs GC_runOrc?</em></p>
<p>Our Nim Program will be <strong>called by C</strong>. (Remember NuttX?)</p>
<p>And Nim works with <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><strong>Garbage Collection</strong></a>. Thus we call <strong>GC_runOrc</strong> to‚Ä¶</p>
<ul>
<li>
<p>Force the Garbage Collection to complete</p>
</li>
<li>
<p>Clean up all remaining Nim Objects</p>
</li>
<li>
<p>Then return to C and NuttX</p>
</li>
</ul>
<p><em>What if we forget to call GC_runOrc?</em></p>
<p>Erm don‚Äôt! To make it unforgettable, we <strong><code>defer</code></strong> the Garbage Collection: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L65">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Print something
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p><strong><code>defer</code></strong> ensures that the Garbage Collection <strong>will always happen</strong>, as soon as we return from the Main Function.</p>
<p>Now we do something cool and enlightening‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nim-code.jpg" alt="Blink an LED with Nim" /></p>
<h1 id="blink-an-led"><a href="#blink-an-led">2 Blink an LED</a></h1>
<p>This is how we <strong>blink an LED</strong> with Nim on NuttX: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L21-L56">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Blink the LED
proc blink_led() =

  ## Open the LED Driver
  echo &quot;Opening /dev/userleds&quot;
  let fd = c_open(&quot;/dev/userleds&quot;, O_WRONLY)

  ## Check the File Descriptor for errors
  if fd &lt; 0:
    echo &quot;Failed to open /dev/userleds&quot;
    return
</code></pre></div>
<p>First we call the NuttX Function <strong><code>open</code></strong> to access the <strong>LED Driver</strong>.</p>
<p>We might forget to <strong><code>close</code></strong> the LED Driver (in case of errors), so we <strong><code>defer</code></strong> the closing‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## On Return: Close the LED Driver
  defer: c_close(fd)
</code></pre></div>
<p>Next we call the NuttX Function <strong><code>ioctl</code></strong> to flip <strong>LED 0 to On</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn on LED
  echo &quot;Set LED 0 to 1&quot;
  var ret = c_ioctl(fd, ULEDIOC_SETALL, 1)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return
</code></pre></div>
<p><strong>ULEDIOC_SETALL</strong> accepts a Bit Mask of LED States. The value <strong><code>1</code></strong> says LED 0 (Bit 0) will be flipped On. (Other LEDs will be flipped Off)</p>
<p>We <strong>pause a while</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Wait a second (literally)
  ## Because 1 million microseconds = 1 second
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>Finally we flip <strong>LED 0 to Off</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>  ## Turn off LED
  echo &quot;Set LED 0 to 0&quot;
  ret = c_ioctl(fd, ULEDIOC_SETALL, 0)
  if ret &lt; 0:
    echo &quot;ioctl(ULEDIOC_SETALL) failed&quot;
    return

  ## Wait again
  echo &quot;Waiting...&quot;
  c_usleep(1000_000)
</code></pre></div>
<p>In our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L56-L69"><strong>Main Function</strong></a>: We call the above function <strong>20 times</strong> to blink our LED (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Main Function in Nim
proc hello_nim() {.exportc, cdecl.} =

  ## On Return: Force the Garbage Collection
  defer: GC_runOrc()

  ## Blink the LED 20 times
  for loop in 0..19:
    blink_led()
</code></pre></div>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello/hello_main.c#L40-L85">(Looks very similar to the <strong>C Version</strong>)</a></p>
<p>And we‚Äôre almost done! Nim needs to discover our NuttX Functions‚Ä¶</p>
<p>TODO: Blink pic</p>
<h1 id="import-nuttx-functions"><a href="#import-nuttx-functions">3 Import NuttX Functions</a></h1>
<p><em>How will Nim know about open / close / ioctl / usleep?</em></p>
<p>We <strong>import the NuttX Functions</strong> from C into Nim: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L1-L21">hello_nim_async.nim</a></p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Functions from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

proc c_open(filename: cstring, mode: cint): cint {.
  importc: &quot;open&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl.}

proc c_close(fd: cint): cint {.
  importc: &quot;close&quot;,
  header: &quot;&lt;fcntl.h&gt;&quot;,
  nodecl, discardable.}

proc c_ioctl(fd: cint, request: cint): cint {.
  importc: &quot;ioctl&quot;,
  header: &quot;&lt;sys/ioctl.h&gt;&quot;,
  nodecl, varargs.}

proc c_usleep(usec: cuint): cint {.
  importc: &quot;usleep&quot;,
  header: &quot;&lt;unistd.h&gt;&quot;,
  nodecl, discardable.}
</code></pre></div>
<p>(<strong>discardable</strong> tells Nim Compiler that the Return Value is optional)</p>
<p>(<strong>nodecl</strong> means don‚Äôt emit the C Declaration in the Generated Code)</p>
<p>We do the same for <strong>NuttX Macros</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Import NuttX Macros from C.
## Based on https://github.com/nim-lang/Nim/blob/devel/lib/std/syncio.nim

var O_WRONLY {.
  importc: &quot;O_WRONLY&quot;, 
  header: &quot;&lt;fcntl.h&gt;&quot;.}: cint

var ULEDIOC_SETALL {.
  importc: &quot;ULEDIOC_SETALL&quot;, 
  header: &quot;&lt;nuttx/leds/userled.h&gt;&quot;.}: cint
</code></pre></div>
<p>We‚Äôre ready to run this!</p>
<p><img src="https://lupyuen.github.io/images/nim-qemu.png" alt="Nim with Apache NuttX RTOS on QEMU RISC-V (64-bit)" /></p>
<h1 id="run-nim-on-qemu"><a href="#run-nim-on-qemu">4 Run Nim on QEMU</a></h1>
<p><em>How to run Nim Blinky on QEMU Emulator?</em></p>
<p>We begin by <strong>booting NuttX RTOS</strong> on RISC-V QEMU Emulator (64-bit)‚Ä¶</p>
<ol>
<li>
<p>Install <a href="https://www.qemu.org/download/"><strong>QEMU Emulator for RISC-V (64-bit)</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For macOS:
brew install qemu

## For Debian and Ubuntu:
sudo apt install qemu-system-riscv64
</code></pre></div></li>
<li>
<p>Download <strong><code>nuttx</code></strong> from the <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/qemu-1/nuttx"><strong>nuttx: NuttX Image for 64-bit RISC-V QEMU</strong></a></p>
<p>If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.github.io/articles/nim#appendix-build-nuttx-for-qemu"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Start the <strong>QEMU RISC-V Emulator</strong> (64-bit) with NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div></li>
<li>
<p>NuttX is now running in the <strong>QEMU Emulator</strong>! (Pic above)</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L199-L208">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
</li>
<li>
<p>Nim on NuttX blinks our <strong>Simulated LED</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L210-L471">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
</li>
</ol>
<p>Now we step out from the Virtual World into the Real World (like ‚ÄúThe Matrix‚Äù)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nim-wiring.jpg" alt="Connect an LED to Ox64 SBC at GPIO 29, Pin 21" /></p>
<h1 id="nim-blinky-on-ox64"><a href="#nim-blinky-on-ox64">5 Nim Blinky on Ox64</a></h1>
<p><em>Will Nim Blinky run on a real RISC-V SBC?</em></p>
<p>Yep! Connect an LED to Ox64 SBC at <strong>GPIO 29, Pin 21</strong> (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Connect</th><th style="text-align: left">To</th><th style="text-align: left">Wire</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>Ox64 Pin 21</strong> <br><em>(GPIO 29)</em></td><td style="text-align: left"><strong>LED +</strong> <br><em>(Curved Edge)</em></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: left"><strong>LED -</strong> <br><em>(Flat Edge)</em></td><td style="text-align: left"><strong>Resistor</strong></td><td style="text-align: left">Breadboard</td></tr>
<tr><td style="text-align: left"><strong>Resistor</strong></td><td style="text-align: left"><strong>Ox64 Pin 23</strong> <br><em>(GND)</em></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p><a href="https://wiki.pine64.org/wiki/File:Ox64_pinout.png">(See the <strong>Ox64 Pinout</strong>)</a></p>
<p>(Resistor is <strong>47 Ohm</strong>, yellow-purple-black-gold, almost Karma Chameleon)</p>
<p>Follow these steps to <strong>boot NuttX RTOS</strong> on our Ox64 BL808 SBC‚Ä¶</p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<ol>
<li>
<p>Flash <a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot"><strong>OpenSBI and U-Boot Bootloader</strong>)</a> to Ox64</p>
</li>
<li>
<p>Prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a></p>
</li>
<li>
<p>Download <strong><code>Image</code></strong> from the <a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/Image"><strong>Image: NuttX Image for Ox64 BL808 SBC</strong></a></p>
<p>If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.github.io/articles/nim#appendix-build-nuttx-for-ox64"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Copy the <strong><code>Image</code></strong> file and overwrite the <strong><code>Image</code></strong> in the Linux microSD</p>
</li>
<li>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
</li>
<li>
<p>NuttX is now running on our <strong>Ox64 SBC</strong>! (Pic below)</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel...
NuttShell (NSH) NuttX-12.0.3
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96#file-ox64-nuttx-nim-blink-log-L112-L125">(See the <strong>Complete Log</strong>)</a></p>
</li>
<li>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
</li>
<li>
<p>Nim on NuttX <a href="TODO"><strong>blinks our LED</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96#file-ox64-nuttx-nim-blink-log-L129-L395">(See the <strong>Complete Log</strong>)</a></p>
</li>
</ol>
<p>Nim blinks a real LED on a real RISC-V SBC! Let‚Äôs figure out how it works‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/nim-ox64.png" alt="Apache NuttX RTOS on Ox64 BL808 RISC-V SBC: Works great with Nim!" /></p>
<h1 id="inside-nim-on-nuttx"><a href="#inside-nim-on-nuttx">6 Inside Nim on NuttX</a></h1>
<p><em>Nim runs incredibly well on NuttX. How is that possible?</em></p>
<p>That‚Äôs because <strong>Nim compiles to C</strong>. As far as NuttX is concerned‚Ä¶</p>
<p>Nim looks like <strong>another C Program!</strong></p>
<p><em>Whoa! How is Nim compiled to C?</em></p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L37-L41"><strong>NuttX Makefile</strong></a> calls the Nim Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile Nim to C
export TOPDIR=$PWD/nuttx
cd apps/examples/hello_nim
nim c --header hello_nim_async.nim 
</code></pre></div>
<p>Nim Compiler compiles our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/hello_nim_async.nim#L54-L63"><strong>Nim Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-nim"><code>## Nim Program that prints something
proc hello_nim() {.exportc, cdecl.} =
  echo &quot;Hello Nim!&quot;
</code></pre></div>
<p>Into this <a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146"><strong>C Program</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Main Function compiled from Nim to C:
// echo &quot;Hello Nim!&quot;
N_LIB_PRIVATE N_CDECL(void, hello_nim)(void) {
  ...
  // `echo` comes from the Nim System Library
  // https://github.com/nim-lang/Nim/blob/devel/lib/system.nim#L2849-L2902
  echoBinSafe(TM__1vqzGCGyH8jPEpAwiaNwvg_2, 1);
  ...
}

// String &quot;Hello Nim!&quot; compiled from Nim to C
static NIM_CONST tyArray__nHXaesL0DJZHyVS07ARPRA TM__1vqzGCGyH8jPEpAwiaNwvg_2 
  = {{10, (NimStrPayload*)&amp;TM__1vqzGCGyH8jPEpAwiaNwvg_3}};

// Actual String for &quot;Hello Nim!&quot;
static const struct { NI cap; NIM_CHAR data[10+1]; } TM__1vqzGCGyH8jPEpAwiaNwvg_3 
  = { 10 | NIM_STRLIT_FLAG, &quot;Hello Nim!&quot; };
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/4d3f44b58fa88b17ca851decb0419b86#file-mhello_nim_async-nim-c-L130-L146">(From .nimcache/@mhello_nim_async.nim.c)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar">(See the <strong>nimcache</strong>)</a></p>
<p>Yep Nim Compiler has produced a perfectly valid C Program. That will compile with any C Compiler!</p>
<p><em>How will NuttX compile this?</em></p>
<p>Nim Compiler generates the code above into the <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> folder.</p>
<p>Our <a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/examples/hello_nim/Makefile#L31-L35"><strong>NuttX Makefile</strong></a> compiles everything inside <a href="https://github.com/lupyuen/nuttx-nim/releases/download/ox64-1/nimcache.tar"><strong><code>.nimcache</code></strong></a> with the GCC Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Compile everything in the .nimcache folder
NIMPATH = $(shell choosenim show path)
CFLAGS += -I $(NIMPATH)/lib -I ../../.nimcache
CSRCS  += $(wildcard ../../.nimcache/*.c)
</code></pre></div>
<p>And links the Nim Modules (compiled by GCC) into NuttX.</p>
<p><em>So Nim Compiler is aware of NuttX?</em></p>
<p>Yep! Nim Compiler is internally wired to <strong>produce NuttX Code</strong> (that GCC will compile correctly)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/nim-lang/Nim/pull/21372/files"><strong>Nim Support for NuttX</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/blob/nim/config.nims"><strong>Nim Configuration for NuttX: config.nims</strong></a></p>
</li>
</ul>
<p>Kudos to <a href="https://github.com/centurysys"><strong>centurysys</strong></a> and the Nim Community for making this possible!</p>
<p><em>Everything is hunky dory with Nim on NuttX?</em></p>
<p>We made some <strong>Minor Fixes</strong>, we‚Äôll upstream to NuttX shortly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>Here we see the Nim Compiler working perfectly, <a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L55-L185"><strong>compiling our program</strong></a> for NuttX (by parsing the NuttX Build Config)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ export TOPDIR=/workspaces/bookworm/nuttx
$ cd /workspaces/bookworm/apps/examples/hello_nim
$ nim c --header hello_nim_async.nim

read_config: /workspaces/bookworm/nuttx/.config
line=CONFIG_DEBUG_SYMBOLS=y
line=CONFIG_DEBUG_FULLOPT=y
line=CONFIG_ARCH=&quot;risc-v&quot;
@[&quot;keyval=&quot;, &quot;ARCH&quot;, &quot;\&quot;risc-v\&quot;&quot;]
keyval[1]=&quot;risc-v&quot;
line=CONFIG_RAM_SIZE=33554432
* arch:    riscv64
* opt:     oSize
* debug:   true
* ramSize: 33554432
* isSim:   false
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/nim.cfg&#39; [Conf]
Hint: used config file &#39;/home/vscode/.choosenim/toolchains/nim-#devel/config/config.nims&#39; [Conf]
Hint: used config file &#39;/workspaces/bookworm/apps/config.nims&#39; [Conf]
....................................................................................................................................
Hint: mm: orc; opt: size; options: -d:danger
92931 lines; 1.214s; 137.633MiB peakmem; proj: /workspaces/bookworm/apps/examples/hello_nim/hello_nim_async.nim; out: /workspaces/bookworm/apps/.nimcache/hello_nim_async.json [SuccessX]
</code></pre></div>
<p><em>Isn‚Äôt Nim supposed to be Memory Safe?</em></p>
<p>Yeah so far we‚Äôre doing Low-Level Coding with NuttX, and the <strong>Nim Memory Safety</strong> doesn‚Äôt shine through.</p>
<p>Later when we write <strong>LVGL Graphical Apps</strong> in Nim, we‚Äôll appreciate the safety and simplicity of Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/mantielero/lvgl.nim"><strong>Nim Wrapper for LVGL</strong></a></p>
<p><a href="https://github.com/nim-lang/Nim/blob/devel/doc/nimc.md#nim-for-embedded-systems">(More about <strong>Embedded Nim</strong>)</a></p>
<p><a href="https://nim-lang.org/docs/nimc.html">(More about <strong>Nim Compiler</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/nim-gpio.jpg" alt="GPIO 29 in BL808 Reference Manual (Page 119)" /></p>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><em>GPIO 29 in BL808 Reference Manual (Page 119)</em></a></p>
<h1 id="led-driver-for-ox64"><a href="#led-driver-for-ox64">7 LED Driver for Ox64</a></h1>
<p><em>Nim Blinky needs an LED Driver for Ox64‚Ä¶</em></p>
<p><em>What‚Äôs the Quickest Way to create a NuttX LED Driver?</em></p>
<p><strong>U-Boot Bootloader</strong> can help! Power up Ox64 and press Enter a few times to reveal the <strong>U-Boot Command Prompt</strong>.</p>
<p>We enter these <strong>U-Boot Commands</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the GPIO 29 Register at 0x20000938 (gpio_cfg29)
$ md 0x20000938 1
20000938: 00400803                             ..@.

## Set GPIO 29 Output to 1:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
## = 0x1000b40
$ mw 0x20000938 0x1000b40 1

## Dump the GPIO 29 Register to verify
$ md 020000938 1
20000938: 01000b40                             @...

## Set GPIO 29 Output to 0:
## (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
## = 0xb40
$ mw 0x20000938 0xb40 1

## Dump the GPIO 29 Register to verify
$ md 0x20000938 1
20000938: 00000b40                             @...
</code></pre></div>
<p>And our LED (GPIO 29) will <strong>flip On and Off</strong>!</p>
<p>Thus we have verified the <strong>Magic Bits</strong> for flipping our LED‚Ä¶</p>
<ul>
<li>
<p>Write to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
</li>
<li>
<p>Register Value <strong><code>0x100</code> <code>0B40</code></strong> will flip the LED On</p>
</li>
<li>
<p>Register Value <strong><code>0xB40</code></strong> will flip the LED Off</p>
</li>
</ul>
<p><em>How did we figure out the Magic Bits for GPIO 29?</em></p>
<p>From <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> Page 56, ‚ÄúNormal GPIO Output Mode‚Äù‚Ä¶</p>
<ul>
<li>
<p>Set <strong>reg_gpio_29_oe</strong> (Bit 6) to <strong><code>1</code></strong> to enable GPIO Output Mode <br>
= (1 &lt;&lt; 6)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_func_sel</strong> (Bits 8 to 12) to <strong><code>11</code></strong> to enter SWGPIO Mode <br>
= (11 &lt;&lt; 8)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_mode</strong> (Bits 30 to 31) to <strong><code>0</code></strong> to enable Normal Output Function of I/O <br>
= (0 &lt;&lt; 30)</p>
</li>
<li>
<p>Set <strong>reg_gpio_29_pu</strong> (Bit 4) and <strong>reg_gpio_29_pd</strong> (Bit 5) to <strong><code>0</code></strong> to disable Internal Pull-Up and Pull-Down functions <br>
= (0 &lt;&lt; 4)</p>
</li>
<li>
<p>Set the Pin Level (<strong><code>0</code></strong> or <strong><code>1</code></strong>) through <strong>reg_gpio_29_o</strong> (Bit 24) <br>
= Either (0 &lt;&lt; 24) Or (1 &lt;&lt; 24)</p>
</li>
</ul>
<p><a href="https://lupyuen.github.io/images/nim-gpio.jpg">(<strong>GPIO Bits</strong> are listed in the pic above)</a></p>
<p>Which means‚Ä¶</p>
<ul>
<li>
<p><strong>Set GPIO Output to 0</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24) <br>
= <strong><code>0xB40</code></strong></p>
</li>
<li>
<p><strong>Set GPIO Output to 1</strong> <br>
= (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24) <br>
= <strong><code>0x100</code> <code>0B40</code></strong></p>
</li>
</ul>
<p>And we write the above values to <strong>GPIO 29 Register</strong> at <strong><code>0x2000</code> <code>0938</code></strong> (gpio_cfg29)</p>
<p><em>How to flip the GPIO in our LED Driver?</em></p>
<p>We do this in our <strong>NuttX LED Driver</strong>: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_userleds.c#L176-L209">bl808_userleds.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Flip the LEDs On and Off according to the LED Set
// (Bit 0 = LED 0)
void board_userled_all(uint32_t ledset) {

  // For LED 0 to 2...
  for (int i = 0; i &lt; BOARD_LEDS; i++) {

    // Get the desired state of the LED
    const bool val = ((ledset &amp; g_led_setmap[i]) != 0);

    // If this is LED 0...
    if (i == 0) {

      // Flip it On or Off?
      if (val) {

        // Flip LED 0 (GPIO 29) to On:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (1 &lt;&lt; 24)
        // mw 0x20000938 0x1000b40 1
        *(volatile uint32_t *) 0x20000938 = 0x1000b40;
      } else {

        // Flip LED 0 (GPIO 29) to Off:
        // Set gpio_cfg29 to (1 &lt;&lt; 6) | (11 &lt;&lt; 8) | (0 &lt;&lt; 30) | (0 &lt;&lt; 4) | (0 &lt;&lt; 24)
        // mw 0x20000938 0xb40 1
        *(volatile uint32_t *) 0x20000938 = 0xb40;
      }
    }
  }
}
</code></pre></div>
<p>That‚Äôs how we created a barebones LED Driver for Ox64!</p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_autoleds.c">(Remember to add the <strong>Auto-LED Driver</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-60cc096e3a9b22a769602cbbc3b0f5e7731e72db7b0338da04fcf665ed753b64">(And update the <strong>Kconfig</strong>)</a></p>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/boards/risc-v/bl808/ox64/src/bl808_appinit.c#L167-L179">(How NuttX starts our <strong>LED Driver</strong>)</a></p>
<p><em>Ahem it looks a little messy‚Ä¶</em></p>
<p>No Worries! Later we‚Äôll replace the (awful) code above by the <strong>BL808 GPIO Driver</strong>. Which we‚Äôll copy from <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl602/bl602_gpio.c"><strong>NuttX for BL602</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Get the desired state of LED[i]
const bool val = ((ledset &amp; g_led_setmap[i]) != 0);

// Call the BL808 GPIO Driver to flip the LED On or Off
bl808_gpio_write(  // Write to the GPIO Output...
  g_led_map[i],    // GPIO Number for LED[i]
  val              // Flip it On or Off
);
</code></pre></div>
<p><em>Anything else we patched?</em></p>
<p>We fixed the <strong>NuttX Timer</strong> for Ox64 (otherwise we can‚Äôt blink)‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nim#appendix-opensbi-timer-for-nuttx"><strong>‚ÄúOpenSBI Timer for NuttX‚Äù</strong></a></li>
</ul>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/nim.md"><strong>lupyuen.github.io/src/nim.md</strong></a></p>
<h1 id="appendix-build-nuttx-for-qemu"><a href="#appendix-build-nuttx-for-qemu">9 Appendix: Build NuttX for QEMU</a></h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for QEMU RISC-V (64-bit)</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-dd54e0076f30825f912248f2424460e3126c2a8f4e2880709f5c68af9342ddcf"><strong>nsh64/defconfig</strong></a>: NuttX Config for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-5905dc63d5fd592e0a1e25ab25783ae99e54180a7b98fb59f56a73dee79104e6"><strong>qemu_rv_autoleds.c</strong></a>
: Auto LED Driver for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-a6fd389669ddef88302f00a34d401479886cb8983f7be58b32ba075699cb5bb8"><strong>qemu_rv_userleds.c</strong></a>: User LED Driver for QEMU</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-beeaeb03fa5642002a542446c89251c9a7c5c1681cfe915387740ea0975e91b3"><strong>qemu_rv_appinit.c</strong></a>: Start LED Driver</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>First we install <a href="https://nim-lang.org/install_unix.html"><strong>Nim Compiler</strong></a> (only the Latest Dev Version supports NuttX)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install Nim Compiler: https://nim-lang.org/install_unix.html
curl https://nim-lang.org/choosenim/init.sh -sSf | sh

## Add Nim to PATH
export PATH=$HOME/.nimble/bin:$PATH

## Select Latest Dev Version of Nim. Will take a while!
choosenim devel --latest
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim#build-nuttx-with-debian-container-in-vscode">(Nim won‚Äôt install? Try a <strong>Linux Container</strong>)</a></p>
<p>Then we download and build NuttX for <strong>QEMU RISC-V (64-bit)</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for QEMU RISC-V (64-bit)
cd nuttx
tools/configure.sh rv-virt:nsh64

## Build NuttX
make

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/qemu-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>This produces the NuttX ELF Image <strong>nuttx</strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Start the QEMU RISC-V Emulator (64-bit) with NuttX RTOS
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
<p>Nim on NuttX blinks our <strong>Simulated LED</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L210-L471">(See the <strong>Complete Log</strong>)</a></p>
<p>To Exit QEMU: Press <strong><code>Ctrl-A</code></strong> then <strong><code>x</code></strong></p>
<h1 id="appendix-build-nuttx-for-ox64"><a href="#appendix-build-nuttx-for-ox64">10 Appendix: Build NuttX for Ox64</a></h1>
<p>In this article, we ran a Work-In-Progress Version of <strong>Apache NuttX RTOS for Ox64</strong> that has Minor Fixes for Nim‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-fa4b30efe1c5e19ba2fdd2216528406d85fa89bf3d2d0e5161794191c1566078"><strong>nsh/defconfig</strong></a>: NuttX Config for Ox64</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nim#appendix-opensbi-timer-for-nuttx"><strong>bl808_timerisr.c</strong></a>: RISC-V Timer for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-efdf5ed87983905c7021de03a7add73932da529d4312b80f948eb199c256b170"><strong>bl808_autoleds.c</strong></a>: Auto LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nim#led-driver-for-ox64"><strong>bl808_userleds.c</strong></a>: User LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/pull/47/files#diff-902a3cb106dc7153d030370077938ef28c9412d8b3434888fca8bbf1a1cfbd54"><strong>bl808_appinit.c</strong></a>: Start LED Driver for Ox64</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-7fb4194c7b9e7b17a2a650d4182f39fb0e932cc9bb566e9b580d22fa8a7b4307"><strong>Makefile</strong></a>: Nimcache has moved 2 folders up</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx-apps/pull/3/files#diff-be274e89063d9377278fad5fdcdd936e89d2f32efd7eb8eb8a6a83ac4c711879"><strong>config.nims</strong></a>: Add support for 64-bit RISC-V</p>
</li>
</ul>
<p>First we install <a href="https://nim-lang.org/install_unix.html"><strong>Nim Compiler</strong></a> (only the Latest Dev Version supports NuttX)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install Nim Compiler: https://nim-lang.org/install_unix.html
curl https://nim-lang.org/choosenim/init.sh -sSf | sh

## Add Nim to PATH
export PATH=$HOME/.nimble/bin:$PATH

## Select Latest Dev Version of Nim. Will take a while!
choosenim devel --latest
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim#build-nuttx-with-debian-container-in-vscode">(Nim won‚Äôt install? Try a <strong>Linux Container</strong>)</a></p>
<p>Then we download and build NuttX for <strong>Ox64 BL808 SBC</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the WIP NuttX Source Code
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx \
  nuttx
git clone \
  --branch nim \
  https://github.com/lupyuen2/wip-pinephone-nuttx-apps \
  apps

## Configure NuttX for Ox64 BL808 RISC-V SBC
cd nuttx
tools/configure.sh ox64:nsh

## Build NuttX
make

## Export the NuttX Kernel
## to `nuttx.bin`
riscv64-unknown-elf-objcopy \
  -O binary \
  nuttx \
  nuttx.bin

## Dump the disassembly to nuttx.S
riscv64-unknown-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1

## Dump the hello_nim disassembly to hello_nim.S
riscv-none-elf-objdump \
  --syms --source --reloc --demangle --line-numbers --wide \
  --debugging \
  ../apps/bin/hello_nim \
  &gt;hello_nim.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/release#build-nuttx-for-star64">(Remember to install the <strong>Build Prerequisites and Toolchain</strong>)</a></p>
<p>Then we build the <strong>Initial RAM Disk</strong> that contains NuttX Shell and NuttX Apps‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build the Apps Filesystem
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd

## Generate the Initial RAM Disk `initrd`
## in ROMFS Filesystem Format
## from the Apps Filesystem `../apps/bin`
## and label it `NuttXBootVol`
genromfs \
  -f initrd \
  -d ../apps/bin \
  -V &quot;NuttXBootVol&quot;

## Prepare a Padding with 64 KB of zeroes
head -c 65536 /dev/zero &gt;/tmp/nuttx.pad

## Append Padding and Initial RAM Disk to NuttX Kernel
cat nuttx.bin /tmp/nuttx.pad initrd \
  &gt;Image
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Script</strong>)</a></p>
<p><a href="https://gist.github.com/lupyuen/578a7eb2d4d827aa252fff37c172dd18">(See the <strong>Build Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Outputs</strong>)</a></p>
<p>Next we prepare a <strong>Linux microSD</strong> for Ox64 as described <a href="https://lupyuen.github.io/articles/ox64"><strong>in the previous article</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ox64#flash-opensbi-and-u-boot">(Remember to flash <strong>OpenSBI and U-Boot Bootloader</strong>)</a></p>
<p>Then we do the <a href="https://lupyuen.github.io/articles/ox64#apache-nuttx-rtos-for-ox64"><strong>Linux-To-NuttX Switcheroo</strong></a>: Overwrite the microSD Linux Image by the <strong>NuttX Kernel</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Overwrite the Linux Image
## on Ox64 microSD
cp Image \
  &quot;/Volumes/NO NAME/Image&quot;
diskutil unmountDisk /dev/disk2
</code></pre></div>
<p>Insert the <a href="https://lupyuen.github.io/images/ox64-sd.jpg"><strong>microSD into Ox64</strong></a> and power up Ox64.</p>
<p>Ox64 boots <a href="https://lupyuen.github.io/articles/sbi"><strong>OpenSBI</strong></a>, which starts <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>, which starts <strong>NuttX Kernel</strong> and the NuttX Shell (NSH).</p>
<p>At the NuttX Prompt, enter ‚Äú<strong>hello_nim</strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello_nim
Hello Nim!
Opening /dev/userleds

Set LED 0 to 1
board_userled_all: led=0, val=1
Waiting...

Set LED 0 to 0
board_userled_all: led=0, val=0
Waiting...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/09e653cbd227b9cdff7cf3cb0a5e1ffa#file-qemu-nuttx-nim-build-log-L472-L497">(Enter ‚Äú<strong>help</strong>‚Äù to see the available commands)</a></p>
<p>Nim on NuttX <a href="TODO"><strong>blinks our LED</strong></a>.</p>
<p><a href="https://gist.github.com/lupyuen/553c2da4ad5d119468d223e162573e96">(See the <strong>NuttX Log</strong>)</a></p>
<p><a href="https://youtube.com/shorts/KCkiXFxBgxQ">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-nim/releases/tag/ox64-1">(See the <strong>Build Outputs</strong>)</a></p>
<h1 id="appendix-opensbi-timer-for-nuttx"><a href="#appendix-opensbi-timer-for-nuttx">11 Appendix: OpenSBI Timer for NuttX</a></h1>
<p>TODO</p>
<p><em>The <code>sleep</code> command hangs in NuttX Shell. How to fix it?</em></p>
<p>That‚Äôs because we haven‚Äôt implemented the RISC-V Timer for Ox64! We should call OpenSBI to handle the Timer, <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/commit/57ea5f000636f739ac3cb8ea1e60936798f6c3a9#diff-535879ffd6d9fc8e7d84b37a88bdeb1609c4a90e3777150939a96bed18696aee">here‚Äôs the fix</a>.</p>
<p>(Ignore riscv_mtimer.c, we were verifying that mtime and mtimecmp¬†are unused in Kernel Mode)</p>
<p>We only need to change¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L116">arch/risc-v/src/bl808/bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Timer Frequency
#define MTIMER_FREQ 1000000

// This function is called during start-up to initialize the timer interrupt.
void up_timer_initialize(void) {
  struct oneshot_lowerhalf_s *lower = riscv_mtimer_initialize(
    0, 0, RISCV_IRQ_STIMER, MTIMER_FREQ);
  DEBUGASSERT(lower);
  up_alarm_set_lowerhalf(lower);
}
</code></pre></div>
<p>How it works: At startup, <code>up_timer_initialize</code> (above) calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L318-L332">riscv_mtimer_initialize</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/riscv_mtimer.c#L136-L141">riscv_mtimer_set_mtimecmp</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L94-L107">riscv_sbi_set_timer</a> which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/common/supervisor/riscv_sbi.c#L53-L76">sbi_ecall</a> which makes an ecall to OpenSBI</p>
</li>
<li>
<p>Which accesses the System Timer</p>
</li>
</ul>
<p>Originally we set¬†MTIMER_FREQ to 10000000:¬†<a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 10000000
</code></pre></div>
<p>But this causes the command <code>sleep 1</code> to pause for 10 seconds. So we divide the frequency by 10: <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/nim/arch/risc-v/src/bl808/bl808_timerisr.c#L44-L48">bl808_timerisr.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define MTIMER_FREQ 1000000
</code></pre></div>
<p>Now the <code>sleep</code> command works correctly in NuttX Shell!</p>
<p><a href="https://gist.github.com/lupyuen/8aa66e7f88d1e31a5f198958c15e4393">Here‚Äôs the log (ignore the errors)</a></p>

    
</body>
</html>