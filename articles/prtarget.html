<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>GitHub Actions pull_request_target vs Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="GitHub Actions pull_request_target vs Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.org/images/prtarget-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/prtarget" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">GitHub Actions pull_request_target vs Apache NuttX RTOS</h1>
    <nav id="rustdoc"><ul>
<li><a href="#history-of-nuttx" title="History of NuttX">1 History of NuttX</a><ul></ul></li>
<li><a href="#malicious-code-in-pr" title="Malicious Code in PR">2 Malicious Code in PR</a><ul></ul></li>
<li><a href="#safer-checkout" title="Safer Checkout">3 Safer Checkout</a><ul></ul></li>
<li><a href="#safer-github-tokens" title="Safer GitHub Tokens">4 Safer GitHub Tokens</a><ul></ul></li>
<li><a href="#compute-the-pr-labels" title="Compute the PR Labels">5 Compute the PR Labels</a><ul></ul></li>
<li><a href="#upload-the-pr-labels" title="Upload the PR Labels">6 Upload the PR Labels</a><ul></ul></li>
<li><a href="#set-the-pr-labels" title="Set the PR Labels">7 Set the PR Labels</a><ul></ul></li>
<li><a href="#zizmor-security-scanner" title="Zizmor Security Scanner">8 Zizmor Security Scanner</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">9 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-compute-the-arch-labels" title="Appendix: Compute the Arch Labels">10 Appendix: Compute the Arch Labels</a><ul></ul></li>
<li><a href="#appendix-change-the-workflow-trigger" title="Appendix: Change the Workflow Trigger">11 Appendix: Change the Workflow Trigger</a><ul></ul></li></ul></nav><p>üìù <em>1 Mar 2026</em></p>
<p><strong>In GitHub Actions:</strong> This is the typical way that we <a href="https://github.com/actions/labeler?tab=readme-ov-file#using-configuration-path-input-together-with-the-actionscheckout-action"><strong>Label a Pull Request</strong></a>. But it‚Äôs <em>potentially dangerous</em>, guess why: <a href="https://github.com/apache/nuttx/blob/cf30528231a23c7329198bba220e8fcbac98baa2/.github/workflows/labeler.yml">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## When a Pull Request is submitted...
on:
  - pull_request_target
jobs:
  labeler: ...
    steps:
      ## Checkout the repo from the Main Branch
      - uses: actions/checkout@v6

      ## Assign the PR Labels based on the updated Paths
      - uses: actions/labeler@main
        with:
          repo-token:  &quot;${{ secrets.GITHUB_TOKEN }}&quot;

      ## Assign the PR Labels based on the PR Size
      - uses: codelytv/pr-size-labeler@v1.10.3
        with:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</code></pre></div>
<p>In this article we explain why the workflow above is potentially unsafe, and how we fixed it.</p>
<h1 id="history-of-nuttx"><a class="doc-anchor" href="#history-of-nuttx">¬ß</a>1 History of NuttX</h1>
<p><em>How did we discover this problem?</em></p>
<p>We were notified about the <a href="https://github.com/apache/nuttx/issues/18359"><strong>Unsafe pull_request_target</strong></a> during a Security Scan‚Ä¶</p>
<blockquote>
<p><em>‚Äúpull_request_target was found as a workflow trigger ‚Ä¶ If after after 60 days these problems are not addressed, we will turn off builds‚Äù</em></p>
</blockquote>
<p>Bummer we need to pull out <em>pull_request_target</em> real quick‚Ä¶ Or Apache NuttX Project dies in 60 days!</p>
<p><em>How did that unsafe workflow get into NuttX?</em></p>
<p>One Year Ago: We added PR Labeling to quicken <a href="https://lupyuen.org/articles/ci3"><strong>NuttX CI Builds</strong></a>. And the GitHub Workflow above is the recommended way to <a href="https://github.com/actions/labeler?tab=readme-ov-file#using-configuration-path-input-together-with-the-actionscheckout-action"><strong>Label a PR</strong></a>.</p>
<p>Though we missed this <a href="https://github.com/actions/labeler?tab=readme-ov-file#recommended-permissions"><strong>ominous warning</strong></a>‚Ä¶</p>
<blockquote>
<p><em>‚ÄúThere exists a potentially dangerous misuse of the pull_request_target workflow trigger that may lead to malicious PR authors (i.e. attackers) being able to obtain repository write permissions or stealing repository secrets.‚Äù</em></p>
</blockquote>
<blockquote>
<p><em>‚ÄúHence, it is advisable that pull_request_target should only be used in workflows that are carefully designed to avoid executing untrusted code and to also ensure that workflows using pull_request_target limit access to sensitive resources.‚Äù</em></p>
</blockquote>
<p>Huh? Let‚Äôs break it down‚Ä¶</p>
<h1 id="malicious-code-in-pr"><a class="doc-anchor" href="#malicious-code-in-pr">¬ß</a>2 Malicious Code in PR</h1>
<p><em>What could possibly go wrong?</em></p>
<p>Suppose someday, our devs innocently add some <strong>Build Commands</strong> into the PR Workflow above‚Ä¶</p>
<p>(Remember: We‚Äôre Embedded Devs, not Security Experts!)</p>
<div class="example-wrap"><pre class="language-yaml"><code>## Note: This is Unsafe!
## When a Pull Request is submitted...
on:
  - pull_request_target
jobs:
  labeler: ...
    steps:
      ## Risky: Checkout the repo based on the PR
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      ## STOP: Never do this!!!
      - uses: actions/setup-node@v1
      - run: |
          npm run build</code></pre></div>
<p><a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/">(Inspired by this)</a></p>
<p>Yep we have a problem‚Ä¶</p>
<ol>
<li>
<p><em>actions/checkout</em> will checkout our Complete GitHub Repo, applying the changes proposed in the PR. Which might contain <strong>Malicious Code and Scripts</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>## Checkout the repo based on the PR...
## Including any Malicious Code inside the PR!
- uses: actions/checkout@v6
  with:
    ref: ${{ github.event.pull_request.head.sha }}</code></pre></div></li>
<li>
<p>Then this will <strong>Execute the Malicious Code</strong> inside the PR‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>## Run the Malicious Code from the PR. Oops!
- run: |
    npm run build</code></pre></div></li>
<li>
<p>When we <strong>Execute Untrusted Code</strong> (from a PR): There shall be terrible consequences‚Ä¶</p>
<p>Remember <a href="https://www.sysdig.com/blog/massive-cryptomining-operation-github-actions"><strong>GitHub Crypto-Mining</strong></a>?</p>
</li>
<li>
<p>Another problem: <strong>Leaking GitHub Tokens</strong>. We grant <a href="https://github.com/apache/nuttx/blob/cf30528231a23c7329198bba220e8fcbac98baa2/.github/workflows/labeler.yml"><strong>Write Permission</strong></a> to the GitHub Token, because it needs to write the PR Labels into the PR‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>## GITHUB_TOKEN has Write Permission
jobs:
  labeler:
    permissions:
      contents:      read
      pull-requests: write
      issues:        write</code></pre></div>
<p>Which means the Malicious Code could <strong>Steal our Permissive GitHub Token</strong>. And do all kinds of tampering mischief.</p>
</li>
</ol>
<p>There‚Äôs a safer solution‚Ä¶</p>
<h1 id="safer-checkout"><a class="doc-anchor" href="#safer-checkout">¬ß</a>3 Safer Checkout</h1>
<p><em>Do we really need the Entire Repo from the PR?</em></p>
<p>Yeah we should <strong>limit our exposure</strong> to any Malicious Code embedded in the PR.</p>
<p>This is how we checkout <strong>One Single File</strong> from our repo: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## Checkout one file from our trusted source: .github/labeler.yml
## Never checkout and execute any untrusted code from the PR.
name: Checkout labeler config
uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
with:
  repository:  apache/nuttx
  ref:         master
  path:        labeler
  fetch-depth: 1
  persist-credentials: false
  sparse-checkout:     .github/labeler.yml
  sparse-checkout-cone-mode: false</code></pre></div>
<p>Config File <em>.github/labeler.yml</em> contains all the settings needed by <em>actions/labeler</em>. Thus we don‚Äôt actually need the Entire Repo, when we‚Äôre Labeling a PR.</p>
<p><em>Changed Files in the PR: Should we check them out?</em></p>
<p>Nope! Internally, <em>actions/labeler</em> calls GitHub API to fetch the <strong>Filenames of the Changed Files</strong> in the PR: <a href="https://github.com/actions/labeler/blob/main/src/changedFiles.ts#L25-L46">actions/labeler/changedFiles.ts</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// To fetch the Filenames of the Changed Files in the PR...
async function getChangedFiles(...): ... {

  // Call the GitHub REST API: pulls.listFiles
  const listFilesOptions = client.rest.pulls.listFiles.endpoint.merge({
    owner, repo, pull_number
  });
  const listFilesResponse = await client.paginate(listFilesOptions);
  ...
}</code></pre></div>
<p>We‚Äôll call the same GitHub API in a while.</p>
<p><a href="https://github.com/CodelyTV/pr-size-labeler/blob/main/src/github.sh#L4-L54">(<em>pr-size-labeler</em> calls GitHub REST inside Docker)</a></p>
<p><em>But everyone else is checking out the Entire Repo?</em></p>
<p>Yeah we‚Äôre not sure why other folks are following the same Potentially Unsafe Pattern, checking out the Entire Repo from the PR. We see plenty in <a href="https://github.com/search?type=code&amp;q=%22actions%2Flabeler%40v6%22+language%3AYAML&amp;l=YAML"><strong>GitHub Code Search</strong></a>.</p>
<p><em>What exactly is the Safer Way to Label PRs in GitHub Actions?</em></p>
<p>We don‚Äôt have any <strong>Official GitHub Guidance</strong> for Safely Labeling a PR. Let‚Äôs do it our way‚Ä¶</p>
<h1 id="safer-github-tokens"><a class="doc-anchor" href="#safer-github-tokens">¬ß</a>4 Safer GitHub Tokens</h1>
<p><em>We limited our exposure to any Untrusted Code from the PR. What about the Leaky GitHub Tokens?</em></p>
<p>Indeed we still have a problem. <a href="https://infra.apache.org/github-actions-policy.html"><strong>ASF Security Policy</strong></a> says‚Ä¶</p>
<blockquote>
<p><em>‚ÄúYou MUST NOT use pull_request_target as a trigger on ANY action that exports ANY confidential credentials or tokens such as GITHUB_TOKEN or NPM_TOKEN.‚Äù</em></p>
</blockquote>
<p>Hmmm we can‚Äôt possibly prove that <a href="https://github.com/apache/nuttx/blob/cf30528231a23c7329198bba220e8fcbac98baa2/.github/workflows/labeler.yml#L35-L45"><em>pr-size-labeler</em></a> (and other GitHub Actions) will never ever leak our GitHub Tokens someday. Let‚Äôs solve this‚Ä¶</p>
<ol>
<li>
<p><strong>Switch our GitHub Token:</strong> <em>(Unsafe)</em> Read-Write Token becomes <em>(Safer)</em> Read-Only Token. Tampering mischief can‚Äôt happen with a Read-Only Token.</p>
</li>
<li>
<p><strong>Label the PR Ourselves:</strong> Without calling another GitHub Action. No more leaky tokens!</p>
</li>
</ol>
<p><em>Don‚Äôt we need a Read-Write Token to Set the PR Label?</em></p>
<p>Aha we‚Äôll come back to this. First we settle the <strong>Read-Only GitHub Token</strong>: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L21-L45">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## Changed the trigger from &quot;pull_request_target&quot; to &quot;pull_request&quot;
## GitHub Token becomes Read-Only (previously Read-Write)
name: &quot;Pull Request Labeler&quot;
on:
  - pull_request

## Everything becomes Read-Only (previously Read-Write)
jobs:
  labeler:
    permissions:
      contents:      read
      pull-requests: read
      issues:        read

    runs-on: ubuntu-latest
    steps:
      ## Checkout one file from our trusted source: .github/labeler.yml
      ## Never checkout and execute any untrusted code from the PR.
      - name: Checkout labeler config
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          repository:  apache/nuttx
          ref:         master
          path:        labeler
          fetch-depth: 1
          persist-credentials: false
          sparse-checkout:     .github/labeler.yml
          sparse-checkout-cone-mode: false</code></pre></div>
<p>Writing the PR Label becomes interesting‚Ä¶</p>
<h1 id="compute-the-pr-labels"><a class="doc-anchor" href="#compute-the-pr-labels">¬ß</a>5 Compute the PR Labels</h1>
<p><em>Setting the PR Labels: Can we call actions/labeler and pr-size-labeler?</em></p>
<p>Sorry we can‚Äôt! Remember we changed the trigger from (unsafe) <em>pull_request_target</em> to (safer) <em>pull_request</em>?</p>
<ul>
<li>
<p>We just lost <strong>Read-Write Permission</strong> for the PR (due to Read-Only safety)</p>
</li>
<li>
<p>Which means <em>actions/labeler</em> and <em>pr-size-labeler</em> won‚Äôt work <a href="https://lupyuen.org/articles/prtarget#appendix-change-the-workflow-trigger">(explained here)</a></p>
</li>
<li>
<p>Which is OK: We‚Äôre doing the PR Labeling ourselves anyway</p>
</li>
</ul>
<p><em>Changed Files in the PR: How do we find out what changed?</em></p>
<p>Inside our Workflow: We call the GitHub API <a href="https://octokit.github.io/rest.js/v22/#pulls-list-files"><em>pulls.listFiles</em></a>. It returns the <strong>Filenames of the Changed Files</strong>, also the <strong>Number of Lines Changed</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>{ status: &#39;added&#39;,    filename: &#39;arch/arm/test.txt&#39;,              
  additions: 3, deletions: 0,    changes: 3 }
{ status: &#39;removed&#39;,  filename: &#39;Documentation/legacy_README.md&#39;, 
  additions: 0, deletions: 2531, changes: 2531 }
{ status: &#39;modified&#39;, filename: &#39;Documentation/security.rst&#39;,     
  additions: 1, deletions: 0,    changes: 1 }</code></pre></div>
<p>This is how we call the GitHub API inside our <em>pull_request</em> workflow: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L45-L63">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>## Fetch the updated PR filenames. Compute the Size Label and Arch Labels.
- name: Compute PR labels
  uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      const owner = context.repo.owner;
      const repo  = context.repo.repo;
      const pull_number = context.issue.number;

      // Fetch the array of updated PR filenames:
      // { status: &#39;added&#39;,    filename: &#39;arch/arm/test.txt&#39;,              additions: 3, deletions: 0,    changes: 3 }
      // { status: &#39;removed&#39;,  filename: &#39;Documentation/legacy_README.md&#39;, additions: 0, deletions: 2531, changes: 2531 }
      // { status: &#39;modified&#39;, filename: &#39;Documentation/security.rst&#39;,     additions: 1, deletions: 0,    changes: 1 }
      const listFilesOptions = github.rest.pulls.listFiles
        .endpoint.merge({ owner, repo, pull_number });
      const listFilesResponse = await github.paginate(listFilesOptions);</code></pre></div>
<p>We loop through the returned filenames, and total up the <strong>Number of Lines Changed</strong>: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L63-L81">labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>      // Sum up the number of lines changed
      const sizeFiles = listFilesResponse
        .filter(f =&gt; (f.status != &#39;removed&#39;));  // Ignore deleted files
      var linesChanged = 0;
      for (const file of sizeFiles) {
        linesChanged += file.changes;
      }
      console.log({ linesChanged });

      // Compute the Size Label
      const sizeLabel =
        (linesChanged   &lt;=   10) ? &#39;Size: XS&#39;
        : (linesChanged &lt;=  100) ? &#39;Size: S&#39;
        : (linesChanged &lt;=  500) ? &#39;Size: M&#39;
        : (linesChanged &lt;= 1000) ? &#39;Size: L&#39;
        : &#39;Size: XL&#39;;
      var prLabels = [ sizeLabel ];
      console.log({ prLabels });</code></pre></div>
<p>Which becomes the <strong>Size Label</strong> for the PR, like <em>‚ÄúSize: XS‚Äù</em>.</p>
<p>We also have <strong>Arch Labels</strong> for the PR, like <em>‚ÄúArch: risc-v‚Äù</em>. This is how we compute them‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.org/articles/prtarget#appendix-compute-the-arch-labels"><strong>‚ÄúCompute the Arch Labels‚Äù</strong></a></li>
</ul>
<p>Size Label and Arch Labels are all ready. Now we stash the PR Labels safely‚Ä¶</p>
<h1 id="upload-the-pr-labels"><a class="doc-anchor" href="#upload-the-pr-labels">¬ß</a>6 Upload the PR Labels</h1>
<p><em>No Write Permission means we can‚Äôt set the PR Labels. How to save the labels?</em></p>
<p>GitHub offers a safe interim storage for our PR Labels: We save them into a <a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/"><strong>PR Artifact</strong></a> during the Workflow Run.</p>
<p>First we write the <strong>PR Number and PR Labels</strong>: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L134-L147">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>      // Save the PR Number and PR Labels into a PR Artifact
      // e.g. &#39;Size: XS\nArch: avr\n&#39;
      const dir = &#39;pr&#39;;
      fs.mkdirSync(dir);
      fs.writeFileSync(dir + &#39;/pr-id.txt&#39;, pull_number + &#39;\n&#39;);
      fs.writeFileSync(dir + &#39;/pr-labels.txt&#39;, prLabels.join(&#39;\n&#39;) + &#39;\n&#39;);</code></pre></div>
<p>Then we upload them as a <strong>PR Artifact</strong>, that will appear in the Workflow Run: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L141-L147">labeler.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## Upload the PR Artifact as pr.zip
- name: Upload PR artifact
  uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
  with:
    name: pr
    path: pr/</code></pre></div>
<p><a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/">(Recommended by GitHub)</a></p>
<p><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=321719166">(And ASF Security Guidance)</a></p>
<p>Here comes the Second Part of the PR Workflow‚Ä¶</p>
<h1 id="set-the-pr-labels"><a class="doc-anchor" href="#set-the-pr-labels">¬ß</a>7 Set the PR Labels</h1>
<p><a href="https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/"><strong>As Recommended by GitHub</strong></a>: We added a new <em>workflow_run</em> workflow that will wait for <em>pull_request</em> workflow to complete. Then it downloads the <strong>PR Artifact</strong>: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/pr_labeler.yml">.github/workflows/pr_labeler.yml</a></p>
<div class="example-wrap"><pre class="language-yaml"><code>## When the Pull Request Labeler workflow is completed...
name: &quot;Set Pull Request Labels&quot;
on:
  workflow_run:
    workflows: [&quot;Pull Request Labeler&quot;]
    types:
      - completed

## Download the PR Artifact and write the PR Labels.
## Warning: GitHub Token has Write Permission.
## Don&#39;t execute any Untrusted Code!
jobs:
  pr_labeler:
    permissions:
      contents:      read
      pull-requests: write
      issues:        write
    runs-on: ubuntu-latest

    ## When the Pull Request Labeler workflow is completed...
    if: &gt;
      github.event.workflow_run.event == &#39;pull_request&#39; &amp;&amp;
      github.event.workflow_run.conclusion == &#39;success&#39;
    steps:
      ## Download the PR Artifact, containing PR Number and PR Labels
      ## https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/
      - name: Download PR artifact
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }},
            });
            const matchArtifact = artifacts.data.artifacts.filter((artifact) =&gt; {
              return artifact.name == &quot;pr&quot;
            })[0];
            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              artifact_id: matchArtifact.id,
              archive_format: &#39;zip&#39;,
            });
            const fs = require(&#39;fs&#39;);
            fs.writeFileSync(&#39;${{github.workspace}}/pr.zip&#39;, Buffer.from(download.data));

      ## Unzip the PR Artifact
      - name: Unzip PR artifact
        run:  unzip pr.zip</code></pre></div>
<p>The PR Artifact contains <strong>PR Number</strong> and <strong>PR Labels</strong>. This is how we write the PR Labels into the PR: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/pr_labeler.yml#L64-L90">pr_labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>      ## Write the PR Labels into the PR
      - name: Write PR labels
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const fs = require(&#39;fs&#39;);

            // Read the PR Number and PR Labels from the PR Artifact
            // e.g. &#39;Size: XS\nArch: avr\n&#39;
            const issue_number = Number(fs.readFileSync(&#39;pr-id.txt&#39;));
            const labels = fs.readFileSync(&#39;pr-labels.txt&#39;, &#39;utf8&#39;)
              .split(&#39;\n&#39;)              // Split by newline
              .filter(s =&gt; (s != &#39;&#39;));  // Remove empty lines
            console.log({ issue_number, labels });

            // Write the PR Labels into the PR
            // e.g. [ &#39;Size: XS&#39;, &#39;Arch: avr&#39; ]
            await github.rest.issues.setLabels({
              owner,
              repo,
              issue_number,
              labels
            });</code></pre></div><h1 id="zizmor-security-scanner"><a class="doc-anchor" href="#zizmor-security-scanner">¬ß</a>8 Zizmor Security Scanner</h1>
<p>Whenever we modify the <strong>GitHub CI Workflow</strong>, remember to run the <a href="https://docs.zizmor.sh/"><strong>Zizmor Security Scanner</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>brew install zizmor
git clone YOUR_NUTTX_REPO
zizmor nuttx</code></pre></div>
<p>We‚Äôll see‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>INFO audit: zizmor: üåà completed .github/workflows/labeler.yml
No findings to report. Good job! (4 suppressed)

INFO audit: zizmor: üåà completed .github/workflows/pr_labeler.yml
error[dangerous-triggers]: use of fundamentally insecure workflow trigger
  --&gt; .github/workflows/pr_labeler.yml:22:1
   |
22 | / on:
23 | |   workflow_run:
24 | |     workflows: [&quot;Pull Request Labeler&quot;]
25 | |     types:
26 | |       - completed
   | |_________________^ workflow_run is almost always used insecurely
   |
   = note: audit confidence ‚Üí Medium</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/e160cc0a57c72ec95432ee148237c5f0">(See the Zizmor Log)</a></p>
<p>Zizmor Security Scan should not report any Security Issues. However Zizmor flags <em>workflow_run</em> as a Potential Security Issue, because it‚Äôs unable to analyse the code inside the workflow. <em>workflow_run</em> is not forbidden in the <a href="https://infra.apache.org/github-actions-policy.html"><strong>ASF Security Policy</strong></a>.</p>
<p>(Remember: Don‚Äôt use the <em>pull_request_target</em> trigger, it‚Äôs disallowed by the <a href="https://infra.apache.org/github-actions-policy.html"><strong>ASF Security Policy</strong></a>)</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>9 What‚Äôs Next</h1>
<p>Here‚Äôs the completed Pull Request‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/pull/18404"><strong>Reimplement PR Labeling without pull_request_target</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/pull/18422"><strong>Fix the PR Labeling for Build System</strong></a></p>
</li>
<li>
<p>TODO: Sync the PR Labeling Workflow from NuttX Repo to NuttX Apps Repo</p>
</li>
</ul>
<p>Pros and Cons of the new implementation‚Ä¶</p>
<ul>
<li>
<p>New Implementation is Quicker: It‚Äôs faster since we don‚Äôt checkout the entire repo. Also <em>pr-size-labeler</em> actually runs in a Docker Container, we don‚Äôt need that any more.</p>
</li>
<li>
<p>But it might be quirky under Heavy Load. Remember that <em>workflow_run</em> trigger will write the PR Labels as a Second Job? When we run out of GitHub Runners, the PR Labels might never be applied. The Build Logic in <em>arch.yml</em> will execute a Complete NuttX Build if it can‚Äôt find the PR Labels.</p>
</li>
<li>
<p>Will the Build Workflow be triggered too early, before the <em>workflow_run</em> trigger? Hopefully not. The Build Workflow begins in the <em>Fetch-Source</em> stage, checking out the Entire Repo and uploading everything in 1.5 minutes, followed by the <em>Select-Builds</em> stage <em>(arch.yml)</em> reading the PR Labels. Before 1.5 minutes, rightfully our <em>workflow_run</em> trigger would have written the PR Labels to the PR.</p>
</li>
<li>
<p>Based on Actual Logs: New PR Labeling completes in 13 elapsed seconds, spanning 2 jobs. Previously: 24 elapsed seconds, in 1 job.</p>
</li>
</ul>
<hr>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://codeberg.org/lupyuen/lupyuen.org/src/branch/master/src/prtarget.md"><strong>lupyuen.org/src/prtarget.md</strong></a></p>
<h1 id="appendix-compute-the-arch-labels"><a class="doc-anchor" href="#appendix-compute-the-arch-labels">¬ß</a>10 Appendix: Compute the Arch Labels</h1>
<p><em>What‚Äôs an Arch Label?</em></p>
<p>Arch Labeling looks like <code>arch: arm</code>, <code>arch: risc-v</code>, <code>board: arm</code>, <code>area: Build system</code>, ‚Ä¶</p>
<p>One Year Ago: We added PR Labeling to quicken <a href="https://lupyuen.org/articles/ci3"><strong>NuttX CI Builds</strong></a>. Depending on the Arch Label, our CI Workflow <em>(arch.yml)</em> will either build <strong>One Specific Architecture</strong> (like Arm32). Or do a <strong>Complete Build</strong> across All Architectures.</p>
<p>(Size Label isn‚Äôt actually consumed by any of our GitHub Workflows today. We used it for the LLM Bot for PR Review, but we stopped the bot because Gemini upgraded their API and it broke our bot)</p>
<p><em>How to compute the Arch Labels for a NuttX PR?</em></p>
<p>We wrote our own GitHub Script (JavaScript) for doing the Arch Labeling (e.g. <code>arch: risc-v</code>).</p>
<p>Arch Labeling (e.g. <code>arch: risc-v</code>) looks straightforward. We just read the rules from <a href="https://github.com/apache/nuttx/blob/master/.github/labeler.yml"><em>.github/labeler.yml</em></a> and apply them.</p>
<p>Remember to work out all the Test Cases for our new implementation of PR Labeling:</p>
<ul>
<li>Simple PR: Arm32-only, Arm64-only, RISC-V-only, ‚Ä¶</li>
<li>Complex PR: Drivers, Arm32 + Arm64, Arm32 + RISC-V, ‚Ä¶</li>
<li>Doc PR, ‚Ä¶</li>
<li><a href="https://gist.github.com/lupyuen/5748c468315b5ba0567464a5cca69403"><strong>See the Test Cases</strong></a></li>
</ul>
<p>And remember to standby 24 x 7, in case our GitHub Workflow goes haywire and we need to rollback ASAP.</p>
<p>Inside our New PR Labeler: This is how we read the Labeling Rules from <em>.github/labeler.yml</em>: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L81-L134">.github/workflows/labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Parse the Arch Label Patterns in .github/labeler.yml. Condense into:
// &quot;Arch: arm&quot;:
// - any-glob-to-any-file: &#39;arch/arm/**&#39;
// - any-glob-to-any-file: ...
const fs = require(&#39;fs&#39;);
const config = fs.readFileSync(&#39;labeler/.github/labeler.yml&#39;, &#39;utf8&#39;)
  .split(&#39;\n&#39;)             // Split by newline
  .map(s =&gt; s.trim())      // Remove leading and trailing spaces
  .filter(s =&gt; (s != &#39;&#39;))  // Remove empty lines
  .filter(s =&gt; !s.startsWith(&#39;#&#39;))                  // Remove comments
  .filter(s =&gt; !s.startsWith(&#39;- changed-files:&#39;));  // Remove &quot;changed-files&quot;</code></pre></div>
<p>We transform the Glob Pattern to Regex Pattern, for easier Filename Matching: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L93-L118">labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Convert the Arch Label Patterns from config to archLabels.
// archLabels will contain the mappings for Arch Label and Filename Pattern:
// { label: &quot;Arch: arm&quot;,   pattern: &quot;arch/arm/.*&quot;   },
// { label: &quot;Arch: arm64&quot;, pattern: &quot;arch/arm64/.*&quot; }, ...
var archLabels = [];
var label = &quot;&quot;;
for (const c of config) {
  // Get the Arch Label
  if (c.startsWith(&#39;&quot;&#39;)) {    // &quot;Arch: arm&quot;:
    label = c.split(&#39;&quot;&#39;)[1];  // Arch: arm

  } else if (c.startsWith(&#39;- any-glob-to-any-file:&#39;)) {  // - any-glob-to-any-file: &#39;arch/arm/**&#39;
    // Convert the Glob Pattern to Regex Pattern
    const pattern = c.split(&quot;&#39;&quot;)[1]      // arch/arm/**
      .split(&#39;.&#39;).join(&#39;\\.&#39;)            // .  becomes \.
      .split(&#39;*&#39;).join(&#39;[^/]*&#39;)          // *  becomes [^/]*
      .split(&#39;[^/]*[^/]*&#39;).join(&#39;.*&#39;);   // ** becomes .*
    archLabels.push({ 
      label,
      pattern: &#39;^&#39; + pattern + &#39;$&#39;       // Match the Line Start and Line End
    });
  } else {
    // We don&#39;t support all rules of `actions/labeler`
    throw new Error(&#39;.github/labeler.yml should contain only changed-files and any-glob-to-any-file, not: &#39; + c);
  }
}</code></pre></div>
<p>This is how we do Regex Matching on the Changed Filenames: <a href="https://github.com/apache/nuttx/blob/master/.github/workflows/labeler.yml#L118-L134">labeler.yml</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Search the filenames for matching Arch Labels
for (const archLabel of archLabels) {
  if (prLabels.includes(archLabel.label)) {
    break;
  }
  for (const file of listFilesResponse) {
    const re = new RegExp(archLabel.pattern);
    const match = re.test(file.filename);
    if (match &amp;&amp; !prLabels.includes(archLabel.label)) {
      prLabels.push(archLabel.label);
      break;
    }
  }
}
console.log({ prLabels });</code></pre></div>
<p><em>Are we reimplementing EVERYTHING from the Official GitHub Labeler actions/labeler?</em></p>
<p>We won‚Äôt implement the Entire GitHub Labeler <em>actions/labeler</em>, just the bare minimum needed for NuttX. We‚Äôre emulating the Labeler Config <em>.github/labeler.yml</em> as is, because someday GitHub might invent a Secure Way to Label PRs inside <em>pull_request_target</em>. (Then we‚Äôll switch back to the Official GitHub Labeler actions/labeler)</p>
<p>There‚Äôs something really jinxed about the way GitHub designed PR Labeling in <em>pull_request_target</em>, it‚Äôs a terrible security hack. This article is the response to that hack :-)</p>
<h1 id="appendix-change-the-workflow-trigger"><a class="doc-anchor" href="#appendix-change-the-workflow-trigger">¬ß</a>11 Appendix: Change the Workflow Trigger</h1>
<p><em>What happens when we change pull_request_target to pull_request? And nothing else?</em></p>
<p>Nope it doesn‚Äôt work! When we changed the trigger from (unsafe) <em>pull_request_target</em> to (safer) <em>pull_request</em>: <a href="https://github.com/lupyuen7/nuttx/blob/master/.github/workflows/labeler.yml#L17">.github/workflows/labeler.yml</a></p>
<p><img src="https://github.com/user-attachments/assets/05a752cc-5ab3-4436-87a9-b7a11bfc0ba8" alt="Change the trigger from (unsafe) pull_request_target to (safer) pull_request" /></p>
<p>The Labeler Workflow fails, even though our GitHub Token has <em>pull-requests: write</em> and <em>issues: write</em> permissions‚Ä¶</p>
<p><img src="https://github.com/user-attachments/assets/467db5f1-9102-4472-b62d-70414dc5adba" alt="Labeler Workflow fails" /></p>
<p><a href="https://github.com/lupyuen7/nuttx/actions/runs/21809066491/job/62917607595">(See the Log)</a></p>
<p>That‚Äôs because the Labeler Action runs on a PR from a Forked Repo, which requires <em>pull_request_target</em>‚Ä¶</p>
<blockquote>
<p><em>However, when the action runs on a pull request from a forked repository, GitHub only grants read access tokens for <code>pull_request</code> events, at most. If you encounter an <code>Error: HttpError: Resource not accessible by integration</code>, it‚Äôs likely due to these permission constraints.</em></p>
</blockquote>
<blockquote>
<p><em>To resolve this issue, you can modify the <code>on:</code> section of your workflow to use
<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target"><code>pull_request_target</code></a> instead of <code>pull_request</code> ‚Ä¶ This change allows the action to have write access, because <code>pull_request_target</code> alters the <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target">context of the action</a> and safely grants additional permissions.</em></p>
</blockquote>
<p><a href="https://github.com/actions/labeler?tab=readme-ov-file#recommended-permissions">(Source)</a></p>
<p>And <em>pull_request_target</em> has <a href="https://github.com/actions/labeler?tab=readme-ov-file#recommended-permissions"><strong>security concerns</strong></a>‚Ä¶</p>
<blockquote>
<p><em>There exists a potentially dangerous misuse of the <code>pull_request_target</code> workflow trigger that may lead to malicious PR authors (i.e. attackers) being able to obtain repository write permissions or stealing repository secrets.</em></p>
</blockquote>
<blockquote>
<p><em>Hence, it is advisable that <code>pull_request_target</code> should only be used in workflows that are carefully designed to avoid executing untrusted code and to also ensure that workflows using <code>pull_request_target</code> limit access to sensitive resources. Refer to the <a href="https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token">GitHub token permissions documentation</a> for more details about access levels and event contexts.</em></p>
</blockquote>
<p>(Then why would GitHub allow us to run an Unsafe Labeler? Sigh)</p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>