<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on Apache NuttX OS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on Apache NuttX OS" 
    data-rh="true">
<meta property="og:description" 
    content="How we run Rust programs on Apache NuttX OS... And transmit a LoRa Message with Rust"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/rust2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on Apache NuttX OS</h1>
    <nav id="TOC"><ul>
<li><a href="#rust-meets-nuttx">1 Rust Meets NuttX</a><ul></ul></li>
<li><a href="#putting-things-neatly">2 Putting Things Neatly</a><ul></ul></li>
<li><a href="#flipping-gpio">3 Flipping GPIO</a><ul></ul></li>
<li><a href="#import-nuttx-functions">4 Import NuttX Functions</a><ul></ul></li>
<li><a href="#rust-embedded-hal">5 Rust Embedded HAL</a><ul></ul></li>
<li><a href="#spi-transfer">6 SPI Transfer</a><ul></ul></li>
<li><a href="#rust-driver-for-lora-sx1262">7 Rust Driver for LoRa SX1262</a><ul></ul></li>
<li><a href="#transmit-lora-message">8 Transmit LoRa Message</a><ul></ul></li>
<li><a href="#download-source-code">9 Download Source Code</a><ul></ul></li>
<li><a href="#build-the-firmware">10 Build The Firmware</a><ul></ul></li>
<li><a href="#run-the-firmware">11 Run The Firmware</a><ul></ul></li>
<li><a href="#lorawan-support">12 LoRaWAN Support</a><ul></ul></li>
<li><a href="#whats-next">13 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">14 Notes</a><ul></ul></li>
<li><a href="#appendix-rust-embedded-hal-for-nuttx">15 Appendix: Rust Embedded HAL for NuttX</a><ul></ul></li>
<li><a href="#appendix-fix-sx1262-driver-for-nuttx">16 Appendix: Fix SX1262 Driver for NuttX</a><ul></ul></li>
<li><a href="#appendix-rust-build-script-for-nuttx">17 Appendix: Rust Build Script for NuttX</a><ul></ul></li>
<li><a href="#appendix-build-flash-and-run-nuttx">18 Appendix: Build, Flash and Run NuttX</a><ul></ul></li></ul></nav><p>üìù <em>16 Jan 2022</em></p>
<p><img src="https://lupyuen.github.io/images/rust2-title.jpg" alt="PineDio Stack BL604 RISC-V Board" /></p>
<p><a href="https://lupyuen.github.io/articles/nuttx"><strong>Apache NuttX</strong></a> is an embedded operating system that‚Äôs portable across <strong>many platforms</strong> (8-bit to 64-bit) and works like a <strong>tiny version of Linux</strong> (because it‚Äôs POSIX Compliant).</p>
<p><em>Can we create (safer) Embedded Apps with <strong>Rust on NuttX</strong>?</em></p>
<p><em>Can we take a Device Driver from <a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates"><strong>Rust Embedded</strong></a>‚Ä¶ And run it on NuttX?</em></p>
<p>Today we shall‚Ä¶</p>
<ol>
<li>
<p>Build and run <strong>Rust programs</strong> on NuttX</p>
</li>
<li>
<p>Access <strong>GPIO and SPI ports</strong> with Rust Embedded HAL</p>
</li>
<li>
<p>Run the <strong>Semtech SX1262 LoRa Driver</strong> from Rust Embedded</p>
</li>
<li>
<p>And transmit a <strong>LoRa Message</strong> over the airwaves with Rust on NuttX!</p>
</li>
</ol>
<p>We tested Rust on NuttX with <a href="https://lupyuen.github.io/articles/pinedio"><strong>PineDio Stack BL604</strong></a> RISC-V Board (pic above) and its onboard Semtech SX1262 Transceiver.</p>
<p>But it should work on ESP32, Arm and other NuttX platforms. (With some tweaking)</p>
<p><strong>Caution:</strong> Work in Progress! Some spots are rough and rocky, I‚Äôm hoping the NuttX and Rust Communities could help to fill in the potholes before release üôè</p>
<p><img src="https://lupyuen.github.io/images/rust2-run.png" alt="Rust running on NuttX" /></p>
<h1 id="rust-meets-nuttx" class="section-header"><a href="#rust-meets-nuttx">1 Rust Meets NuttX</a></h1>
<p>This is the <strong>simplest Rust program</strong> that will run on NuttX and print <em>‚ÄúHello World‚Äù</em>: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L27-L59">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#![<span class="ident">no_std</span>]</span>  <span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems</span>

<span class="attribute">#[<span class="ident">no_mangle</span>]</span>  <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">rust_main</span>() {  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by NuttX</span>

  <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {  <span class="comment">//  Import C Function</span>
    <span class="doccomment">/// Print a message to the serial console (from C stdio library)</span>
    <span class="kw">fn</span> <span class="ident">puts</span>(<span class="ident">s</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) -&gt; <span class="ident">i32</span>;
  }

  <span class="kw">unsafe</span> {  <span class="comment">//  Mark as unsafe because we are calling C</span>
    <span class="comment">//  Print a message to the serial console</span>
    <span class="ident">puts</span>(
      <span class="string">b&quot;Hello World!\0&quot;</span>  <span class="comment">//  Byte String terminated with null</span>
        .<span class="ident">as_ptr</span>()      <span class="comment">//  Convert to pointer</span>
    );
  }
}</code></pre></div>
<p>Let‚Äôs break it down from the top‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library,</span>
<span class="comment">//  which is not compatible with embedded systems</span>
<span class="attribute">#![<span class="ident">no_std</span>]</span></code></pre></div>
<p>We select the <strong>Rust Core Library</strong> (for embedded platforms), which is a subset of the Rust Standard Library (for desktops and servers).</p>
<p>Next we declare the <strong>Rust Function</strong> that will be called by NuttX‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Don&#39;t mangle the function name</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>
<span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by NuttX</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">rust_main</span>() {</code></pre></div>
<p>(Why is it named <strong>‚Äúrust_main‚Äù</strong>? We‚Äôll find out in a while)</p>
<p>NuttX provides the <strong>‚Äúputs‚Äù</strong> function because it‚Äôs POSIX Compliant (like Linux), so we import it from C‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Import C Function</span>
  <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="doccomment">/// Print a message to the serial console (from C stdio library)</span>
    <span class="kw">fn</span> <span class="ident">puts</span>(<span class="ident">s</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>) -&gt; <span class="ident">i32</span>;
  }</code></pre></div>
<p>This declares that <strong>‚Äúputs‚Äù</strong>‚Ä¶</p>
<ul>
<li>
<p>Accepts a ‚Äú<code>*const u8</code>‚Äù pointer</p>
<p>(Equivalent to ‚Äú<code>const uint8_t *</code>‚Äù in C)</p>
</li>
<li>
<p>Returns an ‚Äú<code>i32</code>‚Äù result</p>
<p>(Equivalent to ‚Äú<code>int32_t</code>‚Äù in C)</p>
</li>
</ul>
<p>We call <strong>‚Äúputs‚Äù</strong> like so‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Mark as unsafe because we are calling C</span>
  <span class="kw">unsafe</span> {
    <span class="comment">//  Print a message to the serial console</span>
    <span class="ident">puts</span>(
      <span class="string">b&quot;Hello World!\0&quot;</span>  <span class="comment">//  Byte String terminated with null</span>
        .<span class="ident">as_ptr</span>()        <span class="comment">//  Convert to pointer</span>
    );
  }</code></pre></div>
<p>Passing a string from Rust to C looks rather cumbersome‚Ä¶</p>
<ul>
<li>
<p>Calls to C Functions must be marked as <strong>‚Äú<code>unsafe</code>‚Äù</strong></p>
</li>
<li>
<p>We construct a <strong>Byte String</strong> in Rust with the <code>b&quot;...&quot;</code> syntax</p>
</li>
<li>
<p>Rust Strings are not null-terminated! We add the <strong>Null Byte</strong> ourselves with ‚Äú<code>\0</code>‚Äù</p>
</li>
<li>
<p>We call <strong>‚Äú<code>.as_ptr()</code>‚Äù</strong> to convert the Byte String to a pointer</p>
</li>
</ul>
<p>Though it looks messy, the Rust code above runs perfectly fine from the <strong>NuttX Shell</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; rust_test

Hello World!</code></pre></div>
<p>We‚Äôll make it neater in the next chapter.</p>
<p><em>Is there anything we missed?</em></p>
<p>We need to define a <strong>Panic Handler</strong> that will be called when a Runtime Error or Assertion Failure occurs.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L218-L243">(Our Panic Handler is defined here)</a></p>
<h1 id="putting-things-neatly" class="section-header"><a href="#putting-things-neatly">2 Putting Things Neatly</a></h1>
<p><em>Do we really need the cumbersome syntax for <strong>‚Äúputs‚Äù</strong> when we print things?</em></p>
<p>We can do better! Let‚Äôs wrap this cumbersome code‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Mark as unsafe because we are calling C</span>
<span class="kw">unsafe</span> {
  <span class="comment">//  Print a message to the serial console</span>
  <span class="ident">puts</span>(
    <span class="string">b&quot;Hello World!\0&quot;</span>  <span class="comment">//  Byte String terminated with null</span>
      .<span class="ident">as_ptr</span>()        <span class="comment">//  Convert to pointer</span>
  );
}</code></pre></div>
<p>‚Ä¶with a <strong>Rust Macro</strong>. And we‚Äôll get this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Print a message to the serial console</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</code></pre></div>
<p>Much neater! We‚Äôll see later that <strong>‚Äúprintln!‚Äù</strong> supports Formatted Output too.</p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/macros.rs">(<strong>println!</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L175-L216">(<strong>puts</strong> is wrapped here)</a></p>
<p><em>Why is our Rust Function named <strong>rust_main</strong> instead of <strong>main</strong>?</em></p>
<p>Our Rust code (<strong>rust_main</strong>) is compiled into a <strong>Static Library</strong> that will be linked into the NuttX Firmware.</p>
<p>Our NuttX Firmware contains a NuttX App (<strong>rust_test</strong>) that calls <strong>rust_main</strong> from C: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust_test_main.c#L28-L37">rust_test_main.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Rust Function defined in rust/src/lib.rs
void rust_main(void);

//  Our Main Function in C...
int main(int argc, FAR char *argv[]) {
  //  Calls the Rust Function
  rust_main();
  return 0;
}</code></pre></div>
<p>Thus it‚Äôs indeed possible to call Rust from C‚Ä¶ And C from Rust!</p>
<p>(More about the Rust build script in the Appendix)</p>
<p><img src="https://lupyuen.github.io/images/rust2-gpio.png" alt="Rust opening GPIO Ports on NuttX" /></p>
<h1 id="flipping-gpio" class="section-header"><a href="#flipping-gpio">3 Flipping GPIO</a></h1>
<p>Since we can call NuttX Functions from Rust, let‚Äôs <strong>flip a GPIO High and Low</strong> the POSIX way: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L61-L136">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Open GPIO Output</span>
<span class="kw">let</span> <span class="ident">cs</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">open</span>(<span class="string">b&quot;/dev/gpio1\0&quot;</span>.<span class="ident">as_ptr</span>(), <span class="ident">O_RDWR</span>) 
};
<span class="macro">assert!</span>(<span class="ident">cs</span> <span class="op">&gt;</span> <span class="number">0</span>);</code></pre></div>
<p>We open the GPIO Output at <strong>‚Äú/dev/gpio1‚Äù</strong> with read / write access.</p>
<p>Then we call <strong>ioctl</strong> to set the <strong>GPIO Output to Low</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Set GPIO Output to Low</span>
<span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
  <span class="ident">ioctl</span>(<span class="ident">cs</span>, <span class="ident">GPIOC_WRITE</span>, <span class="number">0</span>) 
};
<span class="macro">assert!</span>(<span class="ident">ret</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);</code></pre></div>
<p>We sleep for 1 second‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Sleep 1 second</span>
<span class="kw">unsafe</span> { 
  <span class="ident">sleep</span>(<span class="number">1</span>); 
}</code></pre></div>
<p>We set the <strong>GPIO Output to High</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Set GPIO Output to High</span>
<span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">unsafe</span> { 
  <span class="ident">ioctl</span>(<span class="ident">cs</span>, <span class="ident">GPIOC_WRITE</span>, <span class="number">1</span>) 
};
<span class="macro">assert!</span>(<span class="ident">ret</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);</code></pre></div>
<p>Finally we <strong>close the GPIO Output</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Close the GPIO Output</span>
<span class="kw">unsafe</span> {
  <span class="ident">close</span>(<span class="ident">cs</span>);
}</code></pre></div>
<p>This code works OK for <strong>blinking an LED</strong> on a GPIO pin, but we‚Äôll do something more ambitious‚Ä¶ Transfer data over SPI!</p>
<p><em>Won‚Äôt this code get really messy when we do lots of GPIO and SPI?</em></p>
<p>Yep it might get terribly messy! <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L61-L136">(Like this)</a></p>
<p>In a while we‚Äôll mop this up with <strong>Rust Embedded HAL</strong>.</p>
<h1 id="import-nuttx-functions" class="section-header"><a href="#import-nuttx-functions">4 Import NuttX Functions</a></h1>
<p><em>How did we import the NuttX Functions: open, ioctl, sleep, close, ‚Ä¶?</em></p>
<p>We <strong>imported the NuttX Functions</strong> like so: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L248-L257">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {  <span class="comment">//  Import NuttX Functions. TODO: Import with bindgen</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">open</span>(<span class="ident">path</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>, <span class="ident">oflag</span>: <span class="ident">i32</span>, ...) -&gt; <span class="ident">i32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">read</span>(<span class="ident">fd</span>: <span class="ident">i32</span>, <span class="ident">buf</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">count</span>: <span class="ident">u32</span>) -&gt; <span class="ident">i32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">write</span>(<span class="ident">fd</span>: <span class="ident">i32</span>, <span class="ident">buf</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>, <span class="ident">count</span>: <span class="ident">u32</span>) -&gt; <span class="ident">i32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">close</span>(<span class="ident">fd</span>: <span class="ident">i32</span>) -&gt; <span class="ident">i32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">ioctl</span>(<span class="ident">fd</span>: <span class="ident">i32</span>, <span class="ident">request</span>: <span class="ident">i32</span>, ...) -&gt; <span class="ident">i32</span>;  <span class="comment">//  On NuttX: request is i32, not u64 like Linux</span>
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">sleep</span>(<span class="ident">secs</span>: <span class="ident">u32</span>) -&gt; <span class="ident">u32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">usleep</span>(<span class="ident">usec</span>: <span class="ident">u32</span>) -&gt; <span class="ident">u32</span>;
  <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">exit</span>(<span class="ident">status</span>: <span class="ident">u32</span>) -&gt; <span class="op">!</span>;  <span class="comment">//  Does not return</span>
}</code></pre></div>
<p>We (very carefully) <strong>imported the NuttX Constants</strong> as well: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L259-L277">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Import NuttX Constants. TODO: Import with bindgen from https://github.com/lupyuen/incubator-nuttx/blob/rust/include/nuttx/ioexpander/gpio.h</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">GPIOC_WRITE</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="ident">_GPIOBASE</span> <span class="op">|</span> <span class="number">1</span>;  <span class="comment">//  _GPIOC(1)</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">GPIOC_READ</span>:  <span class="ident">i32</span> <span class="op">=</span> <span class="ident">_GPIOBASE</span> <span class="op">|</span> <span class="number">2</span>;  <span class="comment">//  _GPIOC(2)</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">_GPIOBASE</span>:   <span class="ident">i32</span> <span class="op">=</span> <span class="number">0x2300</span>;         <span class="comment">//  GPIO driver commands</span>
<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">O_RDWR</span>:      <span class="ident">i32</span> <span class="op">=</span> <span class="ident">O_RDOK</span><span class="op">|</span><span class="ident">O_WROK</span>;  <span class="comment">//  Open for both read &amp; write access</span></code></pre></div>
<p><a href="https://rust-lang.github.io/rust-bindgen/">(Someday we should auto-generate the Rust Bindings for NuttX with the <strong>bindgen</strong> tool)</a></p>
<p><img src="https://lupyuen.github.io/images/rust2-hal.png" alt="Rust Embedded HAL" /></p>
<h1 id="rust-embedded-hal" class="section-header"><a href="#rust-embedded-hal">5 Rust Embedded HAL</a></h1>
<p><em>What is Rust Embedded HAL?</em></p>
<p><strong>Rust Embedded HAL</strong> (Hardware Abstraction Layer) defines a standard interface that‚Äôs used by <strong>Rust Embedded Device Drivers</strong> to access the hardware: GPIO, SPI, I2C, ‚Ä¶</p>
<p><a href="https://github.com/rust-embedded/awesome-embedded-rust#driver-crates">(Check out the Rust Embedded Drivers here)</a></p>
<p><em>What if we implement Rust Embedded HAL for NuttX: GPIO, SPI, I2C, ‚Ä¶?</em></p>
<p>That would be super interesting‚Ä¶ It means that we can pick <strong>any Rust Embedded Driver</strong> and run it on NuttX! (Theoretically)</p>
<p>In a while we‚Äôll test the <strong>Semtech SX1262 LoRa Driver</strong> from Rust Embedded, and see if it works on NuttX!</p>
<p><em>How do we call Rust Embedded HAL from NuttX?</em></p>
<p>We have created a barebones <strong>Rust Embedded HAL for NuttX</strong>.</p>
<p>(More details in the Appendix)</p>
<p>To call it, we import the <strong>NuttX HAL Module (nuttx_hal)</strong> and <strong>Rust Embedded Library</strong> like so: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L7-L25">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Import NuttX HAL Module</span>
<span class="kw">mod</span> <span class="ident">nuttx_hal</span>;

<span class="comment">//  Import Libraries</span>
<span class="kw">use</span> <span class="ident">embedded_hal</span>::{       <span class="comment">//  Rust Embedded HAL</span>
  <span class="ident">digital::v2::OutputPin</span>, <span class="comment">//  GPIO Output</span>
  <span class="ident">blocking</span>::{             <span class="comment">//  Blocking I/O</span>
    <span class="ident">delay::DelayMs</span>,       <span class="comment">//  Delay Interface</span>
    <span class="ident">spi::Transfer</span>,        <span class="comment">//  SPI Transfer</span>
  },
};</code></pre></div>
<p>(NuttX HAL Module lives in its own source file <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/nuttx_hal.rs">nuttx_hal.rs</a>)</p>
<p>To open GPIO Output <strong>‚Äú/dev/gpio1‚Äù</strong> we do this: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L138-L173">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Open GPIO Output</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cs</span> <span class="op">=</span> <span class="ident">nuttx_hal::OutputPin</span>
  <span class="ident">::new</span>(<span class="string">&quot;/dev/gpio1&quot;</span>);</code></pre></div>
<p>(Looks cleaner now!)</p>
<p>We declare it as <strong>‚Äú<code>mut</code>‚Äù</strong> (mutable) because we expect its Internal State to change as we flip the GPIO.</p>
<p>Next we fetch the <strong>Delay Interface</strong> that we‚Äôll use to sleep‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Get a Delay Interface</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">delay</span> <span class="op">=</span> <span class="ident">nuttx_hal::Delay</span>
  <span class="ident">::new</span>();</code></pre></div>
<p>Then we set the <strong>GPIO Output to Low</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Set GPIO Output to Low</span>
<span class="ident">cs</span>.<span class="ident">set_low</span>()
  .<span class="ident">expect</span>(<span class="string">&quot;cs failed&quot;</span>);</code></pre></div>
<p>(‚Äúexpect‚Äù works like an Assertion Check)</p>
<p>We sleep for 1 second‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Wait 1 second (1,000 milliseconds)</span>
<span class="ident">delay</span>.<span class="ident">delay_ms</span>(<span class="number">1000</span>);</code></pre></div>
<p>Finally we set the <strong>GPIO Output to High</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">//  Set GPIO Output to High</span>
<span class="ident">cs</span>.<span class="ident">set_high</span>()
  .<span class="ident">expect</span>(<span class="string">&quot;cs failed&quot;</span>);</code></pre></div>
<p>Rust Embedded HAL makes GPIO programming more fun! Let‚Äôs do SPI now.</p>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio1.jpg" alt="Inside PineDio Stack BL604" /></p>
<h1 id="spi-transfer" class="section-header"><a href="#spi-transfer">6 SPI Transfer</a></h1>
<p>Let‚Äôs test SPI Data Transfer to the <a href="https://www.semtech.com/products/wireless-rf/lora-core/sx1262"><strong>Semtech SX1262 LoRa Transceiver</strong></a>.</p>
<p>For PineDio Stack BL604 with its onboard SX1262 (pic above), we control <strong>SPI Chip Select</strong> ourselves via GPIO Output (‚Äú/dev/gpio1‚Äù).</p>
<p>We begin by opening the <strong>GPIO Output</strong> for SPI Chip Select: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs#L138-L173">lib.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Test the NuttX Embedded HAL by reading SX1262 Register 8</span>
<span class="kw">fn</span> <span class="ident">test_hal</span>() {

  <span class="comment">//  Open GPIO Output for SX1262 Chip Select</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cs</span> <span class="op">=</span> <span class="ident">nuttx_hal::OutputPin</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/gpio1&quot;</span>);</code></pre></div>
<p>Next we open the <strong>SPI Bus</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Open SPI Bus for SX1262</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">spi</span> <span class="op">=</span> <span class="ident">nuttx_hal::Spi</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/spitest0&quot;</span>);</code></pre></div>
<p><strong>‚Äú/dev/spitest0‚Äù</strong> is the <strong>SPI Test Driver</strong> that we have installed to simplify SPI programming. <a href="https://lupyuen.github.io/articles/spi2">(See this)</a></p>
<p>Before talking to SX1262, we set the <strong>Chip Select to Low</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Set SX1262 Chip Select to Low</span>
  <span class="ident">cs</span>.<span class="ident">set_low</span>()
    .<span class="ident">expect</span>(<span class="string">&quot;cs failed&quot;</span>);</code></pre></div>
<p>We transfer <strong>5 bytes of data</strong> to SX1262 over SPI‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Transfer command to SX1262: Read Register 8</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: [ <span class="ident">u8</span>; <span class="number">5</span> ] <span class="op">=</span> [ <span class="number">0x1d</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span> ];
  <span class="ident">spi</span>.<span class="ident">transfer</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;spi failed&quot;</span>);</code></pre></div>
<p>The transmitted data is the <strong>SX1262 Command</strong> that will read <strong>SX1262 Register 8</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>1D 00 08 00 00</code></pre></div>
<p>The value of SX1262 Register 8 is returned as the <strong>last byte</strong> of the SPI Response‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="macro">println!</span>(<span class="string">&quot;test_hal: SX1262 Register 8 is 0x{:02x}&quot;</span>, <span class="ident">data</span>[<span class="number">4</span>]);</code></pre></div>
<p>We set <strong>Chip Select to High</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">//  Set SX1262 Chip Select to High</span>
  <span class="ident">cs</span>.<span class="ident">set_high</span>()
    .<span class="ident">expect</span>(<span class="string">&quot;cs failed&quot;</span>);</code></pre></div>
<p>And we‚Äôre done! Running this Rust code on NuttX shows‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; rust_test
...
test_hal: SX1262 Register 8 is 0x80</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/412cc8bef51c40236767e10693c738b5">(See the Output Log)</a></p>
<p>That‚Äôs the correct value of SX1262 Register 8: <code>0x80</code>!</p>
<p>(We‚Äôll talk about building and flashing the NuttX Firmware in a while)</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal2.png" alt="Calling the Rust Driver for LoRa SX1262" /></p>
<h1 id="rust-driver-for-lora-sx1262" class="section-header"><a href="#rust-driver-for-lora-sx1262">7 Rust Driver for LoRa SX1262</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/sx1262.rs#L25-L113">sx1262.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Test the SX1262 Driver by reading a register and sending a LoRa message.</span>
<span class="doccomment">/// Based on https://github.com/tweedegolf/sx126x-rs/blob/master/examples/stm32f103-ping-pong.rs</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">test_sx1262</span>() {

  <span class="comment">//  Open GPIO Input for SX1262 Busy Pin</span>
  <span class="kw">let</span> <span class="ident">lora_busy</span> <span class="op">=</span> <span class="ident">nuttx_hal::InputPin</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/gpio0&quot;</span>);

  <span class="comment">//  Open GPIO Output for SX1262 Chip Select</span>
  <span class="kw">let</span> <span class="ident">lora_nss</span> <span class="op">=</span> <span class="ident">nuttx_hal::OutputPin</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/gpio1&quot;</span>);

  <span class="comment">//  Open GPIO Interrupt for SX1262 DIO1 Pin</span>
  <span class="kw">let</span> <span class="ident">lora_dio1</span> <span class="op">=</span> <span class="ident">nuttx_hal::InterruptPin</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/gpio2&quot;</span>);

  <span class="comment">//  TODO: Open GPIO Output for SX1262 NRESET Pin</span>
  <span class="kw">let</span> <span class="ident">lora_nreset</span> <span class="op">=</span> <span class="ident">nuttx_hal::UnusedPin</span>
    <span class="ident">::new</span>();

  <span class="comment">//  TODO: Open GPIO Output for SX1262 Antenna Pin</span>
  <span class="kw">let</span> <span class="ident">lora_ant</span> <span class="op">=</span> <span class="ident">nuttx_hal::UnusedPin</span>
    <span class="ident">::new</span>();

  <span class="comment">//  Open SPI Bus for SX1262</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">spi1</span> <span class="op">=</span> <span class="ident">nuttx_hal::Spi</span>
    <span class="ident">::new</span>(<span class="string">&quot;/dev/spitest0&quot;</span>);

  <span class="comment">//  Define the SX1262 Pins</span>
  <span class="kw">let</span> <span class="ident">lora_pins</span> <span class="op">=</span> (
    <span class="ident">lora_nss</span>,    <span class="comment">// /dev/gpio1</span>
    <span class="ident">lora_nreset</span>, <span class="comment">// TODO</span>
    <span class="ident">lora_busy</span>,   <span class="comment">// /dev/gpio0</span>
    <span class="ident">lora_ant</span>,    <span class="comment">// TODO</span>
    <span class="ident">lora_dio1</span>,   <span class="comment">// /dev/gpio2</span>
  );

  <span class="comment">//  Init a busy-waiting delay</span>
  <span class="kw">let</span> <span class="ident">delay</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">nuttx_hal::Delay::new</span>();

  <span class="comment">//  Init LoRa modem</span>
  <span class="macro">println!</span>(<span class="string">&quot;Init modem...&quot;</span>);
  <span class="kw">let</span> <span class="ident">conf</span> <span class="op">=</span> <span class="ident">build_config</span>();
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lora</span> <span class="op">=</span> <span class="ident">SX126x::new</span>(<span class="ident">lora_pins</span>);
  <span class="ident">lora</span>.<span class="ident">init</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="ident">conf</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;sx1262 init failed&quot;</span>);

  <span class="comment">//  Read SX1262 Register 8</span>
  <span class="macro">println!</span>(<span class="string">&quot;Reading Register 8...&quot;</span>);
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span>: [ <span class="ident">u8</span>; <span class="number">1</span> ] <span class="op">=</span> [ <span class="number">0</span>; <span class="number">1</span> ];
  <span class="ident">lora</span>.<span class="ident">read_register</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="number">8</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">result</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;sx1262 read register failed&quot;</span>);

  <span class="comment">//  Show the register value</span>
  <span class="macro">println!</span>(<span class="string">&quot;test_sx1262: SX1262 Register 8 is 0x{:02x}&quot;</span>, <span class="ident">result</span>[<span class="number">0</span>]);</code></pre></div>
<p>TODO: Output</p>
<div class="example-wrap"><pre class="language-text"><code>test_sx1262: SX1262 Register 8 is 0x80</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/412cc8bef51c40236767e10693c738b5">(See the Output Log)</a></p>
<p><img src="https://lupyuen.github.io/images/rust2-transmit2.png" alt="Transmit LoRa Message" /></p>
<h1 id="transmit-lora-message" class="section-header"><a href="#transmit-lora-message">8 Transmit LoRa Message</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/sx1262.rs#L25-L113">sx1262.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// TODO: Change this to your LoRa Frequency</span>
<span class="comment">//  const RF_FREQUENCY: u32 = 868_000_000;  //  868 MHz (EU)</span>
<span class="comment">//  const RF_FREQUENCY: u32 = 915_000_000;  //  915 MHz (US)</span>
<span class="kw">const</span> <span class="ident">RF_FREQUENCY</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">923_000_000</span>;  <span class="comment">//  923 MHz (Asia)</span>

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">test_sx1262</span>() {
  ...
  <span class="comment">//  Write SX1262 Registers to prepare for transmitting LoRa message.</span>
  <span class="comment">//  Based on https://gist.github.com/lupyuen/5fdede131ad0e327478994872f190668</span>
  <span class="macro">println!</span>(<span class="string">&quot;Writing Registers...&quot;</span>);

  <span class="comment">//  Write Register 0x889: 0x04 (TxModulation)</span>
  <span class="ident">lora</span>.<span class="ident">write_register</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="ident">Register::TxModulaton</span>, <span class="kw-2">&amp;</span>[<span class="number">0x04</span>])
    .<span class="ident">expect</span>(<span class="string">&quot;write register failed&quot;</span>);

  <span class="comment">//  Write Register 0x8D8: 0xFE (TxClampConfig)</span>
  <span class="ident">lora</span>.<span class="ident">write_register</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="ident">Register::TxClampConfig</span>, <span class="kw-2">&amp;</span>[<span class="number">0xFE</span>])
    .<span class="ident">expect</span>(<span class="string">&quot;write register failed&quot;</span>);

  <span class="comment">//  Write Register 0x8E7: 0x38 (Over Current Protection)</span>
  <span class="ident">lora</span>.<span class="ident">write_register</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="ident">Register::OcpConfiguration</span>, <span class="kw-2">&amp;</span>[<span class="number">0x38</span>])
    .<span class="ident">expect</span>(<span class="string">&quot;write register failed&quot;</span>);

  <span class="comment">//  Write Register 0x736: 0x0D (Inverted IQ)</span>
  <span class="ident">lora</span>.<span class="ident">write_register</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>, <span class="ident">delay</span>, <span class="ident">Register::IqPolaritySetup</span>, <span class="kw-2">&amp;</span>[<span class="number">0x0D</span>])
    .<span class="ident">expect</span>(<span class="string">&quot;write register failed&quot;</span>);

  <span class="comment">//  Send a LoRa message</span>
  <span class="macro">println!</span>(<span class="string">&quot;Sending LoRa message...&quot;</span>);
  <span class="macro">println!</span>(<span class="string">&quot;Frequency: {}&quot;</span>, <span class="ident">RF_FREQUENCY</span>);
  <span class="ident">lora</span>.<span class="ident">write_bytes</span>(
    <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">spi1</span>,  <span class="comment">//  SPI Interface</span>
    <span class="ident">delay</span>,      <span class="comment">//  Delay Interface</span>
    <span class="string">b&quot;Hello from Rust on NuttX!&quot;</span>,  <span class="comment">//  Payload</span>
    <span class="number">0</span>.<span class="ident">into</span>(),   <span class="comment">//  Disable Transmit Timeout</span>
    <span class="number">8</span>,          <span class="comment">//  Preamble Length</span>
    <span class="ident">packet::lora::LoRaCrcType::CrcOn</span>,  <span class="comment">//  Enable CRC</span>
  ).<span class="ident">expect</span>(<span class="string">&quot;send failed&quot;</span>);</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/412cc8bef51c40236767e10693c738b5">(See the Output Log)</a></p>
<h1 id="download-source-code" class="section-header"><a href="#download-source-code">9 Download Source Code</a></h1>
<p>To run Rust on NuttX, download the modified source code for <strong>NuttX OS and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>mkdir nuttx
cd nuttx
git clone --recursive --branch rust https://github.com/lupyuen/incubator-nuttx nuttx
git clone --recursive --branch rust https://github.com/lupyuen/incubator-nuttx-apps apps</code></pre></div>
<p>Or if we prefer to <strong>add the Rust Library and App</strong> to our NuttX Project, follow these instructions‚Ä¶</p>
<ol>
<li>
<p>TODO: Rust Library</p>
</li>
<li>
<p>TODO: Rust App</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/tree/lorawan/drivers/rf"><strong>‚ÄúInstall SPI Test Driver‚Äù</strong></a></p>
</li>
</ol>
<h1 id="build-the-firmware" class="section-header"><a href="#build-the-firmware">10 Build The Firmware</a></h1>
<p>Let‚Äôs build the NuttX Firmware that contains our <strong>Rust App</strong>‚Ä¶</p>
<ol>
<li>
<p>Install the build prerequisites‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Assume that we have downloaded the <strong>NuttX Source Code</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rust2#download-source-code"><strong>‚ÄúDownload Source Code‚Äù</strong></a></p>
</li>
<li>
<p>Edit the <strong>Pin Definitions</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># For BL602 and BL604:
nuttx/boards/risc-v/bl602/bl602evb/include/board.h

# For ESP32: Change &quot;esp32-devkitc&quot; to our ESP32 board 
nuttx/boards/xtensa/esp32/esp32-devkitc/src/esp32_gpio.c</code></pre></div>
<p>Check that the <strong>Semtech SX1262 Pins</strong> are configured correctly in <a href="https://github.com/lupyuen/incubator-nuttx/blob/lorawan/boards/risc-v/bl602/bl602evb/include/board.h#L36-L95"><strong>board.h</strong></a> or <a href="https://github.com/lupyuen/incubator-nuttx/blob/lorawan/boards/xtensa/esp32/esp32-devkitc/src/esp32_gpio.c#L43-L67"><strong>esp32_gpio.c</strong></a>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/sx1262#connect-sx1262-transceiver"><strong>‚ÄúConnect SX1262 Transceiver‚Äù</strong></a></p>
</li>
<li>
<p>Configure the build‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx

# For BL602: Configure the build for BL602
./tools/configure.sh bl602evb:nsh

# For ESP32: Configure the build for ESP32.
# TODO: Change &quot;esp32-devkitc&quot; to our ESP32 board.
./tools/configure.sh esp32-devkitc:nsh

# Edit the Build Config
make menuconfig </code></pre></div></li>
<li>
<p>Enable the <strong>GPIO Driver</strong> in menuconfig‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#enable-gpio-driver"><strong>‚ÄúEnable GPIO Driver‚Äù</strong></a></p>
</li>
<li>
<p>Enable the <strong>SPI Peripheral</strong>, <strong>SPI Character Driver</strong> and <strong>SPI Test Driver</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-spi"><strong>‚ÄúEnable SPI‚Äù</strong></a></p>
</li>
<li>
<p>Enable <strong>GPIO and SPI Logging</strong> for easier troubleshooting‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/spi2#enable-logging"><strong>‚ÄúEnable Logging‚Äù</strong></a></p>
</li>
<li>
<p>Enable <strong>Stack Backtrace</strong> for easier troubleshooting‚Ä¶</p>
<p>Check the box for <strong>‚ÄúRTOS Features‚Äù</strong> ‚Üí <strong>‚ÄúStack Backtrace‚Äù</strong></p>
<p><a href="https://lupyuen.github.io/images/lorawan3-config4.png">(See this)</a></p>
</li>
<li>
<p>Enable our <strong>Rust Library</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúLibrary Routines‚Äù</strong> ‚Üí <strong>‚ÄúRust Library‚Äù</strong></p>
</li>
<li>
<p>Enable our <strong>Rust Test App</strong>‚Ä¶</p>
<p>Check the box for <strong>‚ÄúApplication Configuration‚Äù</strong> ‚Üí <strong>‚ÄúExamples‚Äù</strong> ‚Üí <strong>‚ÄúRust Test App‚Äù</strong></p>
</li>
<li>
<p>Save the configuration and exit menuconfig</p>
<p><a href="https://gist.github.com/lupyuen/2857bdc21a4bcd5bb868eae78cf44826">(See the .config for BL602 and BL604)</a></p>
</li>
<li>
<p><strong>For ESP32:</strong> Edit the function <strong>esp32_bringup</strong> in this file‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code># Change &quot;esp32-devkitc&quot; to our ESP32 board 
nuttx/boards/xtensa/esp32/esp32-devkitc/src/esp32_bringup.c</code></pre></div>
<p>And call <strong>spi_test_driver_register</strong> to register our SPI Test Driver.</p>
<p><a href="https://lupyuen.github.io/articles/spi2#register-device-driver">(See this)</a></p>
</li>
<li>
<p>TODO</p>
<div class="example-wrap"><pre class="language-bash"><code>cd nuttx/apps/examples/rust_test
./run.sh</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9bfd71f7029bb66e327f89c8a58f450d">(See the Build Log)</a></p>
</li>
<li>
<p>Build, flash and run the NuttX Firmware on BL602 or ESP32‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/rust2#appendix-build-flash-and-run-nuttx"><strong>‚ÄúBuild, Flash and Run NuttX‚Äù</strong></a></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/spi2-pinedio10a.jpg" alt="PineDio Stack BL604 with Antenna" /></p>
<h1 id="run-the-firmware" class="section-header"><a href="#run-the-firmware">11 Run The Firmware</a></h1>
<p>We‚Äôre ready to run the NuttX Firmware and test our <strong>Rust App</strong>!</p>
<ol>
<li>
<p>Before testing, remember to connect the <strong>LoRa Antenna</strong>‚Ä¶ </p>
<p>(So we don‚Äôt fry the SX1262 Transceiver as we charge up the Power Amplifier)</p>
</li>
<li>
<p>In the NuttX Shell, list the <strong>NuttX Devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ls /dev</code></pre></div></li>
<li>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>/dev:
  gpio0
  gpio1
  gpio2
  spi0
  spitest0
  ...</code></pre></div>
<p>Our SPI Test Driver appears as <strong>‚Äú/dev/spitest0‚Äù</strong></p>
<p>The SX1262 Pins for Busy, Chip Select and DIO1 should appear as <strong>‚Äú/dev/gpio0‚Äù</strong> (GPIO Input), <strong>‚Äúgpio1‚Äù</strong> (GPIO Output) and <strong>‚Äúgpio2‚Äù</strong> (GPIO Interrupt) respectively.</p>
</li>
<li>
<p>In the NuttX Shell, run our <strong>Rust App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>rust_test</code></pre></div></li>
</ol>
<p><img src="https://lupyuen.github.io/images/sx1262-title.jpg" alt="PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)" /></p>
<p><em>PineDio Stack BL604 RISC-V Board with onboard Semtech SX1262 LoRa Transceiver (left)‚Ä¶ Sniffed wirelessly with Airspy R2 Software Defined Radio (right)</em></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-chirp2.png" alt="" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-receive.png" alt="" /></p>
<h1 id="lorawan-support" class="section-header"><a href="#lorawan-support">12 LoRaWAN Support</a></h1>
<p>TODO</p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">13 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/rust2.md"><code>lupyuen.github.io/src/rust2.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">14 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1478959963930169345">this Twitter Thread</a></p>
</li>
<li>
<p>TODO</p>
<p><a href="https://github.com/no1wudi/nuttx.rs"><strong>no1wudi/nuttx.rs</strong></a></p>
</li>
<li>
<p>TODO: Libc: Linux / Nix: nostd / ioctl i32 instead of u64</p>
</li>
</ol>
<h1 id="appendix-rust-embedded-hal-for-nuttx" class="section-header"><a href="#appendix-rust-embedded-hal-for-nuttx">15 Appendix: Rust Embedded HAL for NuttX</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal3.png" alt="GPIO HAL" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal4.png" alt="SPI HAL" /></p>
<p><img src="https://lupyuen.github.io/images/rust2-driver.png" alt="Fixing SX1262 Driver for NuttX" /></p>
<h1 id="appendix-fix-sx1262-driver-for-nuttx" class="section-header"><a href="#appendix-fix-sx1262-driver-for-nuttx">16 Appendix: Fix SX1262 Driver for NuttX</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal5.png" alt="Incorrect register value" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal6.png" alt="SPI Transfers in small chunks" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-driver2.png" alt="SPI Transfers after merging" /></p>
<h1 id="appendix-rust-build-script-for-nuttx" class="section-header"><a href="#appendix-rust-build-script-for-nuttx">17 Appendix: Rust Build Script for NuttX</a></h1>
<p>TODO</p>
<p>Build Script: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/run.sh">rust_test/run.sh</a></p>
<p>Rust Custom Target: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/riscv32imacf-unknown-none-elf.json">rust_test/riscv32imacf-unknown-none-elf.json</a></p>
<p>Rust Dependencies: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/Cargo.toml">rust_test/rust/Cargo.toml</a></p>
<p>Rust Source File: <a href="https://github.com/lupyuen/incubator-nuttx-apps/blob/rust/examples/rust_test/rust/src/lib.rs">rust_test/rust/src/lib.rs</a></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-build.png" alt="Copy Rust Static Library to Staging Library" /></p>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-hal7.png" alt="Rust builds OK" /></p>
<h1 id="appendix-build-flash-and-run-nuttx" class="section-header"><a href="#appendix-build-flash-and-run-nuttx">18 Appendix: Build, Flash and Run NuttX</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/rust2-pinedio.jpg" alt="Lots of fun with Rust, NuttX and LoRa on PineDio Stack BL604" /></p>

    
</body>
</html>