<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>TCC RISC-V Compiler runs in the Web Browser (thanks to Zig Compiler)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="TCC RISC-V Compiler runs in the Web Browser (thanks to Zig Compiler)" 
    data-rh="true">
<meta property="og:description" 
    content="Today we're running Apache NuttX RTOS inside a Web Browser. What if we could compile and test NuttX Apps in the Web Browser? Let's explore with TCC 64-bit RISC-V Compiler, compiled to WebAssembly with Zig Compiler."
    data-rh="true">
<meta name="description" 
    content="Today we're running Apache NuttX RTOS inside a Web Browser. What if we could compile and test NuttX Apps in the Web Browser? Let's explore with TCC 64-bit RISC-V Compiler, compiled to WebAssembly with Zig Compiler.">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tcc-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tcc.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">TCC RISC-V Compiler runs in the Web Browser (thanks to Zig Compiler)</h1>
    <nav id="TOC"><ul>
<li><a href="#tcc-in-the-web-browser">1 TCC in the Web Browser</a><ul></ul></li>
<li><a href="#zig-compiles-tcc-to-webassembly">2 Zig compiles TCC to WebAssembly</a><ul></ul></li>
<li><a href="#posix-for-webassembly">3 POSIX for WebAssembly</a><ul></ul></li>
<li><a href="#file-input-and-output">4 File Input and Output</a><ul></ul></li>
<li><a href="#fearsome-fprintf-and-friends">5 Fearsome fprintf and Friends</a><ul></ul></li>
<li><a href="#test-with-apache-nuttx-rtos">6 Test with Apache NuttX RTOS</a><ul></ul></li>
<li><a href="#hello-nuttx">7 Hello NuttX!</a><ul></ul></li>
<li><a href="#whats-next">8 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-compile-tcc-with-zig">9 Appendix: Compile TCC with Zig</a><ul></ul></li>
<li><a href="#appendix-javascript-calls-tcc">10 Appendix: JavaScript calls TCC</a><ul></ul></li>
<li><a href="#appendix-pattern-matching">11 Appendix: Pattern Matching</a><ul></ul></li>
<li><a href="#appendix-nuttx-system-call">12 Appendix: NuttX System Call</a><ul></ul></li>
<li><a href="#appendix-build-nuttx-for-qemu">13 Appendix: Build NuttX for QEMU</a><ul></ul></li>
<li><a href="#appendix-missing-functions">14 Appendix: Missing Functions</a><ul></ul></li></ul></nav><p>üìù <em>7 Feb 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tcc-title.png" alt="TCC RISC-V Compiler runs in the Web Browser (thanks to Zig Compiler)" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/">(Try the <strong>Online Demo</strong>)</a></p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><em>TCC is a Tiny C Compiler for 64-bit RISC-V (and other platforms)‚Ä¶</em></p>
<p><em>Can we run TCC Compiler in a Web Browser?</em></p>
<p>Let‚Äôs do it! We‚Äôll compile <a href="https://github.com/sellicott/tcc-riscv32"><strong>TCC (Tiny C Compiler)</strong></a> from C to WebAssembly with <a href="https://ziglang.org/"><strong>Zig Compiler</strong></a>.</p>
<p>In this article, we talk about the tricky bits of the TCC Port from <strong>C to WebAssembly</strong>‚Ä¶</p>
<ul>
<li>
<p>We compiled <strong>TCC to WebAssembly</strong> with one tiny fix</p>
</li>
<li>
<p>But we hit some <strong>Missing POSIX Functions</strong></p>
</li>
<li>
<p>So we built minimal <strong>File Input and Output</strong> </p>
</li>
<li>
<p>Hacked up a simple workaround for <strong>fprintf and friends</strong></p>
</li>
<li>
<p>And TCC produces a <strong>RISC-V Binary</strong> that runs OK</p>
<p>(After fixing the RISC-V Assembly)</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>Today we‚Äôre running <a href="https://lupyuen.github.io/articles/tinyemu2"><strong>Apache NuttX RTOS</strong></a> inside a Web Browser, with WebAssembly + Emscripten + 64-bit RISC-V.</p>
<p>(<strong>Real-Time Operating System</strong> in Web Browser on General-Purpose Operating System!)</p>
<p>What if we could <strong>compile and test NuttX Apps</strong> in the Web Browser‚Ä¶</p>
<ol>
<li>
<p>We type a <strong>C Program</strong> into our Web Browser (pic below)</p>
</li>
<li>
<p>Compile it into an <strong>ELF Executable</strong> with TCC</p>
</li>
<li>
<p>Copy the ELF Executable to the <strong>NuttX Filesystem</strong></p>
</li>
<li>
<p>And <strong>NuttX Emulator</strong> runs our ELF Executable inside the Web Browser</p>
</li>
</ol>
<p>This is how we made it happen‚Ä¶</p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
<p><a href="https://research.cs.queensu.ca/home/cordy/pub/downloads/tplus/Turing_Plus_Report.pdf">(Not to be confused with <strong>TTC Compiler</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/tcc-web.png" alt="Online Demo of TCC Compiler in WebAssembly" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><em>Online Demo of TCC Compiler in WebAssembly</em></a></p>
<h1 id="tcc-in-the-web-browser"><a href="#tcc-in-the-web-browser">1 TCC in the Web Browser</a></h1>
<p>Click this link to try <strong>TCC Compiler in our Web Browser</strong> (pic above)</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><strong>TCC RISC-V Compiler in WebAssembly</strong></a></p>
<p><a href="https://youtu.be/DJMDYq52Iv8">(Watch the <strong>Demo on YouTube</strong>)</a></p>
</li>
</ul>
<p>This <strong>C Program</strong> appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Demo Program for TCC Compiler
int main(int argc, char *argv[]) {
  printf(&quot;Hello, World!!\n&quot;);
  return 0;
}
</code></pre></div>
<p>Click the ‚Äú<strong>Compile</strong>‚Äù button. Our Web Browser calls TCC to compile the above program‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile to RISC-V ELF
tcc -c hello.c
</code></pre></div>
<p>And it downloads the compiled <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>RISC-V ELF <code>a.out</code></strong></a>. We inspect the Compiled Output‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the RISC-V Disassembly
## of TCC Output
$ riscv64-unknown-elf-objdump \
    --syms --source --reloc --demangle \
    --line-numbers --wide  --debugging \
    a.out

main():
   ## Prepare the Stack
   0: fe010113  addi   sp, sp, -32
   4: 00113c23  sd     ra, 24(sp)
   8: 00813823  sd     s0, 16(sp)
   c: 02010413  addi   s0, sp, 32
  10: 00000013  nop

   ## Load to Register A0: &quot;Hello World&quot;
  14: fea43423  sd     a0, -24(s0)
  18: feb43023  sd     a1, -32(s0)
  1c: 00000517  auipc  a0, 0x0
  1c: R_RISCV_PCREL_HI20 L.0
  20: 00050513  mv     a0, a0
  20: R_RISCV_PCREL_LO12_I .text

   ## Call printf()
  24: 00000097  auipc  ra, 0x0
  24: R_RISCV_CALL_PLT printf
  28: 000080e7  jalr   ra  ## 24 &lt;main+0x24&gt;

   ## Clean up the Stack and
   ## return 0 to Caller
  2c: 0000051b  sext.w a0, zero
  30: 01813083  ld     ra, 24(sp)
  34: 01013403  ld     s0, 16(sp)
  38: 02010113  addi   sp, sp, 32
  3c: 00008067  ret
</code></pre></div>
<p>Yep the <strong>64-bit RISC-V Code</strong> looks legit! Very similar to our <a href="https://lupyuen.github.io/articles/app#inside-a-nuttx-app"><strong>NuttX App</strong></a>. (So it will probably run on NuttX)</p>
<p>What just happened? We go behind the scenes‚Ä¶</p>
<p><a href="https://gist.github.com/lupyuen/ab8febefa9c649ad7c242ee3f7aaf974">(See the <strong>Entire Disassembly</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#inside-a-nuttx-app">(About the <strong>RISC-V Instructions</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/tcc-zig.jpg" alt="Zig Compiler compiles TCC Compiler to WebAssembly" /></p>
<h1 id="zig-compiles-tcc-to-webassembly"><a href="#zig-compiles-tcc-to-webassembly">2 Zig compiles TCC to WebAssembly</a></h1>
<p><em>Will Zig Compiler happily compile TCC to WebAssembly?</em></p>
<p>Amazingly, yes! (Pic above)</p>
<div class="example-wrap"><pre class="language-bash"><code>## Zig Compiler compiles TCC Compiler
## from C to WebAssembly. Produces `tcc.o`
zig cc \
  -c \
  -target wasm32-freestanding \
  -dynamic \
  -rdynamic \
  -lc \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&quot;\&quot;riscv64-\&quot;&quot;  \
  -DCONFIG_TCC_CRTPREFIX=&quot;\&quot;/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_LIBPATHS=&quot;\&quot;{B}:/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&quot;\&quot;{B}/include:/usr/riscv64-linux-gnu/include\&quot;&quot;   \
  -DTCC_GITHASH=&quot;\&quot;main:b3d10a35\&quot;&quot; \
  -Wall \
  -O2 \
  -Wdeclaration-after-statement \
  -fno-strict-aliasing \
  -Wno-pointer-sign \
  -Wno-sign-compare \
  -Wno-unused-result \
  -Wno-format-truncation \
  -Wno-stringop-truncation \
  -I. \
  tcc.c
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/tcc.c">(See the <strong>TCC Source Code</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-compile-tcc-with-zig">(About the <strong>Zig Compiler Options</strong>)</a></p>
<p>We link the TCC WebAssembly with our <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig"><strong>Zig Wrapper</strong></a> (that exports the TCC Compiler to JavaScript)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Compile our Zig Wrapper `tcc-wasm.zig` for WebAssembly
## and link it with TCC compiled for WebAssembly `tcc.o`
## Generates `tcc-wasm.wasm`
zig build-exe \
  -target wasm32-freestanding \
  -rdynamic \
  -lc \
  -fno-entry \
  -freference-trace \
  --verbose-cimport \
  --export=compile_program \
  zig/tcc-wasm.zig \
  tcc.o

## Test everything with Web Browser
## or Node.js
node zig/test.js
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig">(See the <strong>Zig Wrapper tcc-wasm.zig</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test.js">(See the <strong>Test JavaScript test.js</strong>)</a></p>
<p><em>What‚Äôs inside our Zig Wrapper?</em></p>
<p>Our Zig Wrapper will‚Ä¶</p>
<ol>
<li>
<p>Receive the <strong>C Program</strong> from JavaScript</p>
</li>
<li>
<p>Receive the <strong>TCC Compiler Options</strong> from JavaScript</p>
</li>
<li>
<p>Call TCC Compiler to <strong>compile our program</strong></p>
</li>
<li>
<p>Return the compiled <strong>RISC-V ELF</strong> to JavaScript</p>
</li>
</ol>
<p>Like so: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L12-L77">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Call TCC Compiler to compile a
/// C Program to RISC-V ELF
pub export fn compile_program(
  options_ptr: [*:0]const u8, // Options for TCC Compiler (Pointer to JSON Array:  [&quot;-c&quot;, &quot;hello.c&quot;])
  code_ptr:    [*:0]const u8, // C Program to be compiled (Pointer to String)
) [*]const u8 { // Returns a pointer to the `a.out` Compiled Code (Size in first 4 bytes)

  // Receive the C Program from
  // JavaScript and set our Read Buffer
  // https://blog.battlefy.com/zig-made-it-easy-to-pass-strings-back-and-forth-with-webassembly
  const code: []const u8 = std.mem.span(code_ptr);
  read_buf = code;

  // Omitted: Receive the TCC Compiler
  // Options from JavaScript
  // (JSON containing String Array: [&quot;-c&quot;, &quot;hello.c&quot;])
  ...

  // Call the TCC Compiler
  _ = main(@intCast(argc), &amp;args_ptrs);

  // Return pointer of `a.out` to
  // JavaScript. First 4 bytes: Size of
  // `a.out`. Followed by `a.out` data.
  const slice = std.heap.page_allocator.alloc(u8, write_buflen + 4)   
    catch @panic(&quot;Failed to allocate memory&quot;);
  slice[0] = @intCast((write_buflen &gt;&gt;  0) &amp; 0xff);
  slice[1] = @intCast((write_buflen &gt;&gt;  8) &amp; 0xff);
  slice[2] = @intCast((write_buflen &gt;&gt; 16) &amp; 0xff);
  slice[3] = @intCast(write_buflen  &gt;&gt; 24);
  @memcpy(slice[4 .. write_buflen + 4], write_buf[0..write_buflen]);
  return slice.ptr; // TODO: Deallocate this memory
}
</code></pre></div>
<p>Plus a couple of Magical Bits that we‚Äôll cover in the next section.</p>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-javascript-calls-tcc">(How JavaScript calls our <strong>Zig Wrapper</strong>)</a></p>
<p><em>Zig Compiler compiles TCC without any code changes?</em></p>
<p>Inside TCC, we stubbed out the <a href="https://github.com/lupyuen/tcc-riscv32-wasm/commit/e30454a0eb9916f820d58a7c3e104eeda67988d8"><strong>setjmp / longjmp</strong></a> to make it compile with Zig Compiler.</p>
<p>Everything else compiles OK!</p>
<p><em>Is it really OK to stub them out?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Setjmp.h"><strong>setjmp / longjmp</strong></a> are called to <strong>Handle Errors</strong> during TCC Compilation. Assuming everything goes hunky dory, we won‚Äôt need them.</p>
<p>Later we‚Äôll find a better way to express our outrage. (Instead of jumping around)</p>
<p>We probe the Magical Bits inside our Zig Wrapper‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tcc-posix.jpg" alt="TCC Compiler in WebAssembly needs POSIX Functions" /></p>
<h1 id="posix-for-webassembly"><a href="#posix-for-webassembly">3 POSIX for WebAssembly</a></h1>
<p><em>What‚Äôs this POSIX?</em></p>
<p>TCC Compiler was created as a <strong>Command-Line App</strong>. So it calls the typical <a href="https://en.wikipedia.org/wiki/POSIX"><strong>POSIX Functions</strong></a> like <strong>fopen, fprintf, strncpy, malloc,</strong> ‚Ä¶</p>
<p><a href="https://en.wikipedia.org/wiki/C_standard_library">(Which are linked from the <strong>C Standard Library libc</strong>)</a></p>
<p><em>Is POSIX a problem for WebAssembly?</em></p>
<p>WebAssembly running in a Web Browser ain‚Äôt <strong>No Command Line</strong>! (Pic above)</p>
<p>We counted <a href="https://lupyuen.github.io/articles/tcc#appendix-missing-functions"><strong>72 POSIX Functions</strong></a> needed by TCC Compiler, but missing from WebAssembly.</p>
<p>Thus we fill in the <a href="https://lupyuen.github.io/articles/tcc#appendix-missing-functions"><strong>Missing Functions</strong></a> ourselves.</p>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-missing-functions">(About the <strong>Missing POSIX Functions</strong>)</a></p>
<p><em>Surely other Zig Devs will have the same problem?</em></p>
<p>Thankfully we can borrow the POSIX Code from other <strong>Zig Libraries</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/marler8997/ziglibc"><strong>ziglibc</strong></a>: Zig implementation of libc</p>
</li>
<li>
<p><a href="https://github.com/ZigEmbeddedGroup/foundation-libc"><strong>foundation-libc</strong></a>: Freestanding implementation of libc</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl3#appendix-lvgl-memory-allocation"><strong>PinePhone Simulator</strong></a>: For malloc</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L447-L774">(See the <strong>Borrowed Code</strong>)</a></p>
</li>
</ul>
<p><em>72 POSIX Functions? Sounds like a lot of work‚Ä¶</em></p>
<p>We might not need all 72 POSIX Functions. We stubbed out <strong>many of the functions</strong> to identify the ones that are called: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L774-L853">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Stub Out the Missing POSIX
// Functions. If TCC calls them, 
// we&#39;ll see a Zig Panic. Then we 
// implement them. The Types don&#39;t
// matter because we&#39;ll halt anyway.

pub export fn atoi(_: c_int) c_int {
  @panic(&quot;TODO: atoi&quot;);
}
pub export fn exit(_: c_int) c_int {
  @panic(&quot;TODO: exit&quot;);
}
pub export fn fopen(_: c_int) c_int {
  @panic(&quot;TODO: fopen&quot;);
}

// And many more functions...
</code></pre></div>
<p>Some of these functions are especially troubling for WebAssembly‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/tcc-posix2.jpg" alt="File Input and Output are especially troubling for WebAssembly" /></p>
</blockquote>
<h1 id="file-input-and-output"><a href="#file-input-and-output">4 File Input and Output</a></h1>
<p><em>Why no #include in TCC for WebAssembly? And no C Libraries?</em></p>
<p>WebAssembly runs in a Secure Sandbox. <strong>No File Access</strong> allowed, sorry! (Like for Header and Library Files)</p>
<p>That‚Äôs why our Zig Wrapper <strong>Emulates File Access</strong> for the bare minimum 2 files‚Ä¶</p>
<ul>
<li>
<p>Read the <strong>C Program: <code>hello.c</code></strong></p>
</li>
<li>
<p>Write the <strong>RISC-V ELF: <code>a.out</code></strong></p>
</li>
</ul>
<p><strong>Reading a Source File <code>hello.c</code></strong> is extremely simplistic: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L107-L119">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Emulate the POSIX Function `read()`
/// We copy from One Single Read Buffer
/// that contains our C Program
export fn read(fd0: c_int, buf: [*:0]u8, nbyte: size_t) isize {

  // TODO: Support more than one file
  // TODO: Check overflow
  const len = read_buf.len;
  @memcpy(buf[0..len], read_buf[0..len]);
  buf[len] = 0;
  read_buf.len = 0;
  return @intCast(len);
}

/// Read Buffer for read
var read_buf: []const u8 = undefined;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L26-L32">(<strong>read_buf</strong> is populated at startup)</a></p>
<p><strong>Writing the Compiled Output <code>a.out</code></strong> is just as barebones: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L130-L142">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Emulate the POSIX Function `write()`
/// We write to One Single Memory
/// Buffer that will be returned to 
/// JavaScript as `a.out`
export fn fwrite(ptr: [*:0]const u8, size: usize, nmemb: usize, stream: *FILE) usize {

  // TODO: Support more than one `stream`
  const len = size * nmemb;
  @memcpy(write_buf[write_buflen .. write_buflen + len], ptr[0..]);
  write_buflen += len;
  return nmemb;
}

/// Write Buffer for fputc and fwrite
var write_buf = std.mem.zeroes([8192]u8);
var write_buflen: usize = 0;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L62-L78">(<strong>write_buf</strong> will be returned to JavaScript)</a></p>
<p><em>Can we handle Multiple Files?</em></p>
<p>We‚Äôll have to embed an <strong>Emulated Filesystem</strong> inside our Zig Wrapper. The Filesystem will be preloaded with the Header and Library Files needed by TCC.</p>
<p><a href="https://emscripten.org/docs/porting/files/file_systems_overview.html">(Works like the <strong>Emscripten Filesystem</strong>)</a></p>
<p><a href="https://docs.kernel.org/filesystems/romfs.html">(Maybe we embed the simple <strong>ROM FS Filesystem</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/tcc-format.jpg" alt="Our Zig Wrapper uses Pattern Matching to match the C Formats and substitute the Zig Equivalent" /></p>
<h1 id="fearsome-fprintf-and-friends"><a href="#fearsome-fprintf-and-friends">5 Fearsome fprintf and Friends</a></h1>
<p><em>Why is fprintf particularly problematic?</em></p>
<p>Here‚Äôs the fearsome thing about <strong>fprintf</strong> and friends: <strong>sprintf, snprintf, vsnprintf</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>C Format Strings</strong> are difficult to parse</p>
</li>
<li>
<p><strong>Variable Number of Untyped Arguments</strong> might create Bad Pointers</p>
</li>
</ul>
<p>Hence we hacked up an implementation of <strong>String Formatting</strong> that‚Äôs safer, simpler and so-barebones-you-can-make-<em>soup-tulang</em>.</p>
<p><em>Soup tulang? Tell me more‚Ä¶</em></p>
<p>Our Zig Wrapper uses <a href="https://lupyuen.github.io/articles/tcc#appendix-pattern-matching"><strong>Pattern Matching</strong></a> to match the <strong>C Formats</strong> and substitute the <strong>Zig Equivalent</strong> (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Format a Single `%d`
// like `#define __TINYC__ %d`
FormatPattern{

  // If the C Format String contains this...
  .c_spec = &quot;%d&quot;,
  
  // Then we apply this Zig Format...
  .zig_spec = &quot;{}&quot;,
  
  // And extract these Argument Types
  // from the Varargs...
  .type0 = c_int,
  .type1 = null
}
</code></pre></div>
<p>This works OK (for now) because TCC Compiler only uses <strong>5 Patterns for C Format Strings</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Pattern Matching for C String Formatting:
/// We&#39;ll match these patterns when
/// formatting strings
const format_patterns = [_]FormatPattern{

  // Format a Single `%d`, like `#define __TINYC__ %d`
  FormatPattern{
    .c_spec = &quot;%d&quot;,  .zig_spec = &quot;{}&quot;, 
    .type0  = c_int, .type1 = null
  },

  // Format a Single `%u`, like `L.%u`
  FormatPattern{ 
    .c_spec = &quot;%u&quot;,  .zig_spec = &quot;{}&quot;, 
    .type0  = c_int, .type1 = null 
  },

  // Format a Single `%s`, like `.rela%s`
  // Or `#define __BASE_FILE__ &quot;%s&quot;`
  FormatPattern{
    .c_spec = &quot;%s&quot;, .zig_spec = &quot;{s}&quot;,
    .type0  = [*:0]const u8, .type1 = null
  },

  // Format Two `%s`, like `#define %s%s\n`
  FormatPattern{
    .c_spec = &quot;%s%s&quot;, .zig_spec = &quot;{s}{s}&quot;,
    .type0  = [*:0]const u8, .type1 = [*:0]const u8
  },

  // Format `%s:%d`, like `%s:%d: `
  // (File Name and Line Number)
  FormatPattern{
    .c_spec = &quot;%s:%d&quot;, .zig_spec = &quot;{s}:{}&quot;,
    .type0  = [*:0]const u8, .type1 = c_int
  },
};
</code></pre></div>
<p>That‚Äôs our quick hack for <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L209-L447"><strong>fprintf and friends</strong></a>!</p>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-pattern-matching">(How we do <strong>Pattern Matching</strong>)</a></p>
<p><em>So simple? Unbelievable!</em></p>
<p>Actually we‚Äôll hit more Format Patterns as TCC Compiler emits various <strong>Error and Warning Messages</strong>. But it‚Äôs a good start!</p>
<p>Later our Zig Wrapper shall cautiously and meticulously parse all kinds of C Format Strings. Or we do the <a href="https://github.com/marler8997/ziglibc/blob/main/src/printf.c#L32-L191"><strong>parsing in C</strong></a>, compiled to WebAssembly.</p>
<p>(Funny how <strong>printf</strong> is the first thing we learn about C. Yet it‚Äôs incredibly difficult to implement!)</p>
<p><img src="https://lupyuen.github.io/images/tcc-nuttx.jpg" alt="Compile and Run NuttX Apps in the Web Browser" /></p>
<h1 id="test-with-apache-nuttx-rtos"><a href="#test-with-apache-nuttx-rtos">6 Test with Apache NuttX RTOS</a></h1>
<p><em>TCC in WebAssembly has compiled our C Program to RISC-V ELF‚Ä¶</em></p>
<p><em>Will the ELF run on NuttX?</em></p>
<p><a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> is a tiny operating system for 64-bit RISC-V that runs on <a href="https://www.qemu.org/docs/master/system/target-riscv.html"><strong>QEMU Emulator</strong></a>. (And many other platforms)</p>
<p>We build <a href="https://lupyuen.github.io/articles/tcc#appendix-build-nuttx-for-qemu"><strong>NuttX for QEMU</strong></a> and copy the <strong>RISC-V ELF <code>a.out</code></strong> to the <strong>NuttX Apps Filesystem</strong> (pic above)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy RISC-V ELF `a.out`
## to NuttX Apps Filesystem
cp a.out apps/bin/
chmod +x apps/bin/a.out
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-build-nuttx-for-qemu">(How we build <strong>NuttX for QEMU</strong>)</a></p>
<p>Then we boot NuttX and run <strong><code>a.out</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot NuttX on QEMU 64-bit RISC-V
$ qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic

## Run `a.out` in NuttX Shell
NuttShell (NSH) NuttX-12.4.0
nsh&gt; a.out
Loading /system/bin/a.out
Exported symbol &quot;printf&quot; not found
Failed to load program &#39;a.out&#39;
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#test-tcc-output-with-nuttx">(See the <strong>Complete Log</strong>)</a></p>
<p>NuttX politely accepts the RISC-V ELF (produced by TCC). And says that <strong>printf</strong> is missing.</p>
<p>Which makes sense: We haven‚Äôt linked our C Program with the <a href="https://github.com/lupyuen/tcc-riscv32-wasm#how-nuttx-build-links-a-nuttx-app"><strong>C Library</strong></a>!</p>
<p><a href="https://gist.github.com/lupyuen/847f7adee50499cac5212f2b95d19cd3#file-nuttx-elf-loader-log-L882-L1212">(Loading a <strong>RISC-V ELF</strong> should look like this)</a></p>
<p><em>How else can we print something in NuttX?</em></p>
<p>To print something, we can make a <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>System Call (ECALL)</strong></a> directly to NuttX Kernel‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX System Call that prints
// something. System Call Number
// is 61 (SYS_write). Works exactly
// like POSIX `write()`
ssize_t write(
  int fd,           // File Descriptor (1 for Standard Output)
  const char *buf,  // Buffer to be printed
  size_t buflen     // Buffer Length
);

// Which makes an ECALL with these Parameters...
// Register A0 is 61 (SYS_write)
// Register A1 is the File Descriptor (1 for Standard Output)
// Register A2 points to the String Buffer to be printed
// Register A3 is the Buffer Length
</code></pre></div>
<p>That‚Äôs the same NuttX System Call that <strong>printf</strong> executes internally.</p>
<p>Final chance to say hello to NuttX‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tcc-ecall.png" alt="TCC WebAssembly compiles a NuttX System Call" /></p>
<h1 id="hello-nuttx"><a href="#hello-nuttx">7 Hello NuttX!</a></h1>
<p><em>We‚Äôre making a System Call (ECALL) to NuttX Kernel to print something‚Ä¶</em></p>
<p><em>How will we code this in C?</em></p>
<p>We execute the <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>ECALL in RISC-V Assembly</strong></a> like this: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test-nuttx.js#L52-L105">test-nuttx.js</a></p>
<div class="example-wrap"><pre class="language-c"><code>int main(int argc, char *argv[]) {

  // Make NuttX System Call
  // to write(fd, buf, buflen)
  const unsigned int nbr = 61; // SYS_write
  const void *parm1 = 1;       // File Descriptor (stdout)
  const void *parm2 = &quot;Hello, World!!\n&quot;; // Buffer
  const void *parm3 = 15; // Buffer Length

  // Load the Parameters into
  // Registers A0 to A3
  // Note: This doesn&#39;t work with TCC,
  // so we load again below
  register long r0 asm(&quot;a0&quot;) = (long)(nbr);
  register long r1 asm(&quot;a1&quot;) = (long)(parm1);
  register long r2 asm(&quot;a2&quot;) = (long)(parm2);
  register long r3 asm(&quot;a3&quot;) = (long)(parm3);

  // Execute ECALL for System Call
  // to NuttX Kernel. Again: Load the
  // Parameters into Registers A0 to A3
  asm volatile (

    // Load 61 to Register A0 (SYS_write)
    // li a0, 61
    &quot;.long 0x03d00513 \n&quot;

    // Load 1 to Register A1 (File Descriptor)
    // li a1, 1
    &quot;.long 0x00100593 \n&quot;

    // Load 0xc0101000 to Register A2 (Buffer)
    // li a2, 0xc0101000
    &quot;.long 0x000c0637 \n&quot;
    &quot;.long 0x1016061b \n&quot;
    &quot;.long 0x00c61613 \n&quot;

    // Load 15 to Register A3 (Buffer Length)
    // li a3, 15
    &quot;.long 0x00f00693 \n&quot;

    // ECALL for System Call to NuttX Kernel
    &quot;ecall \n&quot;

    // NuttX needs NOP after ECALL
    &quot;.word 0x0001 \n&quot;
  );

  // Loop Forever
  for(;;) {}
  return 0;
}
</code></pre></div>
<p>We copy this into our Web Browser and compile it. (Pic above)</p>
<p><a href="https://lupyuen.github.io/articles/tcc#appendix-nuttx-system-call">(Why so complicated? <strong>Explained here</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/app#nuttx-kernel-handles-system-call">(Warning: <strong>SYS_write 61</strong> may change)</a></p>
<p><em>Does it work?</em></p>
<p>TCC in WebAssembly compiles the code above to <strong>RISC-V ELF <code>a.out</code></strong>. When we copy it to NuttX and run it‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>NuttShell (NSH) NuttX-12.4.0-RC0
nsh&gt; a.out
...
## NuttX System Call for SYS_write (61)
riscv_swint:
  cmd: 61
  A0:  3d  ## SYS_write (61)
  A1:  01  ## File Descriptor (Standard Output)
  A2:  c0101000  ## Buffer
  A3:  0f        ## Buffer Length
...
## NuttX Kernel says hello
Hello, World!!
</code></pre></div>
<p>NuttX Kernel prints <strong>‚ÄúHello World‚Äù</strong> yay!</p>
<p>Indeed we‚Äôve created a C Compiler in a Web Browser, that <strong>produces proper NuttX Apps</strong>!</p>
<p><em>OK so we can compile NuttX Apps in a Web Browser‚Ä¶ But can we run them in a Web Browser?</em></p>
<p>Yep, a NuttX App compiled in the Web Browser‚Ä¶ Now runs OK with <strong>NuttX Emulator in the Web Browser</strong>! üéâ (Pic below)</p>
<ul>
<li>
<p><a href="https://youtu.be/DJMDYq52Iv8">Watch the <strong>Demo on YouTube</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser">Find out <strong>How It Works</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/tcc-emu2.png" alt="NuttX App compiled in a Web Browser‚Ä¶ Runs inside the Web Browser!" /></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#nuttx-app-runs-in-a-web-browser"><em>NuttX App compiled in a Web Browser‚Ä¶ Runs inside the Web Browser!</em></a></p>
<h1 id="whats-next"><a href="#whats-next">8 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Thanks to the <a href="https://github.com/sellicott/tcc-riscv32"><strong>TCC Team</strong></a>, we have a <strong>64-bit RISC-V Compiler</strong> that runs in the Web Browser!</p>
<p>TODO</p>
<p>How will you use <strong>TCC in a Web Browser</strong>? Please lemme know üôè</p>
<p><em>(Build and run RISC-V Apps on iPhone?)</em></p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX and Zig Communities) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tcc.md"><strong>lupyuen.github.io/src/tcc.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/tcc-web.png" alt="Online Demo of TCC Compiler in WebAssembly" /></p>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><em>Online Demo of TCC Compiler in WebAssembly</em></a></p>
<h1 id="appendix-compile-tcc-with-zig"><a href="#appendix-compile-tcc-with-zig">9 Appendix: Compile TCC with Zig</a></h1>
<p>This is how we run <strong>Zig Compiler to compile TCC Compiler</strong> from C to WebAssembly (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the (slightly) Modified TCC Source Code.
## Configure the build for 64-bit RISC-V.

git clone https://github.com/lupyuen/tcc-riscv32-wasm
cd tcc-riscv32-wasm
./configure
make --trace cross-riscv64

## Call Zig Compiler to compile TCC Compiler
## from C to WebAssembly. Produces `tcc.o`

## Omitted: Run the `zig cc` command from earlier...
## https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly

## Compile our Zig Wrapper `tcc-wasm.zig` for WebAssembly
## and link it with TCC compiled for WebAssembly `tcc.o`
## Generates `tcc-wasm.wasm`

## Omitted: Run the `zig build-exe` command from earlier...
## https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly
</code></pre></div>
<p><em>How did we figure out the ‚Äú<code>zig</code> <code>cc</code>‚Äù options?</em></p>
<p>Earlier we saw a long list of <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Compiler Options</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Zig Compiler Options for TCC Compiler
zig cc \
  tcc.c \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&quot;\&quot;riscv64-\&quot;&quot;  \
  -DCONFIG_TCC_CRTPREFIX=&quot;\&quot;/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_LIBPATHS=&quot;\&quot;{B}:/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&quot;\&quot;{B}/include:/usr/riscv64-linux-gnu/include\&quot;&quot;   \
  ...
</code></pre></div>
<p>We got them from ‚Äú<code>make</code> <code>--trace</code>‚Äù, which reveals the <strong>GCC Compiler Options</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Show the GCC Options for compiling TCC
$ make --trace cross-riscv64

gcc \
  -o riscv64-tcc.o \
  -c tcc.c \
  -DTCC_TARGET_RISCV64 \
  -DCONFIG_TCC_CROSSPREFIX=&quot;\&quot;riscv64-\&quot;&quot;  \
  -DCONFIG_TCC_CRTPREFIX=&quot;\&quot;/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_LIBPATHS=&quot;\&quot;{B}:/usr/riscv64-linux-gnu/lib\&quot;&quot; \
  -DCONFIG_TCC_SYSINCLUDEPATHS=&quot;\&quot;{B}/include:/usr/riscv64-linux-gnu/include\&quot;&quot;   \
  -DTCC_GITHASH=&quot;\&quot;main:b3d10a35\&quot;&quot; \
  -Wall \
  -O2 \
  -Wdeclaration-after-statement \
  -fno-strict-aliasing \
  -Wno-pointer-sign \
  -Wno-sign-compare \
  -Wno-unused-result \
  -Wno-format-truncation \
  -Wno-stringop-truncation \
  -I. 
</code></pre></div>
<p>And we copied above GCC Options to become our <a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>Zig Compiler Options</strong></a>.</p>
<p><img src="https://lupyuen.github.io/images/tcc-zig.jpg" alt="Zig Compiler compiles TCC Compiler to WebAssembly" /></p>
<h1 id="appendix-javascript-calls-tcc"><a href="#appendix-javascript-calls-tcc">10 Appendix: JavaScript calls TCC</a></h1>
<p>Previously we saw some <strong>JavaScript (Web Browser and Node.js)</strong> calling our TCC Compiler in WebAssembly (pic above)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/tcc-riscv32-wasm/"><strong>TCC WebAssembly in Web Browser</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/tcc#zig-compiles-tcc-to-webassembly"><strong>TCC WebAssembly in Node.js</strong></a></p>
</li>
</ul>
<p>This is how we test the TCC WebAssembly in a Web Browser with a <strong>Local Web Server</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the (slightly) Modified TCC Source Code
git clone https://github.com/lupyuen/tcc-riscv32-wasm
cd tcc-riscv32-wasm

## Start the Web Server
cargo install simple-http-server
simple-http-server ./docs &amp;

## Copy the Linked TCC WebAssembly to the Web Server
cp tcc-wasm.wasm docs/
</code></pre></div>
<p>Browse to this URL and our TCC WebAssembly will appear‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Test TCC WebAssembly with Web Browser
http://localhost:8000/index.html
</code></pre></div>
<p>Check the <strong>JavaScript Console</strong> for more messages.</p>
<p><a href="https://gist.github.com/lupyuen/5f8191d5c63b7dba030582cbe7481572">(See the <strong>JavaScript Log</strong>)</a></p>
<p><em>How does it work?</em></p>
<p>On clicking the <strong>Compile Button</strong>, our JavaScript loads the TCC WebAssembly: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L170-L187">tcc.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Load the WebAssembly Module and start the Main Function.
// Called by the Compile Button.
async function bootstrap() {
  // Load the WebAssembly Module
  // https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming
  const result = await WebAssembly.instantiateStreaming(
    fetch(&quot;tcc-wasm.wasm&quot;),
    importObject
  );

  // Store references to WebAssembly Functions and Memory exported by Zig
  wasm.init(result);

  // Start the Main Function
  window.requestAnimationFrame(main);
}        
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L25-L48">(<strong>importObject</strong> exports our <strong>JavaScript Logger</strong> to Zig)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L6-L25">(<strong>wasm</strong> is our <strong>WebAssembly Helper</strong>)</a></p>
<p>Which triggers the <strong>Main Function</strong> and calls our Zig Function <strong>compile_program</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L48-L86">tcc.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Main Function
function main() {
  // Allocate a String for passing the Compiler Options to Zig
  // `options` is a JSON Array: [&quot;-c&quot;, &quot;hello.c&quot;]
  const options = read_options();
  const options_ptr = allocateString(JSON.stringify(options));
  
  // Allocate a String for passing the Program Code to Zig
  const code = document.getElementById(&quot;code&quot;).value;
  const code_ptr = allocateString(code);

  // Call TCC to compile the program
  const ptr = wasm.instance.exports
    .compile_program(options_ptr, code_ptr);

  // Get the `a.out` size from first 4 bytes returned
  const memory = wasm.instance.exports.memory;
  const data_len = new Uint8Array(memory.buffer, ptr, 4);
  const len = data_len[0] | data_len[1] &lt;&lt; 8 | data_len[2] &lt;&lt; 16 | data_len[3] &lt;&lt; 24;
  if (len &lt;= 0) { return; }

  // Encode the `a.out` data from the rest of the bytes returned
  // `encoded_data` looks like %7f%45%4c%46...
  const data = new Uint8Array(memory.buffer, ptr + 4, len);
  let encoded_data = &quot;&quot;;
  for (const i in data) {
    const hex = Number(data[i]).toString(16).padStart(2, &quot;0&quot;);
    encoded_data += `%${hex}`;
  }

  // Download the `a.out` data into the Web Browser
  download(&quot;a.out&quot;, encoded_data);

  // Save the ELF Data to Local Storage for loading by NuttX Emulator
  localStorage.setItem(&quot;elf_data&quot;, encoded_data);
};
</code></pre></div>
<p>Our Main Function then downloads the <strong><code>a.out</code></strong> file returned by our Zig Function.</p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L86-L108">(<strong>allocateString</strong> allocates a String from Zig Memory)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/docs/tcc.js#L158-L170">(<strong>download</strong> is here)</a></p>
<p><em>What about Node.js calling TCC WebAssembly?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>## Test TCC WebAssembly with Node.js
node zig/test.js
</code></pre></div>
<p><strong>For Easier Testing</strong> (via Command-Line): We copied the JavaScript above into a Node.js Script: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test.js">test.js</a></p>
<div class="example-wrap"><pre class="language-javascript"><code>// Allocate a String for passing the Compiler Options to Zig
const options = [&quot;-c&quot;, &quot;hello.c&quot;];
const options_ptr = allocateString(JSON.stringify(options));

// Allocate a String for passing Program Code to Zig
const code_ptr = allocateString(`
  int main(int argc, char *argv[]) {
    printf(&quot;Hello, World!!\\n&quot;);
    return 0;
  }
`);

// Call TCC to compile a program
const ptr = wasm.instance.exports
  .compile_program(options_ptr, code_ptr);
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/795327506cad9b1ee82206e614c399cd">(See the <strong>Node.js Log</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/tcc-format.jpg" alt="Our Zig Wrapper doing Pattern Matching for Formatting C Strings" /></p>
<h1 id="appendix-pattern-matching"><a href="#appendix-pattern-matching">11 Appendix: Pattern Matching</a></h1>
<p>A while back we saw our Zig Wrapper doing <strong>Pattern Matching</strong> for Formatting C Strings‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tcc#fearsome-fprintf-and-friends"><strong>‚ÄúFearsome fprintf and Friends‚Äù</strong></a></li>
</ul>
<p>How It Works: We search for <strong>Format Patterns</strong> in the C Format Strings and substitute the <strong>Zig Equivalent</strong> (pic above): <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>// Format a Single `%d`
// like `#define __TINYC__ %d`
FormatPattern{

  // If the C Format String contains this...
  .c_spec = &quot;%d&quot;,
  
  // Then we apply this Zig Format...
  .zig_spec = &quot;{}&quot;,
  
  // And extract these Argument Types
  // from the Varargs...
  .type0 = c_int,
  .type1 = null
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L191-L209">(See the <strong>Format Patterns</strong>)</a></p>
<p>To implement this, we call <strong>comptime Functions</strong> in Zig: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L276-L326">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// CompTime Function to format a string by Pattern Matching.
/// Format a Single Specifier, like `#define __TINYC__ %d\n`
/// If the Spec matches the Format: Return the number of bytes written to `str`, excluding terminating null.
/// Else return 0.
fn format_string1(
  ap: *std.builtin.VaList,  // Varargs passed from C
  str: [*]u8,    // Buffer for returning Formatted String
  size: size_t,  // Buffer Size
  format: []const u8,  // C Format String, like `#define __TINYC__ %d\n`
  comptime c_spec: []const u8,   // C Format Pattern, like `%d`
  comptime zig_spec: []const u8, // Zig Equivalent, like `{}`
  comptime T0: type,   // Type of First Vararg, like `c_int`
) usize {
  // Count the Format Specifiers: `%`
  const spec_cnt   = std.mem.count(u8, c_spec, &quot;%&quot;);
  const format_cnt = std.mem.count(u8, format, &quot;%&quot;);

  // Check the Format Specifiers: `%`
  // Quit if the number of specifiers are different
  // Or if the specifiers are not found
  if (format_cnt != spec_cnt or
      !std.mem.containsAtLeast(u8, format, 1, c_spec)) {
    return 0;
  }

  // Fetch the First Argument from the C Varargs
  const a = @cVaArg(ap, T0);

  // Format the Argument. TODO: Check for overflow
  var buf: [100]u8 = undefined; // Limit to 100 chars
  const buf_slice = std.fmt.bufPrint(&amp;buf, zig_spec, .{a}) catch {
    @panic(&quot;*** format_string1 error: buf too small&quot;);
  };

  // Replace the C Format Pattern by the Zig Equivalent
  var buf2 = std.mem.zeroes([100]u8); // Limit to 100 chars
  _ = std.mem.replace(u8, format, c_spec, buf_slice, &amp;buf2);

  // Return the Formatted String and Length
  const len = std.mem.indexOfScalar(u8, &amp;buf2, 0).?;
  @memcpy(str[0..len], buf2[0..len]);
  str[len] = 0;
  return len;
}
</code></pre></div>
<p>The function above is called by a <strong>comptime Inline Loop</strong> that applies all the <a href="tcc-wasm.zig"><strong>Format Patterns</strong></a> that we saw earlier: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L209-L252"></a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Runtime Function to format a string by Pattern Matching.
/// Return the number of bytes written to `str`, excluding terminating null.
fn format_string(
  ap: *std.builtin.VaList,  // Varargs passed from C
  str: [*]u8,    // Buffer for returning Formatted String
  size: size_t,  // Buffer Size
  format: []const u8,  // C Format String, like `#define __TINYC__ %d\n`
) usize {
  // If no Format Specifiers: Return the Format, like `warning: `
  const len = format_string0(str, size, format);
  if (len &gt; 0) { return len; }

  // For every Format Pattern...
  inline for (format_patterns) |pattern| {

    // Try formatting the string with the pattern...
    const len2 =
      if (pattern.type1) |t1|
      // Pattern has 2 parameters
      format_string2(ap, str, size, format, // Output String and Format String
        pattern.c_spec, pattern.zig_spec,   // Format Specifiers for C and Zig
        pattern.type0, t1 // Types of the Parameters
      )
    else
      // Pattern has 1 parameter
      format_string1(ap, str, size, format, // Output String and Format String
        pattern.c_spec, pattern.zig_spec,   // Format Specifiers for C and Zig
        pattern.type0 // Type of the Parameter
      );

    // Loop until we find a match pattern
    if (len2 &gt; 0) { return len2; }
  }

  // Format String doesn&#39;t match any Format Pattern.
  // We return the Format String and Length.
  const len3 = format.len;
  @memcpy(str[0..len3], format[0..len3]);
  str[len3] = 0;
  return len3;
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L326-L380">(<strong>format_string2</strong> is here)</a></p>
<p>And the above function is called by <strong>fprintf and friends</strong>: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L380-L431">tcc-wasm.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Implement the POSIX Function `fprintf`
export fn fprintf(stream: *FILE, format: [*:0]const u8, ...) c_int {

  // Prepare the varargs
  var ap = @cVaStart();
  defer @cVaEnd(&amp;ap);

  // Format the string. TODO: Catch overflow
  var buf = std.mem.zeroes([100]u8); // Limit to 100 chars
  const format_slice = std.mem.span(format);
  const len = format_string(&amp;ap, &amp;buf, 0, format_slice);

  // TODO: Print to other File Streams.
  // Right now we assume it&#39;s stderr (File Descriptor 2)
  return @intCast(len);
}

// Do the same for sprintf, snprintf, vsnprintf
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/3e650bd6ad72b2e8ee8596858bc94f36">(See the <strong>Formatting Log</strong>)</a></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-the-varargs-functions">(Without <strong>comptime</strong>, the code gets <strong>super tedious</strong>)</a></p>
<p><img src="https://lupyuen.github.io/images/app-syscall.jpg" alt="NuttX Apps make a System Call to print to the console" /></p>
<h1 id="appendix-nuttx-system-call"><a href="#appendix-nuttx-system-call">12 Appendix: NuttX System Call</a></h1>
<p>Just now we saw a huge chunk of C Code that makes a <strong>NuttX System Call</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tcc#hello-nuttx"><strong>‚ÄúHello NuttX!‚Äù</strong></a></li>
</ul>
<p><em>Why so complicated?</em></p>
<p>We refer to the docs for <a href="https://lupyuen.github.io/articles/app#nuttx-app-calls-nuttx-kernel"><strong>NuttX System Calls (ECALL)</strong></a>. Rightfully this <strong>shorter version</strong> should work‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Make NuttX System Call to write(fd, buf, buflen)
const unsigned int nbr = 61; // SYS_write
const void *parm1 = 1;       // File Descriptor (stdout)
const void *parm2 = &quot;Hello, World!!\n&quot;; // Buffer
const void *parm3 = 15; // Buffer Length

// Execute ECALL for System Call to NuttX Kernel
register long r0 asm(&quot;a0&quot;) = (long)(nbr);
register long r1 asm(&quot;a1&quot;) = (long)(parm1);
register long r2 asm(&quot;a2&quot;) = (long)(parm2);
register long r3 asm(&quot;a3&quot;) = (long)(parm3);

asm volatile (
  // ECALL for System Call to NuttX Kernel
  &quot;ecall \n&quot;

  // NuttX needs NOP after ECALL
  &quot;.word 0x0001 \n&quot;
);
</code></pre></div>
<p>Sadly TCC generates <a href="https://github.com/lupyuen/tcc-riscv32-wasm#ecall-for-nuttx-system-call"><strong>mysterious RISC-V Machine Code</strong></a> that mashes up the RISC-V Registers‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>main():
// Prepare the Stack
   0:  fc010113  add     sp, sp, -64
   4:  02113c23  sd      ra, 56(sp)
   8:  02813823  sd      s0, 48(sp)
   c:  04010413  add     s0, sp, 64
  10:  00000013  nop
  14:  fea43423  sd      a0, -24(s0)
  18:  feb43023  sd      a1, -32(s0)

// Correct: Load Register A0 with 61 (SYS_write)
  1c:  03d0051b  addw    a0, zero, 61
  20:  fca43c23  sd      a0, -40(s0)

// Nope: Load Register A0 with 1?
// Mixed up with Register A1! (Value 1)
  24:  0010051b  addw    a0, zero, 1
  28:  fca43823  sd      a0, -48(s0)

// Nope: Load Register A0 with &quot;Hello World&quot;?
// Mixed up with Register A2!
  2c:  00000517  auipc   a0,0x0  2c: R_RISCV_PCREL_HI20  L.0
  30:  00050513  mv      a0,a0   30: R_RISCV_PCREL_LO12_I        .text
  34:  fca43423  sd      a0, -56(s0)

// Nope: Load Register A0 with 15?
// Mixed up with Register A3! (Value 15)
  38:  00f0051b  addw    a0, zero, 15
  3c:  fca43023  sd      a0, -64(s0)

// Execute ECALL with Register A0 set to 15.
// Nope: A0 should be 61!
  40:  00000073  ecall
  44:  0001      nop
</code></pre></div>
<p>Thus we <a href="https://github.com/lupyuen/tcc-riscv32-wasm#ecall-for-nuttx-system-call"><strong>hardcode Registers A0, A1, A2 and A3</strong></a> in RISC-V Machine Code: <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/test-nuttx.js#L55-L87">test-nuttx.js</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Load 61 to Register A0 (SYS_write)
// li a0, 61
&quot;.long 0x03d00513 \n&quot;

// Load 1 to Register A1 (File Descriptor)
// li a1, 1
&quot;.long 0x00100593 \n&quot;

// Load 0xc0101000 to Register A2 (Buffer)
// li a2, 0xc0101000
&quot;.long 0x000c0637 \n&quot;
&quot;.long 0x1016061b \n&quot;
&quot;.long 0x00c61613 \n&quot;

// Load 15 to Register A3 (Buffer Length)
// li a3, 15
&quot;.long 0x00f00693 \n&quot;

// ECALL for System Call to NuttX Kernel
&quot;ecall \n&quot;

// NuttX needs NOP after ECALL
&quot;.word 0x0001 \n&quot;
</code></pre></div>
<p><strong>TODO:</strong> Is there a workaround? Do we paste the ECALL Machine Code ourselves? <a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-missing-printf-in-nuttx-app"><strong>NuttX Libraries</strong></a> won‚Äôt link with TCC</p>
<p><em>What‚Äôs with the <code>li</code> and <code>nop</code>?</em></p>
<p>TCC won‚Äôt assemble the <strong><code>li</code></strong> and <strong><code>nop</code></strong> instructions.</p>
<p>So we used this <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a> to assemble the Machine Code above.</p>
<p>‚Äú<code>li a2, 0xc0101000</code>‚Äù is special because it expands to multiple RISC-V Instructions‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>// Load 0xC0 &lt;&lt; 12 into Register A2 (0xC0000)
000c0637  lui    a2, 0xc0

// Add 257 to Register A2 (0xC0101)
1016061b  addiw  a2, a2, 257

// Shift Left by 12 Bits (0xC010_1000)
00c61613  slli   a2, a2, 0xc
</code></pre></div>
<p><em>How did we figure out that the buffer is at 0xC010_1000?</em></p>
<p>We saw this in the <a href="https://gist.github.com/lupyuen/a715e4e77c011d610d0b418e97f8bf5d#file-nuttx-tcc-app-log-L32-L42"><strong>ELF Loader Log</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>NuttShell (NSH) NuttX-12.4.0
nsh&gt; a.out
...
Read 576 bytes from offset 512
Read 154 bytes from offset 64
1. 00000000-&gt;c0000000
Read 0 bytes from offset 224
2. 00000000-&gt;c0101000
Read 16 bytes from offset 224
3. 00000000-&gt;c0101000
4. 00000000-&gt;c0101010
</code></pre></div>
<p>Which says that the NuttX ELF Loader copied 16 bytes from our NuttX App Data Section <strong><code>.data.ro</code></strong> to <strong><code>0xC010_1000</code></strong>.</p>
<p>That‚Äôs all 15 bytes of <em>‚ÄúHello, World!!\n‚Äù</em>, including the terminating null.</p>
<p>Thus our buffer should be at <strong><code>0xC010_1000</code></strong>.</p>
<p><a href="https://lupyuen.github.io/articles/app#kernel-starts-a-nuttx-app">(More about the <strong>NuttX ELF Loader</strong>)</a></p>
<p><em>Why did we Loop Forever?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Omitted: Execute ECALL for System Call to NuttX Kernel
asm volatile ( ... );

// Loop Forever
for(;;) {}
</code></pre></div>
<p>That‚Äôs because NuttX Apps are not supposed to <a href="https://github.com/lupyuen/tcc-riscv32-wasm#fix-missing-printf-in-nuttx-app"><strong>Return to NuttX Kernel</strong></a>.</p>
<p>We should call the NuttX System Call <strong><code>__exit</code></strong> to terminate peacefully.</p>
<p><img src="https://lupyuen.github.io/images/tcc-demo.png" alt="Online Demo of Apache NuttX RTOS" /></p>
<p><a href="https://nuttx.apache.org/demo/"><em>Online Demo of Apache NuttX RTOS</em></a></p>
<h1 id="appendix-build-nuttx-for-qemu"><a href="#appendix-build-nuttx-for-qemu">13 Appendix: Build NuttX for QEMU</a></h1>
<p>Here are the steps to build and run <strong>NuttX for QEMU 64-bit RISC-V</strong> (Kernel Mode)</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv64-unknown-elf</strong>‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/riscv#appendix-download-toolchain-for-64-bit-risc-v"><strong>‚ÄúDownload Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and configure NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download NuttX Source Code
mkdir nuttx
cd nuttx
git clone https://github.com/apache/nuttx nuttx
git clone https://github.com/apache/nuttx-apps apps

## Configure NuttX for QEMU RISC-V 64-bit (Kernel Mode)
cd nuttx
tools/configure.sh rv-virt:knsh64
make menuconfig
</code></pre></div>
<p>We use <a href="https://lupyuen.github.io/articles/semihost#nuttx-apps-filesystem"><strong>Kernel Mode</strong></a> because it allows loading of NuttX Apps as ELF Files.</p>
<p>(Instead of Statically Linking the NuttX Apps into NuttX Kernel)</p>
</li>
<li>
<p>(Optional) To enable <strong>ELF Loader Logging</strong>, select‚Ä¶</p>
<p>Build Setup &gt; Debug Options &gt; Binary Loader Debug Features:</p>
<ul>
<li>Enable ‚ÄúBinary Loader Error, Warnings and Info‚Äù</li>
</ul>
</li>
<li>
<p>(Optional) To enable <strong>System Call Logging</strong>, select‚Ä¶</p>
<p>Build Setup &gt; Debug Options &gt; SYSCALL  Debug Features:</p>
<ul>
<li>Enable ‚ÄúSYSCALL Error, Warnings and Info‚Äù</li>
</ul>
</li>
<li>
<p>Save and exit <strong>menuconfig</strong>.</p>
</li>
<li>
<p>Build the <strong>NuttX Kernel and NuttX Apps</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build NuttX Kernel
make -j 8

## Build NuttX Apps
make -j 8 export
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make -j 8 import
popd
</code></pre></div></li>
</ol>
<p>This produces the NuttX ELF Image <strong>nuttx</strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For macOS: Install QEMU
brew install qemu

## For Debian and Ubuntu: Install QEMU
sudo apt install qemu-system-riscv64

## Boot NuttX on QEMU 64-bit RISC-V
qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div>
<p>NuttX Apps are located in <strong><code>apps/bin</code></strong>.</p>
<p>We may copy our <strong>RISC-V ELF <code>a.out</code></strong> to that folder.</p>
<p><img src="https://lupyuen.github.io/images/tcc-posix.jpg" alt="POSIX Functions aren‚Äôt supported for TCC in WebAssembly" /></p>
<h1 id="appendix-missing-functions"><a href="#appendix-missing-functions">14 Appendix: Missing Functions</a></h1>
<p>Remember we said that POSIX Functions aren‚Äôt supported in WebAssembly? (Pic above)</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tcc#posix-for-webassembly"><strong>‚ÄúPOSIX for WebAssembly‚Äù</strong></a></li>
</ul>
<p>We dump the <strong>Compiled WebAssembly</strong> of TCC Compiler, and we discover that it calls <strong>72 POSIX Functions</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Dump the Compiled WebAssembly
## for TCC Compiler
$ sudo apt install wabt
$ wasm-objdump -x tcc.o

Import:
 - func[0] sig=1 &lt;env.strcmp&gt;  &lt;- env.strcmp
 - func[1] sig=12 &lt;env.memset&gt; &lt;- env.memset
 - func[2] sig=1 &lt;env.getcwd&gt;  &lt;- env.getcwd
 ...
 - func[69] sig=2 &lt;env.localtime&gt; &lt;- env.localtime
 - func[70] sig=13 &lt;env.qsort&gt;    &lt;- env.qsort
 - func[71] sig=19 &lt;env.strtoll&gt;  &lt;- env.strtoll
</code></pre></div>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm#missing-functions-in-tcc-webassembly">(See the <strong>Complete List</strong>)</a></p>
<p>Do we really need all 72 POSIX Functions? We run through the list‚Ä¶</p>
<hr>
<p><strong>Filesystem Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L89-L168"><em>(Implemented here)</em></a></p>
<p>We‚Äôll simulate these functions for WebAssembly. Maybe with an Emulated Filesystem, similar to <a href="https://emscripten.org/docs/porting/files/file_systems_overview.html"><strong>Emscripten Filesystem</strong></a>.</p>
<p>Or we embed the simple <a href="https://docs.kernel.org/filesystems/romfs.html"><strong>ROM FS Filesystem</strong></a> into our Zig Wrapper‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+getcwd"><strong>getcwd</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+remove"><strong>remove</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+unlink"><strong>unlink</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+open"><strong>open</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fopen"><strong>fopen</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fdopen"><strong>fdopen</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+close"><strong>close</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fclose"><strong>fclose</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fprintf"><strong>fprintf</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fputc"><strong>fputc</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fputs"><strong>fputs</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+read"><strong>read</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fread"><strong>fread</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fwrite"><strong>fwrite</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fflush"><strong>fflush</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fseek"><strong>fseek</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+ftell"><strong>ftell</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+lseek"><strong>lseek</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+puts"><strong>puts</strong></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><hr>
<p><strong>Varargs Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L188-L447"><em>(Implemented here)</em></a></p>
<p>As discussed earlier, Varargs will be <a href="https://lupyuen.github.io/articles/tcc#fearsome-fprintf-and-friends"><strong>tricky to implement</strong></a> in Zig. Probably we should do it in C. <a href="https://github.com/marler8997/ziglibc/blob/main/src/printf.c#L32-L191">(Like <strong>ziglibc</strong>)</a></p>
<p>Right now we‚Äôre doing simple <a href="https://lupyuen.github.io/articles/tcc#appendix-pattern-matching"><strong>Pattern Matching</strong></a>. But it might not be sufficient when TCC compiles Real Programs‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+printf"><strong>printf</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+snprintf"><strong>snprintf</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+sprintf"><strong>sprintf</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+vsnprintf"><strong>vsnprintf</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+sscanf"><strong>sscanf</strong></a></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><hr>
<p><strong>String Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L539-L774"><em>(Implemented here)</em></a></p>
<p>We‚Äôll borrow the String Functions from <a href="https://github.com/marler8997/ziglibc/blob/main/src/cstd.zig"><strong>ziglibc</strong></a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+atoi"><strong>atoi</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strcat"><strong>strcat</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strchr"><strong>strchr</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strcmp"><strong>strcmp</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strncmp"><strong>strncmp</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strncpy"><strong>strncpy</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strrchr"><strong>strrchr</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strstr"><strong>strstr</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtod"><strong>strtod</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtof"><strong>strtof</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtol"><strong>strtol</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtold"><strong>strtold</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtoll"><strong>strtoll</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtoul"><strong>strtoul</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtoull"><strong>strtoull</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strerror"><strong>strerror</strong></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><hr>
<p><strong>Semaphore Functions</strong></p>
<p><a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L168-L188"><em>(Implemented here)</em></a></p>
<p>Not sure why TCC uses Semaphores? Maybe we‚Äôll understand when we support <strong><code>#include</code></strong> files.</p>
<p>(Where can we borrow the Semaphore Functions?)</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+sem_init"><strong>sem_init</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+sem_post"><strong>sem_post</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+sem_wait"><strong>sem_wait</strong></a></td></tr>
</tbody></table>
</div><hr>
<p><strong>Standard Library:</strong></p>
<p><strong>qsort</strong> isn‚Äôt used right now. Maybe for the Linker later?</p>
<p>(Borrow <strong>qsort</strong> from where? We can probably implement <strong>exit</strong>)</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+exit"><strong>exit</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+qsort"><strong>qsort</strong></a></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><hr>
<p><strong>Time and Math Functions:</strong></p>
<p>Not used right now, maybe later.</p>
<p>(Anyone can lend us <strong>ldexp</strong>? How will we get the Time Functions? Call out to JavaScript to fetch the actual time?)</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+time"><strong>time</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+gettimeofday"><strong>gettimeofday</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+localtime"><strong>localtime</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+ldexp"><strong>ldexp</strong></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
</tbody></table>
</div><hr>
<p><strong>Outstanding Functions</strong></p>
<p><a href="ttps://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L774-L853"><em>(Implemented here)</em></a></p>
<p>We have implemented (fully or partially) <strong>48 POSIX Functions</strong> from above.</p>
<p>The ones that we haven‚Äôt implemented? These <a href="https://github.com/lupyuen/tcc-riscv32-wasm/blob/main/zig/tcc-wasm.zig#L774-L853"><strong>24 POSIX Functions will Halt</strong></a> when TCC WebAssembly calls them‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left"></th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+atoi"><strong>atoi</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+exit"><strong>exit</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fopen"><strong>fopen</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fread"><strong>fread</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+fseek"><strong>fseek</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+ftell"><strong>ftell</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+getcwd"><strong>getcwd</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+gettimeofday"><strong>gettimeofday</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+ldexp"><strong>ldexp</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+localtime"><strong>localtime</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+lseek"><strong>lseek</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+printf"><strong>printf</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+qsort"><strong>qsort</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+remove"><strong>remove</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strcat"><strong>strcat</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strerror"><strong>strerror</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strncpy"><strong>strncpy</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtod"><strong>strtod</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtof"><strong>strtof</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtol"><strong>strtol</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtold"><strong>strtold</strong></a></td></tr>
<tr><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtoll"><strong>strtoll</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+strtoul"><strong>strtoul</strong></a></td><td style="text-align: left"><a href="https://github.com/search?type=code&amp;q=repo%3Asellicott%2Ftcc-riscv32+path%3A*tcc*.c+time"><strong>time</strong></a></td></tr>
</tbody></table>
</div>
    
</body>
</html>