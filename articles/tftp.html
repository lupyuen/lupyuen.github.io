<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Star64 JH7110 RISC-V SBC: Boot from Network with U-Boot and TFTP</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Star64 JH7110 RISC-V SBC: Boot from Network with U-Boot and TFTP" 
    data-rh="true">
<meta property="og:description" 
    content="Let's boot Apache NuttX RTOS (or Linux) over the Network with U-Boot Bootloader and TFTP... On Pine64's Star64 JH7110 RISC-V Single-Board Computer"
    data-rh="true">
<meta name="description" 
    content="Let's boot Apache NuttX RTOS (or Linux) over the Network with U-Boot Bootloader and TFTP... On Pine64's Star64 JH7110 RISC-V Single-Board Computer">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tftp-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.org/articles/tftp.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Star64 JH7110 RISC-V SBC: Boot from Network with U-Boot and TFTP</h1>
    <nav id="rustdoc"><ul>
<li><a href="#boot-from-network" title="Boot From Network">1 Boot From Network</a><ul></ul></li>
<li><a href="#install-tftp-server" title="Install TFTP Server">2 Install TFTP Server</a><ul></ul></li>
<li><a href="#copy-kernel-to-tftp-server" title="Copy Kernel to TFTP Server">3 Copy Kernel to TFTP Server</a><ul></ul></li>
<li><a href="#test-u-boot-with-tftp" title="Test U-Boot with TFTP">4 Test U-Boot with TFTP</a><ul></ul></li>
<li><a href="#configure-u-boot-for-tftp" title="Configure U-Boot for TFTP">5 Configure U-Boot for TFTP</a><ul></ul></li>
<li><a href="#whats-next" title="What‚Äôs Next">6 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-boot-script-for-u-boot-bootloader" title="Appendix: Boot Script for U-Boot Bootloader">7 Appendix: Boot Script for U-Boot Bootloader</a><ul>
<li><a href="#boot-from-mmc0" title="Boot from MMC0">7.1 Boot from MMC0</a><ul></ul></li>
<li><a href="#boot-from-dhcp" title="Boot from DHCP">7.2 Boot from DHCP</a><ul></ul></li></ul></li>
<li><a href="#appendix-commands-for-u-boot-bootloader" title="Appendix: Commands for U-Boot Bootloader">8 Appendix: Commands for U-Boot Bootloader</a><ul>
<li><a href="#dhcp-command" title="dhcp Command">8.1 dhcp Command</a><ul></ul></li>
<li><a href="#tftpboot-command" title="tftpboot Command">8.2 tftpboot Command</a><ul></ul></li>
<li><a href="#booti-command" title="booti Command">8.3 booti Command</a><ul></ul></li>
<li><a href="#bootefi-command" title="bootefi Command">8.4 bootefi Command</a><ul></ul></li>
<li><a href="#fdt-command" title="fdt Command">8.5 fdt Command</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>13 Jul 2023</em></p>
<p><img src="https://lupyuen.github.io/images/tftp-title.jpg" alt="Pine64 Star64 JH7110 64-bit RISC-V SBC" /></p>
<p>Testing a new Operating System like <a href="https://lupyuen.github.io/articles/nuttx2"><strong>Apache NuttX RTOS</strong></a> (or Linux) can get <em>painfully tedious</em> on a Single-Board Computer‚Ä¶</p>
<p>Swapping, reflashing and rebooting a MicroSD Card, <a href="https://lupyuen.github.io/articles/nuttx2#boot-nuttx-on-star64"><strong>again and again and again</strong></a>!</p>
<p><a href="https://github.com/lupyuen/pinephone-nuttx">(Like how we tested <strong>NuttX on PinePhone</strong>)</a></p>
<p>Thankfully there‚Äôs a better way: Booting NuttX (or Linux) over the <strong>Local Network</strong>, with <strong>U-Boot Bootloader</strong> and <strong>TFTP</strong>!</p>
<p>Today we‚Äôll configure TFTP Network Boot on <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a>, the new 64-bit RISC-V Single-Board Computer (SBC).</p>
<p>(Powered by <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> SoC)</p>
<p><a href="https://youtu.be/TdSJdiQFsv8">(Watch the <strong>Demo Video</strong> on YouTube)</a></p>
<p><img src="https://lupyuen.github.io/images/tftp-flow.jpg" alt="Boot from Network with U-Boot and TFTP" /></p>
<h1 id="boot-from-network"><a class="doc-anchor" href="#boot-from-network">¬ß</a>1 Boot From Network</h1>
<p>The pic above shows our <strong>Grand Plan</strong> for today‚Ä¶</p>
<ol start="0">
<li>
<p>We‚Äôll install <strong>TFTP Server</strong> on our Computer</p>
<p>(Which will provide the Kernel Image and Device Tree for Star64)</p>
</li>
<li>
<p>Star64 SBC will fetch the <strong>Kernel Image</strong> from our Computer</p>
<p>(NuttX or Linux)</p>
</li>
<li>
<p>Our SBC will load the <strong>Kernel into RAM</strong></p>
<p>(At RAM Address <code>0x4020</code> <code>0000</code>)</p>
</li>
<li>
<p>Star64 will fetch the <strong>Linux Device Tree</strong> from our Computer</p>
<p>(NuttX doesn‚Äôt need it, but we‚Äôll do it anyway)</p>
</li>
<li>
<p>Our SBC will load the <strong>Device Tree into RAM</strong></p>
<p>(At RAM Address <code>0x4600</code> <code>0000</code>)</p>
</li>
<li>
<p>Our SBC will also fetch and load the <strong>Initial RAM Disk</strong></p>
<p>(At RAM Address <code>0x4610</code> <code>0000</code>)</p>
</li>
<li>
<p>Star64 will <strong>boot the Kernel</strong> from RAM, with the Device Tree and Initial RAM Disk</p>
<p>(NuttX or Linux)</p>
</li>
<li>
<p>We‚Äôll configure the SBC to do this <strong>every time it powers on</strong></p>
<p>(It will try MicroSD first, before the Network Boot)</p>
<p><a href="https://youtu.be/TdSJdiQFsv8">(Watch the Demo on YouTube)</a></p>
</li>
</ol>
<p><em>Do we install anything on our SBC?</em></p>
<p>Everything we need is already in the <strong>Internal Flash Memory</strong> of our SBC!</p>
<p>Inside our SBC Flash Memory is the <a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>U-Boot Bootloader</strong></a>. Which normally boots from MicroSD, but can be configured for <strong>Network Boot</strong>.</p>
<p>Let‚Äôs find out how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tftp-flow2.jpg" alt="TFTP Server" /></p>
<h1 id="install-tftp-server"><a class="doc-anchor" href="#install-tftp-server">¬ß</a>2 Install TFTP Server</h1>
<p><em>What‚Äôs this TFTP Server? (Pic above)</em></p>
<p>That‚Äôs a simple program (running on our Computer) that handles the <a href="https://en.wikipedia.org/wiki/Trivial_File_Transfer_Protocol"><strong>Trivial File Transfer Protocol (TFTP)</strong></a>.</p>
<p>It dishes out files over the <strong>Local Network</strong> (via UDP not TCP), when requested by our SBC.</p>
<p>Follow these steps to install the <a href="https://crates.io/crates/tftpd"><strong><code>tftpd</code> TFTP Server</strong></a> on our Linux / macOS / Windows Computer‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Install `tftpd` in Rust
cargo install tftpd

## Create a folder for the TFTP Files
mkdir $HOME/tftproot

## Start the TFTP Server. Needs `sudo` because
## Port 69 is a privileged low port.
## Send Duplicate Packets to prevent TFTP Timeouts.
## https://lupyuen.github.io/articles/tftp2#send-everything-twice
sudo $HOME/.cargo/bin/tftpd \
  --duplicate-packets 1 \
  -i 0.0.0.0 \
  -p 69 \
  -d &quot;$HOME/tftproot&quot;

## Or use `nohup` to keep it running continuously
nohup sudo $HOME/.cargo/bin/tftpd --duplicate-packets 1 -i 0.0.0.0 -p 69 -d &quot;$HOME/tftproot&quot; &amp;
tail -f nohup.out</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/tftp2#send-everything-twice">(<strong><code>duplicate-packets</code></strong> is needed to prevent TFTP Timeouts)</a></p>
<p><a href="https://community.arm.com/oss-platforms/w/docs/495/tftp-remote-network-kernel-using-u-boot">(<strong><code>xinetd</code> + <code>tftpd</code></strong> might cause TFTP Timeouts)</a></p>
<p>(<a href="https://crates.io/crates/tftp_server"><strong><code>tftp_server</code></strong></a> won‚Äôt work, it only supports localhost)</p>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Running TFTP Server on 0.0.0.0:69 in $HOME/tftproot

## Later we&#39;ll see the dishy files...
## Sending a.txt to 127.0.0.1:57125
##   Sent a.txt to 127.0.0.1:57125
## Sending a.txt to 192.168.x.x:33499
##   Sent a.txt to 192.168.x.x:33499</code></pre></div>
<p>Let‚Äôs <strong>test the server</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Create a Test File for TFTP
echo Test123 &gt;$HOME/tftproot/a.txt

## Fetch the Test File over TFTP.
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
curl -v tftp://127.0.0.1/a.txt
curl -v tftp://192.168.x.x/a.txt</code></pre></div>
<p>(<strong><code>localhost</code></strong> won‚Äôt work because of IPv6, I think)</p>
<p>We should see our <strong>Test File</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>* Trying 192.168.x.x:69...
* getpeername() failed with errno 107: Transport endpoint is not connected
* Connected to 192.168.x.x () port 69 (#0)
* getpeername() failed with errno 107: Transport endpoint is not connected
* set timeouts for state 0; Total  300000, retry 6 maxtry 50
...
Test123</code></pre></div>
<p>(Ignore the warnings)</p>
<p>Our TFTP Server is up! In olden days we would actually do this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ tftp 127.0.0.1
tftp&gt; get a.txt
Received 8 bytes in 0.0 seconds
tftp&gt; quit</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">(Just like <strong>FTP</strong>)</a></p>
<p>But <strong><code>curl</code></strong> is so much simpler!</p>
<p><img src="https://lupyuen.github.io/images/star64-armbian.png" alt="Armbian MicroSD for Star64" /></p>
<p><a href="https://lupyuen.github.io/articles/linux#boot-armbian-linux-on-star64"><em>Armbian MicroSD for Star64</em></a></p>
<h1 id="copy-kernel-to-tftp-server"><a class="doc-anchor" href="#copy-kernel-to-tftp-server">¬ß</a>3 Copy Kernel to TFTP Server</h1>
<p><em>How to copy the Kernel to our TFTP Server?</em></p>
<p>We build <strong>Apache NuttX RTOS</strong> with these steps‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen2/wip-nuttx/releases/tag/star64-0.0.1"><strong>‚ÄúApache NuttX RTOS for Star64‚Äù</strong></a></li>
</ul>
<p>This produces the <a href="https://github.com/lupyuen2/wip-nuttx/releases/download/star64-0.0.1/nuttx.bin"><strong>NuttX Kernel Image <code>nuttx.bin</code></strong></a> that we‚Äôll copy to our TFTP Folder‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy NuttX Binary Image `nuttx.bin` to TFTP Folder
cp nuttx.bin $HOME/tftproot/Image

## Test NuttX Binary Image over TFTP.
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
curl -v tftp://192.168.x.x/Image

## We should see:
## `Warning: Binary output can mess up your terminal`</code></pre></div>
<p><strong>For Linux:</strong> Copy the Linux Kernel File <strong><code>Image</code></strong> to our TFTP Folder.</p>
<p><em>What about the Linux Device Tree?</em></p>
<p>(NuttX won‚Äôt need it, but let‚Äôs do it anyway)</p>
<p><strong>For NuttX:</strong> Copy the Device Tree <a href="https://github.com/starfive-tech/VisionFive2/releases/download/VF2_v3.1.5/jh7110-visionfive-v2.dtb"><strong>jh7110-visionfive-v2.dtb</strong></a> from the <a href="https://github.com/starfive-tech/VisionFive2/releases"><strong>StarFive VisionFive2 Software Releases</strong></a> to our TFTP Folder‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the Device Tree for VisionFive2
wget https://github.com/starfive-tech/VisionFive2/releases/download/VF2_v3.1.5/jh7110-visionfive-v2.dtb

## Rename the Device Tree to Star64
cp \
  jh7110-visionfive-v2.dtb \
  jh7110-star64-pine64.dtb

## Copy to TFTP Folder
cp jh7110-star64-pine64.dtb $HOME/tftproot

## Test the Device Tree over TFTP
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
curl -v tftp://192.168.x.x/jh7110-star64-pine64.dtb

## We should see:
## `Warning: Binary output can mess up your terminal`</code></pre></div>
<p><strong>For Linux:</strong> Just copy the Linux Device Tree <strong>jh7110-star64-pine64.dtb</strong> to our TFTP Folder.</p>
<p>Finally we copy the <strong>Initial RAM Disk ‚Äúinitrd‚Äù</strong> (NuttX or Linux) to our TFTP Folder‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Copy Initial RAM Disk to TFTP Folder
cp initrd $HOME/tftproot

## Test the Initial RAM Disk over TFTP
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
curl -v tftp://192.168.x.x/initrd

## We should see:
## `Warning: Binary output can mess up your terminal`</code></pre></div>
<p>Let‚Äôs test this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/tftp-flow.jpg" alt="Boot from Network with U-Boot and TFTP" /></p>
<h1 id="test-u-boot-with-tftp"><a class="doc-anchor" href="#test-u-boot-with-tftp">¬ß</a>4 Test U-Boot with TFTP</h1>
<p>We‚Äôre ready to test U-Boot Bootloader with TFTP!</p>
<p>Connect Star64 to the <strong>Ethernet Wired Network</strong>. (Pic above)</p>
<p>Connect to the <a href="https://lupyuen.github.io/articles/linux#serial-console-on-star64"><strong>Serial Console</strong></a> and power up without a MicroSD Card.</p>
<p>Star64 <strong>fails to boot</strong> over the network, but that‚Äôs OK‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>BOOTP broadcast 1
  *** Unhandled DHCP Option in OFFER/ACK: 43
  DHCP client bound to address 192.168.x.x (351 ms)

TFTP from server 192.168.x.x; our IP address is 192.168.x.x
  Filename &#39;boot.scr.uimg&#39;.

Load address: 0x43900000
  TFTP server died; starting again

Load address: 0x40200000
  TFTP server died; starting again

StarFive #</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx-star64#u-boot-bootloader-log-for-tftp">(Source)</a></p>
<p>That‚Äôs because we don‚Äôt have a <a href="https://en.wikipedia.org/wiki/Bootstrap_Protocol"><strong>BOOTP Server</strong></a> or a <a href="https://lupyuen.github.io/articles/tftp#boot-from-dhcp"><strong>DHCP+TFTP Combo Server</strong></a>.</p>
<p>Since we have a <a href="https://lupyuen.github.io/articles/tftp#install-tftp-server"><strong>Dedicated TFTP Server</strong></a>, we run these <strong>U-Boot Commands</strong> at the prompt‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set the TFTP Server IP
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
setenv tftp_server 192.168.x.x

## Assume Initial RAM Disk is max 16 MB
setenv ramdisk_size 0x1000000

## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x40200000
## tftp_server=192.168.x.x
tftpboot ${kernel_addr_r} ${tftp_server}:Image

## Load the Device Tree from TFTP Server
## fdt_addr_r=0x46000000
## tftp_server=192.168.x.x
tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb

## Set the RAM Address of Device Tree
## fdt_addr_r=0x46000000
fdt addr ${fdt_addr_r}

## Load Initial RAM Disk over TFTP
## ramdisk_addr_r=0x46100000
## tftp_server=192.168.x.x
tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd

## Boot the NuttX Image with the Initial RAM Disk and Device Tree
## kernel_addr_r=0x40200000
## ramdisk_addr_r=0x46100000
## ramdisk_size=0x1000000
## fdt_addr_r=0x46000000
booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/tftp#tftpboot-command">(<strong>tftpboot</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#fdt-command">(<strong>fdt</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#booti-command">(<strong>booti</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(See the <strong>U-Boot Settings</strong>)</a></p>
<p>Our Star64 SBC shall (pic above)‚Ä¶</p>
<ol>
<li>
<p><strong>Fetch the Kernel</strong> over TFTP</p>
</li>
<li>
<p><strong>Load the Kernel</strong> into RAM</p>
</li>
<li>
<p><strong>Fetch the Device Tree</strong> over TFTP</p>
</li>
<li>
<p><strong>Load the Device Tree</strong> into RAM</p>
</li>
<li>
<p><strong>Load the Initial RAM Disk</strong> into RAM</p>
</li>
<li>
<p><strong>Boot the Kernel</strong></p>
</li>
</ol>
<p>Like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ setenv tftp_server 192.168.x.x

$ setenv ramdisk_size 0x1000000

$ tftpboot ${kernel_addr_r} ${tftp_server}:Image
Filename &#39;Image&#39;.
Load address: 0x40200000
Loading: 221.7 KiB/s done
Bytes transferred = 2097832 (2002a8 hex)

$ tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb
Filename &#39;jh7110-star64-pine64.dtb&#39;.
Load address: 0x46000000
Loading: 374 KiB/s done
Bytes transferred = 50235 (c43b hex)

$ fdt addr ${fdt_addr_r}

$ tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd
Filename &#39;initrd&#39;.
Load address: 0x46100000
Loading: 189.5 KiB/s done
Bytes transferred = 8020992 (7a6400 hex)

$ booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r}
Flattened Device Tree blob at 46000000
Booting using the fdt blob at 0x46000000
Using Device Tree in place at 0000000046000000, end 000000004600f43a</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9325fee202d38a671cd0eb3cfd35a1db">(Source)</a></p>
<p>(It might load quicker if we connect our Computer to the <strong>Ethernet Wired Network</strong>, instead of WiFi)</p>
<p>And NuttX (or Linux) boots magically over the Network, no more MicroSD yay!</p>
<div class="example-wrap"><pre class="language-text"><code>Starting kernel ...
clk u5_dw_i2c_clk_core already disabled
clk u5_dw_i2c_clk_apb already disabled
123067DFAGHBC</code></pre></div>
<p><img src="https://lupyuen.github.io/images/privilege-run1.png" alt="Auto-Boot from Network, every time we power on" /></p>
<h1 id="configure-u-boot-for-tftp"><a class="doc-anchor" href="#configure-u-boot-for-tftp">¬ß</a>5 Configure U-Boot for TFTP</h1>
<p><em>But can we Auto-Boot from Network, every time we power on?</em></p>
<p>Sure can! The trick is to use the <strong>saveenv</strong> command, which will save the U-Boot Settings into the <strong>Internal Flash Memory</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Remember the TFTP Server IP.
## TODO: Change `192.168.x.x` to our Computer&#39;s IP Address
setenv tftp_server 192.168.x.x
## Check that it&#39;s correct
printenv tftp_server
## Save it for future reboots
saveenv

## Assume Initial RAM Disk is max 16 MB
setenv ramdisk_size 0x1000000
## Check that it&#39;s correct
printenv ramdisk_size
## Save it for future reboots
saveenv

## Add the Boot Command for TFTP
setenv bootcmd_tftp &#39;if tftpboot ${kernel_addr_r} ${tftp_server}:Image ; then if tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb ; then if fdt addr ${fdt_addr_r} ; then if tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd ; then booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r} ; fi ; fi ; fi ; fi&#39;
## Check that it&#39;s correct
printenv bootcmd_tftp
## Save it for future reboots
saveenv

## Test the Boot Command for TFTP, then reboot
run bootcmd_tftp

## Remember the Original Boot Targets
setenv orig_boot_targets &quot;$boot_targets&quot;
## Should show `mmc0 dhcp`
printenv boot_targets
## Save it for future reboots
saveenv

## Add TFTP to the Boot Targets
setenv boot_targets &quot;$boot_targets tftp&quot;
## Should show `mmc0 dhcp  tftp`
printenv boot_targets
## Save it for future reboots
saveenv</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(See the <strong>U-Boot Settings</strong>)</a></p>
<p><a href="https://github.com/lupyuen/nuttx-star64#u-boot-bootloader-log-for-auto-network-boot">(See the <strong>Network Boot Log</strong>)</a></p>
<p>Now Star64 will <strong>Auto-Boot from the Network</strong>, every time we power up! (Pic above)</p>
<p><a href="https://youtu.be/TdSJdiQFsv8">(Watch the <strong>Demo Video</strong> on YouTube)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#appendix-boot-script-for-u-boot-bootloader">(It will try to boot from <strong>MicroSD before Network</strong>)</a></p>
<p><em>What if we change our mind?</em></p>
<p>We can switch back to the <strong>Original Boot Targets</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Restore the Boot Targets
setenv boot_targets &quot;$orig_boot_targets&quot;
## Should show `mmc0 dhcp`
printenv boot_targets
## Save it for future reboots
saveenv</code></pre></div>
<p><em>What‚Äôs boot_targets?</em></p>
<p>U-Boot Bootloader defines a list of <strong>Targets for Auto-Booting</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## On Power Up: Try booting from MicroSD,
## then from DHCP+TFTP Combo Server
boot_targets=mmc0 dhcp </code></pre></div>
<p>We added <strong>TFTP to the Boot Targets</strong> (pardon the space)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## We added TFTP to the Boot Targets
boot_targets=mmc0 dhcp  tftp</code></pre></div>
<p>Thus U-Boot will execute our TFTP Boot Script <strong>bootcmd_tftp</strong> at startup.</p>
<p><a href="https://lupyuen.github.io/articles/tftp#appendix-boot-script-for-u-boot-bootloader">(As explained here)</a></p>
<p><em>What‚Äôs bootcmd_tftp?</em></p>
<p><strong>bootcmd_tftp</strong> expands to this U-Boot Script‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Load the NuttX Image from TFTP Server
## kernel_addr_r=0x40200000
## tftp_server=192.168.x.x
if tftpboot ${kernel_addr_r} ${tftp_server}:Image;
then

  ## Load the Device Tree from TFTP Server
  ## fdt_addr_r=0x46000000
  if tftpboot ${fdt_addr_r} ${tftp_server}:jh7110-star64-pine64.dtb;
  then

    ## Set the RAM Address of Device Tree
    ## fdt_addr_r=0x46000000
    if fdt addr ${fdt_addr_r};
    then

      ## Load the Intial RAM Disk from TFTP Server
      ## ramdisk_addr_r=0x46100000
      if tftpboot ${ramdisk_addr_r} ${tftp_server}:initrd;
      then

        ## Boot the NuttX Image with the Initial RAM Disk and Device Tree
        ## kernel_addr_r=0x40200000
        ## ramdisk_addr_r=0x46100000
        ## ramdisk_size=0x1000000
        ## fdt_addr_r=0x46000000
        booti ${kernel_addr_r} ${ramdisk_addr_r}:${ramdisk_size} ${fdt_addr_r};
      fi;
    fi;
  fi;
fi</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(See the <strong>U-Boot Settings</strong>)</a></p>
<p>Which does the same thing as the previous section: Boot NuttX (or Linux) over the Network at startup.</p>
<p><a href="https://lupyuen.github.io/articles/tftp#appendix-boot-script-for-u-boot-bootloader">(As explained here)</a></p>
<p><a href="https://community.arm.com/oss-platforms/w/docs/495/tftp-remote-network-kernel-using-u-boot">(Thanks to this article)</a></p>
<p><em>Hmmm why do we see TFTP Timeouts?</em></p>
<p>Yeah <strong>frequent TFTP Timeouts</strong> (‚ÄúT‚Äù below) are affecting our NuttX Testing on Star64 JH7110 SBC.  Effective Transfer Rate is only 430 kbps!</p>
<div class="example-wrap"><pre class="language-text"><code>Loading: . ##############T ###################################################
. ####################T #########T ####################################
. 53.7 KiB/s</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9bdb1f5478318631d0480f03f6041d83#file-jh7110-nuttx-math-log-L140-L173">(Source)</a></p>
<p>Check out the solution here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tftp2"><strong>‚ÄúStrange Workaround for TFTP Timeout in U-Boot Bootloader (Star64 JH7110 RISC-V SBC)‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/tftp-home.png" alt="Home Assistant controls our Smart Power Plug)" /></p>
<p><a href="https://github.com/lupyuen2/autotest-nuttx-sg2000#control-our-sbc-with-an-ikea-smart-power-plug-and-home-assistant"><em>Home Assistant controls our Smart Power Plug</em></a></p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>6 What‚Äôs Next</h1>
<p>With Network Boot running, we‚Äôre now ready for <strong>Automated Testing of Apache NuttX RTOS</strong> on Star64 SBC!</p>
<p><a href="https://github.com/lupyuen2/autotest-nuttx-sg2000#control-our-sbc-with-an-ikea-smart-power-plug-and-home-assistant">(With a <strong>Smart Power Plug</strong> and <strong>Home Assistant</strong> to reboot our SBC)</a></p>
<p>Porting NuttX to Star64 JH7110 becomes so much faster. Stay tuned for updates!</p>
<p>Many Thanks to my <a href="https://lupyuen.github.io/articles/sponsor"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/sponsor"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=36704622"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://forum.pine64.org/showthread.php?tid=18483"><strong>Discuss this article on Pine64 Forum</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tftp.md"><strong>lupyuen.github.io/src/tftp.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/privilege-run1.png" alt="Auto-Boot from Network, every time we power on" /></p>
<h1 id="appendix-boot-script-for-u-boot-bootloader"><a class="doc-anchor" href="#appendix-boot-script-for-u-boot-bootloader">¬ß</a>7 Appendix: Boot Script for U-Boot Bootloader</h1>
<p><em>Earlier we saw boot_targets and bootcmd_tftp. How do they work?</em></p>
<p>We talked about <strong>boot_targets</strong> and <strong>bootcmd_tftp</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp"><strong>‚ÄúConfigure U-Boot for TFTP‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs figure out how they will <strong>Auto-Boot NuttX</strong> (or Linux) from the Network‚Ä¶</p>
<ol>
<li>
<p>At startup, U-Boot Bootloader always executes the <strong>Boot Script</strong> in <a href="https://u-boot.readthedocs.io/en/latest/usage/environment.html#list-of-environment-variables"><strong>bootcmd</strong></a>.</p>
</li>
<li>
<p><strong>bootcmd</strong> is set to‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Load the VisionFive 2 Environment from MMC
run load_vf2_env;

## Load the Boot Environment from MMC
run importbootenv;

## Load the Distro Environment from MMC
run load_distro_uenv;

## Run the `boot2` script (missing)
run boot2;

## For every Boot Target:
## Run the Boot Command 
run distro_bootcmd</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(Source)</a></p>
<p>Which executes <strong>distro_bootcmd</strong></p>
</li>
<li>
<p><strong>distro_bootcmd</strong> is set to‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Every Boot Target...
for target in ${boot_targets};

  ## Run the Boot Command for the Target
  do run bootcmd_${target};
done</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(Source)</a></p>
</li>
<li>
<p>Previously we changed <strong>boot_targets</strong> to‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>mmc0 dhcp  tftp</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp">(Source)</a></p>
<p>Which means U-Boot will execute this sequence‚Ä¶</p>
<ul>
<li>
<p><strong>bootcmd_mmc0</strong>: Try to boot from MicroSD</p>
<p>(See below)</p>
</li>
<li>
<p><strong>bootcmd_dhcp</strong>: Try to boot from DHCP+TFTP Combo Server</p>
<p>(See below)</p>
</li>
<li>
<p><strong>bootcmd_tftp</strong>: Try to boot from TFTP</p>
</li>
</ul>
</li>
<li>
<p>We saw <strong>bootcmd_tftp</strong> earlier‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp"><strong>‚ÄúConfigure U-Boot for TFTP‚Äù</strong></a></p>
<p>It boots NuttX (or Linux) over the Network via TFTP.</p>
</li>
</ol>
<p>And that‚Äôs how U-Boot Bootloader boots NuttX (or Linux) over the Network at startup!</p>
<p><strong>Note:</strong> Don‚Äôt use the special variable <strong>serverip</strong>, it will change after running <a href="https://lupyuen.github.io/articles/tftp#tftpboot-command"><strong>tftpboot</strong></a>!</p>
<h2 id="boot-from-mmc0"><a class="doc-anchor" href="#boot-from-mmc0">¬ß</a>7.1 Boot from MMC0</h2>
<p><em>What‚Äôs in bootcmd_mmc0?</em></p>
<p><strong>bootcmd_mmc0</strong> tries to boot from MicroSD‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Set Device Number
devnum=0;

## Boot from MMC
run mmc_boot</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(Source)</a></p>
<p><strong>mmc_boot</strong> is‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>if mmc dev ${devnum};
then 
  devtype=mmc;
  run scan_dev_for_boot_part;
fi;

mmcbootenv=run scan_mmc_dev;
setenv bootpart ${devnum}:${mmcpart};

if mmc rescan;
then 
  run loadbootenv &amp;&amp; run importbootenv;
  run ext4bootenv &amp;&amp; run importbootenv;

  if test -n $uenvcmd;
  then
    echo Running uenvcmd ...;
    run uenvcmd;
  fi;
fi</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(Source)</a></p>
<h2 id="boot-from-dhcp"><a class="doc-anchor" href="#boot-from-dhcp">¬ß</a>7.2 Boot from DHCP</h2>
<p><em>What about bootcmd_dhcp?</em></p>
<p><strong>bootcmd_dhcp</strong> tries to boot from DHCP+TFTP Combo Server.</p>
<p>It assumes that the DHCP Server is also a TFTP Server.</p>
<p><a href="https://u-boot.readthedocs.io/en/latest/usage/environment.html">(We should probably disable <strong>autoload</strong>)</a></p>
<p><strong>bootcmd_dhcp</strong> is set to‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>devtype=dhcp;

## Load the Boot Script from DHCP+TFTP Server
## scriptaddr=0x43900000
## boot_script_dhcp=boot.scr.uimg
if dhcp ${scriptaddr} ${boot_script_dhcp};
then
  source ${scriptaddr};
fi;

## Set the EFI Variables
## fdtfile=starfive/starfive_visionfive2.dtb
setenv efi_fdtfile ${fdtfile};
setenv efi_old_vci ${bootp_vci};
setenv efi_old_arch ${bootp_arch};
setenv bootp_vci PXEClient:Arch:00027:UNDI:003000;
setenv bootp_arch 0x1b;

## Load the Kernel Image from DHCP+TFTP Server...
## kernel_addr_r=0x40200000
if dhcp ${kernel_addr_r};
then

  ## Load the Device Tree from the DHCP+TFTP Server
  ## fdt_addr_r=0x46000000
  ## efi_fdtfile=starfive/starfive_visionfive2.dtb
  tftpboot ${fdt_addr_r} dtb/${efi_fdtfile};

  ## Set the RAM Address of Device Tree
  ## fdt_addr_r=0x46000000
  if fdt addr ${fdt_addr_r};
  then

    ## Boot the EFI Kernel Image
    ## fdt_addr_r=0x46000000
    bootefi ${kernel_addr_r} ${fdt_addr_r};
  else

    ## Boot the EFI Kernel Image
    ## fdtcontroladdr=fffc6aa0
    bootefi ${kernel_addr_r} ${fdtcontroladdr};
  fi;
fi;

## Unset the EFI Variables
setenv bootp_vci ${efi_old_vci};
setenv bootp_arch ${efi_old_arch};
setenv efi_fdtfile;
setenv efi_old_arch;
setenv efi_old_vci;</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64">(Source)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#dhcp-command">(<strong>dhcp</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#tftpboot-command">(<strong>tftpboot</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#fdt-command">(<strong>fdt</strong> explained here)</a></p>
<p><a href="https://lupyuen.github.io/articles/tftp#booti-command">(<strong>booti</strong> explained here)</a></p>
<p>We used this as the template for our TFTP Boot Script <a href="https://lupyuen.github.io/articles/tftp#configure-u-boot-for-tftp"><strong><strong>bootcmd_tftp</strong></strong></a>.</p>
<h1 id="appendix-commands-for-u-boot-bootloader"><a class="doc-anchor" href="#appendix-commands-for-u-boot-bootloader">¬ß</a>8 Appendix: Commands for U-Boot Bootloader</h1>
<p>We talked about the <strong>U-Boot Bootloader</strong> in previous articles‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-bootloader-for-star64"><strong>‚ÄúU-Boot Bootloader for Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/linux#appendix-u-boot-bootloader-log-for-star64"><strong>‚ÄúU-Boot Bootloader Log for Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-settings-for-star64"><strong>‚ÄúU-Boot Settings for Star64‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/linux#u-boot-commands-for-star64"><strong>‚ÄúU-Boot Commands for Star64‚Äù</strong></a></p>
</li>
</ul>
<p>Below are the <strong>U-Boot Bootloader Commands</strong> mentioned in this article.</p>
<p>We ran ‚Äúhelp &lt;command&gt;‚Äù to explain the commands‚Ä¶</p>
<h2 id="dhcp-command"><a class="doc-anchor" href="#dhcp-command">¬ß</a>8.1 dhcp Command</h2>
<p><strong>dhcp</strong> - boot image via network using DHCP/TFTP protocol</p>
<ul>
<li><strong>dhcp</strong> [loadAddress] [[hostIPaddr:]bootfilename]</li>
</ul>
<p><a href="https://github.com/u-boot/u-boot/blob/master/cmd/net.c#L144-L150">(Source)</a></p>
<h2 id="tftpboot-command"><a class="doc-anchor" href="#tftpboot-command">¬ß</a>8.2 tftpboot Command</h2>
<p><strong>tftpboot</strong> - boot image via network using TFTP protocol</p>
<ul>
<li><strong>tftpboot</strong> [loadAddress] [[hostIPaddr:]bootfilename]</li>
</ul>
<p><a href="https://github.com/u-boot/u-boot/blob/master/cmd/net.c#L61-L69">(Source)</a></p>
<p>(Same as <strong>dhcp</strong> Command?)</p>
<p><strong>Note:</strong> Don‚Äôt use the special variable <a href="https://community.arm.com/oss-platforms/w/docs/495/tftp-remote-network-kernel-using-u-boot"><strong>serverip</strong></a>, it will change after running <a href="https://lupyuen.github.io/articles/tftp#tftpboot-command"><strong>tftpboot</strong></a>!</p>
<h2 id="booti-command"><a class="doc-anchor" href="#booti-command">¬ß</a>8.3 booti Command</h2>
<p><strong>booti</strong> - boot Linux kernel ‚ÄòImage‚Äô format from memory</p>
<ul>
<li>
<p><strong>booti</strong> [addr [initrd[:size]] [fdt]]</p>
<p>boot Linux flat or compressed ‚ÄòImage‚Äô stored at ‚Äòaddr‚Äô</p>
<p>The argument ‚Äòinitrd‚Äô is optional and specifies the address
of an initrd in memory. The optional parameter ‚Äò:size‚Äô allows
specifying the size of a RAW initrd.</p>
<p>Currently only booting from gz, bz2, lzma and lz4 compression
types are supported. In order to boot from any of these compressed
images, user have to set kernel_comp_addr_r and kernel_comp_size environment
variables beforehand.</p>
<p>Since booting a Linux kernel requires a flat device-tree, a
third argument providing the address of the device-tree blob
is required. To boot a kernel with a device-tree blob but
without an initrd image, use a ‚Äò-‚Äô for the initrd argument.</p>
</li>
</ul>
<p><a href="https://github.com/u-boot/u-boot/blob/master/cmd/net.c#L61-L69">(Source)</a></p>
<h2 id="bootefi-command"><a class="doc-anchor" href="#bootefi-command">¬ß</a>8.4 bootefi Command</h2>
<p><strong>bootefi</strong> - Boots an EFI payload from memory</p>
<ul>
<li>
<p><strong>bootefi</strong> &lt;image address&gt; [fdt address]</p>
<p>boot EFI payload stored at address &lt;image address&gt;.</p>
<p>If specified, the device tree located at &lt;fdt address&gt; gets
exposed as EFI configuration table.</p>
</li>
<li>
<p><strong>bootefi</strong> bootmgr [fdt address]</p>
<p>load and boot EFI payload based on BootOrder/BootXXXX variables.</p>
<p>If specified, the device tree located at &lt;fdt address&gt; gets
exposed as EFI configuration table.</p>
</li>
</ul>
<p><a href="https://github.com/u-boot/u-boot/blob/master/cmd/bootefi.c#L724-L733">(Source)</a></p>
<p><em>Will it work for NuttX?</em></p>
<p>Nope it won‚Äôt, since NuttX isn‚Äôt a UEFI Binary‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>$ bootefi ${kernel_addr_r} ${fdt_addr_r}
Card did not respond to voltage select! : -110
Card did not respond to voltage select! : -110
No EFI system partition
No UEFI binary known at 0x40200000</code></pre></div>
<p>That‚Äôs why we call <a href="https://lupyuen.github.io/articles/tftp#booti-command"><strong>booti</strong></a> to boot NuttX.</p>
<h2 id="fdt-command"><a class="doc-anchor" href="#fdt-command">¬ß</a>8.5 fdt Command</h2>
<p><strong>fdt</strong> - flattened device tree utility commands</p>
<ul>
<li>
<p><strong>fdt</strong> addr [-c]  &lt;addr&gt; [&lt;length&gt;]</p>
<p>Set the [control] fdt location to &lt;addr&gt;</p>
</li>
<li>
<p><strong>fdt</strong> apply &lt;addr&gt;</p>
<p>Apply overlay to the DT</p>
</li>
<li>
<p><strong>fdt</strong> move   &lt;fdt&gt; &lt;newaddr&gt; &lt;length&gt;</p>
<p>Copy the fdt to &lt;addr&gt; and make it active</p>
</li>
<li>
<p><strong>fdt</strong> resize [&lt;extrasize&gt;]</p>
<p>Resize fdt to size + padding to 4k addr + some optional &lt;extrasize&gt; if needed</p>
</li>
<li>
<p><strong>fdt</strong> print  &lt;path&gt; [&lt;prop&gt;]</p>
<p>Recursive print starting at &lt;path&gt;</p>
</li>
<li>
<p><strong>fdt</strong> list   &lt;path&gt; [&lt;prop&gt;]</p>
<p>Print one level starting at &lt;path&gt;</p>
</li>
<li>
<p><strong>fdt</strong> get value &lt;var&gt; &lt;path&gt; &lt;prop&gt;</p>
<p>Get &lt;property&gt; and store in &lt;var&gt;</p>
</li>
<li>
<p><strong>fdt</strong> get name &lt;var&gt; &lt;path&gt; &lt;index&gt;</p>
<p>Get name of node &lt;index&gt; and store in &lt;var&gt;</p>
</li>
<li>
<p><strong>fdt</strong> get addr &lt;var&gt; &lt;path&gt; &lt;prop&gt;</p>
<p>Get start address of &lt;property&gt; and store in &lt;var&gt;</p>
</li>
<li>
<p><strong>fdt</strong> get size &lt;var&gt; &lt;path&gt; [&lt;prop&gt;]</p>
<p>Get size of [&lt;property&gt;] or num nodes and store in &lt;var&gt;</p>
</li>
<li>
<p><strong>fdt</strong> set    &lt;path&gt; &lt;prop&gt; [&lt;val&gt;]</p>
<p>Set &lt;property&gt; [to &lt;val&gt;]</p>
</li>
<li>
<p><strong>fdt</strong> mknode &lt;path&gt; &lt;node&gt;</p>
<p>Create a new node after &lt;path&gt;</p>
</li>
<li>
<p><strong>fdt</strong> rm     &lt;path&gt; [&lt;prop&gt;]</p>
<p>Delete the node or &lt;property&gt;</p>
</li>
<li>
<p><strong>fdt</strong> header [get &lt;var&gt; &lt;member&gt;]</p>
<p>Display header info</p>
<p>get - get header member &lt;member&gt; and store it in &lt;var&gt;</p>
</li>
<li>
<p><strong>fdt</strong> bootcpu &lt;id&gt;</p>
<p>Set boot cpuid</p>
</li>
<li>
<p><strong>fdt</strong> memory &lt;addr&gt; &lt;size&gt;</p>
<p>Add/Update memory node</p>
</li>
<li>
<p><strong>fdt</strong> rsvmem print</p>
<p>Show current mem reserves</p>
</li>
<li>
<p><strong>fdt</strong> rsvmem add &lt;addr&gt; &lt;size&gt;</p>
<p>Add a mem reserve</p>
</li>
<li>
<p><strong>fdt</strong> rsvmem delete &lt;index&gt;</p>
<p>Delete a mem reserves</p>
</li>
<li>
<p><strong>fdt</strong> chosen [&lt;start&gt; &lt;end&gt;]</p>
<p>Add/update the /chosen branch in the tree</p>
<p>&lt;start&gt;/&lt;end&gt; - initrd start/end addr</p>
</li>
</ul>
<p><strong>Note:</strong> Dereference aliases by omitting the leading ‚Äò/‚Äô, e.g. fdt print ethernet0.</p>
<p><a href="https://github.com/u-boot/u-boot/blob/master/cmd/fdt.c#L1114-L1162">(Source)</a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>