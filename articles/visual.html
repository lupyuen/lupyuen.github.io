<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Visual Programming with Zig and NuttX Sensors</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Visual Programming with Zig and NuttX Sensors" 
    data-rh="true">
<meta property="og:description" 
    content="What if we could drag-and-drop NuttX Sensors... To create IoT Sensor Apps in Zig? Let's find out!"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/visual-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Visual Programming with Zig and NuttX Sensors</h1>
    <nav id="TOC"><ul>
<li><a href="#blockly-for-iot-sensor-apps">1 Blockly for IoT Sensor Apps</a><ul></ul></li>
<li><a href="#nuttx-blocks">2 NuttX Blocks</a><ul>
<li><a href="#bme280-sensor-block">2.1 BME280 Sensor Block</a><ul></ul></li>
<li><a href="#compose-message-block">2.2 Compose Message Block</a><ul></ul></li>
<li><a href="#transmit-message-block">2.3 Transmit Message Block</a><ul></ul></li>
<li><a href="#every-block">2.4 Every Block</a><ul></ul></li></ul></li>
<li><a href="#test-nuttx-blocks">3 Test NuttX Blocks</a><ul></ul></li>
<li><a href="#connect-bme280-sensor">4 Connect BME280 Sensor</a><ul></ul></li>
<li><a href="#compile-zig-app">5 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">6 Run Zig App</a><ul></ul></li>
<li><a href="#why-zig">7 Why Zig</a><ul>
<li><a href="#type-inference">7.1 Type Inference</a><ul></ul></li>
<li><a href="#compile-time-expressions">7.2 Compile-Time Expressions</a><ul></ul></li>
<li><a href="#variable-arguments">7.3 Variable Arguments</a><ul></ul></li></ul></li>
<li><a href="#real-world-complications">8 Real World Complications</a><ul></ul></li>
<li><a href="#upcoming-fixes">9 Upcoming Fixes</a><ul>
<li><a href="#multithreading-and-synchronisation">9.1 Multithreading and Synchronisation</a><ul></ul></li>
<li><a href="#network-constraints">9.2 Network Constraints</a><ul></ul></li>
<li><a href="#message-constraints">9.3 Message Constraints</a><ul></ul></li>
<li><a href="#blockly-limitations">9.4 Blockly Limitations</a><ul></ul></li></ul></li>
<li><a href="#visual-arduino">10 Visual Arduino?</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-read-sensor-data">13 Appendix: Read Sensor Data</a><ul></ul></li>
<li><a href="#appendix-encode-sensor-data">14 Appendix: Encode Sensor Data</a><ul></ul></li>
<li><a href="#appendix-transmit-sensor-data">15 Appendix: Transmit Sensor Data</a><ul></ul></li>
<li><a href="#appendix-create-custom-blocks">16 Appendix: Create Custom Blocks</a><ul></ul></li></ul></nav><p>üìù <em>20 Aug 2022</em></p>
<p><img src="https://lupyuen.github.io/images/visual-title.jpg" alt="Visual Programming with Zig and NuttX Sensors on Blockly" /></p>
<p><em>What if we could drag-and-drop NuttX Sensors‚Ä¶ To create quick prototypes for IoT Sensor Apps?</em></p>
<p>Let‚Äôs do it! The pic above shows the <strong>IoT Sensor App</strong> that we‚Äôll build with <strong>Visual Programming</strong>, the drag-and-drag way.</p>
<p>This produces a <a href="https://ziglang.org/"><strong>Zig Program</strong></a> that will‚Ä¶</p>
<ul>
<li>
<p>Read the Sensor Data from a <strong>NuttX Sensor</strong> (like Bosch BME280)</p>
</li>
<li>
<p>Encode the Sensor Data (with CBOR)</p>
</li>
<li>
<p>Transmit the encoded data to a <strong>Wireless IoT Network</strong> (like LoRaWAN)</p>
</li>
</ul>
<p>And it has been tested with <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a>. (Pic below)</p>
<p><em>Why are we doing this?</em></p>
<p>Programming NuttX Sensors today feels rather cumbersome, with lots of <strong>Boilerplate Code</strong> and Error Handling. Which might overwhelm those among us who are new to NuttX Sensors.</p>
<p>Perhaps we can wrap the code into a <strong>Visual Component</strong> that we‚Äôll simply pick and drop into our program?</p>
<p>This might also be perfect for <strong>quick experiments</strong> with various NuttX Sensors.</p>
<p>(More about this below)</p>
<p><em>Why Zig?</em></p>
<p>Zig has neat features (like <strong>Type Inference</strong> and <strong>Compile-Time Expressions</strong>) that will greatly simplify the code that‚Äôs auto-generated for our Visual Program.</p>
<p>We could have done this in C‚Ä¶ But it would‚Äôve taken a lot more time and effort.</p>
<p>(We‚Äôll come back to this)</p>
<p><em>Let‚Äôs get started!</em></p>
<p>We‚Äôll head down into the Source Code for our project‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx"><strong>lupyuen/visual-zig-nuttx</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx"><strong>lupyuen3/blockly-zig-nuttx</strong></a></p>
</li>
</ul>
<p>And learn how how we ended up here‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><strong>Blockly with Zig and NuttX (Work in Progress)</strong></a></p>
</li>
<li>
<p><a href="https://youtu.be/GL2VWO4wNcA"><strong>Watch the Demo on YouTube</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)" /></p>
<p><a href="https://lupyuen.github.io/articles/spi2"><em>PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)</em></a></p>
<h1 id="blockly-for-iot-sensor-apps"><a href="#blockly-for-iot-sensor-apps">1 Blockly for IoT Sensor Apps</a></h1>
<p><em>What‚Äôs an IoT Sensor App anyway?</em></p>
<p>Suppose we‚Äôre building an <strong>IoT Sensor Device</strong> that will monitor Temperature, Humidity and Air Pressure.</p>
<p>The firmware in our device will periodically <strong>read and transmit the Sensor Data</strong> like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/blockly-iot.jpg" alt="IoT Sensor App" /></p>
<p>Which we might build as an <strong>IoT Sensor App</strong> like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App in Blockly" /></p>
<p>That‚Äôs our focus for today: Create NuttX Firmware that will‚Ä¶</p>
<ul>
<li>
<p><strong>Read</strong> a NuttX Sensor (like Bosch BME280)</p>
</li>
<li>
<p><strong>Encode</strong> the Sensor Data with <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR</strong></a></p>
</li>
<li>
<p><strong>Transmit</strong> the Sensor Data over <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a></p>
</li>
</ul>
<p><em>How will we do the drag-n-drop?</em></p>
<p>We‚Äôll implement the visual coding with <a href="https://developers.google.com/blockly"><strong>Blockly</strong></a>, the Scratch-like browser-based coding toolkit.</p>
<p>Previously we have <strong>customised Blockly</strong> to generate Zig Programs‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></li>
</ul>
<p>Now we‚Äôll extend Blockly to produce IoT Sensor Apps.</p>
<p><img src="https://lupyuen.github.io/images/visual-block8.jpg" alt="NuttX Blocks that we have added to Blockly" /></p>
<p><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><em>NuttX Blocks that we have added to Blockly</em></a></p>
<h1 id="nuttx-blocks"><a href="#nuttx-blocks">2 NuttX Blocks</a></h1>
<p>In Blockly, we create programs by picking and dropping <strong>Interlocking Blocks</strong>.</p>
<p>Each Block will emit <strong>Zig Code</strong> that we‚Äôll compile and run with NuttX.</p>
<p>To support IoT Sensor Apps, we extend Blockly and add the following <strong>NuttX Blocks</strong> (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>BME280 Sensor Block</strong>: Read Temperature / Humidity / Pressure from <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a></p>
</li>
<li>
<p><strong>Compose Message Block</strong>: Compose a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with our Sensor Data</p>
</li>
<li>
<p><strong>Transmit Message Block</strong>: Transmit a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a></p>
</li>
<li>
<p><strong>Every Block</strong>: Do something every X seconds</p>
</li>
</ul>
<p>Let‚Äôs inspect our NuttX Blocks and the Zig Code that they produce.</p>
<p><img src="https://lupyuen.github.io/images/visual-block5.jpg" alt="BME280 Sensor Block" /></p>
<h2 id="bme280-sensor-block"><a href="#bme280-sensor-block">2.1 BME280 Sensor Block</a></h2>
<p>As pictured above, our <strong>BME280 Sensor Block</strong> reads Temperature, Humidity and Pressure from the <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>.</p>
<p>Our Sensor Block will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>try sen.readSensor(           // Read BME280 Sensor
  c.struct_sensor_baro,       // Sensor Data Struct
  &quot;temperature&quot;,              // Sensor Data Field
  &quot;/dev/sensor/sensor_baro0&quot;  // Path of Sensor Device
);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>This calls our Zig Function <a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data"><strong>readSensor</strong></a> to read a NuttX Sensor at the specified path.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(<strong>readSensor</strong> is defined in the Sensor Module <strong>sen</strong>)</a></p>
<p><em>What‚Äôs <code>try</code>?</em></p>
<p>That‚Äôs how we <strong>handle errors</strong> in Zig. If <strong>readSensor</strong> fails with an error, we stop the current function and return the error to the caller.</p>
<p><em>But struct_sensor_baro is not a value, it‚Äôs a Struct Type!</em></p>
<p>Yep <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>struct_sensor_baro</strong></a> is actually a Struct Type that Zig has auto-imported from NuttX. <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355">(As defined here)</a></p>
<p><em>So Zig will let us pass Struct Types to a Function?</em></p>
<p>That‚Äôs the neat thing about Zig‚Ä¶ It will let us pass <strong>Compile-Time Expressions</strong> (like Struct Types) to Zig Functions (like <strong>readSensor</strong>).</p>
<p>The Zig Compiler will <strong>substitute the Struct Type</strong> inside the code for <strong>readSensor</strong>. (Which works like a C Macro)</p>
<p>Another neat thing: <strong>‚Äútemperature‚Äù</strong> above is also a Compile-Time Expression, because it‚Äôs a Field Name in the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct. Metaprogramming gets so cool!</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(More about <strong>readSensor</strong> in the Appendix)</a></p>
<p><em>Why the full path ‚Äú/dev/sensor/sensor_baro0‚Äù? Why not just ‚Äúbaro0‚Äù?</em></p>
<p>Call me stupendously stubborn, but I think it might be better for learners to see the full path of NuttX Sensors?</p>
<p>So we have a better understanding of NuttX Sensors and how to troubleshoot them.</p>
<p><a href="https://github.com/apache/incubator-nuttx/blob/master/drivers/sensors/sensor.c#L50">(The NuttX Sensor Path has just been renamed to ‚Äú/dev/uorb/sensor_baro0‚Äù)</a></p>
<p><em>What about other sensors? BMP280, ADXL345, LSM330, ‚Ä¶</em></p>
<p>We plan to create a <strong>Sensor Block for every sensor</strong> that‚Äôs supported by NuttX.</p>
<p>Thus we can build all kinds of IoT Sensor Apps by dragging-n-dropping the Sensor Blocks for BMP280, ADXL345, LSM330, ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block7b.jpg" alt="Compose Message Block" /></p>
<h2 id="compose-message-block"><a href="#compose-message-block">2.2 Compose Message Block</a></h2>
<p>The <strong>Compose Message Block</strong> composes a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with the specified Keys (Field Names) and Values (Sensor Data).</p>
<p>CBOR Messages usually require <strong>fewer bytes than JSON</strong> to represent the same data. They work better with Low-Bandwidth Networks. (Like LoRaWAN)</p>
<p>The Block above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>const msg = try composeCbor(.{  // Compose CBOR Message
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Which calls our Zig Function <a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data"><strong>composeCbor</strong></a> to create the CBOR Message.</p>
<p><em>What‚Äôs <code>.{ ... }</code>?</em></p>
<p>That‚Äôs how we pass a <strong>Variable Number of Arguments</strong> to a Zig Function.</p>
<p><em>Is it safe? What if we make a mistake and omit a Key or a Value?</em></p>
<p><strong>composeCbor</strong> uses <strong>Compile-Time Validation</strong> to verify that the parameters are OK.</p>
<p>If we omit a Key or a Value (or if they have the wrong Types), the Zig Compiler will stop us during compilation.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data">(<strong>composeCbor</strong> is explained here)</a></p>
<p><img src="https://lupyuen.github.io/images/visual-block7c.jpg" alt="Transmit Message Block" /></p>
<h2 id="transmit-message-block"><a href="#transmit-message-block">2.3 Transmit Message Block</a></h2>
<p>The <strong>Transmit Message Block</strong> (above) transmits a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a> (the low-power, long-range, low-bandwidth IoT Network)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Transmit message to LoRaWAN
try transmitLorawan(msg);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>And probably other <strong>IoT Networks</strong> in future: NB-IoT, LTE-M, Matter, Bluetooth, WiFi, MQTT, ‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-transmit-sensor-data">(<strong>transmitLorawan</strong> is explained here)</a></p>
<p><img src="https://lupyuen.github.io/images/visual-block10.jpg" alt="Every Block" /></p>
<h2 id="every-block"><a href="#every-block">2.4 Every Block</a></h2>
<p>Lastly we have the <strong>Every Block</strong> (above) that executes the Enclosed Blocks every X seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Every 10 seconds...
while (true) {
  // TODO: Enclosed Blocks
  ...

  // Wait 10 seconds
  _ = c.sleep(10);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p><em>What‚Äôs ‚Äú<code>_ = </code>something‚Äù?</em></p>
<p>Zig Compiler helpfully stops us if we forget to use the <strong>Return Value</strong> of a function.</p>
<p>We write ‚Äú<code>_ = ...</code>‚Äù to tell Zig Compiler that we won‚Äôt use the Return Value of the <strong>sleep</strong> function. (Imported from NuttX)</p>
<p><em>Sleepy fish? This sleeping looks fishy‚Ä¶</em></p>
<p>Yep this <strong>sleep</strong> won‚Äôt work for some types of IoT Sensor Apps.</p>
<p>We‚Äôll revisit this in a while.</p>
<p><em>How did we add these NuttX Blocks to Blockly?</em></p>
<p>Blockly provides <strong>Blockly Developer Tools</strong> for creating our Custom Blocks.</p>
<p>We‚Äôll explain below.</p>
<h1 id="test-nuttx-blocks"><a href="#test-nuttx-blocks">3 Test NuttX Blocks</a></h1>
<p>To test the NuttX Blocks, let‚Äôs drag-n-drop an IoT Sensor App that will‚Ä¶</p>
<ul>
<li>
<p><strong>Read Sensor Data:</strong> Read the Temperature, Pressure and Humidity from BME280 Sensor</p>
</li>
<li>
<p><strong>Print Sensor Data:</strong> Print the Temperature, Pressure and Humidity values</p>
</li>
<li>
<p><strong>Compose Message:</strong> Create a CBOR Message with the Temperature, Pressure and Humidity values</p>
</li>
<li>
<p><strong>Transmit Message:</strong> Send the CBOR Message to LoRaWAN</p>
</li>
</ul>
<p>First we download our <strong>Zig Sensor App</strong> (that imports the NuttX Sensor API into Zig)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download our Zig Sensor App for NuttX
git clone --recursive https://github.com/lupyuen/visual-zig-nuttx</code></pre></div>
<p>(We‚Äôll paste our generated Zig Program inside here)</p>
<p>Now head over to our <strong>Custom Blockly Website</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><strong>Blockly with Zig and NuttX (Work in Progress)</strong></a></li>
</ul>
<p>Drag-n-drop the Blocks to assemble this Visual Program‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App" /></p>
<p>To find the above Blocks, click the <strong>Blocks Toolbox</strong> (at left) and look under <strong>‚ÄúSensors‚Äù</strong>, <strong>‚ÄúVariables‚Äù</strong> and <strong>‚ÄúText‚Äù</strong>‚Ä¶</p>
<ul>
<li><a href="https://youtu.be/GL2VWO4wNcA"><strong>Watch the Demo on YouTube</strong></a></li>
</ul>
<p>Note that we read <strong>Humidity</strong> from <strong>‚Äúsensor_humi0‚Äù</strong> instead of ‚Äúsensor_baro0‚Äù.</p>
<p>Click the <strong>Zig Tab</strong>. We‚Äôll see this Zig Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function
pub fn main() !void {

  // Every 10 seconds...
  while (true) {
    const temperature = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_baro,       // Sensor Data Struct
      &quot;temperature&quot;,              // Sensor Data Field
      &quot;/dev/sensor/sensor_baro0&quot;  // Path of Sensor Device
    );
    debug(&quot;temperature={}&quot;, .{ temperature });

    const pressure = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_baro,       // Sensor Data Struct
      &quot;pressure&quot;,                 // Sensor Data Field
      &quot;/dev/sensor/sensor_baro0&quot;  // Path of Sensor Device
    );
    debug(&quot;pressure={}&quot;, .{ pressure });

    const humidity = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_humi,       // Sensor Data Struct
      &quot;humidity&quot;,                 // Sensor Data Field
      &quot;/dev/sensor/sensor_humi0&quot;  // Path of Sensor Device
    );
    debug(&quot;humidity={}&quot;, .{ humidity });

    const msg = try composeCbor(.{  // Compose CBOR Message
      &quot;t&quot;, temperature,
      &quot;p&quot;, pressure,
      &quot;h&quot;, humidity,
    });

    // Transmit message to LoRaWAN
    try transmitLorawan(msg);

    // Wait 10 seconds
    _ = c.sleep(10);
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Copy the code inside the <strong>Main Function</strong>. (Yep copy the <strong>while</strong> loop)</p>
<p>Paste the code inside the <strong>Zig Sensor App</strong> that we have downloaded earlier‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig"><strong>visual-zig-nuttx/visual.zig</strong></a></li>
</ul>
<p>(Look for ‚ÄúPaste Visual Program Here‚Äù)</p>
<p><em>Can we save the Blocks? So we don‚Äôt need to drag them again when retesting?</em></p>
<p>Click the <strong>JSON Tab</strong> and copy the Blockly JSON that appears.</p>
<p>Whenever we reload Blockly, just paste the Blockly JSON back into the JSON Tab. The Blocks will be automagically restored.</p>
<p><a href="https://gist.github.com/lupyuen/f7466a2e208eb68fd01a788c829b57e9">(See the Blockly JSON)</a></p>
<p>We‚Äôre ready to build and test our IoT Sensor App with NuttX! But first we prep our hardware‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-connect.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>
<p><a href="https://lupyuen.github.io/articles/sensor"><em>Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor</em></a></p>
<h1 id="connect-bme280-sensor"><a href="#connect-bme280-sensor">4 Connect BME280 Sensor</a></h1>
<p>For testing our IoT Sensor App, we connect the BME280 Sensor (I2C) to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L91-L98">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN2)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN1)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<h1 id="compile-zig-app"><a href="#compile-zig-app">5 Compile Zig App</a></h1>
<p>Below are the steps to <strong>compile our IoT Sensor App</strong> for NuttX.</p>
<p>First we download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>Apache NuttX RTOS</strong> for BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>The downloaded version of NuttX already includes our <strong>BME280 Driver</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280"><strong>‚ÄúApache NuttX Driver for BME280 Sensor‚Äù</strong></a></li>
</ul>
<p>Check that the following have been enabled in the NuttX Build‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C0 Port</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C Character Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>BME280 Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>Sensor Driver Test App</strong></a></p>
</li>
</ul>
<p>Remember to set <a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>‚ÄúSensor Driver Test Stack Size‚Äù</strong></a> to <strong>4096</strong>.</p>
<p>(Because our Zig App needs additional Stack Space)</p>
<p>After building NuttX, compile our <strong>IoT Sensor App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Zig Sensor App that we have downloaded earlier.
#  TODO: Paste our visual program into visual-zig-nuttx/visual.zig
cd visual-zig-nuttx

#  Compile the Zig App for BL602
#  (RV32IMACF with Hardware Floating-Point)
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  sensortest.zig</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/eddfb4a11ed306d478f47adece9d6e1a">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p>Also specific to BL602 is the <strong>ARCH_RISCV</strong> Macro in <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L11">visual-zig-nuttx/sensor.zig</a></p>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App into the NuttX Firmware.</p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#sensor-test-app-in-c">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Patch the ELF Header of `sensortest.o` from 
#  Soft-Float ABI to Hard-Float ABI
xxd -c 1 sensortest.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - sensortest2.o
cp sensortest2.o sensortest.o</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Copy the compiled app to NuttX and overwrite `sensortest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp sensortest.o $HOME/nuttx/apps/testing/sensortest/sensortest*.o

#  Build NuttX to link the Zig Object from `sensortest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

#  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>We‚Äôre ready to run our IoT Sensor App!</p>
<h1 id="run-zig-app"><a href="#run-zig-app">6 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#flash-nuttx"><strong>‚ÄúFlash NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#run-nuttx"><strong>‚ÄúRun NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our IoT Sensor App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest visual</code></pre></div>
<p>Our IoT Sensor App should correctly read the Temperature, Pressure and Humidity from BME280 Sensor, and transmit the values to LoRaWAN (simulated)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.3.0
nsh&gt; sensortest visual
Zig Sensor Test
Start main

temperature=31.05
pressure=1007.44
humidity=71.49
composeCbor
  t: 31.05
  p: 1007.44
  h: 71.49
  msg=t:31.05,p:1007.44,h:71.49,
transmitLorawan
  msg=t:31.05,p:1007.44,h:71.49,

temperature=31.15
pressure=1007.40
humidity=70.86
composeCbor
  t: 31.15
  p: 1007.40
  h: 70.86
  msg=t:31.15,p:1007.40,h:70.86,
transmitLorawan
  msg=t:31.15,p:1007.40,h:70.86,</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#test-visual-zig-sensor-app">(See the Complete Log)</a></p>
<p>To test the Zig program above on Linux / macOS / Windows (instead of NuttX), add the stubs below to simulate a NuttX Sensor‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx#test-stubs"><strong>‚ÄúTest Stubs‚Äù</strong></a></li>
</ul>
<h1 id="why-zig"><a href="#why-zig">7 Why Zig</a></h1>
<p><em>Once again‚Ä¶ Why are we doing this in Zig?</em></p>
<p>It‚Äôs <strong>easier to generate</strong> Zig Code for our IoT Sensor App. That‚Äôs because Zig supports‚Ä¶</p>
<ol>
<li>
<p><strong>Type Inference</strong></p>
</li>
<li>
<p><strong>Compile-Time Expressions</strong></p>
</li>
<li>
<p><strong>Compile-Time Variable Arguments</strong></p>
</li>
</ol>
<p>We could have programmed Blockly to generate C Code. But it would be messy, here‚Äôs why‚Ä¶</p>
<h2 id="type-inference"><a href="#type-inference">7.1 Type Inference</a></h2>
<p>In many Compiled Languages (including C), we need to <strong>specify the Types</strong> for our Constants (and Variables)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// This is a Float (f32)
const temperature: f32 = try sen.readSensor(...);

// This is a Struct (CborMessage)
const msg: CborMessage = try composeCbor(...);</code></pre></div>
<p>But thanks to <strong>Type Inference</strong>, we may omit the Types in Zig‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Zig infers that this is a Float
const temperature = try sen.readSensor(...);

// Zig infers that this is a Struct
const msg = try composeCbor(...);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>This simplifies the <strong>Code Generation</strong> in Blockly, since we don‚Äôt track the Types.</p>
<h2 id="compile-time-expressions"><a href="#compile-time-expressions">7.2 Compile-Time Expressions</a></h2>
<p>Earlier we saw this for reading the BME280 Sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read Temperature from BME280 Sensor
temperature = try sen.readSensor(
  c.struct_sensor_baro,       // Sensor Data Struct
  &quot;temperature&quot;,              // Sensor Data Field
  &quot;/dev/sensor/sensor_baro0&quot;  // Path of Sensor Device
);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Looks concise and tidy, but <strong>readSensor</strong> has 2 surprises‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>struct_sensor_baro</strong></a> is actually a <strong>Struct Type</strong></p>
<p>(Auto-imported by Zig from NuttX)</p>
</li>
<li>
<p><strong>‚Äútemperature‚Äù</strong> is actually a <strong>Struct Field Name</strong></p>
<p>(From the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct)</p>
</li>
</ul>
<p>The Zig Compiler will <strong>substitute the Struct Type</strong> and Field Name inside the code for <strong>readSensor</strong>. (Which works like a C Macro)</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(More about <strong>readSensor</strong> in the Appendix)</a></p>
<p><em>Is this doable in C?</em></p>
<p>Possibly, if we define a C Macro that embeds the entire <strong>readSensor</strong> function.</p>
<p>(Which might be a headache for maintenance)</p>
<h2 id="variable-arguments"><a href="#variable-arguments">7.3 Variable Arguments</a></h2>
<p>Zig has a neat way of handling <strong>Variable Arguments</strong> at Compile-Time.</p>
<p>Remember <strong>composeCbor</strong> from earlier?</p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose CBOR Message with a 
// Variable Number of Keys and Values
const msg = try composeCbor(.{
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><strong>composeCbor</strong> accepts a <strong>Variable Number of Arguments</strong> and it uses <strong>Compile-Time Validation</strong> to verify that the parameters are OK.</p>
<p>If we omit a Key or a Value (or if they have the wrong Types), the Zig Compiler will stop us during compilation.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data">(<strong>composeCbor</strong> is explained here)</a></p>
<p><em>Could we have done this in C?</em></p>
<p>In C, we would call some <a href="https://github.com/lupyuen/stm32bluepill-mynewt-sensor/blob/master/libs/sensor_coap/include/sensor_coap/sensor_coap.h#L219-L323"><strong>messy macros</strong></a> to validate and manipulate the parameters at Compile-Time.</p>
<p>Or implement as <a href="https://en.cppreference.com/w/c/variadic"><strong>Variadic Functions in C</strong></a>, without the Compile-Time Type Checking.</p>
<p>That‚Äôs why Zig is a better target for Automated Code Generation in Blockly.</p>
<p><img src="https://lupyuen.github.io/images/blockly-iot.jpg" alt="Expected firmware for our IoT Sensor Device" /></p>
<p><a href="https://lupyuen.github.io/articles/visual#blockly-for-iot-sensor-apps"><em>Expected firmware for our IoT Sensor Device</em></a></p>
<h1 id="real-world-complications"><a href="#real-world-complications">8 Real World Complications</a></h1>
<p>Remember earlier we drew the pic above for our <strong>IoT Sensor Firmware</strong>?</p>
<p>Then we kinda glossed over the details and made this <strong>IoT Sensor App</strong>‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App" /></p>
</blockquote>
<p>To run this in the <strong>Real World</strong>, we need some tweaks‚Ä¶</p>
<p><em>Is it really OK to transmit messages to LoRaWAN every 10 seconds?</em></p>
<p>Nope it‚Äôs NOT OK to send messages every 10 seconds! LoRaWAN sets limits on the <strong>Message Rate</strong>.</p>
<p>We can send one LoRaWAN Message roughly <strong>every 60 seconds</strong>.</p>
<p><em>So we tweak the Loop to run every 60 seconds?</em></p>
<p>Well then our Sensor Data (Temperature / Pressure / Humidity) would become <strong>stale and inaccurate</strong>.</p>
<p>We need to <strong>collect and aggregate</strong> the Sensor Data more often.</p>
<p>This means splitting into two loops: <strong>Read Sensor Loop</strong> and <strong>Transmit Loop</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block12.jpg" alt="Multiple Loops" /></p>
<p>(We‚Äôll explain ‚Äúx100‚Äù in the next section)</p>
<p>Missing from the pic: We need to compute the <strong>Average Temperature / Pressure / Humidity</strong> over the past 60 seconds.</p>
<p>And we <strong>transmit the Average Sensor Data</strong>. (Instead of the Raw Sensor Data)</p>
<p>This gives us better Sensor Data through <strong>frequent sampling</strong>, even though we‚Äôre sending one message every minute.</p>
<p>(Some sensors like BME280 can actually do frequent sampling on their own)</p>
<p><em>Will Blockly and Zig support two Loops?</em></p>
<p>Not yet. With two Loops, we have the problem of <strong>Sleepy Fishes</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read Sensor Loop...
while (true) {
  ...
  // Wait 30 seconds
  _ = c.sleep(30);
}

// Transmit Loop...
while (true) {
  ...
  // Wait 60 seconds
  _ = c.sleep(60);
}

// Oops! Transmit Loop will never run!</code></pre></div>
<p>We loop forever (calling <strong>sleep</strong>) in the First Loop, thus we‚Äôll never reach the Second Loop.</p>
<p><em>So we should do this with Timers instead?</em></p>
<p>Yep our Loops shall be implemented with proper <strong>Multithreaded Timers</strong>.</p>
<p>Like from <strong>NimBLE Porting Layer</strong>. (Or just plain NuttX Timers)</p>
<p>Let‚Äôs sum up the tweaks that we need‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-visual.jpg" alt="Grand Plan for our IoT Sensor App" /></p>
<p><em>Grand Plan for our IoT Sensor App</em></p>
<h1 id="upcoming-fixes"><a href="#upcoming-fixes">9 Upcoming Fixes</a></h1>
<p>In the previous section we talked about the <strong>quirks in our IoT Sensor App</strong> and why it won‚Äôt work in the Real World.</p>
<p>This is how we‚Äôll fix it‚Ä¶</p>
<h2 id="multithreading-and-synchronisation"><a href="#multithreading-and-synchronisation">9.1 Multithreading and Synchronisation</a></h2>
<ul>
<li>
<p><strong>sleep</strong> won‚Äôt work for Multiple Loops. We‚Äôll switch to <strong>Multithreaded Timers</strong> instead</p>
<p>(From <strong>NimBLE Porting Layer</strong> or just plain NuttX Timers)</p>
</li>
<li>
<p>Our Read Sensor Loop needs to pass the <strong>Aggregated Sensor Data</strong> to Transmit Loop</p>
</li>
<li>
<p>Since both Loops are running concurrently, we need to <strong>Lock the Sensor Data</strong> during access</p>
<p>(That‚Äôs why the pic above mentions locking and averaging)</p>
</li>
</ul>
<h2 id="network-constraints"><a href="#network-constraints">9.2 Network Constraints</a></h2>
<p>TODO: LoRaWAN message size, frequency</p>
<h2 id="message-constraints"><a href="#message-constraints">9.3 Message Constraints</a></h2>
<p>TODO: scale 100</p>
<p><img src="https://lupyuen.github.io/images/visual-block11.jpg" alt="Compose Message Block, scaled by 100" /></p>
<p>TODO: Test on <a href="https://www.waveshare.com/wiki/Pico-LoRa-SX1262">Waveshare LoRa SX1262 Breakout Board</a> because our current SX1262 board is reserved for <a href="https://lupyuen.github.io/articles/auto">NuttX Automated Testing</a></p>
<p>TODO: Pine64 sensors, <a href="https://www.waveshare.com/wiki/Pico-Environment-Sensor">Waveshare multisensor board</a></p>
<h2 id="blockly-limitations"><a href="#blockly-limitations">9.4 Blockly Limitations</a></h2>
<p>TODO: Const vs var</p>
<p>TODO: Multiple assignment</p>
<h1 id="visual-arduino"><a href="#visual-arduino">10 Visual Arduino?</a></h1>
<p>TODO</p>
<p><a href="https://www.linkedin.com/in/acassis/"><strong>Alan Carvalho de Assis</strong></a> has a brilliant idea for an Embedded Dev Tool that‚Äôs <strong>modular, visual, plug-and-play</strong>‚Ä¶</p>
<blockquote>
<p>‚ÄúI think creating some modular solution to compete with Arduino could be nice! Imagine that instead of wiring modules in the breadboard people just plug the device in the board and it recognize the device and add it to some graphical interface‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúFor example, you just plug a temperature sensor module in your board and it will identify the module type and you can pass this Temperature variable to use in your logic application‚Äù</p>
</blockquote>
<p>What do you think? Please let us know! üôè</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>Check out my earlier work on Zig, NuttX, LoRaWAN and LVGL‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/visual.md"><strong>lupyuen.github.io/src/visual.md</strong></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1557857587667775489"><strong>this Twitter Thread</strong></a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/visual-block1.jpg" alt="BME280 Sensor Block" /></p>
<h1 id="appendix-read-sensor-data"><a href="#appendix-read-sensor-data">13 Appendix: Read Sensor Data</a></h1>
<p>TODO</p>
<p>As pictured above, our <strong>BME280 Sensor Block</strong> reads Temperature, Humidity and Pressure from the <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>.</p>
<p>The Blocks above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read the Temperature
const temperature = try sen.readSensor(
    c.struct_sensor_baro,       // Sensor Data Struct to be read
    &quot;temperature&quot;,              // Sensor Data Field to be returned
    &quot;/dev/sensor/sensor_baro0&quot;  // Path of Sensor Device
);

// Print the Temperature
debug(&quot;temperature={}&quot;, .{ temperature });</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Here‚Äôs the implementation of <code>readSensor</code>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L34-L108">visual-zig-nuttx/sensor.zig</a></p>
<p>Note that the Sensor Data Struct Type and the Sensor Data Field are declared as <code>comptime</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read a Sensor and return the Sensor Data
pub fn readSensor(
    comptime SensorType: type,        // Sensor Data Struct to be read, like c.struct_sensor_baro
    comptime field_name: []const u8,  // Sensor Data Field to be returned, like &quot;temperature&quot;
    device_path: []const u8           // Path of Sensor Device, like &quot;/dev/sensor/sensor_baro0&quot;
) !f32 { ...</code></pre></div>
<p>Which means that the values will be substituted at Compile-Time. (Works like a C Macro)</p>
<p>We can then refer to the Sensor Data Struct <code>sensor_baro</code> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Define the Sensor Data Type
    var sensor_data = std.mem.zeroes(
        SensorType
    );</code></pre></div>
<p>And return a field <code>temperature</code> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Return the Sensor Data Field
    return @field(sensor_data, field_name);</code></pre></div>
<p>Thus this program‚Ä¶</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig#L27-L61">visual-zig-nuttx/visual.zig</a></p>
<p>Produces this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.3.0
nsh&gt; sensortest visual
Zig Sensor Test
Start main
...
temperature=30.18
pressure=1007.69
humidity=68.67
End main</code></pre></div>
<p>TODO</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L34-L108">visual-zig-nuttx/sensor.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read a Sensor and return the Sensor Data
pub fn readSensor(
    comptime SensorType: type,        // Sensor Data Struct to be read, like c.struct_sensor_baro
    comptime field_name: []const u8,  // Sensor Data Field to be returned, like &quot;temperature&quot;
    device_path: []const u8           // Path of Sensor Device, like &quot;/dev/sensor/sensor_baro0&quot;
) !f32 {
    // Open the Sensor Device
    const fd = c.open(
        &amp;device_path[0],           // Path of Sensor Device
        c.O_RDONLY | c.O_NONBLOCK  // Open for read-only
    );

    // Check for error
    if (fd &lt; 0) {
        std.log.err(&quot;Failed to open device:{s}&quot;, .{ c.strerror(errno()) });
        return error.OpenError;
    }

    // Close the Sensor Device when this function returns
    defer {
        _ = c.close(fd);
    }

    // Set Standby Interval
    const interval: c_uint = 1_000_000;  // 1,000,000 microseconds (1 second)
    var ret = c.ioctl(fd, c.SNIOC_SET_INTERVAL, interval);

    // Check for error
    if (ret &lt; 0 and errno() != c.ENOTSUP) {
        std.log.err(&quot;Failed to set interval:{s}&quot;, .{ c.strerror(errno()) });
        return error.IntervalError;
    }

    // Set Batch Latency
    const latency: c_uint = 0;  // No latency
    ret = c.ioctl(fd, c.SNIOC_BATCH, latency);

    // Check for error
    if (ret &lt; 0 and errno() != c.ENOTSUP) {
        std.log.err(&quot;Failed to batch:{s}&quot;, .{ c.strerror(errno()) });
        return error.BatchError;
    }

    // Poll for Sensor Data
    var fds = std.mem.zeroes(c.struct_pollfd);
    fds.fd = fd;
    fds.events = c.POLLIN;
    ret = c.poll(&amp;fds, 1, -1);

    // Check if Sensor Data is available
    if (ret &lt;= 0) {
        std.log.err(&quot;Sensor data not available&quot;, .{});
        return error.DataError;
    }

    // Define the Sensor Data Type
    var sensor_data = std.mem.zeroes(
        SensorType
    );
    const len = @sizeOf(
        @TypeOf(sensor_data)
    );

    // Read the Sensor Data
    const read_len = c.read(fd, &amp;sensor_data, len);

    // Check size of Sensor Data
    if (read_len &lt; len) {
        std.log.err(&quot;Sensor data incorrect size&quot;, .{});
        return error.SizeError;
    }

    // Return the Sensor Data Field
    return @field(sensor_data, field_name);
}</code></pre></div>
<p><a href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/"><strong>‚ÄúZig Metaprogramming‚Äù</strong></a></p>
<p><img src="https://lupyuen.github.io/images/visual-block7b.jpg" alt="Compose Message Block" /></p>
<h1 id="appendix-encode-sensor-data"><a href="#appendix-encode-sensor-data">14 Appendix: Encode Sensor Data</a></h1>
<p>TODO</p>
<p>The <strong>Compose Message Block</strong> composes a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with the specified Keys (Field Names) and Values (Sensor Data).</p>
<p>CBOR Messages usually require <strong>fewer bytes than JSON</strong> to represent the same data. They work better with Low-Bandwidth Networks. (Like LoRaWAN)</p>
<p>The Block above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>const msg = try composeCbor(.{  // Compose CBOR Message
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p><em><code>composeCbor</code> will work for a variable number of arguments? Strings as well as numbers?</em></p>
<p>Yep, here‚Äôs the implementation of <code>composeCbor</code>: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig#L65-L108">visual.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// TODO: Compose CBOR Message with Key-Value Pairs
/// https://lupyuen.github.io/articles/cbor2
fn composeCbor(args: anytype) !CborMessage {
    debug(&quot;composeCbor&quot;, .{});
    comptime {
        assert(args.len % 2 == 0);  // Missing Key or Value
    }

    // Process each field...
    comptime var i: usize = 0;
    var msg = CborMessage{};
    inline while (i &lt; args.len) : (i += 2) {

        // Get the key and value
        const key   = args[i];
        const value = args[i + 1];

        // Print the key and value
        debug(&quot;  {s}: {}&quot;, .{
            @as([]const u8, key),
            floatToFixed(value)
        });

        // Format the message for testing
        var slice = std.fmt.bufPrint(
            msg.buf[msg.len..], 
            &quot;{s}:{},&quot;,
            .{
                @as([]const u8, key),
                floatToFixed(value)
            }
        ) catch { _ = std.log.err(&quot;Error: buf too small&quot;, .{}); return error.Overflow; };
        msg.len += slice.len;
    }
    debug(&quot;  msg={s}&quot;, .{ msg.buf[0..msg.len] });
    return msg;
}

/// TODO: CBOR Message
/// https://lupyuen.github.io/articles/cbor2
const CborMessage = struct {
    buf: [256]u8 = undefined,  // Limit to 256 chars
    len: usize = 0,
};</code></pre></div>
<p>Note that <code>composeCbor</code> is declared as <code>anytype</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>fn composeCbor(args: anytype) { ...</code></pre></div>
<p>That‚Äôs why <code>composeCbor</code> accepts a variable number of arguments with different types.</p>
<p>To handle each argument, this <code>inline</code> / <code>comptime</code> loop is unrolled at Compile-Time‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Process each field...
    comptime var i: usize = 0;
    inline while (i &lt; args.len) : (i += 2) {

        // Get the key and value
        const key   = args[i];
        const value = args[i + 1];

        // Print the key and value
        debug(&quot;  {s}: {}&quot;, .{
            @as([]const u8, key),
            floatToFixed(value)
        });
        ...
    }</code></pre></div>
<p><em>What happens if we omit a Key or a Value when calling <code>composeCbor</code>?</em></p>
<p>This <code>comptime</code> assertion check will fail at Compile-Time‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>comptime {
    assert(args.len % 2 == 0);  // Missing Key or Value
}</code></pre></div>
<p><img src="https://lupyuen.github.io/images/visual-block7c.jpg" alt="Transmit Message Block" /></p>
<h1 id="appendix-transmit-sensor-data"><a href="#appendix-transmit-sensor-data">15 Appendix: Transmit Sensor Data</a></h1>
<p>TODO</p>
<p>The <strong>Transmit Message Block</strong> (above) transmits a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a> (the low-power, long-range, low-bandwidth IoT Network)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Transmit message to LoRaWAN
try transmitLorawan(msg);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<h1 id="appendix-create-custom-blocks"><a href="#appendix-create-custom-blocks">16 Appendix: Create Custom Blocks</a></h1>
<p>TODO: Previously we have <strong>customised Blockly</strong> to generate Zig Programs‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></li>
</ul>
<p>Now we‚Äôll extend Blockly to produce IoT Sensor Apps.</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#custom-block"><strong>‚ÄúCustom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#create-custom-block"><strong>‚ÄúCreate Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#export-custom-block"><strong>‚ÄúExport Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#load-custom-block"><strong>‚ÄúLoad Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#show-custom-block"><strong>‚ÄúShow Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#code-generator-for-custom-block"><strong>‚ÄúCode Generator for Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#build-custom-block"><strong>‚ÄúBuild Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#test-custom-block"><strong>‚ÄúTest Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#custom-extension"><strong>‚ÄúCustom Extension‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#code-generator-for-custom-extension"><strong>‚ÄúCode Generator for Custom Extension‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#test-custom-extension"><strong>‚ÄúTest Custom Extension‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#test-stubs"><strong>‚ÄúTest Stubs‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#transmit-message"><strong>‚ÄúTransmit Message‚Äù</strong></a></p>
</li>
</ul>
<p>TODO3</p>
<p><img src="https://lupyuen.github.io/images/visual-block3.jpg" alt="TODO" /></p>
<p>TODO4</p>
<p><img src="https://lupyuen.github.io/images/visual-block4.jpg" alt="TODO" /></p>
<p>TODO</p>

    
</body>
</html>