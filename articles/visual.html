<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Visual Programming with Zig and NuttX Sensors</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Visual Programming with Zig and NuttX Sensors" 
    data-rh="true">
<meta property="og:description" 
    content="What if we could drag-and-drop NuttX Sensors... To create IoT Sensor Apps in Zig? Let's find out!"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/visual-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Visual Programming with Zig and NuttX Sensors</h1>
    <nav id="TOC"><ul>
<li><a href="#blockly-for-iot-sensor-apps">1 Blockly for IoT Sensor Apps</a><ul></ul></li>
<li><a href="#nuttx-blocks">2 NuttX Blocks</a><ul>
<li><a href="#bme280-sensor-block">2.1 BME280 Sensor Block</a><ul></ul></li>
<li><a href="#compose-message-block">2.2 Compose Message Block</a><ul></ul></li>
<li><a href="#transmit-message-block">2.3 Transmit Message Block</a><ul></ul></li>
<li><a href="#every-block">2.4 Every Block</a><ul></ul></li></ul></li>
<li><a href="#test-nuttx-blocks">3 Test NuttX Blocks</a><ul></ul></li>
<li><a href="#connect-bme280-sensor">4 Connect BME280 Sensor</a><ul></ul></li>
<li><a href="#compile-zig-app">5 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">6 Run Zig App</a><ul></ul></li>
<li><a href="#why-zig">7 Why Zig</a><ul>
<li><a href="#type-inference">7.1 Type Inference</a><ul></ul></li>
<li><a href="#compile-time-expressions">7.2 Compile-Time Expressions</a><ul></ul></li>
<li><a href="#variable-arguments">7.3 Variable Arguments</a><ul></ul></li></ul></li>
<li><a href="#real-world-complications">8 Real World Complications</a><ul></ul></li>
<li><a href="#upcoming-fixes">9 Upcoming Fixes</a><ul>
<li><a href="#multithreading-and-synchronisation">9.1 Multithreading and Synchronisation</a><ul></ul></li>
<li><a href="#message-constraints">9.2 Message Constraints</a><ul></ul></li>
<li><a href="#blockly-limitations">9.3 Blockly Limitations</a><ul></ul></li></ul></li>
<li><a href="#visual-arduino">10 Visual Arduino?</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-read-sensor-data">13 Appendix: Read Sensor Data</a><ul>
<li><a href="#open-sensor-device">13.1 Open Sensor Device</a><ul></ul></li>
<li><a href="#close-sensor-device-deferred">13.2 Close Sensor Device (Deferred)</a><ul></ul></li>
<li><a href="#set-standby-interval">13.3 Set Standby Interval</a><ul></ul></li>
<li><a href="#set-batch-latency">13.4 Set Batch Latency</a><ul></ul></li>
<li><a href="#poll-sensor">13.5 Poll Sensor</a><ul></ul></li>
<li><a href="#read-sensor-data">13.6 Read Sensor Data</a><ul></ul></li>
<li><a href="#return-sensor-data">13.7 Return Sensor Data</a><ul></ul></li></ul></li>
<li><a href="#appendix-encode-sensor-data">14 Appendix: Encode Sensor Data</a><ul></ul></li>
<li><a href="#appendix-transmit-sensor-data">15 Appendix: Transmit Sensor Data</a><ul></ul></li>
<li><a href="#appendix-create-custom-blocks">16 Appendix: Create Custom Blocks</a><ul></ul></li></ul></nav><p>üìù <em>19 Aug 2022</em></p>
<p><img src="https://lupyuen.github.io/images/visual-title.jpg" alt="Visual Programming with Zig and NuttX Sensors on Blockly" /></p>
<p><em>What if we could drag-and-drop NuttX Sensors‚Ä¶ To create quick prototypes for IoT Sensor Apps?</em></p>
<p>Let‚Äôs do it! The pic above shows the <strong>IoT Sensor App</strong> that we‚Äôll build with <strong>Visual Programming</strong>, the drag-and-drag way.</p>
<p>This produces a <a href="https://ziglang.org/"><strong>Zig Program</strong></a> that will‚Ä¶</p>
<ul>
<li>
<p>Read the Sensor Data from a <strong>NuttX Sensor</strong> (like Bosch BME280)</p>
</li>
<li>
<p>Encode the Sensor Data (with CBOR)</p>
</li>
<li>
<p>Transmit the encoded data to a <strong>Wireless IoT Network</strong> (like LoRaWAN)</p>
</li>
</ul>
<p>And it has been tested with <a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 RISC-V Board</strong></a>. (Pic below)</p>
<p><em>Why are we doing this?</em></p>
<p>Programming NuttX Sensors today feels rather cumbersome, with lots of <strong>Boilerplate Code</strong> and Error Handling. Which might overwhelm those among us who are new to NuttX Sensors.</p>
<p>Perhaps we can wrap the code into a <strong>Visual Component</strong> that we‚Äôll simply pick and drop into our program?</p>
<p>This might also be perfect for <strong>quick experiments</strong> with various NuttX Sensors.</p>
<p>(More about this below)</p>
<p><em>Why Zig?</em></p>
<p>Zig has neat features (like <strong>Type Inference</strong> and <strong>Compile-Time Expressions</strong>) that will greatly simplify the code that‚Äôs auto-generated for our Visual Program.</p>
<p>We could have done this in C‚Ä¶ But it would‚Äôve taken a lot more time and effort.</p>
<p>(We‚Äôll come back to this)</p>
<p><em>Let‚Äôs get started!</em></p>
<p>We‚Äôll head down into the Source Code for our project‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx"><strong>lupyuen/visual-zig-nuttx</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx"><strong>lupyuen3/blockly-zig-nuttx</strong></a></p>
</li>
</ul>
<p>And learn how how we ended up here‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><strong>Blockly with Zig and NuttX (Work in Progress)</strong></a></p>
</li>
<li>
<p><a href="https://youtu.be/GL2VWO4wNcA"><strong>Watch the Demo on YouTube</strong></a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/spi2-title.jpg" alt="PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)" /></p>
<p><a href="https://lupyuen.github.io/articles/spi2"><em>PineCone BL602 Board (right) connected to Semtech SX1262 LoRa Transceiver (left)</em></a></p>
<h1 id="blockly-for-iot-sensor-apps"><a href="#blockly-for-iot-sensor-apps">1 Blockly for IoT Sensor Apps</a></h1>
<p><em>What‚Äôs an IoT Sensor App anyway?</em></p>
<p>Suppose we‚Äôre building an <strong>IoT Sensor Device</strong> that will monitor Temperature, Humidity and Air Pressure.</p>
<p>The firmware in our device will periodically <strong>read and transmit the Sensor Data</strong> like this‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/blockly-iot.jpg" alt="IoT Sensor App" /></p>
<p>Which we might build as an <strong>IoT Sensor App</strong> like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App in Blockly" /></p>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<p>That‚Äôs our focus for today: Create NuttX Firmware that will‚Ä¶</p>
<ul>
<li>
<p><strong>Read</strong> a NuttX Sensor (like Bosch BME280)</p>
</li>
<li>
<p><strong>Encode</strong> the Sensor Data with <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR</strong></a></p>
</li>
<li>
<p><strong>Transmit</strong> the Sensor Data over <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a></p>
</li>
</ul>
<p><em>How will we do the drag-n-drop?</em></p>
<p>We‚Äôll implement the visual coding with <a href="https://developers.google.com/blockly"><strong>Blockly</strong></a>, the Scratch-like browser-based coding toolkit.</p>
<p>Previously we have <strong>customised Blockly</strong> to generate Zig Programs‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></li>
</ul>
<p>Now we‚Äôll extend Blockly to produce IoT Sensor Apps.</p>
<p><img src="https://lupyuen.github.io/images/visual-block8.jpg" alt="NuttX Blocks that we have added to Blockly" /></p>
<p><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><em>NuttX Blocks that we have added to Blockly</em></a></p>
<h1 id="nuttx-blocks"><a href="#nuttx-blocks">2 NuttX Blocks</a></h1>
<p>In Blockly, we create programs by picking and dropping <strong>Interlocking Blocks</strong>.</p>
<p>Each Block will emit <strong>Zig Code</strong> that we‚Äôll compile and run with NuttX.</p>
<p>To support IoT Sensor Apps, we extend Blockly and add the following <strong>NuttX Blocks</strong> (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>BME280 Sensor Block</strong>: Read Temperature / Humidity / Pressure from <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a></p>
</li>
<li>
<p><strong>Compose Message Block</strong>: Compose a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with our Sensor Data</p>
</li>
<li>
<p><strong>Transmit Message Block</strong>: Transmit a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a></p>
</li>
<li>
<p><strong>Every Block</strong>: Do something every X seconds</p>
</li>
</ul>
<p>Let‚Äôs inspect our NuttX Blocks and the Zig Code that they produce.</p>
<p><img src="https://lupyuen.github.io/images/visual-block5.jpg" alt="BME280 Sensor Block" /></p>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<h2 id="bme280-sensor-block"><a href="#bme280-sensor-block">2.1 BME280 Sensor Block</a></h2>
<p>As pictured above, our <strong>BME280 Sensor Block</strong> reads Temperature, Humidity and Pressure from the <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>.</p>
<p>Our Sensor Block will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>try sen.readSensor(           // Read BME280 Sensor
  c.struct_sensor_baro,       // Sensor Data Struct
  &quot;temperature&quot;,              // Sensor Data Field
  &quot;/dev/uorb/sensor_baro0&quot;    // Path of Sensor Device
);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>This calls our Zig Function <a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data"><strong>readSensor</strong></a> to read a NuttX Sensor at the specified path.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(<strong>readSensor</strong> is defined in the Sensor Module <strong>sen</strong>)</a></p>
<p><em>What‚Äôs <code>try</code>?</em></p>
<p>That‚Äôs how we <strong>handle errors</strong> in Zig. If <strong>readSensor</strong> fails with an error, we stop the current function and return the error to the caller.</p>
<p><em>But struct_sensor_baro is not a value, it‚Äôs a Struct Type!</em></p>
<p>Yep <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>struct_sensor_baro</strong></a> is actually a Struct Type that Zig has auto-imported from NuttX. <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355">(As defined here)</a></p>
<p><em>So Zig will let us pass Struct Types to a Function?</em></p>
<p>That‚Äôs the neat thing about Zig‚Ä¶ It will let us pass <strong>Compile-Time Expressions</strong> (like Struct Types) to Zig Functions (like <strong>readSensor</strong>).</p>
<p>The Zig Compiler will <strong>substitute the Struct Type</strong> inside the code for <strong>readSensor</strong>. (Which works like a C Macro)</p>
<p>Another neat thing: <strong>‚Äútemperature‚Äù</strong> above is also a Compile-Time Expression, because it‚Äôs a Field Name in the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct. Metaprogramming gets so cool!</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(More about <strong>readSensor</strong> in the Appendix)</a></p>
<p><em>Why the full path ‚Äú/dev/uorb/sensor_baro0‚Äù? Why not just ‚Äúbaro0‚Äù?</em></p>
<p>Call me stupendously stubborn, but I think it might be better for learners to see the full path of NuttX Sensors?</p>
<p>So we have a better understanding of NuttX Sensors and how to troubleshoot them.</p>
<p><em>What about other sensors? BMP280, ADXL345, LSM330, ‚Ä¶</em></p>
<p>We plan to create a <strong>Sensor Block for every sensor</strong> that‚Äôs supported by NuttX.</p>
<p>Thus we can build all kinds of IoT Sensor Apps by dragging-n-dropping the Sensor Blocks for BMP280, ADXL345, LSM330, ‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block7b.jpg" alt="Compose Message Block" /></p>
<h2 id="compose-message-block"><a href="#compose-message-block">2.2 Compose Message Block</a></h2>
<p>The <strong>Compose Message Block</strong> composes a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with the specified Keys (Field Names) and Values (Sensor Data).</p>
<p>(Think of CBOR as a compact, binary form of JSON)</p>
<p>CBOR Messages usually require <strong>fewer bytes than JSON</strong> to represent the same data. They work better with Low-Bandwidth Networks. (Like LoRaWAN)</p>
<p>The Block above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>const msg = try composeCbor(.{  // Compose CBOR Message
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Which calls our Zig Function <a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data"><strong>composeCbor</strong></a> to create the CBOR Message.</p>
<p><em>What‚Äôs <code>.{ ... }</code>?</em></p>
<p>That‚Äôs how we pass a <strong>Variable Number of Arguments</strong> to a Zig Function.</p>
<p><em>Is it safe? What if we make a mistake and omit a Key or a Value?</em></p>
<p><strong>composeCbor</strong> uses <strong>Compile-Time Validation</strong> to verify that the parameters are OK.</p>
<p>If we omit a Key or a Value (or if they have the wrong Types), the Zig Compiler will stop us during compilation.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data">(<strong>composeCbor</strong> is explained here)</a></p>
<p><img src="https://lupyuen.github.io/images/visual-block7c.jpg" alt="Transmit Message Block" /></p>
<h2 id="transmit-message-block"><a href="#transmit-message-block">2.3 Transmit Message Block</a></h2>
<p>The <strong>Transmit Message Block</strong> (above) transmits a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a> (the low-power, long-range, low-bandwidth IoT Network)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Transmit message to LoRaWAN
try transmitLorawan(msg);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>And probably other <strong>IoT Networks</strong> in future: NB-IoT, LTE-M, Matter, Bluetooth, WiFi, MQTT, ‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-transmit-sensor-data">(<strong>transmitLorawan</strong> is explained here)</a></p>
<p><img src="https://lupyuen.github.io/images/visual-block10.jpg" alt="Every Block" /></p>
<h2 id="every-block"><a href="#every-block">2.4 Every Block</a></h2>
<p>Lastly we have the <strong>Every Block</strong> (above) that executes the Enclosed Blocks every X seconds‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Every 10 seconds...
while (true) {
  // TODO: Enclosed Blocks
  ...

  // Wait 10 seconds
  _ = c.sleep(10);
}</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p><em>What‚Äôs ‚Äú<code>_ = </code>something‚Äù?</em></p>
<p>Zig Compiler helpfully stops us if we forget to use the <strong>Return Value</strong> of a function.</p>
<p>We write ‚Äú<code>_ = ...</code>‚Äù to tell Zig Compiler that we won‚Äôt use the Return Value of the <strong>sleep</strong> function. (Imported from NuttX)</p>
<p><em>Sleepy fish? This sleeping looks fishy‚Ä¶</em></p>
<p>Yep this <strong>sleep</strong> won‚Äôt work for some types of IoT Sensor Apps.</p>
<p>We‚Äôll revisit this in a while.</p>
<p><em>How did we add these NuttX Blocks to Blockly?</em></p>
<p>Blockly provides <strong>Blockly Developer Tools</strong> for creating our Custom Blocks.</p>
<p>We‚Äôll explain the steps in the Appendix‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/visual#appendix-create-custom-blocks"><strong>‚ÄúCreate Custom Blocks‚Äù</strong></a></li>
</ul>
<h1 id="test-nuttx-blocks"><a href="#test-nuttx-blocks">3 Test NuttX Blocks</a></h1>
<p>To test the NuttX Blocks, let‚Äôs drag-n-drop an IoT Sensor App that will‚Ä¶</p>
<ul>
<li>
<p><strong>Read Sensor Data:</strong> Read the Temperature, Pressure and Humidity from BME280 Sensor</p>
</li>
<li>
<p><strong>Print Sensor Data:</strong> Print the above values</p>
</li>
<li>
<p><strong>Compose Message:</strong> Create a CBOR Message with the Temperature, Pressure and Humidity values</p>
</li>
<li>
<p><strong>Transmit Message:</strong> Send the CBOR Message to LoRaWAN</p>
</li>
</ul>
<p>First we download our <strong>Zig Sensor App</strong> (that imports the NuttX Sensor API into Zig)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Download our Zig Sensor App for NuttX
git clone --recursive https://github.com/lupyuen/visual-zig-nuttx</code></pre></div>
<p>(We‚Äôll paste our generated Zig Program inside here)</p>
<p>Now head over to our <strong>Custom Blockly Website</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen3.github.io/blockly-zig-nuttx/demos/code/"><strong>Blockly with Zig and NuttX (Work in Progress)</strong></a></li>
</ul>
<p>Drag-n-drop the Blocks to assemble this Visual Program‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App" /></p>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<p>To find the above Blocks, click the <strong>Blocks Toolbox</strong> (at left) and look under <strong>‚ÄúSensors‚Äù</strong>, <strong>‚ÄúVariables‚Äù</strong> and <strong>‚ÄúText‚Äù</strong>‚Ä¶</p>
<ul>
<li><a href="https://youtu.be/GL2VWO4wNcA"><strong>Watch the Demo on YouTube</strong></a></li>
</ul>
<p>Note that we read <strong>Humidity</strong> from <strong>‚Äúsensor_humi0‚Äù</strong> instead of ‚Äúsensor_baro0‚Äù.</p>
<p>Click the <strong>Zig Tab</strong>. We‚Äôll see this Zig Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Main Function
pub fn main() !void {

  // Every 10 seconds...
  while (true) {
    const temperature = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_baro,       // Sensor Data Struct
      &quot;temperature&quot;,              // Sensor Data Field
      &quot;/dev/uorb/sensor_baro0&quot;    // Path of Sensor Device
    );
    debug(&quot;temperature={}&quot;, .{ temperature });

    const pressure = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_baro,       // Sensor Data Struct
      &quot;pressure&quot;,                 // Sensor Data Field
      &quot;/dev/uorb/sensor_baro0&quot;    // Path of Sensor Device
    );
    debug(&quot;pressure={}&quot;, .{ pressure });

    const humidity = try sen.readSensor(  // Read BME280 Sensor
      c.struct_sensor_humi,       // Sensor Data Struct
      &quot;humidity&quot;,                 // Sensor Data Field
      &quot;/dev/uorb/sensor_humi0&quot;    // Path of Sensor Device
    );
    debug(&quot;humidity={}&quot;, .{ humidity });

    const msg = try composeCbor(.{  // Compose CBOR Message
      &quot;t&quot;, temperature,
      &quot;p&quot;, pressure,
      &quot;h&quot;, humidity,
    });

    // Transmit message to LoRaWAN
    try transmitLorawan(msg);

    // Wait 10 seconds
    _ = c.sleep(10);
  }
}</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Copy the code inside the <strong>Main Function</strong>. (Yep copy the <strong>while</strong> loop)</p>
<p>Paste the code inside the <strong>Zig Sensor App</strong> that we have downloaded earlier‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig"><strong>visual-zig-nuttx/visual.zig</strong></a></li>
</ul>
<p>(Look for ‚ÄúPaste Visual Program Here‚Äù)</p>
<p><em>Can we save the Blocks? So we don‚Äôt need to drag them again when retesting?</em></p>
<p>Click the <strong>JSON Tab</strong> and copy the Blockly JSON that appears.</p>
<p>Whenever we reload Blockly, just paste the Blockly JSON back into the JSON Tab. The Blocks will be automagically restored.</p>
<p><a href="https://gist.github.com/lupyuen/f7466a2e208eb68fd01a788c829b57e9">(See the Blockly JSON)</a></p>
<p>We‚Äôre ready to build and test our IoT Sensor App! But first we prep our hardware‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-connect.jpg" alt="Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor" /></p>
<p><a href="https://lupyuen.github.io/articles/sensor"><em>Pine64 PineCone BL602 RISC-V Board connected to Bosch BME280 Sensor</em></a></p>
<h1 id="connect-bme280-sensor"><a href="#connect-bme280-sensor">4 Connect BME280 Sensor</a></h1>
<p>For testing our IoT Sensor App, we connect the BME280 Sensor (I2C) to Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602 Board</strong></a> (pic above)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">BL602 Pin</th><th style="text-align: center">BME280 Pin</th><th style="text-align: left">Wire Colour</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>GPIO 1</code></strong></td><td style="text-align: center"><code>SDA</code></td><td style="text-align: left">Green</td></tr>
<tr><td style="text-align: center"><strong><code>GPIO 2</code></strong></td><td style="text-align: center"><code>SCL</code></td><td style="text-align: left">Blue</td></tr>
<tr><td style="text-align: center"><strong><code>3V3</code></strong></td><td style="text-align: center"><code>3.3V</code></td><td style="text-align: left">Red</td></tr>
<tr><td style="text-align: center"><strong><code>GND</code></strong></td><td style="text-align: center"><code>GND</code></td><td style="text-align: left">Black</td></tr>
</tbody></table>
</div>
<p>The <strong>I2C Pins</strong> on BL602 are defined here: <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L91-L98">board.h</a></p>
<div class="example-wrap"><pre class="language-c"><code>/* I2C Configuration */
#define BOARD_I2C_SCL \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN2)
#define BOARD_I2C_SDA \
  (GPIO_INPUT | GPIO_PULLUP | GPIO_FUNC_I2C | \
  GPIO_PIN1)</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/expander#pin-functions">(Which pins can be used? See this)</a></p>
<h1 id="compile-zig-app"><a href="#compile-zig-app">5 Compile Zig App</a></h1>
<p>Below are the steps to <strong>compile our IoT Sensor App</strong> for NuttX.</p>
<p>We download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>NuttX for BL602</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>The downloaded version of NuttX already includes our <strong>BME280 Driver</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/bme280"><strong>‚ÄúApache NuttX Driver for BME280 Sensor‚Äù</strong></a></li>
</ul>
<p>Check that the following have been enabled in the NuttX Build‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C0 Port</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>I2C Character Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>BME280 Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>Sensor Driver Test App</strong></a></p>
</li>
</ul>
<p>Remember to set <a href="https://lupyuen.github.io/articles/bme280#configure-nuttx"><strong>‚ÄúSensor Driver Test Stack Size‚Äù</strong></a> to <strong>4096</strong>.</p>
<p>(Because our Zig App needs additional Stack Space)</p>
<p>After building NuttX, compile our <strong>IoT Sensor App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Zig Sensor App that we have downloaded earlier.
#  TODO: Paste our visual program into visual-zig-nuttx/visual.zig
cd visual-zig-nuttx

#  Compile the Zig App for BL602
#  (RV32IMACF with Hardware Floating-Point)
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  sensortest.zig</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/eddfb4a11ed306d478f47adece9d6e1a">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p>Also specific to BL602 is the <strong>ARCH_RISCV</strong> Macro in <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L11">visual-zig-nuttx/sensor.zig</a></p>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App into the NuttX Firmware.</p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#sensor-test-app-in-c">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Patch the ELF Header of `sensortest.o` from 
#  Soft-Float ABI to Hard-Float ABI
xxd -c 1 sensortest.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - sensortest2.o
cp sensortest2.o sensortest.o</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Copy the compiled app to NuttX and overwrite `sensortest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp sensortest.o $HOME/nuttx/apps/testing/sensortest/sensortest*.o

#  Build NuttX to link the Zig Object from `sensortest.o`
#  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

#  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash</code></pre></div>
<p>We‚Äôre ready to run our IoT Sensor App!</p>
<p><img src="https://lupyuen.github.io/images/visual-run1.png" alt="IoT Sensor App running on PineCone BL602" /></p>
<p><em>IoT Sensor App running on PineCone BL602</em></p>
<h1 id="run-zig-app"><a href="#run-zig-app">6 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on BL602‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#flash-nuttx"><strong>‚ÄúFlash NuttX‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/nuttx#run-nuttx"><strong>‚ÄúRun NuttX‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our <strong>IoT Sensor App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>sensortest visual</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sensor#main-function">(<strong>sensortest</strong> is explained here)</a></p>
<p>Our IoT Sensor App should correctly read the <strong>Temperature, Pressure and Humidity</strong> from BME280 Sensor, and transmit the values to LoRaWAN (simulated)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>NuttShell (NSH) NuttX-10.3.0
nsh&gt; sensortest visual
Zig Sensor Test
Start main

temperature=31.05
pressure=1007.44
humidity=71.49
composeCbor
  t: 31.05
  p: 1007.44
  h: 71.49
  msg=t:31.05,p:1007.44,h:71.49,
transmitLorawan
  msg=t:31.05,p:1007.44,h:71.49,

temperature=31.15
pressure=1007.40
humidity=70.86
composeCbor
  t: 31.15
  p: 1007.40
  h: 70.86
  msg=t:31.15,p:1007.40,h:70.86,
transmitLorawan
  msg=t:31.15,p:1007.40,h:70.86,</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#test-visual-zig-sensor-app">(See the Complete Log)</a></p>
<p>Yep we have successfully created an IoT Sensor App with Blockly, Zig and NuttX! üéâ</p>
<p><em>Can we test without NuttX?</em></p>
<p>To test our IoT Sensor App on <strong>Linux / macOS / Windows</strong> (instead of NuttX), add the stubs below to simulate a NuttX Sensor‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/visual-zig-nuttx#test-stubs"><strong>‚ÄúTest Stubs‚Äù</strong></a></li>
</ul>
<h1 id="why-zig"><a href="#why-zig">7 Why Zig</a></h1>
<p><em>Once again‚Ä¶ Why are we doing this in Zig?</em></p>
<p>It‚Äôs <strong>easier to generate</strong> Zig Code for our IoT Sensor App. That‚Äôs because Zig supports‚Ä¶</p>
<ul>
<li>
<p><strong>Type Inference</strong>: Zig Compiler will fill in the missing Types</p>
</li>
<li>
<p><strong>Compile-Time Expressions</strong>: Zig Compiler will let us manipulate Struct Types and Fields at Compile-Time</p>
</li>
<li>
<p><strong>Compile-Time Variable Arguments</strong>: Zig Compiler will validate the Variable Arguments for our Function</p>
</li>
</ul>
<p>We could have programmed Blockly to generate C Code. But it would be messy, here‚Äôs why‚Ä¶</p>
<h2 id="type-inference"><a href="#type-inference">7.1 Type Inference</a></h2>
<p>In many Compiled Languages (including C), we need to <strong>specify the Types</strong> for our Constants (and Variables)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// This is a Float (f32)
const temperature: f32 = try sen.readSensor(...);

// This is a Struct (CborMessage)
const msg: CborMessage = try composeCbor(...);</code></pre></div>
<p>But thanks to <strong>Type Inference</strong>, we may omit the Types in Zig‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Zig Compiler infers that this is a Float
const temperature = try sen.readSensor(...);

// Zig Compiler infers that this is a Struct
const msg = try composeCbor(...);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>This simplifies the <strong>Code Generation</strong> in Blockly, since we don‚Äôt track the Types.</p>
<h2 id="compile-time-expressions"><a href="#compile-time-expressions">7.2 Compile-Time Expressions</a></h2>
<p>Earlier we saw this for reading the BME280 Sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read Temperature from BME280 Sensor
temperature = try sen.readSensor(
  c.struct_sensor_baro,       // Sensor Data Struct
  &quot;temperature&quot;,              // Sensor Data Field
  &quot;/dev/uorb/sensor_baro0&quot;    // Path of Sensor Device
);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Looks concise and tidy, but <strong>readSensor</strong> has 2 surprises‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>struct_sensor_baro</strong></a> is actually a <strong>Struct Type</strong></p>
<p>(Auto-imported by Zig from NuttX)</p>
</li>
<li>
<p><strong>‚Äútemperature‚Äù</strong> is actually a <strong>Struct Field Name</strong></p>
<p>(From the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct)</p>
</li>
</ul>
<p>The Zig Compiler will <strong>substitute the Struct Type</strong> and Field Name inside the code for <strong>readSensor</strong>. (Which works like a C Macro)</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-read-sensor-data">(More about <strong>readSensor</strong> in the Appendix)</a></p>
<p><em>Is this doable in C?</em></p>
<p>Possibly, if we define a C Macro that embeds the entire <strong>readSensor</strong> function.</p>
<p>(Which might be a headache for maintenance)</p>
<h2 id="variable-arguments"><a href="#variable-arguments">7.3 Variable Arguments</a></h2>
<p>Zig has a neat way of handling <strong>Variable Arguments</strong> at Compile-Time.</p>
<p>Remember <strong>composeCbor</strong> from earlier?</p>
<div class="example-wrap"><pre class="language-zig"><code>// Compose CBOR Message with a 
// Variable Number of Keys and Values
const msg = try composeCbor(.{
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><strong>composeCbor</strong> accepts a <strong>Variable Number of Arguments</strong> and it uses <strong>Compile-Time Validation</strong> to verify that the parameters are OK.</p>
<p>If we omit a Key or a Value (or if they have the wrong Types), the Zig Compiler will stop us during compilation.</p>
<p><a href="https://lupyuen.github.io/articles/visual#appendix-encode-sensor-data">(<strong>composeCbor</strong> is explained here)</a></p>
<p><em>Could we have done this in C?</em></p>
<p>In C, we would call some <a href="https://github.com/lupyuen/stm32bluepill-mynewt-sensor/blob/master/libs/sensor_coap/include/sensor_coap/sensor_coap.h#L219-L323"><strong>messy macros</strong></a> to validate and manipulate the parameters at Compile-Time.</p>
<p>Or implement as <a href="https://en.cppreference.com/w/c/variadic"><strong>Variadic Functions in C</strong></a>, without the Compile-Time Type Checking.</p>
<p>That‚Äôs why Zig is a better target for Automated Code Generation in Blockly.</p>
<p><img src="https://lupyuen.github.io/images/blockly-iot.jpg" alt="Expected firmware for our IoT Sensor Device" /></p>
<p><a href="https://lupyuen.github.io/articles/visual#blockly-for-iot-sensor-apps"><em>Expected firmware for our IoT Sensor Device</em></a></p>
<h1 id="real-world-complications"><a href="#real-world-complications">8 Real World Complications</a></h1>
<p>Remember earlier we drew the pic above for our <strong>IoT Sensor Firmware</strong>?</p>
<p>Then we kinda glossed over the details and made this <strong>IoT Sensor App</strong>‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/visual-block6.jpg" alt="IoT Sensor App" /></p>
</blockquote>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<p>To run this in the <strong>Real World</strong>, we need some tweaks‚Ä¶</p>
<p><em>Is it really OK to transmit messages to LoRaWAN every 10 seconds?</em></p>
<p>Nope it‚Äôs NOT OK to send messages every 10 seconds! LoRaWAN imposes limits on the <strong>Message Rate</strong>.</p>
<p>We can send one LoRaWAN Message roughly <strong>every 20 to 60 seconds</strong>, depending on the Message Size.</p>
<p><a href="https://lupyuen.github.io/articles/lorawan3#message-interval">(More about this)</a></p>
<p><em>So we tweak the Loop to run every 60 seconds?</em></p>
<p>Well then our Sensor Data (Temperature / Pressure / Humidity) would become <strong>stale and inaccurate</strong>.</p>
<p>We need to <strong>collect and aggregate</strong> the Sensor Data more often.</p>
<p>This means splitting into two loops: <strong>Read Sensor Loop</strong> and <strong>Transmit Loop</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/visual-block12.jpg" alt="Multiple Loops" /></p>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<p>(We‚Äôll explain ‚Äúx100‚Äù in the next section)</p>
<p>Missing from the pic: We need to compute the <strong>Average Temperature / Pressure / Humidity</strong> over the past 60 seconds.</p>
<p>And we <strong>transmit the Average Sensor Data</strong>. (Instead of the Raw Sensor Data)</p>
<p>This gives us better Sensor Data through <strong>frequent sampling</strong>, even though we‚Äôre sending one message every minute.</p>
<p>(Some sensors like BME280 can actually do frequent sampling on their own. Check for <a href="https://lupyuen.github.io/articles/bme280#standby-interval"><strong>Standby Interval</strong></a>)</p>
<p><em>Will Blockly and Zig support two Loops?</em></p>
<p>Not yet. With two Loops, we have the problem of <strong>Sleepy Fishes</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read Sensor Loop...
while (true) {
  ...
  // Wait 30 seconds
  _ = c.sleep(30);
}

// Transmit Loop...
while (true) {
  ...
  // Wait 60 seconds
  _ = c.sleep(60);
}

// Oops! Transmit Loop will never run!</code></pre></div>
<p>We loop forever (calling <strong>sleep</strong>) in the First Loop, thus we‚Äôll never reach the Second Loop.</p>
<p><em>So we should do this with Timers instead?</em></p>
<p>Yep our Loops shall be implemented with proper <strong>Multithreaded Timers</strong>.</p>
<p>Like from <a href="https://lupyuen.github.io/articles/sx1262#multithreading-with-nimble-porting-layer"><strong>NimBLE Porting Layer</strong></a>. (Or just plain NuttX Timers)</p>
<p>Let‚Äôs sum up the tweaks that we need‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/sensor-visual.jpg" alt="Grand Plan for our IoT Sensor App" /></p>
<p><em>Grand Plan for our IoT Sensor App</em></p>
<h1 id="upcoming-fixes"><a href="#upcoming-fixes">9 Upcoming Fixes</a></h1>
<p>In the previous section we talked about the <strong>quirks in our IoT Sensor App</strong> and why it won‚Äôt work in the Real World.</p>
<p>This is how we‚Äôll fix it‚Ä¶</p>
<h2 id="multithreading-and-synchronisation"><a href="#multithreading-and-synchronisation">9.1 Multithreading and Synchronisation</a></h2>
<ul>
<li>
<p><strong>sleep</strong> won‚Äôt work for Multiple Loops. We‚Äôll switch to <strong>Multithreaded Timers</strong> instead</p>
<p>(From <a href="https://lupyuen.github.io/articles/sx1262#multithreading-with-nimble-porting-layer"><strong>NimBLE Porting Layer</strong></a> or just plain NuttX Timers)</p>
</li>
<li>
<p>Our Read Sensor Loop needs to pass the <strong>Aggregated Sensor Data</strong> to Transmit Loop</p>
</li>
<li>
<p>Since both Loops run concurrently, we need to <strong>Lock the Sensor Data</strong> during access</p>
<p>(Hence the Locking and Averaging in the sketch above)</p>
</li>
</ul>
<h2 id="message-constraints"><a href="#message-constraints">9.2 Message Constraints</a></h2>
<ul>
<li>
<p>Our app shall transmit LoRaWAN Messages <strong>every 60 seconds</strong>, due to the Message Rate limits. <a href="https://lupyuen.github.io/articles/lorawan3#message-interval">(Here‚Äôs why)</a></p>
</li>
<li>
<p>CBOR Messages are smaller if we encode our <strong>Sensor Data as Integers</strong> (instead of Floating-Point Numbers)</p>
<p>We propose to scale up our Sensor Data by 100 (pic below) and encode them as Integers. (Which preserves 2 decimal places)</p>
<p><a href="https://lupyuen.github.io/articles/cbor2#floating-point-numbers">(More about CBOR Encoding)</a></p>
</li>
<li>
<p>We‚Äôll probably test LoRaWAN with Waveshare‚Äôs <a href="https://www.waveshare.com/wiki/Pico-LoRa-SX1262"><strong>LoRa SX1262 Breakout Board</strong></a> (non-sponsored)</p>
<p>(Because our current LoRa SX1262 Board is reserved for <a href="https://lupyuen.github.io/articles/auto"><strong>NuttX Automated Testing</strong></a>)</p>
</li>
<li>
<p>Waveshare‚Äôs <a href="https://www.waveshare.com/wiki/Pico-Environment-Sensor"><strong>I2C Multi-Sensor Board</strong></a> (non-sponsored) looks super interesting for mixing-n-matching Multiple Sensors</p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/visual-block11.jpg" alt="Sensor Data scaled by 100 and encoded as integers" /></p>
<p><em>Sensor Data scaled by 100 and encoded as integers</em></p>
<h2 id="blockly-limitations"><a href="#blockly-limitations">9.3 Blockly Limitations</a></h2>
<ul>
<li>
<p>Some Blocks won‚Äôt emit <strong>valid Zig Code</strong></p>
<p><a href="https://lupyuen.github.io/articles/blockly#code-generator">(Our Zig Code Generator for Blockly is incomplete)</a></p>
</li>
<li>
<p><strong>Double Assignment</strong> fails with Zig and Blockly‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/blockly-run12.jpg" alt="Double Assignment" /></p>
<p><a href="https://lupyuen.github.io/articles/blockly#constants-vs-variables">(More about this)</a></p>
</li>
<li>
<p><strong>Shadowed Identifiers</strong> won‚Äôt work either‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/blockly-run15.jpg" alt="Shadowed Identifiers" /></p>
<p><a href="https://lupyuen.github.io/articles/blockly#constants-vs-variables">(More about this)</a></p>
</li>
<li>
<p>Copying the Zig Code from Blockly into NuttX feels cumbersome. We might streamline this by wrapping Blockly as a <strong>Desktop App.</strong></p>
<p><a href="https://lupyuen.github.io/articles/blockly#desktop-and-mobile">(More about this)</a></p>
</li>
</ul>
<p>There‚Äôs plenty to be fixed, please lemme know if you‚Äôre keen to help! üôè</p>
<p><img src="https://lupyuen.github.io/images/visual-arduino.jpg" alt="Connect a Sensor to our Microcontroller and it pops up in Blockly!" /></p>
<p><em>Connect a Sensor to our Microcontroller and it pops up in Blockly!</em></p>
<h1 id="visual-arduino"><a href="#visual-arduino">10 Visual Arduino?</a></h1>
<p><a href="https://www.linkedin.com/in/acassis/"><strong>Alan Carvalho de Assis</strong></a> has a brilliant idea for an Embedded Dev Tool that‚Äôs <strong>modular, visual, plug-and-play</strong>‚Ä¶</p>
<blockquote>
<p>‚ÄúI think creating some modular solution to compete with Arduino could be nice! Imagine that instead of wiring modules in the breadboard people just plug the device in the board and it recognize the device and add it to some graphical interface‚Äù</p>
</blockquote>
<blockquote>
<p>‚ÄúFor example, you just plug a temperature sensor module in your board and it will identify the module type and you can pass this Temperature variable to use in your logic application‚Äù</p>
</blockquote>
<p>Just <strong>connect a Sensor</strong> to our Microcontroller‚Ä¶ And it pops up in <strong>Blockly</strong>, all ready for us to read the Sensor Data! (Pic above)</p>
<p>To detect the Sensor, we could use <a href="https://en.m.wikipedia.org/wiki/Serial_presence_detect"><strong>SPD (Serial Presence Detection)</strong></a>, like for DDR Memory Modules.</p>
<p>(Or maybe we scan the I2C Bus and read the Chip ID?)</p>
<p>What do you think? Please let us know! üôè</p>
<p>(Would be great if we could create a Proof-of-Concept using Universal Perforated Board)</p>
<p><img src="https://lupyuen.github.io/images/prometheus-title.jpg" alt="Up Next: Prometheus, Grafana and The Things Network" /></p>
<p><a href="https://lupyuen.github.io/articles/prometheus"><em>Up Next: Prometheus, Grafana and The Things Network</em></a></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>This has been an exhilarating journey into <strong>IoT, Zig and Visual Programming</strong> that spans four articles (including this one)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/sensor"><strong>‚ÄúRead NuttX Sensor Data with Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></p>
</li>
</ul>
<p>I hope you‚Äôll join me for more!</p>
<p>Check out my earlier work on Zig and NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl"><strong>‚ÄúBuild an LVGL Touchscreen App with Zig‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Zig/comments/wr9axi/visual_programming_with_zig_and_nuttx_sensors/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/visual.md"><strong>lupyuen.github.io/src/visual.md</strong></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1557857587667775489"><strong>this Twitter Thread</strong></a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/visual-block1.jpg" alt="BME280 Sensor Block" /></p>
<p><em>NOTE: ‚Äú/dev/sensor‚Äù has been changed to ‚Äú/dev/uorb‚Äù</em></p>
<h1 id="appendix-read-sensor-data"><a href="#appendix-read-sensor-data">13 Appendix: Read Sensor Data</a></h1>
<p>As pictured above, our <strong>BME280 Sensor Block</strong> reads Temperature, Humidity and Pressure from the <a href="https://www.bosch-sensortec.com/products/environmental-sensors/humidity-sensors-bme280/"><strong>Bosch BME280 Sensor</strong></a>.</p>
<p>The Blocks above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Read the Temperature
const temperature = try sen.readSensor(
  c.struct_sensor_baro,       // Sensor Data Struct to be read
  &quot;temperature&quot;,              // Sensor Data Field to be returned
  &quot;/dev/uorb/sensor_baro0&quot;    // Path of Sensor Device
);

// Print the Temperature
debug(&quot;temperature={}&quot;, .{ temperature });</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Looks concise and tidy, but <strong>readSensor</strong> has 2 surprises‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>struct_sensor_baro</strong></a> is actually a <strong>Struct Type</strong></p>
<p>(Auto-imported by Zig from NuttX)</p>
</li>
<li>
<p><strong>‚Äútemperature‚Äù</strong> is actually a <strong>Struct Field Name</strong></p>
<p>(From the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct)</p>
</li>
</ul>
<p>The Zig Compiler will <strong>substitute the Struct Type</strong> and Field Name inside the code for <strong>readSensor</strong>. (Which works like a C Macro)</p>
<p><em>How does it work?</em></p>
<p><strong>readSensor</strong> declares the Sensor Data Struct Type and Sensor Data Field as <strong><code>comptime</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read a Sensor and return the Sensor Data
pub fn readSensor(
  comptime SensorType: type,        // Sensor Data Struct to be read, like c.struct_sensor_baro
  comptime field_name: []const u8,  // Sensor Data Field to be returned, like &quot;temperature&quot;
  device_path: []const u8           // Path of Sensor Device, like &quot;/dev/uorb/sensor_baro0&quot;
) !f32 { ...</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L34-L108">(Source)</a></p>
<p>Which means that Zig Compiler will <strong>substitute the values</strong> at Compile-Time (like a C Macro)‚Ä¶</p>
<ul>
<li>
<p><strong>SensorType</strong> changes to <strong>c.struct_sensor_baro</strong></p>
</li>
<li>
<p><strong>field_name</strong> changes to <strong>‚Äútemperature‚Äù</strong></p>
</li>
</ul>
<p><strong>readSensor</strong> will then use <strong>SensorType</strong> to refer to the <a href="https://github.com/lupyuen/incubator-nuttx/blob/master/include/nuttx/sensors/sensor.h#L348-L355"><strong>sensor_baro</strong></a> Struct‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Define the Sensor Data Type.
  // Zig Compiler replaces `SensorType` by `c.struct_sensor_baro`
  var sensor_data = std.mem.zeroes(
    SensorType
  );</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L89-L92">(Source)</a></p>
<p>And <strong>readSensor</strong> will use <strong>field_name</strong> to refer to the <strong>‚Äútemperature‚Äù</strong> field‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the Sensor Data Field.
  // Zig Compiler replaces `field_name` by &quot;temperature&quot;
  return @field(
    sensor_data,  // Sensor Data Type from above
    field_name    // Field Name is &quot;temperature&quot;
  );</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L106-L107">(Source)</a></p>
<p>Check out this doc for details on <strong><code>comptime</code></strong> and Zig Metaprogramming‚Ä¶</p>
<ul>
<li><a href="https://ikrima.dev/dev-notes/zig/zig-metaprogramming/"><strong>‚ÄúZig Metaprogramming‚Äù</strong></a></li>
</ul>
<p><em>What‚Äôs inside readSensor?</em></p>
<p>Let‚Äôs look at the implementation of <strong>readSensor</strong> in <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L34-L108">sensor.zig</a> and walk through the steps for reading a NuttX Sensor‚Ä¶</p>
<h2 id="open-sensor-device"><a href="#open-sensor-device">13.1 Open Sensor Device</a></h2>
<p>We begin by <strong>opening the NuttX Sensor Device</strong>: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L34-L108">sensor.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Read a Sensor and return the Sensor Data
pub fn readSensor(
  comptime SensorType: type,        // Sensor Data Struct to be read, like c.struct_sensor_baro
  comptime field_name: []const u8,  // Sensor Data Field to be returned, like &quot;temperature&quot;
  device_path: []const u8           // Path of Sensor Device, like &quot;/dev/uorb/sensor_baro0&quot;
) !f32 {

  // Open the Sensor Device
  const fd = c.open(
    &amp;device_path[0],           // Path of Sensor Device
    c.O_RDONLY | c.O_NONBLOCK  // Open for read-only
  );</code></pre></div>
<p><strong><code>open()</code></strong> should look familiar‚Ä¶ On Linux we open Devices the same way.</p>
<p><em>What‚Äôs ‚Äú<code>[]const u8</code>‚Äù?</em></p>
<p>That‚Äôs a <strong>Slice of Bytes</strong>, roughly equivalent to a String in C.</p>
<p><a href="https://lupyuen.github.io/articles/sensor#slice-vs-string">(More about Slices)</a></p>
<p><em>What‚Äôs ‚Äú<code>!f32</code>‚Äù?</em></p>
<p>That‚Äôs the <strong>Return Type</strong> of our function‚Ä¶</p>
<ul>
<li>
<p>Our function returns the Sensor Data as a 32-bit <strong>Floating-Point Number</strong></p>
<p>(Hence ‚Äú<code>f32</code>‚Äù)</p>
</li>
<li>
<p>But it might return an <strong>Error</strong></p>
<p>(Hence the ‚Äú<code>!</code>‚Äù)</p>
</li>
</ul>
<p><em>Why the ‚Äú<code>c.</code>‚Äù prefix?</em></p>
<p>We write ‚Äú<code>c.</code><em>something</em>‚Äù for Functions, Types and Macros <strong>imported from C</strong>.</p>
<p><a href="https://lupyuen.github.io/articles/sensor#import-nuttx-functions">(As explained here)</a></p>
<p>Next we check if the Sensor Device has been <strong>successfully opened</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (fd &lt; 0) {
    std.log.err(
      &quot;Failed to open device:{s}&quot;,
      .{ c.strerror(errno()) }
    );
    return error.OpenError;
  }</code></pre></div>
<p>If the Sensor Device doesn‚Äôt exist, we print a Formatted Message to the <strong>Error Log</strong> and return an Error.</p>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>OpenError</strong> is defined here)</a></p>
<p><em>What‚Äôs ‚Äú<code>{s}</code>‚Äù?</em></p>
<p>That‚Äôs for printing a <strong>Formatted String</strong> in Zig.</p>
<p>It‚Äôs equivalent to ‚Äú<code>%s</code>‚Äù in C‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>printf(&quot;Failed to open device:%s&quot;, strerror(errno()));</code></pre></div>
<p><em>What‚Äôs ‚Äú<code>.{ ... }</code>‚Äù?</em></p>
<p>That‚Äôs how we pass a <strong>list of Arguments</strong> when printing a Formatted Message.</p>
<p>If we have no Arguments, we write ‚Äú<code>.{}</code>‚Äù</p>
<p><a href="https://ziglang.org/documentation/master/#Anonymous-Struct-Literals">(‚Äú<code>.{ ... }</code>‚Äù creates an Anonymous Struct)</a></p>
<h2 id="close-sensor-device-deferred"><a href="#close-sensor-device-deferred">13.2 Close Sensor Device (Deferred)</a></h2>
<p>We‚Äôve just opened the Sensor Device and we must <strong>close it later</strong>‚Ä¶</p>
<p>But the Control Flow gets complicated because we might need to <strong>handle Errors</strong> and quit early. In C we‚Äôd code this with ‚Äú<code>goto</code>‚Äù.</p>
<p>For Zig we do this nifty trick‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Close the Sensor Device when this function returns
  defer {
    _ = c.close(fd);
  }</code></pre></div>
<p>When we write <strong>‚Äú<code>defer</code>‚Äù</strong>, this chunk of code will be executed <strong>when our function returns</strong>.</p>
<p>This brilliantly solves our headache of <strong>closing the Sensor Device</strong> when we hit Errors later.</p>
<p><em>Why the ‚Äú<code>_ =</code> something‚Äù?</em></p>
<p>Zig Compiler stops us if we forget to use the <strong>Return Value</strong> of a Function.</p>
<p>We write ‚Äú<code>_ =</code> <em>something</em>‚Äù to tell Zig Compiler that we‚Äôre not using the Return Value.</p>
<h2 id="set-standby-interval"><a href="#set-standby-interval">13.3 Set Standby Interval</a></h2>
<p>Some sensors (like BME280) will automatically measure Sensor Data at <strong>Periodic Intervals</strong>. <a href="https://lupyuen.github.io/articles/bme280#standby-interval">(Like this)</a></p>
<p>Let‚Äôs assume that our sensor will measure Sensor Data <strong>every 1 second</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set Standby Interval
  const interval: c_uint = 1_000_000;  // 1,000,000 microseconds (1 second)
  var ret = c.ioctl(
    fd,                  // Sensor Device
    SNIOC_SET_INTERVAL,  // ioctl Command
    interval             // Standby Interval
  );</code></pre></div>
<p>(<strong>c_uint</strong> is equivalent to ‚Äúunsigned int‚Äù in C)</p>
<p>In case of error, we quit‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (ret &lt; 0 and errno() != c.ENOTSUP) {
    std.log.err(&quot;Failed to set interval:{s}&quot;, .{ c.strerror(errno()) });
    return error.IntervalError;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>IntervalError</strong> is defined here)</a></p>
<p>Which also closes the Sensor Device. (Due to our earlier ‚Äú<code>defer</code>‚Äù)</p>
<h2 id="set-batch-latency"><a href="#set-batch-latency">13.4 Set Batch Latency</a></h2>
<p>We set the <strong>Batch Latency</strong>, if it‚Äôs needed by our sensor‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Set Batch Latency
  const latency: c_uint = 0;  // No latency
  ret = c.ioctl(
    fd,             // Sensor Device
    c.SNIOC_BATCH,  // ioctl Command
    latency         // Batch Latency
  );</code></pre></div>
<p>And we check for error‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Check for error
  if (ret &lt; 0 and errno() != c.ENOTSUP) {
    std.log.err(&quot;Failed to batch:{s}&quot;, .{ c.strerror(errno()) });
    return error.BatchError;
  }</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/sensor.zig#L152-L163">(<strong>BatchError</strong> is defined here)</a></p>
<h2 id="poll-sensor"><a href="#poll-sensor">13.5 Poll Sensor</a></h2>
<p>After the enabling the sensor, we <strong>poll the sensor</strong> to check if Sensor Data is available‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Poll for Sensor Data
  var fds = std.mem.zeroes(c.struct_pollfd);
  fds.fd = fd;
  fds.events = c.POLLIN;
  ret = c.poll(&amp;fds, 1, -1);

  // Check if Sensor Data is available
  if (ret &lt;= 0) {
    std.log.err(&quot;Sensor data not available&quot;, .{});
    return error.DataError;
  }</code></pre></div>
<p><strong>std.mem.zeroes</strong> creates a <strong>pollfd</strong> Struct that‚Äôs initialised with nulls.</p>
<p>(The struct lives on the stack)</p>
<h2 id="read-sensor-data"><a href="#read-sensor-data">13.6 Read Sensor Data</a></h2>
<p>We <strong>allocate a buffer</strong> (on the stack) to receive the Sensor Data‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Define the Sensor Data Type
  var sensor_data = std.mem.zeroes(
    SensorType
  );
  const len = @sizeOf(
    @TypeOf(sensor_data)
  );</code></pre></div>
<p>Remember that <strong>SensorType</strong> is a <strong><code>comptime</code></strong> Compile-Time Type.</p>
<p>Zig Compiler will change <strong>SensorType</strong> to a Struct Type like <strong>c.struct_sensor_baro</strong></p>
<p><strong>std.mem.zeroes</strong> returns a Sensor Data Struct, initialised with nulls.</p>
<p>We <strong>read the Sensor Data</strong> into the struct‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Read the Sensor Data
  const read_len = c.read(fd, &amp;sensor_data, len);

  // Check size of Sensor Data
  if (read_len &lt; len) {
    std.log.err(&quot;Sensor data incorrect size&quot;, .{});
    return error.SizeError;
  }</code></pre></div><h2 id="return-sensor-data"><a href="#return-sensor-data">13.7 Return Sensor Data</a></h2>
<p>Finally we return the <strong>Sensor Data Field</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Return the Sensor Data Field
  return @field(
    sensor_data,  // Sensor Data Type from above
    field_name    // Field Name like &quot;temperature&quot;
  );
}</code></pre></div>
<p>Remember that <strong>field_name</strong> is a <strong><code>comptime</code></strong> Compile-Time String.</p>
<p>Zig Compiler will change <strong>field_name</strong> to a Field Name like <strong>‚Äútemperature‚Äù</strong></p>
<p>And that‚Äôs how <strong>readSensor</strong> reads the Sensor Data from a NuttX Sensor!</p>
<p><img src="https://lupyuen.github.io/images/visual-block7b.jpg" alt="Compose Message Block" /></p>
<p><em>Compose Message Block</em></p>
<h1 id="appendix-encode-sensor-data"><a href="#appendix-encode-sensor-data">14 Appendix: Encode Sensor Data</a></h1>
<p>The <strong>Compose Message Block</strong> composes a <a href="https://lupyuen.github.io/articles/cbor2"><strong>CBOR Message</strong></a> with the specified Keys (Field Names) and Values (Sensor Data).</p>
<p>(Think of CBOR as a compact, binary form of JSON)</p>
<p>CBOR Messages usually require <strong>fewer bytes than JSON</strong> to represent the same data. They work better with Low-Bandwidth Networks. (Like LoRaWAN)</p>
<p>The Block above will generate this <strong>Zig Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>const msg = try composeCbor(.{  // Compose CBOR Message
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Which will show this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>composeCbor
  t: 31.05
  p: 1007.44
  h: 71.49
  msg=t:31.05,p:1007.44,h:71.49,</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#test-visual-zig-sensor-app">(Source)</a></p>
<p><em>composeCbor accepts a variable number of arguments? Strings as well as numbers?</em></p>
<p>Yep, here‚Äôs the implementation of <strong>composeCbor</strong>: <a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig#L59-L102">visual.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// TODO: Compose CBOR Message with Key-Value Pairs
/// https://lupyuen.github.io/articles/cbor2
fn composeCbor(args: anytype) !CborMessage {
  debug(&quot;composeCbor&quot;, .{});
  comptime {
    assert(args.len % 2 == 0);  // Missing Key or Value
  }

  // Process each field...
  comptime var i: usize = 0;
  var msg = CborMessage{};
  inline while (i &lt; args.len) : (i += 2) {

    // Get the key and value
    const key   = args[i];
    const value = args[i + 1];

    // Print the key and value
    debug(&quot;  {s}: {}&quot;, .{
      @as([]const u8, key),
      floatToFixed(value)
    });

    // Format the message for testing
    var slice = std.fmt.bufPrint(
      msg.buf[msg.len..], 
      &quot;{s}:{},&quot;,
      .{
        @as([]const u8, key),
        floatToFixed(value)
      }
    ) catch { _ = std.log.err(&quot;Error: buf too small&quot;, .{}); return error.Overflow; };
    msg.len += slice.len;
  }
  debug(&quot;  msg={s}&quot;, .{ msg.buf[0..msg.len] });
  return msg;
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sensor#appendix-fixed-point-sensor-data">(<strong>floatToFixed</strong> is explained here)</a></p>
<p><strong>CborMessage</strong> is a Struct that contains the CBOR Buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// TODO: CBOR Message
/// https://lupyuen.github.io/articles/cbor2
const CborMessage = struct {
  buf: [256]u8 = undefined,  // Limit to 256 bytes
  len: usize = 0,            // Length of buffer
};</code></pre></div>
<p>Note that <strong>composeCbor</strong>‚Äôs parameter is declared as <strong><code>anytype</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>fn composeCbor(args: anytype) { ...</code></pre></div>
<p>That‚Äôs why <strong>composeCbor</strong> accepts a variable number of arguments with different types.</p>
<p>To handle each argument, the Zig Compiler will unroll (expand) this <strong><code>inline</code></strong> <strong><code>comptime</code></strong> loop during compilation‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Zig Compiler will unroll (expand) this Loop.
  // Process each field...
  comptime var i: usize = 0;
  inline while (i &lt; args.len) : (i += 2) {

    // Get the key and value
    const key   = args[i];
    const value = args[i + 1];

    // Print the key and value
    debug(&quot;  {s}: {}&quot;, .{
      @as([]const u8, key),
      floatToFixed(value)
    });
    ...
  }</code></pre></div>
<p>(Think of it as a C Macro, expanding our code during compilation)</p>
<p>Thus if we have 3 pairs of Key-Values, Zig Compiler will emit the above code 3 times.</p>
<p><a href="https://lupyuen.github.io/articles/sensor#appendix-fixed-point-sensor-data">(<strong>floatToFixed</strong> is explained here)</a></p>
<p><em>What happens if we omit a Key or a Value when calling composeCbor?</em></p>
<p>This <strong><code>comptime</code></strong> Assertion Check will <strong>fail during compilation</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// This assertion fails at Compile-Time
// if we&#39;re missing a Key or a Value
comptime {
  assert(args.len % 2 == 0);
}</code></pre></div>
<p><em>What happens if we pass incorrect Types for the Key or Value?</em></p>
<p><strong>composeCbor</strong> expects the following Types‚Ä¶</p>
<ul>
<li>
<p>Key should be a (string-like) <strong>Byte Slice</strong> (<code>[]const u8</code>)</p>
</li>
<li>
<p>Value should be a <strong>Floating-Point Number</strong> (<code>f32</code>)</p>
</li>
</ul>
<p>If the Types are incorrect, Zig Compiler will stop us here <strong>during compilation</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>    // Print the key and value
    debug(&quot;  {s}: {}&quot;, .{
      @as([]const u8, key),
      floatToFixed(value)
    });</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/sensor#appendix-fixed-point-sensor-data">(<strong>floatToFixed</strong> is explained here)</a></p>
<p>Hence <strong>composeCbor</strong> might look fragile with its Variable Arguments and Types‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>const msg = try composeCbor(.{  // Compose CBOR Message
  &quot;t&quot;, temperature,
  &quot;p&quot;, pressure,
  &quot;h&quot;, humidity,
});</code></pre></div>
<p>But Zig Compiler will actually stop us during compilation if we pass invalid arguments.</p>
<p><em>The implementation of CBOR Encoding is missing?</em></p>
<p>Yep we shall import the <strong>TinyCBOR Library</strong> from C to implement the CBOR Encoding in <strong>composeCbor</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor2"><strong>‚ÄúEncode Sensor Data with CBOR‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/visual-block7c.jpg" alt="Transmit Message Block" /></p>
<p><em>Transmit Message Block</em></p>
<h1 id="appendix-transmit-sensor-data"><a href="#appendix-transmit-sensor-data">15 Appendix: Transmit Sensor Data</a></h1>
<p>The <strong>Transmit Message Block</strong> (above) transmits a CBOR Message to <a href="https://makezine.com/2021/05/24/go-long-with-lora-radio/"><strong>LoRaWAN</strong></a> (the low-power, long-range, low-bandwidth IoT Network)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Transmit message to LoRaWAN
try transmitLorawan(msg);</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig">(Source)</a></p>
<p>Which will show this output‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>transmitLorawan
  msg=t:31.05,p:1007.44,h:71.49,</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx#test-visual-zig-sensor-app">(Source)</a></p>
<p>The implementation of <strong>transmitLorawan</strong> is currently a stub‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// TODO: Transmit message to LoRaWAN
fn transmitLorawan(msg: CborMessage) !void { 
  debug(&quot;transmitLorawan&quot;, .{});
  debug(&quot;  msg={s}&quot;, .{ msg.buf[0..msg.len] });
}</code></pre></div>
<p><a href="https://github.com/lupyuen/visual-zig-nuttx/blob/main/visual.zig#L107-L111">(Source)</a></p>
<p>We shall implement LoRaWAN Messaging by calling the <strong>LoRaWAN Library</strong> that‚Äôs imported from C‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/visual-block3.jpg" alt="Blockly Developer Tools" /></p>
<p><em>Blockly Developer Tools</em></p>
<h1 id="appendix-create-custom-blocks"><a href="#appendix-create-custom-blocks">16 Appendix: Create Custom Blocks</a></h1>
<p>In the previous article we have <strong>customised Blockly</strong> to generate Zig Programs‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/blockly"><strong>‚ÄúZig Visual Programming with Blockly‚Äù</strong></a></li>
</ul>
<p>For this article we <strong>added Custom Blocks</strong> to Blockly to produce IoT Sensor Apps‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#custom-block"><strong>‚ÄúCustom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#create-custom-block"><strong>‚ÄúCreate Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#export-custom-block"><strong>‚ÄúExport Custom Block‚Äù</strong></a></p>
</li>
</ul>
<p>This is how we <strong>loaded our Custom Blocks</strong> into Blockly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#load-custom-block"><strong>‚ÄúLoad Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#show-custom-block"><strong>‚ÄúShow Custom Block‚Äù</strong></a></p>
</li>
</ul>
<p>Each Custom Block has a <strong>Code Generator</strong> that will emit Zig Code‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#code-generator-for-custom-block"><strong>‚ÄúCode Generator for Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#build-custom-block"><strong>‚ÄúBuild Custom Block‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#test-custom-block"><strong>‚ÄúTest Custom Block‚Äù</strong></a></p>
</li>
</ul>
<p>The <strong>Compose Message Block</strong> is more sophisticated, we implemented it as a Custom Extension in Blockly‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#custom-extension"><strong>‚ÄúCustom Extension‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#code-generator-for-custom-extension"><strong>‚ÄúCode Generator for Custom Extension‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen3/blockly-zig-nuttx#test-custom-extension"><strong>‚ÄúTest Custom Extension‚Äù</strong></a></p>
</li>
</ul>
<p>Official docs for <strong>Blockly Custom Blocks</strong>‚Ä¶</p>
<ul>
<li><a href="https://developers.google.com/blockly/guides/create-custom-blocks/overview"><strong>‚ÄúCustomise Blockly‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/visual-block4.jpg" alt="Block Exporter in Blockly Developer Tools" /></p>
<p><em>Block Exporter in Blockly Developer Tools</em></p>

    
</body>
</html>