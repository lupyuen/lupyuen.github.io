<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Encode Sensor Data with CBOR on BL602</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Encode Sensor Data with CBOR on BL602" 
    data-rh="true">
<meta property="og:description" 
    content="How we compress Sensor Data with CBOR... And transmit over LoRaWAN on the BL602 / BL604 RISC-V SoC"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/cbor-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Encode Sensor Data with CBOR on BL602</h1>
    <nav id="TOC"><ul>
<li><a href="#encode-sensor-data-with-tinycbor">1 Encode Sensor Data with TinyCBOR</a><ul>
<li><a href="#output-buffer-and-cbor-encoder">1.1 Output Buffer and CBOR Encoder</a><ul></ul></li>
<li><a href="#create-map-encoder">1.2 Create Map Encoder</a><ul></ul></li>
<li><a href="#encode-key-and-value">1.3 Encode Key and Value</a><ul></ul></li>
<li><a href="#close-map-encoder">1.4 Close Map Encoder</a><ul></ul></li>
<li><a href="#get-encoded-output">1.5 Get Encoded Output</a><ul></ul></li>
<li><a href="#magic-happens">1.6 Magic Happens</a><ul></ul></li></ul></li>
<li><a href="#add-another-field">2 Add Another Field</a><ul>
<li><a href="#modify-map-encoder">2.1 Modify Map Encoder</a><ul></ul></li>
<li><a href="#encode-first-key-and-value">2.2 Encode First Key and Value</a><ul></ul></li>
<li><a href="#encode-second-key-and-value">2.3 Encode Second Key and Value</a><ul></ul></li>
<li><a href="#watch-the-magic">2.4 Watch the Magic</a><ul></ul></li></ul></li>
<li><a href="#cbor-data-types">3 CBOR Data Types</a><ul>
<li><a href="#numbers">3.1 Numbers</a><ul></ul></li>
<li><a href="#strings">3.2 Strings</a><ul></ul></li>
<li><a href="#other-types">3.3 Other Types</a><ul></ul></li></ul></li>
<li><a href="#floating-point-numbers">4 Floating-Point Numbers</a><ul>
<li><a href="#encode-floats-as-integers">4.1 Encode Floats as Integers</a><ul></ul></li>
<li><a href="#accuracy-and-precision">4.2 Accuracy and Precision</a><ul></ul></li></ul></li>
<li><a href="#lorawan-with-cbor">5 LoRaWAN With CBOR</a><ul>
<li><a href="#encode-sensor-data">5.1 Encode Sensor Data</a><ul></ul></li>
<li><a href="#send-lorawan-packet">5.2 Send LoRaWAN Packet</a><ul></ul></li>
<li><a href="#cbor-in-action">5.3 CBOR In Action</a><ul></ul></li></ul></li>
<li><a href="#decode-cbor">6 Decode CBOR</a><ul></ul></li>
<li><a href="#whats-next">7 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">8 Notes</a><ul></ul></li>
<li><a href="#appendix-build-and-run-cbor-firmware">9 Appendix: Build and Run CBOR Firmware</a><ul>
<li><a href="#build-cbor-firmware">9.1 Build CBOR Firmware</a><ul></ul></li>
<li><a href="#flash-cbor-firmware">9.2 Flash CBOR Firmware</a><ul></ul></li>
<li><a href="#run-cbor-firmware">9.3 Run CBOR Firmware</a><ul></ul></li></ul></li>
<li><a href="#appendix-add-tinycbor-to-your-project">10 Appendix: Add TinyCBOR to Your Project</a><ul></ul></li>
<li><a href="#appendix-build-and-run-lorawan-firmware">11 Appendix: Build and Run LoRaWAN Firmware</a><ul>
<li><a href="#build-lorawan-firmware">11.1 Build LoRaWAN Firmware</a><ul></ul></li>
<li><a href="#flash-lorawan-firmware">11.2 Flash LoRaWAN Firmware</a><ul></ul></li>
<li><a href="#run-lorawan-firmware">11.3 Run LoRaWAN Firmware</a><ul></ul></li>
<li><a href="#enter-lorawan-commands">11.4 Enter LoRaWAN Commands</a><ul></ul></li></ul></li>
<li><a href="#appendix-porting-tinycbor-to-bl602">12 Appendix: Porting TinyCBOR to BL602</a><ul></ul></li></ul></nav><p>üìù <em>5 Oct 2021</em></p>
<p>Suppose we‚Äôre creating an IoT Gadget that transmits <strong>Sensor Data</strong> from a <strong>Temperature Sensor</strong> and a <strong>Light Sensor</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234, 
  &quot;l&quot;: 2345 
}
</code></pre></div>
<p>(Located in a Greenhouse perhaps)</p>
<p>And we‚Äôre transmitting over a <strong>low-power wireless network</strong> like LoRa, Zigbee or Bluetooth LE.</p>
<p>We could transmit <strong>19 bytes of JSON</strong>. But there‚Äôs a more compact way to do it‚Ä¶.</p>
<p><a href="https://en.wikipedia.org/wiki/CBOR"><strong>Concise Binary Object Representation (CBOR)</strong></a>, which works like a binary, compressed form of JSON.</p>
<p>And we need only <strong>11 bytes of CBOR</strong>!</p>
<p><img src="https://lupyuen.github.io/images/cbor-title.jpg" alt="Encoding Sensor Data with CBOR on BL602" /></p>
<p>Today we‚Äôll learn to encode Sensor Data with the <strong>TinyCBOR Library</strong> that we have ported to the <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602</strong></a> and <a href="https://lupyuen.github.io/articles/pinedio2"><strong>BL604</strong></a> RISC-V SoCs‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/tinycbor-bl602"><strong>lupyuen/tinycbor-bl602</strong></a></li>
</ul>
<p>The library has been tested on <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a>, but it should work on <strong>any BL602 or BL604 Board</strong>: <a href="https://docs.ai-thinker.com/en/wb2"><strong>Ai-Thinker Ai-WB2</strong></a>, PineCone BL602, Pinenut, DT-BL10, MagicHome BL602, ‚Ä¶</p>
<p><em>Must we scrimp and save every single byte?</em></p>
<p>Yes, <strong>every single byte matters</strong> for low-power wireless networks!</p>
<ol>
<li>
<p>Low-power wireless networks operate on Radio Frequency Bands that are <strong>shared with many other gadgets</strong>.</p>
<p>They are prone to <strong>collisions and interference</strong>.</p>
<p>The <strong>smaller the data packet</strong>, the higher the chance that it will be <strong>transmitted successfully</strong>!</p>
</li>
<li>
<p>When we transmit LoRa packets to <strong>The Things Network</strong> (the free public global LoRa network), we‚Äôre limited by their <a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network"><strong>Fair Use Policy</strong></a>.</p>
<p><a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network">(Roughly <strong>12 bytes</strong> per message, assuming 10 messages per hour)</a></p>
<p>JSON is too big for this. But CBOR works well!</p>
<p>In a while we‚Äôll watch the TinyCBOR Library in action for encoding Sensor Data in The Things Network.</p>
</li>
</ol>
<h1 id="encode-sensor-data-with-tinycbor"><a href="#encode-sensor-data-with-tinycbor">1 Encode Sensor Data with TinyCBOR</a></h1>
<p>We begin by encoding one data field into CBOR‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234
}
</code></pre></div>
<p>We call this a <strong>CBOR Map</strong> that maps a <strong>Key</strong> (‚Äú<code>t</code>‚Äù) to a <strong>Value</strong> (<code>1234</code>)‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-map.png" alt="CBOR Map with 1 Key-Value Pair" /></p>
</blockquote>
<p>Let‚Äôs look at the code from our firmware that encodes the above into CBOR‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/pinedio_cbor"><strong>pinedio_cbor Firmware</strong></a></li>
</ul>
<h2 id="output-buffer-and-cbor-encoder"><a href="#output-buffer-and-cbor-encoder">1.1 Output Buffer and CBOR Encoder</a></h2>
<p>First we create an <strong>Output Buffer</strong> that will hold the encoded CBOR data: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_cbor/pinedio_cbor/demo.c#L9-L66">pinedio_cbor/demo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Test CBOR Encoding for { &quot;t&quot;: 1234 }
static void test_cbor(char *buf, int len, int argc, char **argv) {

  //  Max output size is 50 bytes (which fits in a LoRa packet)
  uint8_t output[50];
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/ttn#fair-use-of-the-things-network">(50 bytes is the max packet size for The Things Network AS923 DR2)</a></p>
<p><strong>Output Buffer Size</strong> is important: Calls to the <strong>TinyCBOR library will fail</strong> if we run out of buffer space!</p>
<p>Next we define the <strong>CBOR Encoder</strong> (from TinyCBOR) that will encode our data‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Our CBOR Encoder and Map Encoder
  CborEncoder encoder, mapEncoder;
</code></pre></div>
<p>As well as the <strong>Map Encoder</strong> that will encode our CBOR Map.</p>
<p>We <strong>initialise the CBOR Encoder</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Init our CBOR Encoder
  cbor_encoder_init(
    &amp;encoder,        //  CBOR Encoder
    output,          //  Output Buffer
    sizeof(output),  //  Output Buffer Size
    0                //  Options (always 0)
  );
</code></pre></div><h2 id="create-map-encoder"><a href="#create-map-encoder">1.2 Create Map Encoder</a></h2>
<p>Now we create the <strong>Map Encoder</strong> that will encode our CBOR Map‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Create a Map Encoder that maps keys to values
  CborError res = cbor_encoder_create_map(
    &amp;encoder,     //  CBOR Encoder
    &amp;mapEncoder,  //  Map Encoder
    1             //  Number of Key-Value Pairs
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>The last parameter (<code>1</code>) is important: It must match the <strong>Number of Key-Value Pairs</strong> (like <code>&quot;t&quot;: 1234</code>) that we shall encode.</p>
<h2 id="encode-key-and-value"><a href="#encode-key-and-value">1.3 Encode Key and Value</a></h2>
<p>We encode the <strong>Key</strong> (‚Äú<code>t</code>‚Äù) into the CBOR Map‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;t&quot;           //  Key
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>Followed by the <strong>Value</strong> (<code>1234</code>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    1234          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p><strong>cbor_encode_int</strong> encodes <strong>64-bit Signed Integers</strong>.</p>
<p>(We‚Äôll look at other data types in a while)</p>
<h2 id="close-map-encoder"><a href="#close-map-encoder">1.4 Close Map Encoder</a></h2>
<p>We‚Äôre done with our CBOR Map, so we <strong>close the Map Encoder</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Map Encoder
  res = cbor_encoder_close_container(
    &amp;encoder,    //  CBOR Encoder
    &amp;mapEncoder  //  Map Encoder
  );
  assert(res == CborNoError);
</code></pre></div>
<p>Our CBOR Encoding is complete!</p>
<h2 id="get-encoded-output"><a href="#get-encoded-output">1.5 Get Encoded Output</a></h2>
<p>To work with the Encoded CBOR Output, we need to know <strong>how many bytes</strong> have been encoded‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  How many bytes were encoded
  size_t output_len = cbor_encoder_get_buffer_size(
    &amp;encoder,  //  CBOR Encoder
    output     //  Output Buffer
  );
  printf(&quot;CBOR Output: %d bytes\r\n&quot;, output_len);
</code></pre></div>
<p>For the demo we <strong>dump the encoded CBOR data</strong> to the console‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Dump the encoded CBOR output (6 bytes):
  //  0xa1 0x61 0x74 0x19 0x04 0xd2
  for (int i = 0; i &lt; output_len; i++) {
    printf(&quot;  0x%02x\r\n&quot;, output[i]);
  }
}
</code></pre></div>
<p>And that‚Äôs how we call the TinyCBOR Library to work with CBOR data!</p>
<p>Let‚Äôs watch what happens when we run the firmware‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-code.png" alt="Calling the TinyCBOR Library" /></p>
</blockquote>
<h2 id="magic-happens"><a href="#magic-happens">1.6 Magic Happens</a></h2>
<p>Follow the steps in the Appendix to <strong>build, flash and run</strong> the CBOR Firmware‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor#appendix-build-and-run-cbor-firmware"><strong>‚ÄúBuild and Run CBOR Firmware‚Äù</strong></a></li>
</ul>
<p>At the BL602 / BL604 Command Prompt, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>test_cbor
</code></pre></div>
<p>We‚Äôll see 6 bytes of <strong>Encoded CBOR Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CBOR Output: 6 bytes
  0xa1
  0x61
  0x74
  0x19
  0x04
  0xd2
</code></pre></div>
<p>We have just compressed <strong>10 bytes of JSON</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234
}
</code></pre></div>
<p>Into <strong>6 bytes of CBOR</strong>.</p>
<p>We have scrimped and saved <strong>4 bytes</strong>!</p>
<p><img src="https://lupyuen.github.io/images/cbor-output2.png" alt="Encoded CBOR Output" /></p>
<h1 id="add-another-field"><a href="#add-another-field">2 Add Another Field</a></h1>
<p>Now we <strong>add another field</strong> to our CBOR Encoding‚Ä¶</p>
<div class="example-wrap"><pre class="language-json"><code>{ 
  &quot;t&quot;: 1234, 
  &quot;l&quot;: 2345 
}
</code></pre></div>
<p>And watch how our program changes to accommodate the second field.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-map2.png" alt="CBOR Map with 2 Key-Value Pairs" /></p>
</blockquote>
<h2 id="modify-map-encoder"><a href="#modify-map-encoder">2.1 Modify Map Encoder</a></h2>
<p>We begin the same way as before: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_cbor/pinedio_cbor/demo.c#L68-L139">pinedio_cbor/demo.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Test CBOR Encoding for { &quot;t&quot;: 1234, &quot;l&quot;: 2345 }
static void test_cbor2( ... ) {

  //  Max output size is 50 bytes (which fits in a LoRa packet)
  uint8_t output[50];

  //  Our CBOR Encoder and Map Encoder
  CborEncoder encoder, mapEncoder;

  //  Init our CBOR Encoder
  cbor_encoder_init( ... );
</code></pre></div>
<p>Now we <strong>create the Map Encoder</strong> with a tiny modification‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Create a Map Encoder that maps keys to values
  CborError res = cbor_encoder_create_map(
    &amp;encoder,     //  CBOR Encoder
    &amp;mapEncoder,  //  Map Encoder
    2             //  Number of Key-Value Pairs
  );    
  assert(res == CborNoError);
</code></pre></div>
<p>We changed the <strong>Number of Key-Value Pairs</strong> to <code>2</code>.</p>
<p>(Previously it was <code>1</code>)</p>
<h2 id="encode-first-key-and-value"><a href="#encode-first-key-and-value">2.2 Encode First Key and Value</a></h2>
<p>We encode the <strong>First Key and Value</strong> the same way as before‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;t&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  First Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    1234          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>(Yep no changes above)</p>
<h2 id="encode-second-key-and-value"><a href="#encode-second-key-and-value">2.3 Encode Second Key and Value</a></h2>
<p>This part is new: We encode the <strong>Second Key and Value</strong> (‚Äú<code>l</code>‚Äù and <code>2345</code>)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Second Key-Value Pair: Map the Key
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;l&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  Second Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    2345          //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>And the rest of the code is the same‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Map Encoder
  res = cbor_encoder_close_container( ... );

  //  How many bytes were encoded
  size_t output_len = cbor_encoder_get_buffer_size( ... );

  //  Dump the encoded CBOR output (11 bytes):
  //  0xa2 0x61 0x74 0x19 0x04 0xd2 0x61 0x6c 0x19 0x09 0x29
  for (int i = 0; i &lt; output_len; i++) {
    printf(&quot;  0x%02x\r\n&quot;, output[i]);
  }
}
</code></pre></div>
<p>Recap: To add a data field to our CBOR Encoding, we‚Ä¶</p>
<ol>
<li>
<p>Modify the call to <strong>cbor_encoder_create_map</strong> and update the <strong>Number of Key-Value Pairs</strong> (<code>2</code>)</p>
</li>
<li>
<p>Add the new <strong>Key and Value</strong>  (‚Äú<code>l</code>‚Äù and <code>2345</code>) to the CBOR Map</p>
</li>
</ol>
<p>Everything else stays the same.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/cbor-code2.png" alt="Add a second field" /></p>
</blockquote>
<h2 id="watch-the-magic"><a href="#watch-the-magic">2.4 Watch the Magic</a></h2>
<p>Follow the steps in the Appendix to <strong>build, flash and run</strong> the CBOR Firmware‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor#appendix-build-and-run-cbor-firmware"><strong>‚ÄúBuild and Run CBOR Firmware‚Äù</strong></a></li>
</ul>
<p>At the BL602 / BL604 Command Prompt, enter‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>test_cbor2
</code></pre></div>
<p>This time we‚Äôll see 11 bytes of <strong>Encoded CBOR Output</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CBOR Output: 11 bytes
  0xa2
  0x61
  0x74
  0x19
  0x04
  0xd2
  0x61
  0x6c
  0x19
  0x09
  0x29
</code></pre></div>
<p>We have just compressed <strong>19 bytes of JSON</strong> into <strong>11 bytes of CBOR</strong>.</p>
<p><strong>8 bytes</strong> saved!</p>
<p>If we wish to call TinyCBOR from an existing BL602 / BL604 project, check the Appendix‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor#appendix-add-tinycbor-to-your-project"><strong>‚ÄúAdd TinyCBOR to Your Project‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/cbor-title.jpg" alt="Encoding Sensor Data with CBOR on BL602" /></p>
<h1 id="cbor-data-types"><a href="#cbor-data-types">3 CBOR Data Types</a></h1>
<p><em>We‚Äôve been encoding 64-bit Signed Integers. What other Data Types can we encode?</em></p>
<p>Below are the <strong>CBOR Data Types</strong> and their respective <strong>Encoder Functions</strong> from the TinyCBOR Library‚Ä¶</p>
<h2 id="numbers"><a href="#numbers">3.1 Numbers</a></h2>
<ul>
<li>
<p><strong>Signed Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gabbf6e10fd963d673f5ad293dff4a67a9">cbor_encode_int</a></p>
<p>(We called this earlier. Works for positive and negative integers)</p>
</li>
<li>
<p><strong>Unsigned Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga2b898ce6f5821c5aba8b6f0020c4b5ba">cbor_encode_uint</a></p>
<p>(Positive integers only)</p>
</li>
<li>
<p><strong>Negative Integer</strong> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga0e84daa854e0480f4a3758bcb46b9b60">cbor_encode_negative_int</a></p>
<p>(Negative integers only)</p>
</li>
<li>
<p><strong>Floating-Point Number</strong> (16, 32 or 64 bits): </p>
<p>(See the next chapter)</p>
</li>
</ul>
<h2 id="strings"><a href="#strings">3.2 Strings</a></h2>
<ul>
<li>
<p><strong>Null-Terminated String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga6df3eff486535322f66584dc5431f9e9">cbor_encode_text_stringz</a></p>
<p>(We called this earlier to encode our Keys)</p>
</li>
<li>
<p><strong>Text String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga4fa673c63e85b1fd6f8067aca4ccdde4">cbor_encode_text_string</a></p>
<p>(For strings that are not null-terminated)</p>
</li>
<li>
<p><strong>Byte String</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga1260b72bb0f067fd3c68d49a6b5f58d0">cbor_encode_byte_string</a></p>
<p>(For strings containing binary data)</p>
</li>
</ul>
<h2 id="other-types"><a href="#other-types">3.3 Other Types</a></h2>
<ul>
<li>
<p><strong>Boolean</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga857154b97cad978f4afb3e2f809051bd">cbor_encode_boolean</a></p>
</li>
<li>
<p><strong>Null</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga30b769ff1da73ed8b4536f551347c5ed">cbor_encode_null</a></p>
</li>
<li>
<p><strong>Undefined</strong>: <a href="https://intel.github.io/tinycbor/current/a00046.html#ga9d9f0668e2cf69352a45095006efab4f">cbor_encode_undefined</a></p>
</li>
</ul>
<p>For the complete list of CBOR Encoder Functions, refer to the TinyCBOR docs‚Ä¶</p>
<ul>
<li><a href="https://intel.github.io/tinycbor/current/a00046.html"><strong>TinyCBOR: Encoding To CBOR</strong></a></li>
</ul>
<p>CBOR Data Types are explained in the CBOR Specification‚Ä¶</p>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-cbor-data-models"><strong>CBOR Data Models</strong></a></li>
</ul>
<p>To experiment with CBOR Encoding and Decoding, try the <a href="http://cbor.me/"><strong>CBOR Playground</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/grafana-cbor5.png" alt="CBOR Playground" /></p>
<h1 id="floating-point-numbers"><a href="#floating-point-numbers">4 Floating-Point Numbers</a></h1>
<p>The CBOR spec says that there are <a href="https://www.rfc-editor.org/rfc/rfc8949.html#name-floating-point-numbers-and-"><strong>3 ways to encode floats</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Half-precision_floating-point_format"><strong>Half-Precision Float</strong></a> (16 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gad8e5a125cfaceb9a32528e620e003bc6">cbor_encode_half_float</a></p>
<p>(<strong>3.3</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Half-precision_floating-point_format#IEEE_754_half-precision_binary_floating-point_format:_binary16">See this</a>)</p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Single-precision_floating-point_format"><strong>Single-Precision Float</strong></a> (32 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#gae981ee934ef22ce4c5b52f8069e1b15c">cbor_encode_float</a></p>
<p>(<strong>6 to 9</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32">See this</a>)</p>
</li>
<li>
<p><a href="https://en.m.wikipedia.org/wiki/Double-precision_floating-point_format"><strong>Double-Precision Float</strong></a> (64 bits): <a href="https://intel.github.io/tinycbor/current/a00046.html#ga211aa80dc5b793ee8dd74d24cb9e7ca6">cbor_encode_double</a></p>
<p>(<strong>15 to 17</strong> significant decimal digits. <a href="https://en.m.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64">See this</a>)</p>
</li>
</ul>
<p><em>How do we select the proper float encoding?</em></p>
<p>Suppose we‚Äôre encoding Temperature Data (like <code>12.34</code> ¬∫C) that could range from <strong><code>0.00</code> ¬∫C to <code>99.99</code> ¬∫C</strong>.</p>
<p>This means that we need <strong>4 significant decimal digits</strong>.</p>
<p>Which is too many for a Half-Precision Float (16 bits), but OK for a <strong>Single-Precision Float</strong> (32 bits).</p>
<p>Thus we need <strong>5 bytes</strong> to encode the Temperature Data. (Including the CBOR Initial Byte)</p>
<h2 id="encode-floats-as-integers"><a href="#encode-floats-as-integers">4.1 Encode Floats as Integers</a></h2>
<p><em>Huh? If we encode an integer like <code>1234</code>, we need only <strong>3 bytes</strong>!</em></p>
<p>That‚Äôs why in this article we <strong>scale up 100 times</strong> for the Temperature Data and <strong>encode as an integer</strong> instead.</p>
<p>(So <code>1234</code> actually means <code>12.34</code> ¬∫C)</p>
<p><strong>2 bytes</strong> saved!</p>
<p>(Our scaling of Sensor Data is similar to <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic#Fixed-point_representation">Fixed-Point Representation</a>)</p>
<h2 id="accuracy-and-precision"><a href="#accuracy-and-precision">4.2 Accuracy and Precision</a></h2>
<p><em>Is it meaningful to record temperatures that are accurate to 0.01 ¬∫C?</em></p>
<p><em>How much accuracy do we need for Sensor Data anyway?</em></p>
<p>The accuracy for our Sensor Data depends on‚Ä¶</p>
<ol>
<li>
<p>Our monitoring requirements, and</p>
</li>
<li>
<p>Accuracy of our sensors</p>
</li>
</ol>
<p>Learn more about Accuracy and Precision of Sensor Data‚Ä¶</p>
<ul>
<li><a href="https://kotahi.net/iots-lesser-known-power-good-enough-data-accuracy/">IoT‚Äôs Lesser Known Power: ‚ÄúGood Enough‚Äù Data Accuracy</a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/ttn-title.jpg" alt="PineDio Stack BL604 RISC-V Board (foreground) talking to The Things Network via RAKWireless RAK7248 LoRaWAN Gateway (background)" /></p>
<p><em>PineDio Stack BL604 RISC-V Board (foreground) talking to The Things Network via RAKWireless RAK7248 LoRaWAN Gateway (background)</em></p>
<h1 id="lorawan-with-cbor"><a href="#lorawan-with-cbor">5 LoRaWAN With CBOR</a></h1>
<p>Let‚Äôs watch CBOR in action on a real wireless network‚Ä¶ As <a href="https://lupyuen.github.io/articles/lorawan2"><strong>PineDio Stack BL604</strong></a> talks to <a href="https://lupyuen.github.io/articles/ttn"><strong>The Things Network over LoRaWAN</strong></a>!</p>
<p>In a while we shall run this LoRaWAN Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_app_tx_cbor 2 0 1234 2345
</code></pre></div>
<p>This means‚Ä¶</p>
<ul>
<li>
<p>Transmit a LoRaWAN Packet to <strong>Port 2</strong></p>
</li>
<li>
<p>That contains the values <strong><code>t=1234</code></strong> (Temperature), <strong><code>l=2345</code></strong> (Light Level)</p>
</li>
<li>
<p><code>0</code> means that this is an <strong>Unconfirmed Message</strong></p>
<p>(Because we‚Äôre not expecting an acknowledgement)</p>
</li>
</ul>
<p>Our CBOR Encoding happens inside the <strong>las_app_tx_cbor</strong> function: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_lorawan/pinedio_lorawan/lorawan.c#L893-L1050">pinedio_lorawan/lorawan.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>/// Transmit CBOR payload to LoRaWAN. The command
///   las_app_tx_cbor 2 0 1234 2345
/// Will transmit the CBOR payload
///   { &quot;t&quot;: 1234, &quot;l&quot;: 2345 }
/// To port 2, unconfirmed (0).
void las_cmd_app_tx_cbor( ... ) {
  ...
  //  Get the &quot;t&quot; value from command args
  uint16_t t = parse_ull_bounds(argv[3], 0, 65535, &amp;rc);
    
  //  Get the &quot;l&quot; value from command args
  uint16_t l = parse_ull_bounds(argv[4], 0, 65535, &amp;rc);
</code></pre></div>
<p>In the code above we get the values of <strong>‚Äú<code>t</code>‚Äù</strong> (Temperature Sensor) and <strong>‚Äú<code>l</code>‚Äù</strong> (Light Sensor) from the command line arguments.</p>
<p>(Our sensors are simulated for now)</p>
<p>Watch how we encode ‚Äú<code>t</code>‚Äù and ‚Äú<code>l</code>‚Äù and transmit them‚Ä¶</p>
<h2 id="encode-sensor-data"><a href="#encode-sensor-data">5.1 Encode Sensor Data</a></h2>
<p>This part looks super familiar: We initialise our <strong>CBOR Encoder and Map Encoder</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Encode into CBOR for { &quot;t&quot;: ????, &quot;l&quot;: ???? }
  //  Max output size is 50 bytes (which fits in a LoRa packet)
  uint8_t output[50];

  //  Our CBOR Encoder and Map Encoder
  CborEncoder encoder, mapEncoder;

  //  Init our CBOR Encoder
  cbor_encoder_init( ... );

  //  Create a Map Encoder that maps keys to values (2 pairs)
  CborError res = cbor_encoder_create_map( ... );
</code></pre></div>
<p>Next we encode the <strong>Key and Value for ‚Äú<code>t</code>‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  First Key-Value Pair: Map the Key (&quot;t&quot;)
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;t&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  First Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    t             //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>Then we encode the <strong>Key and Value for ‚Äú<code>l</code>‚Äù</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Second Key-Value Pair: Map the Key (&quot;l&quot;)
  res = cbor_encode_text_stringz(
    &amp;mapEncoder,  //  Map Encoder
    &quot;l&quot;           //  Key
  );    
  assert(res == CborNoError);

  //  Second Key-Value Pair: Map the Value
  res = cbor_encode_int(
    &amp;mapEncoder,  //  Map Encoder 
    l             //  Value
  );
  assert(res == CborNoError);
</code></pre></div>
<p>And we <strong>close the Map Encoder</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Close the Map Encoder
  res = cbor_encoder_close_container( ... );

  //  How many bytes were encoded
  size_t output_len = cbor_encoder_get_buffer_size( ... );
</code></pre></div><h2 id="send-lorawan-packet"><a href="#send-lorawan-packet">5.2 Send LoRaWAN Packet</a></h2>
<p>We‚Äôre ready to transmit our encoded Sensor Data!</p>
<p>First we <strong>allocate a Packet Buffer</strong> for our LoRaWAN Packet‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Validate the output size
  if (lora_app_mtu() &lt; output_len) { return; }  //  Output too big

  //  Attempt to allocate a Packet Buffer
  struct pbuf *om = lora_pkt_alloc(output_len);
  if (!om) { return; }  //  Unable to allocate Packet Buffer
</code></pre></div>
<p>Next we <strong>copy our encoded Sensor Data</strong> into the Packet Buffer‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Copy the encoded CBOR into the Packet Buffer
  rc = pbuf_copyinto(om, 0, output, output_len);
  assert(rc == 0);
</code></pre></div>
<p>Finally we <strong>transmit the Packet Buffer</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>  //  Send the Packet Buffer
  rc = lora_app_port_send(port, mcps_type, om);

  //  Omitted: Check the return code
</code></pre></div>
<p>That‚Äôs how we encode Sensor Data and transmit over LoRaWAN!</p>
<p><img src="https://lupyuen.github.io/images/cbor-code3.png" alt="Encoding Sensor Data and transmitting over LoRaWAN" /></p>
<h2 id="cbor-in-action"><a href="#cbor-in-action">5.3 CBOR In Action</a></h2>
<p>Follow the instructions in the Appendix to <strong>build, flash and run</strong> the LoRaWAN Firmware‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/cbor#appendix-build-and-run-lorawan-firmware"><strong>‚ÄúBuild and Run LoRaWAN Firmware‚Äù</strong></a></li>
</ul>
<p>At the BL602 / BL604 Command Prompt, enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_app_tx_cbor 2 0 1234 2345
</code></pre></div>
<p>This means‚Ä¶</p>
<ul>
<li>
<p>Transmit a LoRaWAN Packet to <strong>Port 2</strong></p>
</li>
<li>
<p>That contains the values <strong><code>t=1234</code></strong> (Temperature), <strong><code>l=2345</code></strong> (Light Level)</p>
</li>
<li>
<p><code>0</code> means that this is an <strong>Unconfirmed Message</strong></p>
<p>(Because we‚Äôre not expecting an acknowledgement)</p>
</li>
</ul>
<p>Our Sensor Data has been transmitted via LoRaWAN to The Things Network!</p>
<p><em>How do we see the Sensor Data in The Things Network?</em></p>
<p>We could use <strong>Grafana</strong>, the open source tool for data visualisation‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/cbor-grafana.jpg" alt="Sensor Data visualised with Grafana" /></p>
<p>Check out this article for the details‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/grafana"><strong>‚ÄúGrafana Data Source for The Things Network‚Äù</strong></a></li>
</ul>
<p>See also this demo of PineDio Stack with Roblox and The Things Network‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/roblox#digital-twin-demo"><strong>‚ÄúIoT Digital Twin with Roblox and The Things Network‚Äù</strong></a></li>
</ul>
<h1 id="decode-cbor"><a href="#decode-cbor">6 Decode CBOR</a></h1>
<p><em>For decoding CBOR packets, can we call the TinyCBOR Library?</em></p>
<p>Sure, we can call the <strong>Decoder Functions</strong> in the TinyCBOR Library‚Ä¶</p>
<ul>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00047.html"><strong>TinyCBOR: Parsing CBOR streams</strong></a></p>
</li>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00048.html"><strong>TinyCBOR: Converting CBOR to text</strong></a></p>
</li>
<li>
<p><a href="https://intel.github.io/tinycbor/current/a00049.html"><strong>TinyCBOR: Converting CBOR to JSON</strong></a></p>
</li>
</ul>
<p>If we‚Äôre transmitting CBOR packets to a server (or cloud), we can decode them with a <strong>CBOR Library for Node.js, Go, Rust,</strong> ‚Ä¶</p>
<ul>
<li><a href="https://cbor.io/impls.html"><strong>CBOR Implementations</strong></a></li>
</ul>
<p>We can decode CBOR Payloads in <strong>The Things Network</strong> with a CBOR Payload Formatter‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/payload"><strong>‚ÄúCBOR Payload Formatter for The Things Network‚Äù</strong></a></li>
</ul>
<p>For Grafana we used a <strong>Go Library for CBOR</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/grafana#decode-cbor-in-go"><strong>‚ÄúDecode CBOR in Go‚Äù</strong></a></li>
</ul>
<p>There‚Äôs even a CBOR Library for <strong>Roblox and Lua Scripting</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/roblox-the-things-network#decode-base64-and-cbor-in-roblox"><strong>‚ÄúDecode Base64 and CBOR in Roblox‚Äù</strong></a></li>
</ul>
<p>TinyCBOR is available on various <strong>Embedded Operating Systems</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/mynewt-core/tree/master/encoding/tinycbor"><strong>Apache Mynewt</strong></a></p>
</li>
<li>
<p><a href="https://doc.riot-os.org/group__pkg__tinycbor.html"><strong>RIOT</strong></a></p>
</li>
<li>
<p><a href="https://docs.zephyrproject.org/latest/reference/kconfig/CONFIG_TINYCBOR.html"><strong>Zephyr</strong></a></p>
</li>
</ul>
<h1 id="whats-next"><a href="#whats-next">7 What‚Äôs Next</a></h1>
<p>For the next article we shall take a quick detour and explore PineDio Stack transmitting Sensor Data to <a href="https://github.com/lupyuen/roblox-the-things-network"><strong>Roblox via The Things Network</strong></a>.</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/roblox"><strong>‚ÄúIoT Digital Twin with Roblox and The Things Network‚Äù</strong></a></li>
</ul>
<p>Then we shall head back and transmit BL602 / BL604‚Äôs <strong>Internal Temperature Sensor Data</strong> to The Things Network.</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/tsen"><strong>‚ÄúInternal Temperature Sensor on BL602‚Äù</strong></a></li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/q1ir5x/encode_sensor_data_with_cbor_on_bl602/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/cbor.md"><code>lupyuen.github.io/src/cbor.md</code></a></p>
<h1 id="notes"><a href="#notes">8 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1441626008931602433">this Twitter Thread</a></li>
</ol>
<h1 id="appendix-build-and-run-cbor-firmware"><a href="#appendix-build-and-run-cbor-firmware">9 Appendix: Build and Run CBOR Firmware</a></h1>
<p>Here are the steps to build, flash and run the <strong>CBOR Firmware for BL602 and BL604</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/pinedio_cbor"><strong>bl_iot_sdk/customer_app/pinedio_cbor</strong></a></li>
</ul>
<p>(If we wish to add the TinyCBOR Library to an existing BL602 / BL604 project, check the next chapter)</p>
<h2 id="build-cbor-firmware"><a href="#build-cbor-firmware">9.1 Build CBOR Firmware</a></h2>
<p>Download the firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the master branch of lupyuen&#39;s bl_iot_sdk
git clone --recursive --branch master https://github.com/lupyuen/bl_iot_sdk
</code></pre></div>
<p>Build the Firmware Binary File <code>pinedio_cbor.bin</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602

cd bl_iot_sdk/customer_app/pinedio_cbor
make

## For WSL: Copy the firmware to /mnt/c/blflash, which refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp build_out/pinedio_cbor.bin /mnt/c/blflash
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<h2 id="flash-cbor-firmware"><a href="#flash-cbor-firmware">9.2 Flash CBOR Firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>pinedio_cbor.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>pinedio_cbor.bin</code> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux:
blflash flash build_out/pinedio_cbor.bin \
    --port /dev/ttyUSB0

## For macOS:
blflash flash build_out/pinedio_cbor.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

## For Windows: Change COM5 to the BL602 / BL604 Serial Port
blflash flash c:\blflash\pinedio_cbor.bin --port COM5
</code></pre></div>
<p>(For WSL: Do this under plain old Windows CMD, not WSL, because blflash needs to access the COM port)</p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-cbor-firmware"><a href="#run-cbor-firmware">9.3 Run CBOR Firmware</a></h2>
<p>Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602 / BL604</a></p>
<h1 id="appendix-add-tinycbor-to-your-project"><a href="#appendix-add-tinycbor-to-your-project">10 Appendix: Add TinyCBOR to Your Project</a></h1>
<p>Here are the steps for <strong>adding the TinyCBOR Library</strong> to an existing BL602 or BL604 project‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/tinycbor-bl602"><strong>lupyuen/tinycbor-bl602</strong></a></li>
</ul>
<p>We assume there‚Äôs an existing <strong>bl_iot_sdk</strong> folder.</p>
<p>Add <strong>tinycbor-bl602</strong> as a submodule under <strong>bl_iot_sdk/components/3rdparty</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cd bl_iot_sdk/components/3rdparty
git submodule add https://github.com/lupyuen/tinycbor-bl602
</code></pre></div>
<p>Edit the <strong>Makefile</strong> for our project‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Insert this line into the COMPONENTS block
COMPONENTS_TINYCBOR := tinycbor-bl602
...

## Insert this line into INCLUDE_COMPONENTS block
INCLUDE_COMPONENTS += $(COMPONENTS_TINYCBOR)
...

## This should appear after INCLUDE_COMPONENTS block
include $(BL60X_SDK_PATH)/make_scripts_riscv/project.mk
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_cbor/Makefile#L21-L36">(See a sample Makefile)</a></p>
<p>Include <strong>‚Äúcbor.h‚Äù</strong> in our source file‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>##include &quot;cbor.h&quot;  //  For Tiny CBOR Library
</code></pre></div>
<p>And start coding with TinyCBOR!</p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_cbor/pinedio_cbor/demo.c">(See a sample source file)</a></p>
<h1 id="appendix-build-and-run-lorawan-firmware"><a href="#appendix-build-and-run-lorawan-firmware">11 Appendix: Build and Run LoRaWAN Firmware</a></h1>
<p>Here are the steps to build, flash and run the <strong>LoRaWAN Firmware for PineDio Stack BL604</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/pinedio_lorawan"><strong>bl_iot_sdk/customer_app/pinedio_lorawan</strong></a></li>
</ul>
<h2 id="build-lorawan-firmware"><a href="#build-lorawan-firmware">11.1 Build LoRaWAN Firmware</a></h2>
<p>Download the <a href="https://github.com/lupyuen/bl_iot_sdk/tree/master/customer_app/pinedio_lorawan"><strong>LoRaWAN firmware and driver source code</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the master branch of lupyuen&#39;s bl_iot_sdk
git clone --recursive --branch master https://github.com/lupyuen/bl_iot_sdk
</code></pre></div>
<p>In the <code>customer_app/pinedio_lorawan</code> folder, edit <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_lorawan/Makefile"><code>Makefile</code></a> and find this setting‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>CFLAGS += -DCONFIG_LORA_NODE_REGION=1
</code></pre></div>
<p>Change ‚Äú<code>1</code>‚Äù to your LoRa Region‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Value</th><th style="text-align: left">Region</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td><td style="text-align: left">No region</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">AS band on 923MHz</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">Australian band on 915MHz</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">Chinese band on 470MHz</td></tr>
<tr><td style="text-align: left">4</td><td style="text-align: left">Chinese band on 779MHz</td></tr>
<tr><td style="text-align: left">5</td><td style="text-align: left">European band on 433MHz</td></tr>
<tr><td style="text-align: left">6</td><td style="text-align: left">European band on 868MHz</td></tr>
<tr><td style="text-align: left">7</td><td style="text-align: left">South Korean band on 920MHz</td></tr>
<tr><td style="text-align: left">8</td><td style="text-align: left">India band on 865MHz</td></tr>
<tr><td style="text-align: left">9</td><td style="text-align: left">North American band on 915MHz</td></tr>
<tr><td style="text-align: left">10</td><td style="text-align: left">North American band on 915MHz with a maximum of 16 channels</td></tr>
</tbody></table>
</div>
<p>The <strong>GPIO Pin Numbers</strong> for LoRa SX1262 are defined in‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>components/3rdparty/lora-sx1262/include/sx126x-board.h
</code></pre></div>
<p>They have been configured for PineDio Stack. (So no changes needed)</p>
<p>Build the Firmware Binary File <code>pinedio_lorawan.bin</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## TODO: Change this to the full path of bl_iot_sdk
export BL60X_SDK_PATH=$HOME/bl_iot_sdk
export CONFIG_CHIP_NAME=BL602

cd bl_iot_sdk/customer_app/pinedio_lorawan
make

## For WSL: Copy the firmware to /mnt/c/blflash, which refers to c:\blflash in Windows
mkdir /mnt/c/blflash
cp build_out/pinedio_lorawan.bin /mnt/c/blflash
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building bl_iot_sdk</a></p>
<h2 id="flash-lorawan-firmware"><a href="#flash-lorawan-firmware">11.2 Flash LoRaWAN Firmware</a></h2>
<p>Follow these steps to install <code>blflash</code>‚Ä¶</p>
<ol>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
</ol>
<p>We assume that our Firmware Binary File <code>pinedio_lorawan.bin</code> has been copied to the <code>blflash</code> folder.</p>
<p>Set BL602 / BL604 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>High</strong> <a href="https://lupyuen.github.io/images/pinedio-high.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>Enter these commands to flash <code>pinedio_lorawan.bin</code> to BL602 / BL604 over UART‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux:
blflash flash build_out/pinedio_lorawan.bin \
    --port /dev/ttyUSB0

## For macOS:
blflash flash build_out/pinedio_lorawan.bin \
    --port /dev/tty.usbserial-1420 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

## For Windows: Change COM5 to the BL602 / BL604 Serial Port
blflash flash c:\blflash\pinedio_lorawan.bin --port COM5
</code></pre></div>
<p>(For WSL: Do this under plain old Windows CMD, not WSL, because blflash needs to access the COM port)</p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<h2 id="run-lorawan-firmware"><a href="#run-lorawan-firmware">11.3 Run LoRaWAN Firmware</a></h2>
<p>Set BL602 / BL604 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineDio Stack BL604:</strong></p>
<ol>
<li>
<p>Set the <strong>GPIO 8 Jumper</strong> to <strong>Low</strong> <a href="https://lupyuen.github.io/images/pinedio-low.jpg">(Like this)</a></p>
</li>
<li>
<p>Disconnect the USB cable and reconnect</p>
<p>Or use the Improvised Reset Button <a href="https://lupyuen.github.io/articles/pinedio#appendix-improvised-reset-button-for-pinedio-stack">(Here‚Äôs how)</a></p>
</li>
</ol>
<p><strong>For PineCone BL602:</strong></p>
<ol>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ol>
<p><strong>For BL10:</strong></p>
<ol>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ol>
<p><strong>For <a href="https://docs.ai-thinker.com/en/wb2">Ai-Thinker Ai-WB2</a>, Pinenut and MagicHome BL602:</strong></p>
<ol>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ol>
<p>After restarting, connect to BL602 / BL604‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<p><strong>For Linux:</strong></p>
<div class="example-wrap"><pre class="language-bash"><code>screen /dev/ttyUSB0 2000000
</code></pre></div>
<p><strong>For macOS:</strong> Use CoolTerm (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>For Windows:</strong> Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602 / BL604</a></p>
<h2 id="enter-lorawan-commands"><a href="#enter-lorawan-commands">11.4 Enter LoRaWAN Commands</a></h2>
<p>Let‚Äôs enter the LoRaWAN Commands to join The Things Network and transmit a Data Packet!</p>
<ol>
<li>
<p>Log on to <strong>The Things Network</strong>. Browse to our Device and copy these values‚Ä¶</p>
<p><strong>JoinEUI</strong> (Join Extended Unique Identifier)</p>
<p><strong>DevEUI</strong> (Device Extended Unique Identifier)</p>
<p><strong>AppKey</strong> (Application Key)</p>
<p><a href="https://lupyuen.github.io/articles/ttn#join-device-to-the-things-network">(Instructions here)</a></p>
</li>
<li>
<p>In the BL602 / BL604 terminal, press Enter to reveal the command prompt.</p>
</li>
<li>
<p>First we start the <strong>Background Task</strong> that will handle LoRa packets‚Ä¶</p>
<p>Enter this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>create_task
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/lora2#event-queue">(<code>create_task</code> is explained here)</a></p>
</li>
<li>
<p>Next we initialise the <strong>LoRa SX1262 and LoRaWAN Drivers</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>init_lorawan
</code></pre></div>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/pinedio_lorawan/pinedio_lorawan/lorawan.c#L168-L174">(<code>init_lorawan</code> is defined here)</a></p>
</li>
<li>
<p>Set the <strong>DevEUI</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_wr_dev_eui 0xAB:0xBA:0xDA:0xBA:0xAB:0xBA:0xDA:0xBA
</code></pre></div>
<p>Change ‚Äú<code>0xAB:0xBA:...</code>‚Äù to your <strong>DevEUI</strong></p>
<p>(Remember to change the <strong>‚Äú<code>,</code>‚Äù</strong> delimiter to <strong>‚Äú<code>:</code>‚Äù</strong>)</p>
</li>
<li>
<p>Set the <strong>JoinEUI</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_wr_app_eui 0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00
</code></pre></div>
<p>Change ‚Äú<code>0x00:0x00:...</code>‚Äù to your <strong>JoinEUI</strong></p>
<p>(Yep change the <strong>‚Äú<code>,</code>‚Äù</strong> delimiter to <strong>‚Äú<code>:</code>‚Äù</strong>)</p>
</li>
<li>
<p>Set the <strong>AppKey</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_wr_app_key 0xAB:0xBA:0xDA:0xBA:0xAB:0xBA:0xDA:0xBA0xAB:0xBA:0xDA:0xBA:0xAB:0xBA:0xDA:0xBA
</code></pre></div>
<p>Change ‚Äú<code>0xAB:0xBA:...</code>‚Äù to your <strong>AppKey</strong></p>
<p>(Again change <strong>‚Äú<code>,</code>‚Äù</strong> to <strong>‚Äú<code>:</code>‚Äù</strong>)</p>
</li>
<li>
<p>We send a request to <strong>join The Things Network</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_join 1
</code></pre></div>
<p>‚Äú<code>1</code>‚Äù means try only once.</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#join-network-request">(<code>las_join</code> is explained here)</a></p>
</li>
<li>
<p>We open an <strong>Application Port</strong> that will connect to The Things Network‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_app_port open 2
</code></pre></div>
<p>‚Äú<code>2</code>‚Äù is the Application Port Number</p>
<p><a href="https://lupyuen.github.io/articles/lorawan#open-lorawan-port">(<code>las_app_port</code> is explained here)</a></p>
</li>
<li>
<p>Finally we <strong>send a data packet to The Things Network</strong> over LoRaWAN‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>las_app_tx_cbor 2 0 1234 2345
</code></pre></div>
<p>This means‚Ä¶</p>
<ul>
<li>
<p>Transmit a LoRaWAN Packet to <strong>Port 2</strong></p>
</li>
<li>
<p>That contains the values <strong><code>t=1234</code></strong> (Temperature), <strong><code>l=2345</code></strong> (Light Level)</p>
</li>
<li>
<p><code>0</code> means that this is an <strong>Unconfirmed Message</strong></p>
<p>(Because we‚Äôre not expecting an acknowledgement)</p>
</li>
</ul>
<p>Our Sensor Data has been transmitted via LoRaWAN to The Things Network!</p>
<p><a href="https://youtu.be/BMMIIiZG6G0"><strong>Watch the demo video on YouTube</strong></a></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/customer_app/sdk_app_lorawan/README.md#output-log"><strong>See the output log</strong></a></p>
</li>
</ol>
<p>Check out this demo of PineDio Stack with Roblox and The Things Network‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/roblox#digital-twin-demo"><strong>‚ÄúIoT Digital Twin with Roblox and The Things Network‚Äù</strong></a></li>
</ul>
<h1 id="appendix-porting-tinycbor-to-bl602"><a href="#appendix-porting-tinycbor-to-bl602">12 Appendix: Porting TinyCBOR to BL602</a></h1>
<p>Below are the fixes we made while porting the TinyCBOR library to BL602 / BL604‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/tinycbor-bl602/commit/971dca84b0b036a4ed44aa808e6eb18033161170">‚ÄúFix fall through‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tinycbor-bl602/commit/c32bbc7696a54578f050467f1e182f4fd0f9bb9a">‚ÄúFix RetType, LenType‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tinycbor-bl602/commit/65f857a3f2c8f0169ff215047fbcf7cd956eb55a">‚ÄúFix open_memstream‚Äù</a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/tinycbor-bl602/commit/0594d2f29646f65db22a60102d25c7aa675e9cae">‚ÄúDon‚Äôt use memstream‚Äù</a></p>
</li>
</ul>

    
</body>
</html>