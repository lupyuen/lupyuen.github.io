<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Rust on RISC-V BL602: Is It Sunny?</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Rust on RISC-V BL602: Is It Sunny?" 
    data-rh="true">
<meta property="og:description" 
    content="Rust Firmware that reads Analog Inputs... With the Analog-to-Digital Converter on RISC-V BL602"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/adc-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Rust on RISC-V BL602: Is It Sunny?</h1>
    <nav id="TOC"><ul>
<li><a href="#bl602-adc-in-c">1 BL602 ADC in C</a><ul>
<li><a href="#definitions">1.1 Definitions</a><ul></ul></li>
<li><a href="#initialise-the-adc-channel">1.2 Initialise the ADC Channel</a><ul></ul></li>
<li><a href="#read-the-adc-channel">1.3 Read the ADC Channel</a><ul></ul></li>
<li><a href="#run-the-c-firmware">1.4 Run the C Firmware</a><ul></ul></li>
<li><a href="#set-the-adc-gain">1.5 Set the ADC Gain</a><ul></ul></li></ul></li>
<li><a href="#create-a-bl602-rust-project">2 Create a BL602 Rust Project</a><ul></ul></li>
<li><a href="#bl602-adc-in-rust">3 BL602 ADC in Rust</a><ul>
<li><a href="#definitions-1">3.1 Definitions</a><ul></ul></li>
<li><a href="#initialise-the-adc-channel-1">3.2 Initialise the ADC Channel</a><ul></ul></li>
<li><a href="#read-the-adc-channel-1">3.3 Read the ADC Channel</a><ul></ul></li></ul></li>
<li><a href="#build-the-bl602-rust-firmware">4 Build the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#flash-the-bl602-rust-firmware">5 Flash the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a><ul></ul></li>
<li><a href="#from-c-to-rust">7 From C To Rust</a><ul>
<li><a href="#safer-rust">7.1 Safer Rust</a><ul></ul></li>
<li><a href="#static-variables-in-rust">7.2 Static Variables in Rust</a><ul></ul></li></ul></li>
<li><a href="#rust-wrapper-for-bl602-iot-sdk">8 Rust Wrapper for BL602 IoT SDK</a><ul></ul></li>
<li><a href="#why-sunlight">9 Why Sunlight?</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li>
<li><a href="#appendix-call-c-functions-from-rust">12 Appendix: Call C Functions from Rust</a><ul></ul></li>
<li><a href="#appendix-convert-c-pointers-to-rust">13 Appendix: Convert C Pointers to Rust</a><ul></ul></li>
<li><a href="#appendix-copy-memory-with-c-pointers">14 Appendix: Copy Memory with C Pointers</a><ul></ul></li>
<li><a href="#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">15 Appendix: Generating the Rust Wrapper for BL602 IoT SDK</a><ul>
<li><a href="#how-it-works">15.1 How it works</a><ul></ul></li>
<li><a href="#inject-the-docs">15.2 Inject the docs</a><ul></ul></li>
<li><a href="#rename-the-functions">15.3 Rename the functions</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>8 Aug 2021</em></p>
<p>Today we shall magically transform <a href="https://lupyuen.github.io/articles/pinecone"><strong>any RISC-V BL602 Board</strong></a> into a <strong>Light Sensor!</strong></p>
<p>We‚Äôll do this two ways‚Ä¶</p>
<ol>
<li>
<p>First we code the firmware in C</p>
</li>
<li>
<p>Then we port the C firmware to Rust with the‚Ä¶</p>
<p><a href="https://crates.io/crates/bl602-sdk"><strong>Rust Wrapper for BL602 IoT SDK</strong></a></p>
<p>(New to Rust? No worries we have tips for you!)</p>
</li>
</ol>
<p><em>Wait‚Ä¶ Do all BL602 Boards have an onboard Light Sensor?</em></p>
<p>Nope, all we need is a <strong>BL602 Board with an LED</strong>!</p>
<p>Reading the LED with BL602‚Äôs <strong>Analog-to-Digital Converter (ADC)</strong> will turn it into a simple, improvised Light Sensor.</p>
<p><em>Amazing! Will this work with any BL602 Board?</em></p>
<p>We have tested this with <a href="https://lupyuen.github.io/articles/pinecone"><strong>PineCone BL602</strong></a> and its onboard LED.</p>
<p>It will probably work with any BL602 / BL604 Board with an <strong>onboard or external LED:</strong> PineDio Stack, Pinenut, DT-BL10, MagicHome BL602, ‚Ä¶</p>
<p><em>Will our Light Sensor detect any kind of light?</em></p>
<p>Our LED-turned-Light-Sensor works best for <strong>detecting sunlight</strong>‚Ä¶ We‚Äôll learn why in a while.</p>
<p>(Yep It‚Äôs Always Sunny in Singapore ‚Ä¶ So this Sunlight Sensor won‚Äôt be so useful in Singapore üòÇ)</p>
<p><img src="https://lupyuen.github.io/images/adc-title.jpg" alt="Testing the improvised Light Sensor on PineCone BL602 RISC-V Board. BTW that‚Äôs the moon" /></p>
<p><em>Testing the improvised Light Sensor on PineCone BL602 RISC-V Board. BTW that‚Äôs the moon</em></p>
<h1 id="bl602-adc-in-c" class="section-header"><a href="#bl602-adc-in-c">1 BL602 ADC in C</a></h1>
<p>On PineCone BL602, there‚Äôs a <strong>Blue LED</strong> connected on <strong>GPIO Pin Number 11</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/led-rgb.png" alt="PineCone RGB LED Schematic" /></p>
<p><a href="https://github.com/pine64/bl602-docs/blob/main/mirrored/Pine64%20BL602%20EVB%20Schematic%20ver%201.1.pdf">(From PineCone RGB LED Schematic)</a></p>
<p>For light sensing, we shall <strong>read the voltage</strong> from this LED GPIO with BL602‚Äôs Analog-to-Digital Converter (ADC).</p>
<p>(Because LEDs will produce a current when exposed to light. <a href="https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227">See this</a>)</p>
<p>Let‚Äôs study the <strong>C Firmware for BL602 ADC</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/"><code>sdk_app_adc2</code></a></p>
<p>By calling the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c"><strong>BL602 ADC Low Level HAL</strong></a> (Hardware Abstraction Layer), we shall‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise the ADC Channel</strong> for reading our LED GPIO</p>
</li>
<li>
<p><strong>Compute the average value</strong> of the ADC Samples that have been read</p>
</li>
</ol>
<h2 id="definitions" class="section-header"><a href="#definitions">1.1 Definitions</a></h2>
<p>We start by defining the <strong>GPIO Pin Number</strong> that will be read via ADC: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L13-L31"><code>demo.c</code></a></p>
<pre><code class="language-c">/// GPIO Pin Number that will be configured as ADC Input.
/// PineCone Blue LED is connected on BL602 GPIO 11.
/// PineCone Green LED is connected on BL602 GPIO 14.
/// Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
/// TODO: Change the GPIO Pin Number for your BL602 board
#define ADC_GPIO 11
</code></pre>
<p><strong>Not all GPIOs</strong> are supported by BL602‚Äôs ADC!</p>
<p>According to the BL602 Reference Manual, only the following GPIOs are <strong>supported for ADC</strong>: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15</p>
<p><img src="https://lupyuen.github.io/images/adc-pins.png" alt="ADC GPIO Pin Numbers" /></p>
<p>Next we define the <strong>ADC Frequency</strong>. We shall read 10,000 ADC Samples every second‚Ä¶</p>
<pre><code class="language-c">/// We set the ADC Frequency to 10 kHz according to &lt;https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227&gt;
/// This is 10,000 samples per second.
#define ADC_FREQUENCY 10000  //  Hz
</code></pre>
<p>For computing the average, we shall remember the <strong>last 1,000 ADC Samples read</strong>‚Ä¶</p>
<pre><code class="language-c">/// We shall read 1,000 ADC samples, which will take 0.1 seconds
#define ADC_SAMPLES 1000
</code></pre>
<p>Finally we set the <strong>ADC Gain</strong> to increase the sensitivity of the ADC‚Ä¶</p>
<pre><code class="language-c">/// Set ADC Gain to Level 1 to increase the ADC sensitivity.
/// To disable ADC Gain, set `ADC_GAIN1` and `ADC_GAIN2` to `ADC_PGA_GAIN_NONE`.
/// See &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;
#define ADC_GAIN1 ADC_PGA_GAIN_1
#define ADC_GAIN2 ADC_PGA_GAIN_1
</code></pre>
<p>More about ADC Gain in a while.</p>
<h2 id="initialise-the-adc-channel" class="section-header"><a href="#initialise-the-adc-channel">1.2 Initialise the ADC Channel</a></h2>
<p>Here‚Äôs how we <strong>initialise the ADC Channel</strong> for reading our LED GPIO: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L36-L77"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Command to init the ADC Channel and start reading the ADC Samples.
/// Based on `hal_adc_init` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L50-L102&gt;
void init_adc(char *buf, int len, int argc, char **argv) {
  //  Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15
  assert(ADC_GPIO==4 || ADC_GPIO==5 || ADC_GPIO==6 || ADC_GPIO==9 || ADC_GPIO==10 || ADC_GPIO==11 || ADC_GPIO==12 || ADC_GPIO==13 || ADC_GPIO==14 || ADC_GPIO==15);

  //  For Single-Channel Conversion Mode, frequency must be between 500 and 16,000 Hz
  assert(ADC_FREQUENCY &gt;= 500 &amp;&amp; ADC_FREQUENCY &lt;= 16000);

  //  Init the ADC Frequency for Single-Channel Conversion Mode
  int rc = bl_adc_freq_init(1, ADC_FREQUENCY);
  assert(rc == 0);
</code></pre>
<p>Our <strong><code>init_adc</code> Command</strong> begins by validating the GPIO Pin Number and ADC Frequency.</p>
<p>Then it calls <strong><code>bl_adc_freq_init</code></strong> to set the <strong>ADC Frequency</strong>.</p>
<p>(Functions named <code>bl_adc_*</code> are defined in the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c">BL602 ADC Low Level HAL</a>)</p>
<p>The first parameter to <code>bl_adc_freq_init</code> selects the <strong>ADC Mode</strong>‚Ä¶</p>
<ul>
<li>
<p>ADC Mode 0: <strong>Scan Conversion Mode</strong></p>
<p>BL602 ADC Controller reads <strong>One ADC Sample</strong> from <strong>Multiple ADC Channels.</strong></p>
<p>(So it‚Äôs scanning across multiple ADC Channels, recording one sample per channel)</p>
</li>
<li>
<p>ADC Mode 1: <strong>Single-Channel Conversion Mode</strong></p>
<p>BL602 ADC Controller reads <strong>Multiple ADC Samples</strong> continuously from <strong>One ADC Channel.</strong></p>
<p>(This is the mode we‚Äôre using)</p>
</li>
</ul>
<p>Next we set the <strong>ADC GPIO Pin Number</strong> for ADC Mode 1 (Single-Channel Conversion)‚Ä¶</p>
<pre><code class="language-c">  //  Init the ADC GPIO for Single-Channel Conversion Mode
  rc = bl_adc_init(1, ADC_GPIO);
  assert(rc == 0);
</code></pre>
<p>To increase the ADC sensitivity, we set the <strong>ADC Gain</strong>‚Ä¶</p>
<pre><code class="language-c">  //  Enable ADC Gain to increase the ADC sensitivity
  rc = set_adc_gain(ADC_GAIN1, ADC_GAIN2);
  assert(rc == 0);
</code></pre>
<p>(More about this in a while)</p>
<p>BL602 ADC Controller shall transfer the ADC Samples directly into RAM, thanks to the <strong>Direct Memory Access (DMA) Controller</strong>‚Ä¶</p>
<pre><code class="language-c">  //  Init DMA for the ADC Channel for Single-Channel Conversion Mode
  rc = bl_adc_dma_init(1, ADC_SAMPLES);
  assert(rc == 0);
</code></pre>
<p>(First parameter of <code>bl_adc_dma_init</code> is the ADC Mode)</p>
<p>We configure the GPIO Pin for <strong>ADC Input</strong>‚Ä¶</p>
<pre><code class="language-c">  //  Configure the GPIO Pin as ADC Input, no pullup, no pulldown
  rc = bl_adc_gpio_init(ADC_GPIO);
  assert(rc == 0);
</code></pre>
<p>We set the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>
<pre><code class="language-c">  //  Get the ADC Channel Number for the GPIO Pin
  int channel = bl_adc_get_channel_by_gpio(ADC_GPIO);

  //  Get the DMA Context for the ADC Channel
  adc_ctx_t *ctx = bl_dma_find_ctx_by_channel(ADC_DMA_CHANNEL);
  assert(ctx != NULL);

  //  Indicate that the GPIO has been configured for ADC
  ctx-&gt;chan_init_table |= (1 &lt;&lt; channel);
</code></pre>
<p>(<code>bl_dma_find_ctx_by_channel</code> is defined in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_dma.c">BL602 DMA HAL</a>)</p>
<p>Finally we <strong>start the ADC Channel</strong>‚Ä¶</p>
<pre><code class="language-c">  //  Start reading the ADC via DMA
  bl_adc_start();
}
</code></pre>
<p>BL602 ADC Controller will <strong>read the ADC Samples continuously</strong> (from the GPIO Pin) into RAM (until we stop the ADC Channel).</p>
<h2 id="read-the-adc-channel" class="section-header"><a href="#read-the-adc-channel">1.3 Read the ADC Channel</a></h2>
<p><em>After starting the ADC Channel, how do we fetch the ADC Samples that have been read?</em></p>
<p>Let‚Äôs find out in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L79-L116"><code>demo.c</code></a> ‚Ä¶</p>
<pre><code class="language-c">/// Command to compute the average value of the ADC Samples that have just been read.
/// Based on `hal_adc_get_data` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L142-L179&gt;
void read_adc(char *buf, int len, int argc, char **argv) {
  //  Get the ADC Channel Number for the GPIO Pin
  int channel = bl_adc_get_channel_by_gpio(ADC_GPIO);
    
  //  Get the DMA Context for the ADC Channel
  adc_ctx_t *ctx = bl_dma_find_ctx_by_channel(ADC_DMA_CHANNEL);
  assert(ctx != NULL);

  //  Verify that the GPIO has been configured for ADC
  assert(((1 &lt;&lt; channel) &amp; ctx-&gt;chan_init_table) != 0);
</code></pre>
<p>Our <strong><code>read_adc</code> Command</strong> begins by verifying the <strong>DMA Context</strong> for the ADC Channel.</p>
<p>Next we check whether the <strong>ADC Sampling</strong> has been completed for the ADC Channel‚Ä¶</p>
<pre><code class="language-c">  //  If ADC Sampling is not finished, try again later    
  if (ctx-&gt;channel_data == NULL) {
    printf(&quot;ADC Sampling not finished\r\n&quot;);
    return;
  }
</code></pre>
<p>Remember that the BL602 ADC Controller will <strong>read ADC Samples continuously</strong> and write the last 1,000 samples to RAM (via DMA).</p>
<p>Let‚Äôs <strong>copy the last 1,000 ADC Samples</strong> from the DMA Context (in RAM) to a Static Array <code>adc_data</code>‚Ä¶</p>
<pre><code class="language-c">  //  Static array that will store 1,000 ADC Samples
  static uint32_t adc_data[ADC_SAMPLES];

  //  Copy the read ADC Samples to the static array
  memcpy(
    (uint8_t*) adc_data,             //  Destination
    (uint8_t*) (ctx-&gt;channel_data),  //  Source
    sizeof(adc_data)                 //  Size
  );  
</code></pre>
<p>Then we compute the <strong>average value of the ADC Samples</strong> in <code>adc_data</code>‚Ä¶</p>
<pre><code class="language-c">  //  Compute the average value of the ADC Samples
  uint32_t sum = 0;
  for (int i = 0; i &lt; ADC_SAMPLES; i++) {
    //  Scale up the ADC Sample to the range 0 to 3199
    uint32_t scaled = ((adc_data[i] &amp; 0xffff) * 3200) &gt;&gt; 16;
    sum += scaled;
  }
  printf(&quot;Average: %lu\r\n&quot;, (sum / ADC_SAMPLES));
}
</code></pre>
<p>The default ADC Configuration has roughly <strong>12 Bits of Resolution per ADC Sample</strong>.</p>
<p>Thus we scale each ADC Sample to the range <strong>0 to 3199</strong>.</p>
<p>And that‚Äôs how we code BL602 ADC Firmware in C!</p>
<p><img src="https://lupyuen.github.io/images/adc-demo.png" alt="Running the BL602 ADC Firmware in C" /></p>
<h2 id="run-the-c-firmware" class="section-header"><a href="#run-the-c-firmware">1.4 Run the C Firmware</a></h2>
<p>Watch what happens when we <strong>flash and run</strong> the C Firmware for BL602 ADC: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/"><code>sdk_app_adc2</code></a></p>
<ol>
<li>
<p>Enter this command to <strong>initialise the ADC Channel</strong>‚Ä¶</p>
<pre><code class="language-text"># init_adc
</code></pre>
<p>(We‚Äôve seen this function earlier)</p>
</li>
<li>
<p>Place the BL602 Board (with LED) in a <strong>dark place</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times to get the <strong>average values</strong> of the last 1,000 ADC Samples‚Ä¶</p>
<pre><code class="language-text"># read_adc
Average: 1416

# read_adc
Average: 1416

# read_adc
Average: 1416
</code></pre>
</li>
<li>
<p>Now place the BL602 Board (with LED) <strong>under sunlight</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times‚Ä¶</p>
<pre><code class="language-text"># read_adc
Average: 1408

# read_adc
Average: 1408

# read_adc
Average: 1408
</code></pre>
<p>Note that the average values have <strong>dropped from 1416 to 1408.</strong></p>
</li>
<li>
<p>Place the BL602 Board (with LED) <strong>back in the dark</strong> and check the average values‚Ä¶</p>
<pre><code class="language-text"># read_adc
Average: 1417

# read_adc
Average: 1416

# read_adc
Average: 1416
</code></pre>
<p>The average values have <strong>increased from 1408 to 1416.</strong></p>
<p>Yep our improvised BL602 Light Sensor works!</p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/adc-gain2.png" alt="Setting the ADC Gain" /></p>
<h2 id="set-the-adc-gain" class="section-header"><a href="#set-the-adc-gain">1.5 Set the ADC Gain</a></h2>
<p>Let‚Äôs chat about <strong>ADC Gain</strong>, which we used when reading the LED as a Light Sensor. </p>
<p>(ADC Gain probably won‚Äôt be needed for reading most types of ADC Inputs)</p>
<p><em>Why do we need ADC Gain when reading an LED?</em></p>
<p>Our LED generates a <strong>tiny bit of current</strong> when exposed to light. To measure that tiny bit of current, we need to increase the ADC sensitivity.</p>
<p>Thus we <strong>increase the ADC Gain</strong>. (By default there‚Äôs no ADC Gain)</p>
<p><em>BL602 HAL has a function that sets the ADC Gain right?</em></p>
<p>Sadly no. We need to go really low-level and call the <a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_adc.c#L152-L230"><strong>BL602 Standard Driver for ADC</strong></a>.</p>
<p>(The BL602 Standard Driver directly manipulates the BL602 Hardware Registers)</p>
<p>Here‚Äôs the low-level code that <strong>sets the ADC Gain</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc2/sdk_app_adc2/demo.c#L118-L146"><code>demo.c</code></a></p>
<pre><code class="language-c">/// Enable ADC Gain to increase the ADC sensitivity.
/// Based on ADC_Init in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_adc.c#L152-L230&gt;
static int set_adc_gain(uint32_t gain1, uint32_t gain2) {
  //  Read the ADC Configuration Hardware Register
  uint32_t reg = BL_RD_REG(AON_BASE, AON_GPADC_REG_CONFIG2);

  //  Set the ADC Gain
  reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_PGA1_GAIN, gain1);
  reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_PGA2_GAIN, gain2);

  //  Set the ADC Chop Mode
  if (gain1 != ADC_PGA_GAIN_NONE || gain2 != ADC_PGA_GAIN_NONE) {
    reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_CHOP_MODE, 2);
  } else {
    reg = BL_SET_REG_BITS_VAL(reg, AON_GPADC_CHOP_MODE, 1);        
  }

  //  Enable the ADC PGA
  reg = BL_CLR_REG_BIT(reg, AON_GPADC_PGA_VCMI_EN);
  if (gain1 != ADC_PGA_GAIN_NONE || gain2 != ADC_PGA_GAIN_NONE) {
    reg = BL_SET_REG_BIT(reg, AON_GPADC_PGA_EN);
  } else {
    reg = BL_CLR_REG_BIT(reg, AON_GPADC_PGA_EN);
  }

  //  Update the ADC Configuration Hardware Register
  BL_WR_REG(AON_BASE, AON_GPADC_REG_CONFIG2, reg);
  return 0;
}
</code></pre>
<h1 id="create-a-bl602-rust-project" class="section-header"><a href="#create-a-bl602-rust-project">2 Create a BL602 Rust Project</a></h1>
<p>Before diving into the Rust Firmware, let‚Äôs walk through the steps for <strong>creating a BL602 Rust Project</strong> (like <code>sdk_app_rust_adc</code>)‚Ä¶</p>
<ol>
<li>
<p><strong>Copy the Project Folder</strong> for an existing Rust Project, like <code>sdk_app_rust_gpio</code> ‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_gpio"><strong>Project Folder for <code>sdk_app_rust_gpio</code></strong></a></li>
</ul>
</li>
<li>
<p><strong>Paste the Project Folder</strong> into <strong><code>bl_iot_sdk/customer_app</code></strong> and rename it (like <code>sdk_app_rust_adc</code>)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-project.png" alt="BL602 Rust Project" /></p>
<p>Be sure to <strong>rename the Sub Folder</strong> too. (The <code>sdk_app_rust_adc</code> inside <code>sdk_app_rust_adc</code>)</p>
<p><strong>Delete the <code>build_out</code> folder</strong> if it exists.</p>
</li>
<li>
<p><strong>Edit the <code>Makefile</code></strong> in the new folder and set the Project Name: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/Makefile"><code>sdk_app_rust_adc/Makefile</code></a></p>
<pre><code class="language-text">#  Set the project name
PROJECT_NAME := sdk_app_rust_adc
</code></pre>
</li>
<li>
<p>Set the <strong>GCC Compiler Options</strong> (if any) in the Makefile <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/sdk_app_rust_adc/bouffalo.mk"><code>sdk_app_rust_adc / sdk_app_rust_adc / bouffalo.mk</code></a></p>
</li>
<li>
<p>Edit the <strong><code>run.sh</code> script</strong> in the new folder and set the Project Name: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/run.sh"><code>sdk_app_rust_adc/run.sh</code></a></p>
<pre><code class="language-bash">#  Set the project name
export APP_NAME=sdk_app_rust_adc
</code></pre>
</li>
<li>
<p>Replace the <strong>Rust Source Code</strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs"><code>sdk_app_rust_adc/ rust/src/lib.rs</code></a> </p>
</li>
<li>
<p>Remember to edit <strong><code>README.md</code></strong> and fill in the project details</p>
</li>
</ol>
<h1 id="bl602-adc-in-rust" class="section-header"><a href="#bl602-adc-in-rust">3 BL602 ADC in Rust</a></h1>
<p>Now we study the <strong>Rust Firmware for BL602 ADC</strong>: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc"><code>sdk_app_rust_adc</code></a></p>
<p>We have <strong>converted the C Firmware to Rust</strong> line by line, so the Rust code will look highly similar to C.</p>
<p>Recall that our firmware implements two commands‚Ä¶</p>
<ol>
<li>
<p><strong>Initialise the ADC Channel</strong> for reading our LED GPIO</p>
</li>
<li>
<p><strong>Compute the average value</strong> of the ADC Samples that have been read</p>
</li>
</ol>
<p>Here is the Rust implementation‚Ä¶</p>
<h2 id="definitions-1" class="section-header"><a href="#definitions-1">3.1 Definitions</a></h2>
<p>We start by declaring to the Rust Compiler that we‚Äôre calling the <strong>Rust Core Library</strong> (instead of Rust Standard Library): <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L1-L37"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">no_std</span>]</span>  <span class="comment">//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems</span></pre></div>
<p>(Rust Standard Library is too heavy for embedded programs)</p>
<p>Next we <strong>import the functions</strong> from Rust Core Library that will be used in a while‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Import Libraries</span>
<span class="kw">use</span> <span class="ident">core</span>::{          <span class="comment">//  Rust Core Library</span>
  <span class="ident">fmt::Write</span>,        <span class="comment">//  String Formatting    </span>
  <span class="ident">mem::transmute</span>,    <span class="comment">//  Pointer Casting</span>
  <span class="ident">panic::PanicInfo</span>,  <span class="comment">//  Panic Handler</span>
};</pre></div>
<p>We import the <strong>Rust Wrapper for BL602 IoT SDK</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">bl602_sdk</span>::{     <span class="comment">//  Rust Wrapper for BL602 IoT SDK</span>
  <span class="ident">adc</span>,               <span class="comment">//  ADC HAL</span>
  <span class="ident">dma</span>,               <span class="comment">//  DMA HAL</span>
  <span class="ident">puts</span>,              <span class="comment">//  Console Output</span>
  <span class="ident">Ptr</span>,               <span class="comment">//  C Pointer</span>
  <span class="ident">String</span>,            <span class="comment">//  Strings (limited to 64 chars)</span>
};</pre></div>
<p>We shall read <strong>GPIO 11</strong> (the Blue LED) as ADC Input‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// GPIO Pin Number that will be configured as ADC Input.</span>
<span class="doccomment">/// PineCone Blue LED is connected on BL602 GPIO 11.</span>
<span class="doccomment">/// PineCone Green LED is connected on BL602 GPIO 14.</span>
<span class="doccomment">/// Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15</span>
<span class="doccomment">/// TODO: Change the GPIO Pin Number for your BL602 board</span>
<span class="kw">const</span> <span class="ident">ADC_GPIO</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">11</span>;</pre></div>
<p>BL602 ADC Controller shall read <strong>10,000 ADC Samples per second</strong>, and remember the last <strong>100 ADC Samples</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// We set the ADC Frequency to 10 kHz according to &lt;https://wiki.analog.com/university/courses/electronics/electronics-lab-led-sensor?rev=1551786227&gt;</span>
<span class="doccomment">/// This is 10,000 samples per second.</span>
<span class="kw">const</span> <span class="ident">ADC_FREQUENCY</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">10000</span>;  <span class="comment">//  Hz</span>

<span class="doccomment">/// We shall read 100 ADC samples, which will take 0.01 seconds</span>
<span class="kw">const</span> <span class="ident">ADC_SAMPLES</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">100</span>;</pre></div>
<p>(<code>usize</code> is similar to <code>size_t</code> in C, it‚Äôs used to represent the size of arrays)</p>
<p>We shall set the <strong>ADC Gain</strong> to increase the ADC sensitivity‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Set ADC Gain to Level 1 to increase the ADC sensitivity.</span>
<span class="doccomment">/// To disable ADC Gain, set `ADC_GAIN1` and `ADC_GAIN2` to `ADC_PGA_GAIN_NONE`.</span>
<span class="doccomment">/// See &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;</span>
<span class="kw">const</span> <span class="ident">ADC_GAIN1</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ADC_PGA_GAIN_1</span>;
<span class="kw">const</span> <span class="ident">ADC_GAIN2</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="ident">ADC_PGA_GAIN_1</span>;</pre></div>
<p>But <strong><code>ADC_PGA_GAIN_1</code></strong> is missing from our Rust Wrapper.</p>
<p>Thus we copy the value from BL602 IoT SDK and define it here‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">const</span> <span class="ident">ADC_PGA_GAIN_1</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span>;  <span class="comment">//  From &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/bl602/bl602_std/bl602_std/StdDriver/Inc/bl602_adc.h#L133-L144&gt;</span></pre></div>
<p><img src="https://lupyuen.github.io/images/adc-rust.png" alt="Rust Firmware for BL602 ADC" /></p>
<h2 id="initialise-the-adc-channel-1" class="section-header"><a href="#initialise-the-adc-channel-1">3.2 Initialise the ADC Channel</a></h2>
<p>Here‚Äôs our Rust Function <strong><code>init_adc</code></strong> that will be called by the BL602 Command-Line Interface: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L39-L100"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Command to init the ADC Channel and start reading the ADC Samples.</span>
<span class="doccomment">/// Based on `hal_adc_init` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L50-L102&gt;</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>             <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">init_adc</span>(  <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware</span>
  <span class="ident">_result</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>,        <span class="comment">//  Result to be returned to command-line interface (char *)</span>
  <span class="ident">_len</span>:  <span class="ident">i32</span>,              <span class="comment">//  Size of result buffer (int)</span>
  <span class="ident">_argc</span>: <span class="ident">i32</span>,              <span class="comment">//  Number of command line args (int)</span>
  <span class="ident">_argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>  <span class="comment">//  Array of command line args (char **)</span>
) {
  <span class="ident">puts</span>(<span class="string">&quot;[Rust] Init ADC&quot;</span>);</pre></div>
<p>(We won‚Äôt be parsing the command-line arguments, so let‚Äôs ignore the parameters passed to <code>init_adc</code>)</p>
<p>We start by validating the GPIO Pin Number and ADC Frequency‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Only these GPIOs are supported: 4, 5, 6, 9, 10, 11, 12, 13, 14, 15</span>
  <span class="macro">assert!</span>(<span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">4</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">5</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">6</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">9</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">10</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">11</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">12</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">13</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">14</span> <span class="op">|</span><span class="op">|</span> <span class="ident">ADC_GPIO</span><span class="op">=</span><span class="op">=</span><span class="number">15</span>);

  <span class="comment">//  For Single-Channel Conversion Mode, frequency must be between 500 and 16,000 Hz</span>
  <span class="macro">assert!</span>(<span class="ident">ADC_FREQUENCY</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">500</span> <span class="op">&amp;&amp;</span> <span class="ident">ADC_FREQUENCY</span> <span class="op">&lt;</span><span class="op">=</span> <span class="number">16000</span>);</pre></div>
<p>(Remember: Not all GPIOs are supported for ADC!)</p>
<p>Next we select <strong>ADC Mode 1</strong> (Single-Channel Conversion) and set the <strong>ADC Frequency</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Init the ADC Frequency for Single-Channel Conversion Mode</span>
  <span class="ident">adc::freq_init</span>(<span class="number">1</span>, <span class="ident">ADC_FREQUENCY</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;ADC Freq failed&quot;</span>);</pre></div>
<p>We set the <strong>ADC GPIO Pin Number</strong> for ADC Mode 1‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Init the ADC GPIO for Single-Channel Conversion Mode</span>
  <span class="ident">adc::init</span>(<span class="number">1</span>, <span class="ident">ADC_GPIO</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;ADC Init failed&quot;</span>);</pre></div>
<p>To increase the ADC sensitivity, we set the <strong>ADC Gain</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Enable ADC Gain to increase the ADC sensitivity</span>
  <span class="kw">let</span> <span class="ident">rc</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">set_adc_gain</span>(<span class="ident">ADC_GAIN1</span>, <span class="ident">ADC_GAIN2</span>) };  <span class="comment">//  Unsafe because we are calling C function</span>
  <span class="macro">assert!</span>(<span class="ident">rc</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>);</pre></div>
<p>(This calls our C function <code>set_adc_gain</code>, which shall be explained below)</p>
<p>BL602 ADC Controller shall transfer the ADC Samples directly into RAM, thanks to the <strong>Direct Memory Access (DMA) Controller</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Init DMA for the ADC Channel for Single-Channel Conversion Mode</span>
  <span class="ident">adc::dma_init</span>(<span class="number">1</span>, <span class="ident">ADC_SAMPLES</span> <span class="kw">as</span> <span class="ident">u32</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;DMA Init failed&quot;</span>);</pre></div>
<p>(First parameter of <code>dma_init</code> is the ADC Mode)</p>
<p>We configure the GPIO Pin for <strong>ADC Input</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Configure the GPIO Pin as ADC Input, no pullup, no pulldown</span>
  <span class="ident">adc::gpio_init</span>(<span class="ident">ADC_GPIO</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;ADC GPIO failed&quot;</span>);</pre></div>
<p>And we fetch the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Get the ADC Channel Number for the GPIO Pin</span>
  <span class="kw">let</span> <span class="ident">channel</span> <span class="op">=</span> <span class="ident">adc::get_channel_by_gpio</span>(<span class="ident">ADC_GPIO</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;ADC Channel failed&quot;</span>);

  <span class="comment">//  Get the DMA Context for the ADC Channel</span>
  <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">dma::find_ctx_by_channel</span>(<span class="ident">adc::ADC_DMA_CHANNEL</span> <span class="kw">as</span> <span class="ident">i32</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;DMA Ctx failed&quot;</span>);</pre></div>
<p>However the returned pointer <code>ptr</code> is actually a ‚Äú<code>void *</code>‚Äù pointer from C.</p>
<p>To use the pointer in Rust, we cast it to a <strong>DMA Context Pointer</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)</span>
  <span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="kw">unsafe</span> {     <span class="comment">//  Unsafe because we are casting a pointer</span>
    <span class="ident">transmute</span>::<span class="op">&lt;</span>         <span class="comment">//  Cast the type...</span>
      <span class="ident">Ptr</span>,               <span class="comment">//  From C Pointer (void *)</span>
      <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">adc::adc_ctx</span>  <span class="comment">//  To DMA Context Pointer (adc_ctx *)</span>
    <span class="op">&gt;</span>(<span class="ident">ptr</span>)               <span class="comment">//  For this pointer</span>
  };</pre></div>
<p>(More about <code>transmute</code> in the Appendix)</p>
<p>Now we may update the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Indicate that the GPIO has been configured for ADC</span>
  <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because we are dereferencing a pointer</span>
    (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">chan_init_table</span> <span class="op">|</span><span class="op">=</span> <span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">channel</span>;
  }</pre></div>
<p>(We flag this as <code>unsafe</code> because we‚Äôre dereferencing a pointer: <code>ctx</code>)</p>
<p>Finally we <strong>start the ADC Channel</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Start reading the ADC via DMA</span>
  <span class="ident">adc::start</span>()
    .<span class="ident">expect</span>(<span class="string">&quot;ADC Start failed&quot;</span>);
}</pre></div>
<p>BL602 ADC Controller will <strong>read the ADC Samples continuously</strong> (from the GPIO Pin) into RAM (until we stop the ADC Channel).</p>
<p><img src="https://lupyuen.github.io/images/adc-rust2.png" alt="Rust Firmware to read BL602 ADC" /></p>
<h2 id="read-the-adc-channel-1" class="section-header"><a href="#read-the-adc-channel-1">3.3 Read the ADC Channel</a></h2>
<p><em>Our ADC Channel has been started, how do we average the ADC Samples that have been read?</em></p>
<p>Let‚Äôs check out the Rust Function <strong><code>read_adc</code></strong> in <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L102-L165"><code>lib.rs</code></a> ‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="doccomment">/// Command to compute the average value of the ADC Samples that have just been read.</span>
<span class="doccomment">/// Based on `hal_adc_get_data` in &lt;https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/hal_adc.c#L142-L179&gt;</span>
<span class="attribute">#[<span class="ident">no_mangle</span>]</span>              <span class="comment">//  Don&#39;t mangle the function name</span>
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> <span class="kw">fn</span> <span class="ident">read_adc</span>(   <span class="comment">//  Declare `extern &quot;C&quot;` because it will be called by BL602 firmware</span>
  <span class="ident">_result</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>,        <span class="comment">//  Result to be returned to command-line interface (char *)</span>
  <span class="ident">_len</span>:  <span class="ident">i32</span>,              <span class="comment">//  Size of result buffer (int)</span>
  <span class="ident">_argc</span>: <span class="ident">i32</span>,              <span class="comment">//  Number of command line args (int)</span>
  <span class="ident">_argv</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>  <span class="comment">//  Array of command line args (char **)</span>
) {</pre></div>
<p>First we fetch the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Get the ADC Channel Number for the GPIO Pin</span>
  <span class="kw">let</span> <span class="ident">channel</span> <span class="op">=</span> <span class="ident">adc::get_channel_by_gpio</span>(<span class="ident">ADC_GPIO</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;ADC Channel failed&quot;</span>);
  
  <span class="comment">//  Get the DMA Context for the ADC Channel</span>
  <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">dma::find_ctx_by_channel</span>(<span class="ident">adc::ADC_DMA_CHANNEL</span> <span class="kw">as</span> <span class="ident">i32</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;DMA Ctx failed&quot;</span>);</pre></div>
<p>Again we cast the returned C pointer <code>ptr</code> to a <strong>DMA Context Pointer</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)</span>
  <span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="kw">unsafe</span> {     <span class="comment">//  Unsafe because we are casting a pointer</span>
    <span class="ident">transmute</span>::<span class="op">&lt;</span>         <span class="comment">//  Cast the type...</span>
      <span class="ident">Ptr</span>,               <span class="comment">//  From C Pointer (void *)</span>
      <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">adc::adc_ctx</span>  <span class="comment">//  To DMA Context Pointer (adc_ctx *)</span>
    <span class="op">&gt;</span>(<span class="ident">ptr</span>)               <span class="comment">//  For this pointer</span>
  };</pre></div>
<p>(More about <code>transmute</code> in the Appendix)</p>
<p>Now we may verify the <strong>DMA Context</strong> for the ADC Channel‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Verify that the GPIO has been configured for ADC</span>
  <span class="kw">unsafe</span> {  <span class="comment">//  Unsafe because we are dereferencing a pointer</span>
    <span class="macro">assert!</span>(((<span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">channel</span>) <span class="op">&amp;</span> (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">chan_init_table</span>) <span class="op">!</span><span class="op">=</span> <span class="number">0</span>);
  }</pre></div>
<p>(We flag this as <code>unsafe</code> because we‚Äôre dereferencing a pointer: <code>ctx</code>)</p>
<p>And we check whether the <strong>ADC Sampling</strong> has been completed for the ADC Channel (<code>channel_data</code> shouldn‚Äôt be null)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  If ADC Sampling is not finished, try again later    </span>
  <span class="kw">if</span> <span class="kw">unsafe</span> { (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">channel_data</span>.<span class="ident">is_null</span>() } {  <span class="comment">//  Unsafe because we are dereferencing a pointer</span>
    <span class="ident">puts</span>(<span class="string">&quot;ADC Sampling not finished&quot;</span>);
    <span class="kw">return</span>;
  }</pre></div>
<p>(Again we flag as <code>unsafe</code> because we‚Äôre dereferencing the pointer <code>ctx</code>)</p>
<p>Remember that the BL602 ADC Controller will <strong>read ADC Samples continuously</strong> and write the last 100 samples to RAM (via DMA).</p>
<p>We define an array <code>adc_data</code> to store the last 100 samples temporarily (on the stack)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Array that will store the last 100 ADC Samples</span>
  <span class="comment">//  (`ADC_SAMPLES` is 100)</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">adc_data</span>: [<span class="ident">u32</span>; <span class="ident">ADC_SAMPLES</span>]
    <span class="op">=</span> [<span class="number">0</span>; <span class="ident">ADC_SAMPLES</span>];  <span class="comment">//  Init array to 100 zeroes</span></pre></div>
<p>(Rust requires all variables to be initialised, so we set the array to 100 zeroes)</p>
<p>Let‚Äôs <strong>copy the last 100 ADC Samples</strong> from the DMA Context (in RAM) to our array <code>adc_data</code> (on the stack)‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Copy the read ADC Samples to the array</span>
  <span class="kw">unsafe</span> {                    <span class="comment">//  Unsafe because we are copying raw memory</span>
    <span class="ident">core::ptr::copy</span>(          <span class="comment">//  Copy the memory...</span>
      (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">channel_data</span>,    <span class="comment">//  From Source (ADC DMA data)</span>
      <span class="ident">adc_data</span>.<span class="ident">as_mut_ptr</span>(),  <span class="comment">//  To Destination (mutable pointer to adc_data)</span>
      <span class="ident">adc_data</span>.<span class="ident">len</span>()          <span class="comment">//  Number of Items (each item is uint32 or 4 bytes)</span>
    );    
  }</pre></div>
<p>(More about this in the Appendix)</p>
<p>(<code>adc_data.len()</code> returns the array length: 100)</p>
<p>Then we compute the <strong>average value of the ADC Samples</strong> in <code>adc_data</code>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Compute the average value of the ADC Samples</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">sum</span> <span class="op">=</span> <span class="number">0</span>;
  <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">ADC_SAMPLES</span> {  <span class="comment">//  From 0 to 99, `..` excludes 100</span>
    <span class="comment">//  Scale up the ADC Sample to the range 0 to 3199</span>
    <span class="kw">let</span> <span class="ident">scaled</span> <span class="op">=</span> ((<span class="ident">adc_data</span>[<span class="ident">i</span>] <span class="op">&amp;</span> <span class="number">0xffff</span>) <span class="op">*</span> <span class="number">3200</span>) <span class="op">&gt;</span><span class="op">&gt;</span> <span class="number">16</span>;
    <span class="ident">sum</span> <span class="op">+</span><span class="op">=</span> <span class="ident">scaled</span>;
  }
  <span class="kw">let</span> <span class="ident">avg</span> <span class="op">=</span> <span class="ident">sum</span> <span class="op">/</span> <span class="ident">ADC_SAMPLES</span> <span class="kw">as</span> <span class="ident">u32</span>;</pre></div>
<p>We scale each ADC Sample to the range <strong>0 to 3199</strong>. (Because the default ADC Configuration produces 12-bit samples)</p>
<p>Finally we compose a <strong>formatted string with the average value</strong> and display it‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
  <span class="comment">//  Format the output</span>
  <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">String::new</span>();
  <span class="macro">write!</span>(<span class="ident">buf</span>, <span class="string">&quot;[Rust] Average: {}&quot;</span>, <span class="ident">avg</span>)
    .<span class="ident">expect</span>(<span class="string">&quot;buf overflow&quot;</span>);

  <span class="comment">//  Display the formatted output</span>
  <span class="ident">puts</span>(<span class="kw-2">&amp;</span><span class="ident">buf</span>);
}</pre></div>
<p>(Yep Rust will helpfully <strong>check for buffer overflow</strong>‚Ä¶ safer than <code>sprintf</code>!)</p>
<p>Default String Size is <strong>64 characters</strong>, as defined in the BL602 Rust Wrapper.</p>
<p>(Similar to ‚Äú<code>char[64]</code>‚Äù in C)</p>
<p>The <strong>formatted output</strong> will appear like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-format.jpg" alt="Output from Rust Firmware" /></p>
<p>And we‚Äôre done‚Ä¶ That‚Äôs how we code BL602 ADC Firmware in Rust!</p>
<h1 id="build-the-bl602-rust-firmware" class="section-header"><a href="#build-the-bl602-rust-firmware">4 Build the BL602 Rust Firmware</a></h1>
<p>Here are the steps to build the BL602 Rust Firmware <code>sdk_app_rust_adc.bin</code></p>
<ol>
<li>
<p>Install <strong><code>rustup</code>, <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code></strong></p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#install-rustup"><strong>‚ÄúInstall rustup‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/flash#download-and-build-blflash"><strong>‚ÄúDownload and build blflash‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/debug#install-gdb"><strong>‚ÄúInstall <code>xpack-riscv-none-embed-gcc</code>‚Äù</strong></a></p>
</li>
</ul>
</li>
<li>
<p>Download the <strong>source code</strong> for the BL602 Rust Firmware‚Ä¶</p>
<pre><code class="language-bash"># Download the adc branch of lupyuen's bl_iot_sdk
git clone --recursive --branch adc https://github.com/lupyuen/bl_iot_sdk
cd bl_iot_sdk/customer_app/sdk_app_rust_adc
</code></pre>
</li>
<li>
<p>Edit the script <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/run.sh"><strong><code>run.sh</code></strong></a> in the <code>sdk_app_rust_adc</code> folder.</p>
<p>This build script was created for macOS, but can be modified to run on Linux x64 and Windows WSL.</p>
</li>
<li>
<p>In <code>run.sh</code>, set the following variables to the downloaded folders for <code>blflash</code> and <code>xpack-riscv-none-embed-gcc</code>‚Ä¶</p>
<pre><code class="language-bash">#  Where blflash is located
export BLFLASH_PATH=$PWD/../../../blflash

#  Where GCC is located
export GCC_PATH=$PWD/../../../xpack-riscv-none-embed-gcc
</code></pre>
<p>Save the changes into <code>run.sh</code></p>
</li>
<li>
<p>Build the firmware‚Ä¶</p>
<pre><code class="language-bash">./run.sh
</code></pre>
</li>
<li>
<p>We should see‚Ä¶</p>
<pre><code class="language-text">----- Building Rust app and BL602 firmware for riscv32imacf-unknown-none-elf / sdk_app_rust_adc...

----- Build BL602 Firmware
+ make
...
LD build_out/sdk_app_rust_adc.elf
ld: undefined reference to `init_adc'
ld: undefined reference to `read_adc'
----- Ignore undefined references to Rust Library
</code></pre>
<p>This means that the <strong>C code from our BL602 Firmware</strong> has been built successfully.</p>
<p><a href="https://lupyuen.github.io/articles/pinecone#building-firmware">More details on building BL602 firmware</a></p>
</li>
<li>
<p>Next the script <strong>compiles our Rust code</strong> into a static library: <code>libapp.a</code></p>
<pre><code class="language-text">----- Build Rust Library
+ rustup default nightly

+ cargo build \
    --target ../riscv32imacf-unknown-none-elf.json \
    -Z build-std=core

Updating crates.io index
Compiling compiler_builtins v0.1.46
Compiling core v0.0.0
...
Compiling bl602-macros v0.0.2
Compiling bl602-sdk v0.0.6
Compiling app v0.0.1 (bl_iot_sdk/customer_app/sdk_app_rust_adc/rust)
Finished dev [unoptimized + debuginfo] target(s) in 23.55s
</code></pre>
</li>
<li>
<p>Finally the script <strong>links the Rust static library</strong> into our BL602 firmware‚Ä¶</p>
<pre><code class="language-text">----- Link BL602 Firmware with Rust Library
+ make
use existing version.txt file
LD build_out/sdk_app_rust_adc.elf
Generating BIN File to build_out/sdk_app_rust_adc.bin
...
Building Finish. To flash build output.
</code></pre>
<p>Ignore the error from <code>blflash</code>, we‚Äôll fix this in a while.</p>
</li>
<li>
<p>Our <strong>BL602 Rust Firmware file</strong> has been generated at‚Ä¶</p>
<pre><code class="language-text">build_out/sdk_app_rust_adc.bin
</code></pre>
<p>Let‚Äôs flash this to BL602 and run it!</p>
</li>
</ol>
<p>Check out the complete build log here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/run.sh#L135-L497"><strong>Build Log for BL602 Rust Firmware</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/adc-build.png" alt="Building the BL602 Rust Firmware" /></p>
<h1 id="flash-the-bl602-rust-firmware" class="section-header"><a href="#flash-the-bl602-rust-firmware">5 Flash the BL602 Rust Firmware</a></h1>
<p>Here‚Äôs how we flash the Rust Firmware file <code>sdk_app_rust_adc.bin</code> to BL602‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Flashing Mode</strong> and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>H</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperh.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>
<p>Connect BL10 to the USB port</p>
</li>
<li>
<p>Press and hold the <strong>D8 Button (GPIO 8)</strong></p>
</li>
<li>
<p>Press and release the <strong>EN Button (Reset)</strong></p>
</li>
<li>
<p>Release the D8 Button</p>
</li>
</ul>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>3.3V</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>Enter this at the command prompt‚Ä¶</p>
<pre><code class="language-bash">./run.sh
</code></pre>
<p>The script should automatically flash the firmware after building‚Ä¶</p>
<pre><code class="language-text">----- Flash BL602 Firmware

+ cargo run flash sdk_app_rust_adc.bin \
    --port /dev/tty.usbserial-1410 \
    --initial-baud-rate 230400 \
    --baud-rate 230400

Finished dev [unoptimized + debuginfo] target(s) in 0.61s
Running `target/debug/blflash flash sdk_app_rust_adc.bin --port /dev/tty.usbserial-1420 --initial-baud-rate 230400 --baud-rate 230400`
Start connection...
5ms send count 115
handshake sent elapsed 104.593¬µs
Connection Succeed
Bootrom version: 1
Boot info: BootInfo { len: 14, bootrom_version: 1, otp_info: [0, 0, 0, 0, 3, 0, 0, 0, 61, 9d, c0, 5, b9, 18, 1d, 0] }
Sending eflash_loader...
Finished 1.595620342s 17.92KB/s
5ms send count 115
handshake sent elapsed 81.908¬µs
Entered eflash_loader
Skip segment addr: 0 size: 47504 sha256 matches
Skip segment addr: e000 size: 272 sha256 matches
Skip segment addr: f000 size: 272 sha256 matches
Erase flash addr: 10000 size: 135808
Program flash... ed8a4cdacbc4c1543c74584d7297ad876b6731104856a10dff4166c123c6637d
Program done 7.40735771s 17.91KB/s
Skip segment addr: 1f8000 size: 5671 sha256 matches
Success
</code></pre>
<p>(We might need to edit the script to use the right serial port)</p>
</li>
<li>
<p><strong>For Linux and Windows:</strong></p>
<p>Copy <code>build_out/sdk_app_rust_adc.bin</code> to the <code>blflash</code> folder.</p>
<p>Then enter this at the command prompt‚Ä¶</p>
<pre><code class="language-bash"># TODO: Change this to the downloaded blflash folder
cd blflash

# For Linux:
sudo cargo run flash sdk_app_lora.bin \
    --port /dev/ttyUSB0

# For Windows: Change COM5 to the BL602 Serial Port
cargo run flash sdk_app_lora.bin --port COM5
</code></pre>
</li>
</ol>
<p><a href="https://lupyuen.github.io/articles/flash#flash-the-firmware">More details on flashing firmware</a></p>
<p><img src="https://lupyuen.github.io/images/adc-demo2.png" alt="Running the BL602 Rust Firmware" /></p>
<h1 id="run-the-bl602-rust-firmware" class="section-header"><a href="#run-the-bl602-rust-firmware">6 Run the BL602 Rust Firmware</a></h1>
<p>Finally we run the BL602 Rust Firmware‚Ä¶</p>
<ol>
<li>
<p>Set BL602 to <strong>Normal Mode</strong> (Non-Flashing) and restart the board‚Ä¶</p>
<p><strong>For PineCone:</strong></p>
<ul>
<li>
<p>Set the <strong>PineCone Jumper (IO 8)</strong> to the <strong><code>L</code> Position</strong> <a href="https://lupyuen.github.io/images/pinecone-jumperl.jpg">(Like this)</a></p>
</li>
<li>
<p>Press the Reset Button</p>
</li>
</ul>
<p><strong>For BL10:</strong></p>
<ul>
<li>Press and release the <strong>EN Button (Reset)</strong></li>
</ul>
<p><strong>For Pinenut and MagicHome BL602:</strong></p>
<ul>
<li>
<p>Disconnect the board from the USB Port</p>
</li>
<li>
<p>Connect <strong>GPIO 8</strong> to <strong>GND</strong></p>
</li>
<li>
<p>Reconnect the board to the USB port</p>
</li>
</ul>
</li>
<li>
<p><strong>For macOS:</strong></p>
<p>The <code>run.sh</code> script should automatically launch CoolTerm after flashing‚Ä¶</p>
<pre><code class="language-text">----- Run BL602 Firmware
+ open -a CoolTerm
</code></pre>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More about CoolTerm</a></p>
<p><strong>For Linux:</strong></p>
<p>Connect to BL602‚Äôs UART Port at 2 Mbps like so‚Ä¶</p>
<pre><code class="language-bash">sudo screen /dev/ttyUSB0 2000000
</code></pre>
<p><strong>For Windows:</strong> </p>
<p>Use <code>putty</code> (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><strong>Alternatively:</strong> </p>
<p>Use the Web Serial Terminal (<a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">See this</a>)</p>
<p><a href="https://lupyuen.github.io/articles/flash#watch-the-firmware-run">More details on connecting to BL602</a></p>
</li>
<li>
<p>In the serial console, enter the <code>init_adc</code> command to <strong>initialise the ADC Channel</strong>‚Ä¶</p>
<pre><code class="language-text"># init_adc
[Rust] Init ADC
</code></pre>
<p>(We‚Äôve seen this function earlier)</p>
</li>
<li>
<p>Place the BL602 Board (with LED) in a <strong>dark place</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times to get the <strong>average values</strong> of the last 1,000 ADC Samples‚Ä¶</p>
<pre><code class="language-text"># read_adc
[Rust] Average: 1417
# read_adc
[Rust] Average: 1417
# read_adc
[Rust] Average: 1417
</code></pre>
</li>
<li>
<p>Now place the BL602 Board (with LED) <strong>under sunlight</strong>.</p>
</li>
<li>
<p>Enter the <code>read_adc</code> command a few times‚Ä¶</p>
<pre><code class="language-text"># read_adc
[Rust] Average: 1411
# read_adc
[Rust] Average: 1411
# read_adc
[Rust] Average: 1412
</code></pre>
<p>Note that the average values have <strong>dropped from 1417 to 1412.</strong></p>
</li>
<li>
<p>Place the BL602 Board (with LED) <strong>back in the dark</strong> and check the average values‚Ä¶</p>
<pre><code class="language-text"># read_adc
[Rust] Average: 1417
# read_adc
[Rust] Average: 1417
# read_adc
[Rust] Average: 1417
</code></pre>
<p>The average values have <strong>increased from 1412 to 1417.</strong></p>
<p>Our improvised BL602 Light Sensor works in Rust yay!</p>
</li>
</ol>
<h1 id="from-c-to-rust" class="section-header"><a href="#from-c-to-rust">7 From C To Rust</a></h1>
<p><em>I‚Äôm new to Rust. Is there an easier way to jump from C to Rust?</em></p>
<p>Today we‚Äôve seen that it‚Äôs feasible to <strong>translate C Firmware into Rust</strong> line by line‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-compare.png" alt="Compare C and Rust" /></p>
<p>Which is great for embedded developers new to Rust!</p>
<p>Just be mindful of the <strong>differences between C and Rust</strong>‚Ä¶</p>
<ol>
<li>
<p><strong>BL602 HAL Functions</strong> have been renamed for Rust.</p>
<p>(Like ‚Äú<code>bl_adc_init</code>‚Äù becomes ‚Äú<code>adc::init</code>‚Äù)</p>
<p>To see the list of BL602 HAL Functions for Rust, <a href="https://docs.rs/bl602-sdk">check out the <code>bl602-sdk</code> documentation</a>.</p>
<p>(More about this in the next chapter)</p>
</li>
<li>
<p>In Rust we check for <strong>BL602 HAL Errors</strong> by calling ‚Äú<code>expect</code>‚Äù instead of ‚Äú<code>assert</code>‚Äù.</p>
<p>(Rust Compiler will warn us if we forget to ‚Äú<code>expect</code>‚Äù)</p>
</li>
<li>
<p>Rust is <strong>super strict about Mutability</strong>‚Ä¶ Only variables and pointers declared ‚Äú<code>mut</code>‚Äù can be changed.</p>
<p>(That‚Äôs why we write ‚Äú<code>*mut i32</code>‚Äù to get a pointer to an integer whose value may be changed)</p>
</li>
<li>
<p><strong>Pointer Deferencing</strong> like ‚Äú<code>ptr-&gt;field</code>‚Äù doesn‚Äôt work in Rust.</p>
<p>We rewrite it in Rust as ‚Äú<code>(*ptr).field</code>‚Äù</p>
</li>
<li>
<p>Rust will helpfully <strong>check for Buffer Overflow</strong>.</p>
<p>(No more silent ‚Äú<code>sprintf</code>‚Äù overflow!)</p>
<p>For BL602 Rust Wrapper the default string size is <strong>64 characters</strong>.</p>
<p>(Similar to ‚Äú<code>char[64]</code>‚Äù in C)</p>
</li>
<li>
<p>All Rust variables shall be <strong>initialised</strong> before use.</p>
<p>(Even arrays and structs!)</p>
</li>
</ol>
<p>Let‚Äôs talk about ‚Äú<code>unsafe</code>‚Äù code in Rust‚Ä¶ </p>
<h2 id="safer-rust" class="section-header"><a href="#safer-rust">7.1 Safer Rust</a></h2>
<p>Rust reminds us to be Extra Careful when we work with <strong>C Functions and C Pointers</strong>.</p>
<p>That‚Äôs why we need to flag the following code as <strong><code>unsafe</code></strong>‚Ä¶</p>
<ol>
<li>
<p><strong>Calling C Functions</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Call the C function `set_adc_gain`</span>
<span class="kw">unsafe</span> { <span class="ident">set_adc_gain</span>(<span class="ident">ADC_GAIN1</span>, <span class="ident">ADC_GAIN2</span>) };</pre></div>
<p>(More about this in the Appendix)</p>
</li>
<li>
<p><strong>Casting C Pointers</strong> to Rust</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Cast a C Pointer to a Rust Pointer</span>
<span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">transmute</span>::<span class="op">&lt;</span>         <span class="comment">//  Cast the type...</span>
    <span class="ident">Ptr</span>,               <span class="comment">//  From C Pointer (void *)</span>
    <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">adc::adc_ctx</span>  <span class="comment">//  To DMA Context Pointer (adc_ctx *)</span>
  <span class="op">&gt;</span>(<span class="ident">ptr</span>)               <span class="comment">//  For this pointer</span>
};</pre></div>
<p>(More about this in the Appendix)</p>
</li>
<li>
<p><strong>Dereferencing C Pointers</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Dereference a C Pointer (ctx)</span>
<span class="kw">unsafe</span> {
  (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">chan_init_table</span> <span class="op">=</span> ...
}</pre></div>
</li>
<li>
<p><strong>Copying Memory</strong> with C Pointers</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Copy memory with a C Pointer (channel_data)</span>
<span class="kw">unsafe</span> {
  <span class="ident">core::ptr::copy</span>(          <span class="comment">//  Copy the memory...</span>
    (<span class="kw-2">*</span><span class="ident">ctx</span>).<span class="ident">channel_data</span>,    <span class="comment">//  From Source (ADC DMA data)</span>
    <span class="ident">adc_data</span>.<span class="ident">as_mut_ptr</span>(),  <span class="comment">//  To Destination (mutable pointer to adc_data)</span>
    <span class="ident">adc_data</span>.<span class="ident">len</span>()          <span class="comment">//  Number of Items (each item is uint32 or 4 bytes)</span>
  );    
}</pre></div>
</li>
</ol>
<p>Accessing <strong>Static Variables</strong> is also ‚Äú<code>unsafe</code>‚Äù. Let‚Äôs talk about this‚Ä¶</p>
<h2 id="static-variables-in-rust" class="section-header"><a href="#static-variables-in-rust">7.2 Static Variables in Rust</a></h2>
<p>Earlier we saw this Rust code for <strong>averaging the ADC Samples</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  `adc_data` will store 100 ADC Samples (`ADC_SAMPLES` is 100)</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">adc_data</span>: [<span class="ident">u32</span>; <span class="ident">ADC_SAMPLES</span>] <span class="op">=</span> [<span class="number">0</span>; <span class="ident">ADC_SAMPLES</span>];

<span class="comment">//  Omitted: Copy data into `adc_data`</span>
...

<span class="comment">//  Compute average of `adc_data`</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">ADC_SAMPLES</span> {
  <span class="comment">//  Get value from `adc_data`</span>
  <span class="kw">let</span> <span class="ident">scaled</span> <span class="op">=</span> <span class="ident">adc_data</span>[<span class="ident">i</span>] <span class="op">&amp;</span> ...</pre></div>
<p>Note that <strong><code>adc_data</code> lives on the stack</strong>.</p>
<p>That‚Äôs a huge chunk of data on the stack‚Ä¶ <strong>400 bytes!</strong></p>
<p><em>What if we turn <code>adc_data</code> into a Static Array?</em></p>
<p>We convert <code>adc_data</code> to a Static Array like this‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  `adc_data` becomes a Static Array</span>
<span class="kw">static</span> <span class="kw-2">mut</span> <span class="ident">adc_data</span>: [<span class="ident">u32</span>; <span class="ident">ADC_SAMPLES</span>] <span class="op">=</span> [<span class="number">0</span>; <span class="ident">ADC_SAMPLES</span>];</pre></div>
<p><code>adc_data</code> no longer lives on the stack, it‚Äôs now in Static Memory.</p>
<p><em>What‚Äôs the catch?</em></p>
<p>Unfortunately <strong>Static Variables in Rust are <code>unsafe</code></strong>.</p>
<p>Thus all references to <code>adc_data</code> must be <strong>flagged as <code>unsafe</code></strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  `adc_data` is now unsafe because it&#39;s a Static Variable</span>
<span class="kw">let</span> <span class="ident">scaled</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">adc_data</span>[<span class="ident">i</span>] } <span class="op">&amp;</span> ...</pre></div>
<p>Which makes the code harder to read. That‚Äôs why we left <code>adc_data</code> on the stack for this tutorial.</p>
<p><em>Why are Static Variables <code>unsafe</code>?</em></p>
<p>Because it‚Äôs potentially possible to execute the above code in <strong>multiple tasks</strong>‚Ä¶</p>
<p>Which produces undefined behaviour when multiple tasks <strong>access the same Static Variable</strong>.</p>
<p>So it‚Äôs perfectly OK to use Static Variables in Rust. Just that we need to‚Ä¶</p>
<ol>
<li>
<p>Flag the Static Variables as <strong><code>unsafe</code></strong></p>
</li>
<li>
<p>Ensure ourselves that Static Variables are only accessed by <strong>one task at a time</strong></p>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/adc-crate.png" alt="Rust Wrapper for BL602 IoT SDK" /></p>
<h1 id="rust-wrapper-for-bl602-iot-sdk" class="section-header"><a href="#rust-wrapper-for-bl602-iot-sdk">8 Rust Wrapper for BL602 IoT SDK</a></h1>
<p><em>The BL602 Rust Wrapper Functions look mighty similar to the C Functions from the BL602 IoT SDK. How is this possible?</em></p>
<p>Because the Rust Functions were <strong>automatically generated from BL602 IoT SDK!</strong></p>
<p>We ran a script to generate the <strong>Rust Wrapper for BL602 IoT SDK</strong>.</p>
<p>And we published the Rust Wrapper on <strong><code>crates.io</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://crates.io/crates/bl602-sdk"><strong><code>bl602-sdk</code>: Rust Wrapper for BL602 IoT SDK</strong></a></li>
</ul>
<p><em>Which functions from the BL602 IoT SDK are supported?</em></p>
<p>Today our BL602 Rust Wrapper supports‚Ä¶</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/adc/index.html"><strong>ADC</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/i2c/index.html"><strong>I2C</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/uart/index.html"><strong>UART</strong></a></td></tr>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/dma/index.html"><strong>DMA</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/pwm/index.html"><strong>PWM</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/wifi/index.html"><strong>WiFi</strong></a></td></tr>
<tr><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/gpio/index.html"><strong>GPIO</strong></a></td><td>‚óæ <a href="https://docs.rs/bl602-sdk/latest/bl602_sdk/spi/index.html"><strong>SPI</strong></a></td><td></td></tr>
</tbody></table>
<p><a href="https://docs.rs/bl602-sdk">(See the complete list)</a></p>
<p><em>How do we add the BL602 Rust Wrapper to our Rust Project?</em></p>
<p>Just add <strong><code>bl602-sdk</code></strong> to the Rust project configuration: <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/Cargo.toml#L9-L11"><code>rust/Cargo.toml</code></a></p>
<pre><code class="language-text"># External Rust libraries used by this module.  See crates.io.
[dependencies]
bl602-sdk = &quot;0.0.6&quot;  # Rust Wrapper for BL602 IoT SDK: https://crates.io/crates/bl602-sdk
</code></pre>
<p><a href="https://crates.io/crates/bl602-sdk">(Change <code>&quot;0.0.6&quot;</code> to the latest version on <code>crates.io</code>)</a></p>
<p>The BL602 Rust Wrapper will be auto-downloaded from <code>crates.io</code> when building the project.</p>
<p><img src="https://lupyuen.github.io/images/adc-doc2.png" alt="BL602 Rust Wrapper Documentation" /></p>
<p><em>Is the BL602 Rust Wrapper documented?</em></p>
<p>Yep! Every Rust Function is linked to the section in <a href="https://lupyuen.github.io/articles/book"><strong>‚ÄúThe RISC-V BL602 Book‚Äù</strong></a> that explains how we call the function‚Ä¶</p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<p>(Check the Appendix to learn more about the BL602 Rust Wrapper)</p>
<p>Here‚Äôs a sample project that calls the Rust Wrapper for GPIO‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-gpio.png" alt="Rust Wrapper for GPIO" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_gpio/rust/src/lib.rs">(Source)</a></p>
<h1 id="why-sunlight" class="section-header"><a href="#why-sunlight">9 Why Sunlight?</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/adc-pinebook.jpg" alt="Testing the improvised Light Sensor on PineCone BL602 with Pinebook Pro" /></p>
<p><em>Testing the improvised Light Sensor on PineCone BL602 with Pinebook Pro</em></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<p>TODO</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/o4u9e7/machine_learning_on_riscv_bl602_with_tensorflow/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/adc.md"><code>lupyuen.github.io/src/adc.md</code></a></p>
<h1 id="notes" class="section-header"><a href="#notes">11 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1416608940876435462">this Twitter Thread on Rust Wrapper for BL602 IoT SDK</a></p>
<p>And <a href="https://twitter.com/MisterTechBlog/status/1418025678251773954">this Twitter Thread on BL602 ADC</a></p>
</li>
<li>
<p>We may also use BL602 ADC HAL to read the BL602 Internal Temperature Sensor‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_adc.c#L224-L282">Read BL602 Internal Temperature Sensor via ADC Low Level HAL</a></li>
</ul>
</li>
<li>
<p>Is there a simpler way to code ADC Firmware in C?</p>
<p>Yes, we could call the <strong>ADC High Level HAL</strong> (instead of the ADC Low Level HAL that we‚Äôve seen).</p>
<p>Here‚Äôs our ADC Firmware, rewritten to call the ADC High Level HAL‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-highlevel.png" alt="BL602 ADC High Level HAL" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_adc/sdk_app_adc/demo.c">(Source)</a></p>
<p>But the ADC High Level HAL won‚Äôt let us set the <strong>ADC Gain</strong>.</p>
<p>We need to <strong>patch the ADC Low Level HAL</strong> like so‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-gain.png" alt="Setting the ADC Gain by patching the ADC High Level HAL" /></p>
<p><a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/components/hal_drv/bl602_hal/bl_adc.c#L339-L389">(Source)</a></p>
<p>Also note that the ADC High Level HAL doesn‚Äôt allow us to compute the <strong>average of the ADC Samples</strong>.</p>
<p>It returns only one ADC Sample.</p>
</li>
<li>
<p>ESP32 has something similar to the BL602 Rust Wrapper‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/esp-rs/esp-idf-sys"><code>esp-idf-sys</code></a> defines the Rust Bindings for ESP32 IDF SDK (generated with <code>bindgen</code>)</p>
</li>
<li>
<p><a href="https://github.com/esp-rs/esp-idf-hal"><code>esp-idf-hal</code></a> wraps <code>esp-idf-sys</code> into a Rust Embedded HAL for ESP32</p>
</li>
<li>
<p><a href="https://mabez.dev/blog/posts/esp-rust-espressif/">More about this</a></p>
</li>
</ul>
</li>
<li>
<p>This article was inspired by the BBC micro:bit, which uses LED as a Light Sensor. <a href="https://learn.adafruit.com/micro-bit-lesson-4-sensing-light-and-temperature/built-in-light-sensor">(See this)</a></p>
</li>
</ol>
<h1 id="appendix-call-c-functions-from-rust" class="section-header"><a href="#appendix-call-c-functions-from-rust">12 Appendix: Call C Functions from Rust</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L64-L66"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Enable ADC Gain to increase the ADC sensitivity</span>
<span class="kw">unsafe</span> { <span class="ident">set_adc_gain</span>(<span class="ident">ADC_GAIN1</span>, <span class="ident">ADC_GAIN2</span>) };  <span class="comment">//  Unsafe because we are calling C function</span></pre></div>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L180-L184"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {  <span class="comment">//  Import C Function</span>
  <span class="doccomment">/// Enable ADC Gain to increase the ADC sensitivity.</span>
  <span class="doccomment">/// Defined in customer_app/sdk_app_rust_adc/sdk_app_rust_adc/demo.c</span>
  <span class="kw">fn</span> <span class="ident">set_adc_gain</span>(<span class="ident">gain1</span>: <span class="ident">u32</span>, <span class="ident">gain2</span>: <span class="ident">u32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">i32</span>;
}</pre></div>
<h1 id="appendix-convert-c-pointers-to-rust" class="section-header"><a href="#appendix-convert-c-pointers-to-rust">13 Appendix: Convert C Pointers to Rust</a></h1>
<p>TODO</p>
<p>From <a href="https://github.com/lupyuen/bl_iot_sdk/blob/adc/customer_app/sdk_app_rust_adc/rust/src/lib.rs#L119-L129"><code>lib.rs</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Get the C Pointer (void *) for DMA Context</span>
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> ...

<span class="comment">//  Cast the returned C Pointer (void *) to a DMA Context Pointer (adc_ctx *)</span>
<span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span> <span class="kw">unsafe</span> {     <span class="comment">//  Unsafe because we are casting a pointer</span>
  <span class="ident">transmute</span>::<span class="op">&lt;</span>         <span class="comment">//  Cast the type...</span>
    <span class="ident">Ptr</span>,               <span class="comment">//  From C Pointer (void *)</span>
    <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">adc::adc_ctx</span>  <span class="comment">//  To DMA Context Pointer (adc_ctx *)</span>
  <span class="op">&gt;</span>(<span class="ident">ptr</span>)               <span class="comment">//  For this pointer</span>
};</pre></div>
<p><img src="https://lupyuen.github.io/images/adc-cast.png" alt="Casting a C Pointer to a Rust Pointer" /></p>
<h1 id="appendix-copy-memory-with-c-pointers" class="section-header"><a href="#appendix-copy-memory-with-c-pointers">14 Appendix: Copy Memory with C Pointers</a></h1>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/adc-copy.png" alt="Copy ADC data in Rust" /></p>
<h1 id="appendix-generating-the-rust-wrapper-for-bl602-iot-sdk" class="section-header"><a href="#appendix-generating-the-rust-wrapper-for-bl602-iot-sdk">15 Appendix: Generating the Rust Wrapper for BL602 IoT SDK</a></h1>
<p><em>How was the BL602 Rust Wrapper generated for publishing on <a href="https://crates.io/crates/bl602-sdk"><code>crates.io</code></a>?</em></p>
<p>Two tools were used to generate the <strong>Rust Wrapper for BL602 IoT SDK</strong>‚Ä¶</p>
<ol>
<li>
<p><a href="https://rust-lang.github.io/rust-bindgen"><strong><code>bindgen</code></strong></a>: Command-line tool that generates the <strong>Rust Bindings</strong> for a C API.</p>
<p>(As specified by C Header Files)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><strong><code>safe_wrap</code></strong></a>: A Rust Procedural Macro we wrote to transform the BL602 C Types to <strong>safer Rust-Friendly Types</strong>.</p>
<p>(Including the ‚Äú<code>expect</code>‚Äù checking for return values)</p>
</li>
</ol>
<p>Here are the steps for <strong>generating the Rust Wrapper</strong>‚Ä¶</p>
<pre><code class="language-bash">#  Install bindgen and clang: https://rust-lang.github.io/rust-bindgen/requirements.html 
cargo install bindgen
sudo apt install llvm-dev libclang-dev clang

#  Download the source code
git clone --recursive https://github.com/lupyuen/bl602-rust-wrapper
git clone --recursive https://github.com/lupyuen/bl_iot_sdk

#  Generate the Rust Bindings for BL602 IoT SDK
cd bl602-rust-wrapper
scripts/gen-bindings.sh

#  Build the docs and the test project
scripts/build.sh
</code></pre>
<p><img src="https://lupyuen.github.io/images/adc-bindgen.png" alt="BL602 Rust Wrapper generated by bindgen and safe_wrap" /></p>
<h2 id="how-it-works" class="section-header"><a href="#how-it-works">15.1 How it works</a></h2>
<p>This script‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/scripts/gen-bindings.sh"><code>scripts/gen-bindings.sh</code></a></li>
</ul>
<p>Calls <strong><code>bindgen</code></strong> to read the BL602 IoT SDK <strong>Header Files</strong>‚Ä¶</p>
<pre><code class="language-c">//  Function Declarations from BL602 IoT SDK (GPIO HAL)
//  https://github.com/lupyuen/bl_iot_sdk/blob/master/components/hal_drv/bl602_hal/bl_gpio.h
int bl_gpio_enable_output(uint8_t pin, uint8_t pullup, uint8_t pulldown);
int bl_gpio_output_set(uint8_t pin, uint8_t value);
</code></pre>
<p>To produce the <strong>Rust Bindings</strong> for BL602 IoT SDK‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src/gpio.rs"><code>bl602-sdk/src/gpio.rs</code></a></li>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src/adc.rs"><code>bl602-sdk/src/adc.rs</code></a></li>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/src">More Bindings</a></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Rust Bindings for BL602 GPIO generated by gen-bindings.sh</span>
<span class="attribute">#[<span class="ident">safe_wrap</span>(<span class="kw">_</span>)]</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">pullup</span>: <span class="ident">u8</span>, <span class="ident">pulldown</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">::cty::c_int</span>;
}

<span class="attribute">#[<span class="ident">safe_wrap</span>(<span class="kw">_</span>)]</span> <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">::cty::c_int</span>;
}</pre></div>
<p>(<code>safe_wrap</code> was inserted by an <code>sed</code> script in <code>gen-bindings.sh</code>)</p>
<p>When the above Rust Bindings are compiled, they invoke the <strong><code>safe_wrap</code> Procedural Macro</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs"><code>bl602-macros/src/safe_wrap.rs</code></a></li>
</ul>
<p>To produce the <strong>Rust Wrapper</strong> for BL602 IoT SDK‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/logs/sdk-expanded.rs">Expanded <code>safe_wrap</code> macros: <code>logs/sdk-expanded.rs</code></a></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Expanded version of `safe_wrap` macros for the GPIO Rust Bindings</span>
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in \&quot;Enable GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">pullup</span>: <span class="ident">u8</span>, <span class="ident">pulldown</span>: <span class="ident">u8</span>)
    <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BlResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="string">&quot;----------Extern Decl----------&quot;</span>;
    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">pullup</span>: <span class="ident">u8</span>, <span class="ident">pulldown</span>: <span class="ident">u8</span>)
        <span class="op">-</span><span class="op">&gt;</span> <span class="ident">::cty::c_int</span>;
    }
    <span class="string">&quot;----------Validation----------&quot;</span>;
    <span class="kw">unsafe</span> {
        <span class="string">&quot;----------Call----------&quot;</span>;
        <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span>
            <span class="ident">bl_gpio_enable_output</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">pullup</span> <span class="kw">as</span> <span class="ident">u8</span>,
                                    <span class="ident">pulldown</span> <span class="kw">as</span> <span class="ident">u8</span>);
        <span class="string">&quot;----------Result----------&quot;</span>;
        <span class="kw">match</span> <span class="ident">res</span> { <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(()), <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">BlError::from</span>(<span class="ident">res</span>)), }
    }
}

<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Set output value of GPIO Pin. See `bl_gpio_output_set` in \&quot;Read and Write GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BlResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="string">&quot;----------Extern Decl----------&quot;</span>;
    <span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
        <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>)
        <span class="op">-</span><span class="op">&gt;</span> <span class="ident">::cty::c_int</span>;
    }
    <span class="string">&quot;----------Validation----------&quot;</span>;
    <span class="kw">unsafe</span> {
        <span class="string">&quot;----------Call----------&quot;</span>;
        <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">bl_gpio_output_set</span>(<span class="ident">pin</span> <span class="kw">as</span> <span class="ident">u8</span>, <span class="ident">value</span> <span class="kw">as</span> <span class="ident">u8</span>);
        <span class="string">&quot;----------Result----------&quot;</span>;
        <span class="kw">match</span> <span class="ident">res</span> { <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(()), <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">BlError::from</span>(<span class="ident">res</span>)), }
    }
}</pre></div>
<p>(More about <strong><code>doc</code></strong> in the next section)</p>
<p>Note that the <code>safe_wrap</code> macro converts the BL602 return values to a <strong>Rust Result Type</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">match</span> <span class="ident">res</span> { 
    <span class="number">0</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Ok</span>(()), 
    <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="prelude-val">Err</span>(<span class="ident">BlError::from</span>(<span class="ident">res</span>))
}</pre></div>
<p>Which enables the caller to check for errors with <strong><code>expect</code></strong>.</p>
<p>We build the docs and the test project with this script‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/scripts/build.sh"><code>scripts/build.sh</code></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/README.md#build-log">See the build log</a></p>
</li>
</ul>
<p>In the previous article we attempted to code the BL602 Rust Wrapper by hand‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/rust"><strong>‚ÄúRun Rust RISC-V Firmware with BL602 IoT SDK‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/adc-doc2.png" alt="BL602 Rust Wrapper Documentation" /></p>
<h2 id="inject-the-docs" class="section-header"><a href="#inject-the-docs">15.2 Inject the docs</a></h2>
<p><em>How did we create the docs for BL602 Rust Wrapper? (Pic above)</em></p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<p>Sadly BL602 IoT SDK doesn‚Äôt have much documentation‚Ä¶ But much of the SDK is already documented in <a href="https://lupyuen.github.io/articles/book"><strong>‚ÄúThe RISC-V BL602 Book‚Äù</strong></a>!</p>
<p>So we linked each Rust Wrapper Function to the relevant section in ‚ÄúThe RISC-V BL602 Book‚Äù.</p>
<p>We do this through the <strong>Rust <code>doc</code> Attribute</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">//  Expanded version of `safe_wrap` macros for the GPIO Rust Bindings</span>
<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Configure a GPIO Pin for Output Mode. See `bl_gpio_enable_output` in \&quot;Enable GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#enable-gpio&gt;&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">enable_output</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">pullup</span>: <span class="ident">u8</span>, <span class="ident">pulldown</span>: <span class="ident">u8</span>) { ...

<span class="attribute">#[<span class="ident">doc</span> <span class="op">=</span> <span class="string">&quot;Set output value of GPIO Pin. See `bl_gpio_output_set` in \&quot;Read and Write GPIO\&quot; &lt;https://lupyuen.github.io/articles/led#read-and-write-gpio&gt;&quot;</span>]</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">output_set</span>(<span class="ident">pin</span>: <span class="ident">u8</span>, <span class="ident">value</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BlResult</span><span class="op">&lt;</span>()<span class="op">&gt;</span> { ...</pre></div>
<p><img src="https://lupyuen.github.io/images/adc-doclink.png" alt="Documentation links to be injected" /></p>
<p><em>How did we inject the doc links into the <code>doc</code> Attribute?</em></p>
<p>For each Rust Wrapper Function, the links to <a href="https://lupyuen.github.io/articles/book">‚ÄúThe RISC-V BL602 Book‚Äù</a> are defined in this <strong>Markdown Text File</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-sdk/doclinks.md"><code>bl602-sdk/doclinks.md</code></a></li>
</ul>
<pre><code class="language-text">| Function              | Description                           | Section             | URL
| --------------------- | ------------------------------------- | ------------------- | ---
| bl_gpio_enable_output | Configure a GPIO Pin for Output Mode. | Enable GPIO         | https://lupyuen.github.io/articles/led#enable-gpio
| bl_gpio_output_set    | Set the output value of a GPIO Pin.   | Read and Write GPIO | https://lupyuen.github.io/articles/led#read-and-write-gpio
</code></pre>
<p>When our Rust Firmware is compiled, the <code>safe_wrap</code> macro <strong>loads the Markdown File</strong> into memory‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-doclink2.png" alt="Loading the documentation links" /></p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs#L532-L573">(Source)</a></p>
<p>And <strong>injects the doc links</strong> into the <code>doc</code> attribute‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/adc-doclink3.png" alt="Injecting the documentation links" /></p>
<p><a href="https://github.com/lupyuen/bl602-rust-wrapper/blob/master/bl602-macros/src/safe_wrap.rs#L476-L530">(Source)</a></p>
<p>And the links to ‚ÄúThe RISC-V BL602 Book‚Äù will magically appear in the Rust Docs!</p>
<ul>
<li><a href="https://docs.rs/bl602-sdk"><strong>Documentation for BL602 Rust Wrapper</strong></a></li>
</ul>
<h2 id="rename-the-functions" class="section-header"><a href="#rename-the-functions">15.3 Rename the functions</a></h2>
<p>TODO</p>
<p><img src="https://lupyuen.github.io/images/adc-prefix.png" alt="Renaming the Rust Functions" /></p>
<p><img src="https://lupyuen.github.io/images/adc-title2.jpg" alt="Testing the improvised Light Sensor on PineCone BL602" /></p>

    
</body>
</html>