<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone" 
    data-rh="true">
<meta property="og:description" 
    content="Apache NuttX RTOS now runs on Arm Cortex-A53 with Multi-Core SMP... Will it run on PinePhone? Let's find out!"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/arm-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Apache NuttX RTOS on Arm Cortex-A53: How it might run on PinePhone</h1>
    <nav id="TOC"><ul>
<li><a href="#download-nuttx">1 Download NuttX</a><ul></ul></li>
<li><a href="#download-toolchain">2 Download Toolchain</a><ul></ul></li>
<li><a href="#download-qemu">3 Download QEMU</a><ul></ul></li>
<li><a href="#build-nuttx-single-core">4 Build NuttX: Single Core</a><ul></ul></li>
<li><a href="#test-nuttx-with-qemu-single-core">5 Test NuttX with QEMU: Single Core</a><ul></ul></li>
<li><a href="#build-nuttx-multi-core">6 Build NuttX: Multi Core</a><ul></ul></li>
<li><a href="#test-nuttx-with-qemu-multi-core">7 Test NuttX with QEMU: Multi Core</a><ul></ul></li>
<li><a href="#inside-nuttx-for-cortex-a53">8 Inside NuttX for Cortex-A53</a><ul></ul></li>
<li><a href="#nuttx-image">9 NuttX Image</a><ul></ul></li>
<li><a href="#nuttx-ram">10 NuttX RAM</a><ul></ul></li>
<li><a href="#pinephone-image">11 PinePhone Image</a><ul></ul></li>
<li><a href="#will-nuttx-boot-on-pinephone">12 Will NuttX Boot On PinePhone?</a><ul></ul></li>
<li><a href="#uart-driver-for-nuttx">13 UART Driver for NuttX</a><ul></ul></li>
<li><a href="#pinephone-on-rtos">14 PinePhone on RTOS</a><ul></ul></li>
<li><a href="#pinephone-drivers-and-apps">15 PinePhone Drivers and Apps</a><ul></ul></li>
<li><a href="#whats-next">16 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">17 Notes</a><ul></ul></li></ul></nav><p>üìù <em>30 Aug 2022</em></p>
<p><img src="https://lupyuen.github.io/images/arm-title.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<p><em>Ghidra with Apache NuttX RTOS for Arm Cortex-A53</em></p>
<p><a href="https://nuttx.apache.org/docs/latest/"><strong>Apache NuttX RTOS</strong></a> (Real-Time Operating System) runs on 64-bit <strong>Arm Cortex-A53</strong> with Multiple Cores‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/tree/master/boards/arm64/qemu/qemu-a53"><strong>NuttX on Arm Cortex-A53</strong></a></li>
</ul>
<p><strong>Pine64 PinePhone</strong> is based on the <a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 SoC</strong></a> with 4 Cores of Arm Cortex-A53‚Ä¶</p>
<ul>
<li><a href="https://wiki.pine64.org/index.php/PinePhone"><strong>PinePhone Wiki</strong></a></li>
</ul>
<p>Will NuttX run on PinePhone? Let‚Äôs find out!</p>
<p><em>Why NuttX?</em></p>
<p>NuttX is a <strong>tiny operating system</strong>. It might be a fun way to teach more people about the internals of Phone Operating Systems. (Without digging deep into the Linux Stack)</p>
<p>Someday we might have a cheap, fast, responsive and tweakable phone running on NuttX!</p>
<p><em>But why an RTOS for PinePhone? What about drivers and apps?</em></p>
<p>Yep we have interesting challenges running NuttX on PinePhone, we‚Äôll talk more below.</p>
<p>First we experiment with NuttX on Arm Cortex-A53, <strong>emulated with QEMU</strong>. Then we discuss how it might work on PinePhone‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>lupyuen/pinephone-nuttx</strong></a></li>
</ul>
<p>Many thanks to <a href="https://github.com/qinwei2004"><strong>qinwei2004</strong></a> and the NuttX Team for implementing <a href="https://github.com/apache/incubator-nuttx/pull/6478"><strong>Cortex-A53 support</strong></a>!</p>
<h1 id="download-nuttx"><a href="#download-nuttx">1 Download NuttX</a></h1>
<p><strong>NuttX Mainline</strong> has the latest support for Arm Cortex-A53. Let‚Äôs download the Source Code for our experiment‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Create NuttX Directory
mkdir nuttx
cd nuttx

# Download NuttX OS
git clone \
    --recursive \
    https://github.com/apache/incubator-nuttx \
    nuttx

# Download NuttX Apps
git clone \
    --recursive \
    https://github.com/apache/incubator-nuttx-apps \
    apps

# We&#39;ll build NuttX inside nuttx/nuttx
cd nuttx</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-nuttx#download-nuttx">(Having problems? Try my <strong><code>arm64</code></strong> branch)</a></p>
<p>We‚Äôll build NuttX in a while. Install the <strong>Build Prerequisites</strong> below, but skip the RISC-V Toolchain‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs download the Arm64 Toolchain instead‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-toolchain.png" alt="Arm64 Toolchain" /></p>
<h1 id="download-toolchain"><a href="#download-toolchain">2 Download Toolchain</a></h1>
<p>We‚Äôll <strong>cross-compile Arm64 NuttX</strong> on our computer. Download the Arm Toolchain for <strong>AArch64 ELF Bare-Metal Target <code>aarch64-none-elf</code></strong>‚Ä¶</p>
<ul>
<li><a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><strong>Arm GNU Toolchain Downloads</strong></a></li>
</ul>
<p>For Linux x64 and WSL:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz">gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz</a></li>
</ul>
<p>For macOS:</p>
<ul>
<li><a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.3.rel1/binrel/arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg">arm-gnu-toolchain-11.3.rel1-darwin-x86_64-aarch64-none-elf.pkg</a></li>
</ul>
<p>(I don‚Äôt recommend building NuttX on Plain Old Windows CMD, please use WSL instead)</p>
<p>Add the downloaded Arm Toolchain to the <strong><code>PATH</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># For Linux x64 and WSL:
export PATH=&quot;$PATH:$HOME/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin&quot;

# For macOS:
export PATH=&quot;$PATH:/Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin&quot;</code></pre></div>
<p>Check the Arm Toolchain‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ aarch64-none-elf-gcc -v
gcc version 11.3.1 20220712 (Arm GNU Toolchain 11.3.Rel1)</code></pre></div>
<p><a href="https://github.com/apache/incubator-nuttx/tree/master/boards/arm64/qemu/qemu-a53">(Based on the instructions here)</a></p>
<h1 id="download-qemu"><a href="#download-qemu">3 Download QEMU</a></h1>
<p>Our experiment today will run on any Linux / macOS / Windows computer, <strong>no PinePhone needed</strong>.</p>
<p>That‚Äôs because we‚Äôre emulating Arm Cortex-A53 with the awesome <a href="https://www.qemu.org/"><strong>QEMU Machine Emulator</strong></a>.</p>
<p>Download and install QEMU‚Ä¶</p>
<ul>
<li><a href="https://www.qemu.org/download/"><strong>Download QEMU</strong></a></li>
</ul>
<p>For macOS we may use <strong><code>brew</code></strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>brew install qemu</code></pre></div>
<p>QEMU runs surprisingly well for emulating 64-bit Arm Cortex-A53, especially for a light operating system like NuttX.</p>
<p>Let‚Äôs build NuttX‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/arm-build.png" alt="Build NuttX" /></p>
</blockquote>
<h1 id="build-nuttx-single-core"><a href="#build-nuttx-single-core">4 Build NuttX: Single Core</a></h1>
<p>We‚Äôll run two experiments with QEMU‚Ä¶</p>
<ul>
<li>
<p>NuttX on a <strong>Single Core</strong> of Arm Cortex-A53</p>
</li>
<li>
<p>NuttX on <strong>4 Cores</strong> of Arm Cortex-A53</p>
</li>
</ul>
<p>Which works like 4 Arm64 Processors running in parallel, similar to PinePhone.</p>
<p>First we build NuttX for a <strong>Single Core</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Configure NuttX for Single Core
./tools/configure.sh -l qemu-a53:nsh

# Build NuttX
make

# Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/2c5db82c3103f52ed7ca99804f9220c1">(See the Build Log)</a></p>
<p>(On an old MacBook Pro 2012, NuttX builds in 2 minutes)</p>
<p>The NuttX Output Files may be found here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v1.0.1"><strong>NuttX for Arm Cortex-A53 Single Core</strong></a></li>
</ul>
<p>The output file <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.1/nuttx"><strong><code>nuttx</code></strong></a> is the Arm64 <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF Executable</strong></a> that we‚Äôll run in the next step.</p>
<h1 id="test-nuttx-with-qemu-single-core"><a href="#test-nuttx-with-qemu-single-core">5 Test NuttX with QEMU: Single Core</a></h1>
<p>We‚Äôre ready to run NuttX! This is how we test <strong>NuttX on QEMU</strong> with a Single Core of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Start QEMU (Single Core) with NuttX
qemu-system-aarch64 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>QEMU shows this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

nx_start: Entry
up_allocate_heap: heap_start=0x0x402c4000, heap_size=0x7d3c000
gic_validate_dist_version: GICv3 version detect
gic_validate_dist_version: GICD_TYPER = 0x37a0007
gic_validate_dist_version: 224 SPIs implemented
gic_validate_dist_version: 0 Extended SPIs implemented
gic_validate_dist_version: Distributor has no Range Selector support
gic_validate_redist_version: GICD_TYPER = 0x1000011
gic_validate_redist_version: 16 PPIs implemented
gic_validate_redist_version: no VLPI support, no direct LPI support
up_timer_initialize: up_timer_initialize: cp15 timer(s) running at 62.50MHz, cycle 62500
uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
work_start_highpri: Starting high-priority kernel worker thread(s)
nx_start_application: Starting init thread
lib_cxx_initialize: _sinit: 0x402a7000 _einit: 0x402a7000 _stext: 0x40280000 _etext: 0x402a8000
nsh: sysinit: fopen failed: 2
nsh: mkfatfs: command not found

NuttShell (NSH) NuttX-10.4.0
nsh&gt; nx_start: CPU0: Beginning Idle Loop</code></pre></div>
<p>Welcome to NuttX Land!</p>
<p>Enter ‚Äú<strong><code>help</code></strong>‚Äù or ‚Äú<strong><code>?</code></strong>‚Äù to see the <strong>NuttX Commands</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

  .         cd        dmesg     help      mount     rmdir     true      xd        
  [         cp        echo      hexdump   mv        set       truncate  
  ?         cmp       exec      kill      printf    sleep     uname     
  basename  dirname   exit      ls        ps        source    umount    
  break     dd        false     mkdir     pwd       test      unset     
  cat       df        free      mkrd      rm        time      usleep    

Builtin Apps:
  getprime  hello     nsh       ostest    sh        </code></pre></div>
<p>To be really sure that we‚Äôre <strong>emulating Arm64</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC2 1e8f2a8 Aug 23 2022 07:04:54 arm64 qemu-a53</code></pre></div>
<p><a href="https://github.com/apache/incubator-nuttx-apps/blob/master/examples/hello/hello_main.c"><strong>‚ÄúHello World‚Äù</strong></a> works as expected‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; hello
task_spawn: name=hello entry=0x4029b594 file_actions=0x402c9580 attr=0x402c9588 argv=0x402c96d0
spawn_execattrs: Setting policy=2 priority=100 for pid=3
Hello, World!!</code></pre></div>
<p>NuttX is <a href="https://nuttx.apache.org/docs/latest/introduction/inviolables.html"><strong>POSIX Compliant</strong></a>, so the Developer Experience feels very much like Linux (but much smaller)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /
/:
 dev/
 etc/
 proc/</code></pre></div>
<p>We started the Bare Minimum of <strong>NuttX Devices</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /dev
/dev:
 console
 null
 ram0
 ram2
 ttyS0
 zero</code></pre></div>
<p>With a few <strong>Background Processes</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /proc
/proc:
 0/
 1/
 2/
 meminfo
 memdump
 fs/
 self/
 uptime
 version</code></pre></div>
<p>And NuttX runs <strong>everything in RAM</strong>, no File System needed (for today)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /etc
/etc:
 init.d/

nsh&gt; ls /etc/init.d
/etc/init.d:
 rcS

nsh&gt; cat /etc/init.d/rcS

mkrd -m 2 -s 512 1024
mkfatfs /dev/ram2
mount -t vfat /dev/ram2 /tmp</code></pre></div>
<p>Press <strong>Ctrl-C</strong> to quit QEMU.</p>
<h1 id="build-nuttx-multi-core"><a href="#build-nuttx-multi-core">6 Build NuttX: Multi Core</a></h1>
<p>From Single Core to Multi Core! Now we build NuttX for <strong>4 Cores</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Erase the NuttX Configuration
make distclean

# Configure NuttX for 4 Cores
./tools/configure.sh -l qemu-a53:nsh_smp

# Build NuttX
make

# Dump the disassembly to nuttx.S
aarch64-none-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1</code></pre></div>
<p>The NuttX Output Files may be found here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-nuttx/releases/tag/v1.0.0"><strong>NuttX for Arm Cortex-A53 Multi-Core</strong></a></li>
</ul>
<h1 id="test-nuttx-with-qemu-multi-core"><a href="#test-nuttx-with-qemu-multi-core">7 Test NuttX with QEMU: Multi Core</a></h1>
<p>And this is how we test NuttX on QEMU with <strong>4 Cores</strong> of Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Start QEMU (4 Cores) with NuttX
qemu-system-aarch64 \
  -smp 4 \
  -cpu cortex-a53 \
  -nographic \
  -machine virt,virtualization=on,gic-version=3 \
  -net none \
  -chardev stdio,id=con,mux=on \
  -serial chardev:con \
  -mon chardev=con,mode=readline \
  -kernel ./nuttx</code></pre></div>
<p>Note that <strong><code>smp</code></strong> is set to 4. <a href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Symmetric-multi-processing?lang=en">(Symmetric Multi-Processing)</a></p>
<p>QEMU shows this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize</code></pre></div>
<p>NuttX boots on the <strong>First Core</strong> of our emulated Arm Cortex-A53‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>[CPU0] psci_detect: Detected PSCI v1.1
[CPU0] nx_start: Entry
[CPU0] up_allocate_heap: heap_start=0x0x402db000, heap_size=0x7d25000
[CPU0] gic_validate_dist_version: GICv3 version detect
[CPU0] gic_validate_dist_version: GICD_TYPER = 0x37a0007
[CPU0] gic_validate_dist_version: 224 SPIs implemented
[CPU0] gic_validate_dist_version: 0 Extended SPIs implemented
[CPU0] gic_validate_dist_version: Distributor has no Range Selector support
[CPU0] gic_validate_redist_version: GICD_TYPER = 0x1000001
[CPU0] gic_validate_redist_version: 16 PPIs implemented
[CPU0] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU0] up_timer_initialize: up_timer_initialize: cp15 timer(s) running at 62.50MHz, cycle 62500
[CPU0] uart_register: Registering /dev/console
[CPU0] uart_register: Registering /dev/ttyS0</code></pre></div>
<p>Here comes excitement: NuttX boots on the <strong>Second Core</strong> of our Arm Cortex-A53!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU1] gic_validate_redist_version: GICD_TYPER = 0x101000101
[CPU1] gic_validate_redist_version: 16 PPIs implemented
[CPU1] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU1] nx_idle_trampoline: CPU1: Beginning Idle Loop
[CPU0] arm64_start_cpu: Secondary CPU core 1 (MPID:0x1) is up</code></pre></div>
<p>Followed by the <strong>Third Core</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU2] gic_validate_redist_version: GICD_TYPER = 0x201000201
[CPU2] gic_validate_redist_version: 16 PPIs implemented
[CPU2] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU2] nx_idle_trampoline: CPU2: Beginning Idle Loop
[CPU0] arm64_start_cpu: Secondary CPU core 2 (MPID:0x2) is up</code></pre></div>
<p>Finally all <strong>4 Cores</strong> are up!</p>
<div class="example-wrap"><pre class="language-text"><code>- Ready to Boot CPU
- Boot from EL2
- Boot from EL1
- Boot to C runtime for OS Initialize

[CPU3] gic_validate_redist_version: GICD_TYPER = 0x301000311
[CPU3] gic_validate_redist_version: 16 PPIs implemented
[CPU3] gic_validate_redist_version: no VLPI support, no direct LPI support
[CPU0] arm64_start_cpu: Secondary CPU core 3 (MPID:0x3) is up
[CPU0] work_start_highpri: Starting high-priority kernel worker thread(s)
[CPU0] nx_start_application: Starting init thread
[CPU3] nx_idle_trampoline: CPU3: Beginning Idle Loop
[CPU0] nx_start: CPU0: Beginning Idle Loop</code></pre></div>
<p><strong>NuttX Shell</strong> appears‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh: sysinit: fopen failed: 2
nsh: mkfatfs: command not found
NuttShell (NSH) NuttX-10.4.0
nsh&gt;</code></pre></div>
<p>Even though we have 4 Cores, everything works as expected‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC2 1e8f2a8 Aug 21 2022 15:57:35 arm64 qemu-a53

nsh&gt; hello
[CPU0] task_spawn: name=hello entry=0x4029cee4 file_actions=0x402e52b0 attr=0x402e52b8 argv=0x402e5400
[CPU0] spawn_execattrs: Setting policy=2 priority=100 for pid=6
Hello, World!</code></pre></div>
<p><a href="https://developer.arm.com/documentation/den0024/a/Multi-core-processors/Multi-processing-systems/Symmetric-multi-processing?lang=en"><strong>Symmetric Multi-Processing</strong></a> never looked so cool!</p>
<p>(Can we use QEMU to emulate parts of PinePhone? That would be extremely helpful for testing!)</p>
<p><img src="https://lupyuen.github.io/images/arm-source.png" alt="Arm64 Architecture-Specific Source Files" /></p>
<p><a href="https://github.com/apache/incubator-nuttx/tree/master/arch/arm64/src/common"><em>Arm64 Architecture-Specific Source Files</em></a></p>
<h1 id="inside-nuttx-for-cortex-a53"><a href="#inside-nuttx-for-cortex-a53">8 Inside NuttX for Cortex-A53</a></h1>
<p><em>What‚Äôs inside the NuttX code for Cortex-A53?</em></p>
<p>Let‚Äôs browse the <strong>Source Files</strong> for the implementation of Cortex-A53 on NuttX.</p>
<p>NuttX treats QEMU as a <strong>Target Board</strong> (as though it was a dev board). Here are the Source Files and Build Configuration for the <strong>QEMU Board</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/tree/master/boards/arm64/qemu/qemu-a53">nuttx/boards/arm64/qemu/qemu-a53</a></li>
</ul>
<p>(We‚Äôll clone this to create a Target Board for PinePhone)</p>
<p>The <strong>Board-Specific Drivers</strong> for QEMU are started in <a href="https://github.com/apache/incubator-nuttx/blob/master/boards/arm64/qemu/qemu-a53/src/qemu_bringup.c">qemu_bringup.c</a></p>
<p>(We‚Äôll start the PinePhone Drivers here)</p>
<p>The QEMU Board calls the <strong>QEMU Architecture-Specific Drivers</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/tree/master/arch/arm64/src/qemu">nuttx/arch/arm64/src/qemu</a></li>
</ul>
<p>The <strong>UART Driver</strong> is located at <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/qemu/qemu_serial.c">qemu_serial.c</a> and <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/qemu/qemu_lowputc.S">qemu_lowputc.S</a></p>
<p>(For PinePhone we‚Äôll create a UART Driver for Allwinner A64 SoC. I2C, SPI and other Low-Level A64 Drivers will be located here too)</p>
<p>The QEMU Functions (Board and Architecture) call the <strong>Arm64 Architecture Functions</strong> (pic above)‚Ä¶</p>
<ul>
<li><a href="https://github.com/apache/incubator-nuttx/tree/master/arch/arm64/src/common">nuttx/arch/arm64/src/common</a></li>
</ul>
<p>Which implement all kinds of Arm64 Features: <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/common/arm64_fpu.c"><strong>FPU</strong></a>, <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/common/arm64_gicv3.c"><strong>Interrupts</strong></a>, <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c"><strong>MMU</strong></a>, <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/common/arm64_task_sched.c"><strong>Tasks</strong></a>, <a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/common/arm64_arch_timer.c"><strong>Timers</strong></a>‚Ä¶</p>
<p>(We‚Äôll reuse them for PinePhone)</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra1.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<h1 id="nuttx-image"><a href="#nuttx-image">9 NuttX Image</a></h1>
<p><em>NuttX can‚Äôt possibly boot on PinePhone right?</em></p>
<p>It might! Let‚Äôs compare our <strong>NuttX Image</strong> with a <strong>PinePhone Linux Image</strong>. And find out what needs to be patched.</p>
<p>We load our <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx"><strong>NuttX ELF Image <code>nuttx</code></strong></a> into <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a>, the popular open-source tool for Reverse Engineering.</p>
<p>TODO: Load NuttX into Ghidra</p>
<p>Ghidra says that our NuttX Image will be loaded at address <strong><code>0x4028</code> <code>0000</code></strong>. (Pic above)</p>
<p>The Arm64 Instructions at the top of our NuttX Image will jump to <strong><code>real_start</code></strong> (to skip the header)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>40280000 4d 5a 00 91     add        x13,x18,#0x16
40280004 0f 00 00 14     b          real_start</code></pre></div>
<p>After the header, <strong><code>real_start</code></strong> is defined at <code>0x4028</code> <code>0040</code> with the Startup Code‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-title.png" alt="Ghidra with Apache NuttX RTOS for Arm Cortex-A53" /></p>
<p>We see something interesting: The <strong>Magic Number <code>ARM\x64</code></strong> appears at address <code>0x4028</code> <code>0038</code>. (Offset <code>0x38</code>)</p>
<p>Searching the net for this Magic Number reveals that it‚Äôs actually an <strong>Arm64 Linux Kernel Header!</strong></p>
<p>When we refer to the <a href="https://github.com/lupyuen/pinephone-nuttx/releases/download/v1.0.0/nuttx.S"><strong>NuttX Disassembly <code>nuttx.S</code></strong></a>, we find happiness: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/arch/arm64/src/common/arm64_head.S#L79-L117">arch/arm64/src/common/arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>  /* Kernel startup entry point.
   * ---------------------------
   *
   * The requirements are:
   *   MMU = off, D-cache = off, I-cache = on or off,
   *   x0 = physical address to the FDT blob.
   *       it will be used when NuttX support device tree in the future
   *
   * This must be the very first address in the loaded image.
   * It should be loaded at any 4K-aligned address.
   */
  .globl __start;
__start:

  /* DO NOT MODIFY. Image header expected by Linux boot-loaders.
   *
   * This add instruction has no meaningful effect except that
   * its opcode forms the magic &quot;MZ&quot; signature of a PE/COFF file
   * that is required for UEFI applications.
   *
   * Some bootloader (such imx8 uboot) checking the magic &quot;MZ&quot; to see
   * if the image is a valid Linux image. but modifying the bootLoader is
   * unnecessary unless we need to do a customize secure boot.
   * so just put the &#39;&#39;MZ&quot; in the header to make bootloader happiness
   */

  add     x13, x18, #0x16      /* the magic &quot;MZ&quot; signature */
  b       real_start           /* branch to kernel start */</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">(‚ÄúMZ‚Äù refers to Mark Zbikowski)</a></p>
<p>Yep that‚Äôs the jump to <strong><code>real_start</code></strong> that we saw earlier.</p>
<p>Followed by this header‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>  .quad   0x480000              /* Image load offset from start of RAM */
  .quad   _e_initstack - __start         /* Effective size of kernel image, little-endian */
  .quad   __HEAD_FLAGS         /* Informative flags, little-endian */
  .quad   0                    /* reserved */
  .quad   0                    /* reserved */
  .quad   0                    /* reserved */
  .ascii  &quot;ARM\x64&quot;            /* Magic number, &quot;ARM\x64&quot; */
  .long   0                    /* reserved */

real_start: ...</code></pre></div>
<p>Our NuttX Image actually follows the <strong>Arm64 Linux Kernel Image Format</strong>! As defined here‚Ä¶</p>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html"><strong>‚ÄúBooting AArch64 Linux‚Äù</strong></a></li>
</ul>
<p>The doc says that a Linux Kernel Image (for Arm64) begins with this <strong>64-byte header</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>u32 code0;                    /* Executable code */
u32 code1;                    /* Executable code */
u64 text_offset;              /* Image load offset, little endian */
u64 image_size;               /* Effective Image size, little endian */
u64 flags;                    /* kernel flags, little endian */
u64 res2      = 0;            /* reserved */
u64 res3      = 0;            /* reserved */
u64 res4      = 0;            /* reserved */
u32 magic     = 0x644d5241;   /* Magic number, little endian, &quot;ARM\x64&quot; */
u32 res5;                     /* reserved (used for PE COFF offset) */</code></pre></div>
<p><a href="https://www.kernel.org/doc/html/latest/arm64/booting.html">(Source)</a></p>
<p><em>Is there a proper Linux Header in our NuttX Image?</em></p>
<p>Let‚Äôs do a quick check on our NuttX Header.</p>
<p>The <strong>Image Load Offset</strong> in our NuttX Header is <strong><code>0x48</code> <code>0000</code></strong> as we‚Äôve seen earlier‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>.quad   0x480000  /* Image load offset from start of RAM */</code></pre></div>
<p><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/arch/arm64/src/common/arm64_head.S#L107">(Source)</a></p>
<p>Our RAM starts at <strong><code>0x4000</code> <code>0000</code></strong>. (We‚Äôll see later)</p>
<p>This means that our NuttX Image will be loaded at <strong><code>0x4048</code> <code>0000</code></strong>.</p>
<p>But Ghidra (and the Arm Disassembly) says that our NuttX Image is actually loaded at <strong><code>0x4028</code> <code>0000</code></strong>! (Instead of <code>0x4048</code> <code>0000</code>)</p>
<p>Maybe the Image Load Offset should have been <strong><code>0x28</code> <code>0000</code></strong>? (Instead of <code>0x48</code> <code>0000</code>)</p>
<p>Everything else in the NuttX Header looks like a <strong>proper Linux Kernel Header</strong>.</p>
<p>Yep our NuttX Image might actually boot on PinePhone with some patching!</p>
<h1 id="nuttx-ram"><a href="#nuttx-ram">10 NuttX RAM</a></h1>
<p><em>How do we know that RAM starts at <code>0x4000</code> <code>0000</code>?</em></p>
<p><strong>RAM Size and RAM Start</strong> are defined in the NuttX Configuration for Arm64: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/boards/arm64/qemu/qemu-a53/configs/nsh_smp/defconfig#L47-L48">nsh_smp/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>CONFIG_RAM_SIZE=134217728
CONFIG_RAM_START=0x40000000</code></pre></div>
<p>That‚Äôs 128 MB RAM. Which should fit inside PinePhone‚Äôs 2 GB RAM.</p>
<p><em>Why is our NuttX Image loaded at <code>0x4028</code> <code>0000</code>?</em></p>
<p>Our NuttX Image was built with this <strong>Linker Command</strong>, as observed with ‚Äú<code>make</code> <code>--trace</code>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>aarch64-none-elf-ld \
  --entry=__start \
  -nostdlib \
  --cref \
  -Map=nuttx/nuttx/nuttx.map \
  -Tnuttx/nuttx/boards/arm64/qemu/qemu-a53/scripts/dramboot.ld  \
  -L nuttx/nuttx/staging \
  -L nuttx/nuttx/arch/arm64/src/board  \
  -o nuttx/nuttx/nuttx arm64_head.o  \
  --start-group \
  -lsched \
  -ldrivers \
  -lboards \
  -lc \
  -lmm \
  -larch \
  -lapps \
  -lfs \
  -lbinfmt \
  -lboard /Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin/../lib/gcc/aarch64-none-elf/11.3.1/libgcc.a /Applications/ArmGNUToolchain/11.3.rel1/aarch64-none-elf/bin/../lib/gcc/aarch64-none-elf/11.3.1/../../../../aarch64-none-elf/lib/libm.a \
  --end-group</code></pre></div>
<p>In the Linker Command above, we see the <strong>NuttX Linker Script</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/boards/arm64/qemu/qemu-a53/scripts/dramboot.ld#L30-L33">boards/arm64/qemu/qemu-a53/scripts/dramboot.ld</a></li>
</ul>
<p>Which defines <strong><code>_start</code></strong> as <code>0x4028</code> <code>0000</code>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
  . = 0x40280000;  /* uboot load address */
  _start = .;</code></pre></div>
<p>That‚Äôs why our NuttX Image is loaded at <code>0x4028</code> <code>0000</code>!</p>
<p><em>Will this work with PinePhone?</em></p>
<p>We‚Äôll change <code>_start</code> to <strong><code>0x4000</code> <code>0000</code></strong> for PinePhone.</p>
<p>In a while we‚Äôll see that Start of RAM is <strong><code>0x4000</code> <code>0000</code></strong> and Image Load Offset is 0 for a PinePhone Linux Image.</p>
<p>(What‚Äôs the significance of <code>0x4028</code> <code>0000</code>? Something specific to NXP i.MX8?)</p>
<h1 id="pinephone-image"><a href="#pinephone-image">11 PinePhone Image</a></h1>
<p>We‚Äôve seen our NuttX Image (which actually looks like a Linux Kernel Image). Let‚Äôs compare with a <strong>PinePhone Linux Kernel Image</strong> and see what needs to be patched in NuttX.</p>
<p>We‚Äôll analyse the Linux Kernel in the <strong>PinePhone Jumpdrive Image</strong>, since it‚Äôs small‚Ä¶</p>
<ul>
<li><a href="https://github.com/dreemurrs-embedded/Jumpdrive"><strong>dreemurrs-embedded/Jumpdrive</strong></a></li>
</ul>
<p>Here are the steps‚Ä¶</p>
<ol>
<li>
<p>Download <a href="https://github.com/dreemurrs-embedded/Jumpdrive/releases/download/0.8/pine64-pinephone.img.xz"><strong><code>pine64-pinephone.img.xz</code></strong></a></p>
</li>
<li>
<p>Extract the files from the microSD Image with <a href="https://www.balena.io/etcher/"><strong>Balena Etcher</strong></a></p>
</li>
<li>
<p>Expand the extracted files‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>gunzip Image.gz
gunzip initramfs.gz
tar xvf initramfs</code></pre></div></li>
<li>
<p>Import the uncompressed <strong><code>Image</code></strong> (Linux Kernel) into Ghidra</p>
</li>
<li>
<p>For ‚ÄúLanguage‚Äù select ‚ÄúAARCH64:LE:v8A:default‚Äù‚Ä¶</p>
<ul>
<li>Processor: <code>AARCH64</code></li>
<li>Variant: <code>v8A</code></li>
<li>Size: <code>64</code></li>
<li>Endian: <code>little</code></li>
<li>Compiler: <code>default</code></li>
</ul>
</li>
</ol>
<p><img src="https://lupyuen.github.io/images/Screenshot%202022-08-22%20at%203.39.06%20PM.png" alt="For ‚ÄúLanguage‚Äù select AARCH64:LE:v8A:default" /></p>
<p>TODO: Load PinePhone Kernel into Ghidra</p>
<p>Here‚Äôs the Jumpdrive <code>Image</code> (Linux Kernel) in Ghidra‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra2.png" alt="Ghidra with PinePhone Linux Image" /></p>
<p><em>We should see the Linux Kernel Header?</em></p>
<p>Yep when we check the <a href="https://www.kernel.org/doc/html/latest/arm64/booting.html"><strong>Linux Kernel Header</strong></a>‚Ä¶</p>
<ul>
<li>
<p><strong>Magic Number</strong> <code>ARM\x64</code> appears at offset <code>0x38</code></p>
</li>
<li>
<p><strong>Image Load Offset</strong> is <code>0</code> (offset <code>0x08</code>)</p>
</li>
</ul>
<p>Now the <strong>Start of RAM</strong> is <code>0x4000</code> <code>0000</code> according to the PinePhone Memory Map‚Ä¶</p>
<ul>
<li><a href="https://linux-sunxi.org/A64/Memory_map"><strong>Allwinner A64 Memory Map</strong></a></li>
</ul>
<p>So we shift <code>Image</code> in Ghidra to start at <code>0x4000</code> <code>0000</code>‚Ä¶</p>
<ul>
<li>
<p>Click ‚ÄúWindow‚Äù &gt; ‚ÄúMemory Map‚Äù</p>
</li>
<li>
<p>Click ‚Äúram‚Äù</p>
</li>
<li>
<p>Click the icon with the Four Arrows</p>
<p>(‚ÄúMove a block to another address‚Äù)</p>
</li>
<li>
<p>Set ‚ÄúNew Start Address‚Äù to <strong><code>40000000</code></strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/Screenshot%202022-08-21%20at%207.07.15%20PM.png" alt="Change Start Address to 40000000" /></p>
<p>The first instruction at <code>0x4000</code> <code>0000</code> jumps to <code>0x4081</code> <code>0000</code> (to skip the Linux Kernel Header)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>40000000 00 40 20 14     b          FUN_40810000</code></pre></div>
<p><a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">(Sorry Mr Zbikowski, we don‚Äôt need your Magic Signature)</a></p>
<p>The <strong>Linux Kernel Code</strong> actually begins at <code>0x4081</code> <code>0000</code>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/arm-ghidra3.png" alt="Ghidra with PinePhone Linux Image" /></p>
<p>After comparing our NuttX Image with a PinePhone Linux Image, we can conclude that they look quite similar!</p>
<h1 id="will-nuttx-boot-on-pinephone"><a href="#will-nuttx-boot-on-pinephone">12 Will NuttX Boot On PinePhone?</a></h1>
<p><em>So will NuttX boot on PinePhone?</em></p>
<p>It‚Äôs highly plausible! We discovered (with happiness) that NuttX already generates an Arm64 <strong>Linux Kernel Header.</strong></p>
<p>Thus NuttX could be a <strong>drop-in replacement</strong> for the PinePhone Linux Kernel! We just need to‚Ä¶</p>
<ul>
<li>
<p>Write <strong>PinePhone Jumpdrive</strong> to a microSD Card</p>
</li>
<li>
<p>Overwrite <strong><code>Image.gz</code></strong> by the (gzipped) NuttX Binary Image <strong><code>nuttx.bin</code></strong></p>
</li>
<li>
<p>Insert the microSD Card into PinePhone</p>
</li>
<li>
<p>Power on PinePhone</p>
</li>
</ul>
<p>And NuttX should (theoretically) <strong>boot on PinePhone!</strong></p>
<p><em>But we need some changes in NuttX?</em></p>
<p>Yep 3 things we‚Äôll modify in NuttX, as mentioned earlier‚Ä¶</p>
<ul>
<li>
<p>Change <strong><code>_start</code></strong> to <strong><code>0x4000</code> <code>0000</code></strong> (from <code>0x4028</code> <code>0000</code>) in the NuttX Linker Script: <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/boards/arm64/qemu/qemu-a53/scripts/dramboot.ld#L30-L33">dramboot.ld</a></p>
<div class="example-wrap"><pre class="language-text"><code>SECTIONS
{
/* TODO: Change to 0x4000000 for PinePhone */
. = 0x40280000;  /* uboot load address */
_start = .;</code></pre></div></li>
<li>
<p>Change <strong>Image Load Offset</strong> in our NuttX Header to <strong><code>0x0</code></strong> (from <code>0x48</code> <code>0000</code>): <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/arch/arm64/src/common/arm64_head.S#L107">arm64_head.S</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* TODO: Change to 0x0 for PinePhone */
.quad   0x480000  /* Image load offset from start of RAM */</code></pre></div></li>
<li>
<p>Increase the <strong>RAM Size</strong> to <strong>2 GB</strong> (from 128 MB): <a href="https://github.com/lupyuen/incubator-nuttx/blob/pinephone/boards/arm64/qemu/qemu-a53/configs/nsh_smp/defconfig#L47-L48">nsh_smp/defconfig</a></p>
<div class="example-wrap"><pre class="language-text"><code>/* TODO: Increase to 2 GB for PinePhone */
CONFIG_RAM_SIZE=134217728
CONFIG_RAM_START=0x40000000</code></pre></div></li>
</ul>
<p>And hopefully NuttX will boot on PinePhone!</p>
<p><em>But will we see anything when NuttX boots on PinePhone?</em></p>
<p>Not yet. We need to implement the UART Driver for NuttX‚Ä¶</p>
<h1 id="uart-driver-for-nuttx"><a href="#uart-driver-for-nuttx">13 UART Driver for NuttX</a></h1>
<p>We won‚Äôt see any output from NuttX until we implement the <strong>UART Driver for NuttX</strong>.</p>
<p><strong>For QEMU:</strong> These are the Source Files for the UART Driver (PL011)‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/qemu/qemu_serial.c">arch/arm64/src/qemu/qemu_serial.c</a></p>
</li>
<li>
<p><a href="https://github.com/apache/incubator-nuttx/blob/master/arch/arm64/src/qemu/qemu_lowputc.S">arch/arm64/src/qemu/qemu_lowputc.S</a></p>
<p><a href="https://krinkinmu.github.io/2020/11/29/PL011.html">(More about PL011 UART)</a></p>
</li>
</ul>
<p>We‚Äôll redo the code above for the <strong>PinePhone UART Driver</strong> (Allwinner A64 SoC)‚Ä¶</p>
<ul>
<li>
<p><a href="https://linux-sunxi.org/A64/Memory_map"><strong>UART0 Memory Map</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/UART"><strong>Allwinner A64 UART</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/File:Allwinner_A64_User_Manual_V1.1.pdf"><strong>Allwinner A64 User Manual</strong></a></p>
</li>
<li>
<p><a href="https://linux-sunxi.org/A64"><strong>Allwinner A64 Info</strong></a></p>
</li>
</ul>
<p><em>Where‚Äôs the UART Port on PinePhone?</em></p>
<p>To access the UART Port on PinePhone, we‚Äôll use this <strong>USB Serial Debug Cable</strong>‚Ä¶</p>
<ul>
<li><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><strong>PinePhone Serial Debug Cable</strong></a></li>
</ul>
<p>Which connects to PinePhone‚Äôs <strong>Headphone Port.</strong> Genius!</p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Privacy_switch_configuration">(Remember to flip the Headphone Switch to OFF)</a></p>
<p><img src="https://lupyuen.github.io/images/arm-uart.jpg" alt="PinePhone UART Port in disguise" /></p>
<p><a href="https://wiki.pine64.org/index.php/PinePhone#Serial_console"><em>PinePhone UART Port in disguise</em></a></p>
<h1 id="pinephone-on-rtos"><a href="#pinephone-on-rtos">14 PinePhone on RTOS</a></h1>
<p>TODO</p>
<p><em>Will an RTOS work well on Phones?</em></p>
<p><a href="https://en.wikipedia.org/wiki/BlackBerry_10"><strong>BlackBerry 10</strong></a> phones ran on <a href="https://en.wikipedia.org/wiki/QNX"><strong>QNX</strong></a>, which is a Real-Time Operating System. (10 years ago!)</p>
<p><em>What‚Äôs an RTOS anyway?</em></p>
<p>On a <a href="https://en.wikipedia.org/wiki/Real-time_operating_system"><strong>Real-Time Operating System (RTOS)</strong></a>, the Task Scheduling Behaviour is predictable. Like: Task X will be scheduled to run <strong>within Y microseconds</strong>.</p>
<p>An RTOS is not designed for High Processing Throughput. But it will guarantee (somewhat) that a Task will respond within a fixed period of time.</p>
<p><em>What does it mean for PinePhone on RTOS?</em></p>
<p>With an RTOS, I‚Äôm guessing the PinePhone User Interface will feel <strong>more responsive</strong>? And Incoming Calls and Text Messages will hopefully pop up quicker.</p>
<p>That assumes we‚Äôll assign the correct <strong>Priority for each Task</strong>. It sounds like we‚Äôre micro-managing the resources on PinePhone, but I‚Äôm curious to see the actual outcome.</p>
<p>(And it will be super educational!)</p>
<p><em>But NuttX might be too tiny for PinePhone?</em></p>
<p>A tiny operating system (like NuttX), might be good for <strong>teaching the internals</strong> of a Phone Operating System.</p>
<p>We might not get all PinePhone features to work.  But at least we‚Äôll understand every single feature that we built!</p>
<p>Tiny OSes are also easier to tweak. Think of the super-tweakable <strong>PineTime Smartwatch</strong>, which also runs on an RTOS. (FreeRTOS)</p>
<p>(Maybe someday PineTime, PinePhone and Pinebook Pro will run NuttX for <strong>Educational Purposes</strong>!)</p>
<p><img src="https://lupyuen.github.io/images/pinephone-title.jpg" alt="PinePhone on Linux with a Zig GTK App" /></p>
<p><a href="https://lupyuen.github.io/articles/pinephone"><em>PinePhone on Linux with a Zig GTK App</em></a></p>
<h1 id="pinephone-drivers-and-apps"><a href="#pinephone-drivers-and-apps">15 PinePhone Drivers and Apps</a></h1>
<p>TODO</p>
<p>Here comes the hard part.</p>
<p>No drivers? Well PinePhone comes bundled with a fixed set of peripherals‚Ä¶</p>
<ul>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.11_LCM/CTP"><strong>LCD Display / Touch Panel</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.15_MODEM-4G"><strong>LTE Modem</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.14_WIFI+BT"><strong>WiFi / BLE</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.7_NAND/eMMC"><strong>eMMC</strong></a></p>
</li>
<li>
<p><a href="https://wiki.pine64.org/wiki/PinePhone_component_list#P.6_POWER"><strong>Power Management</strong></a></p>
</li>
<li>
<p>And more</p>
</li>
</ul>
<p>And interfaces: UART, I2C, SPI, ‚Ä¶</p>
<p>Just build the drivers and we‚Äôre done? (Yep I sound really naive now)</p>
<p>Just like PineDio Stack BL604: Display, Touch Panel, LoRaWAN, ‚Ä¶</p>
<p>For Educational Purposes, we might not need all the PinePhone Drivers. Just pick the NuttX Drivers that we need, compile them into NuttX, copy to microSD and boot up PinePhone.</p>
<p>No apps? Might be interesting to build PinePhone Apps the safer way with Zig</p>
<p>Simple apps might work with LVGL and Zig</p>
<p>Can we build PinePhone Drivers in Zig?</p>
<p>TODO: From <a href="https://www.linkedin.com/in/acassis/"><strong>Alan Carvalho de Assis</strong></a></p>
<ul>
<li>
<p>I ran NuttX on PCDuino (ARM Cortex-A9 I think)</p>
</li>
<li>
<p>also NuttX on iMX6 and BeagleBoneBlack</p>
</li>
<li>
<p>nice to try evolve NuttX on Desktop direction</p>
</li>
<li>
<p>Tom Window Manager that Greg ported to NuttX</p>
</li>
<li>
<p>TODO: port NanoX (nxlib/microwindows) it could open doors to port X11 graphic applications from Linux</p>
</li>
</ul>
<h1 id="whats-next"><a href="#whats-next">16 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>There‚Äôs plenty to be done, please lemme know if you‚Äôre keen to help! üôè</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Current Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/arm.md"><strong>lupyuen.github.io/src/arm.md</strong></a></p>
<h1 id="notes"><a href="#notes">17 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1561843749168173056"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>TODO: Boot Docs</p>
<p><a href="https://linux-sunxi.org/BROM#A64"><strong>A64 Boot ROM</strong></a></p>
<p><a href="https://linux-sunxi.org/U-Boot"><strong>A64 U-Boot</strong></a></p>
<p><a href="https://linux-sunxi.org/BROM#U-Boot_SPL_limitations"><strong>A64 U-Boot SPL</strong></a></p>
<p><a href="https://linux-sunxi.org/Bootable_SD_card#SD_Card_Layout"><strong>SD Card Layout</strong></a></p>
</li>
</ol>

    
</body>
</html>