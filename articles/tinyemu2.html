<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/tinyemu2-title.png">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/tinyemu2.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Emulate Ox64 BL808 in the Web Browser: Experiments with TinyEMU RISC-V Emulator and Apache NuttX RTOS</h1>
    <nav id="TOC"><ul>
<li><a href="#install-tinyemu-emulator">1 Install TinyEMU Emulator</a><ul></ul></li>
<li><a href="#change-risc-v-addresses-in-tinyemu">2 Change RISC-V Addresses in TinyEMU</a><ul></ul></li>
<li><a href="#run-tinyemu-emulator">3 Run TinyEMU Emulator</a><ul></ul></li>
<li><a href="#uart-registers-for-bl808-soc">4 UART Registers for BL808 SoC</a><ul></ul></li>
<li><a href="#intercept-the-uart-registers">5 Intercept the UART Registers</a><ul>
<li><a href="#emulate-the-uart-status">5.1 Emulate the UART Status</a><ul></ul></li>
<li><a href="#emulate-the-uart-output">5.2 Emulate the UART Output</a><ul></ul></li></ul></li>
<li><a href="#emulator-prints-to-console">6 Emulator Prints To Console</a><ul></ul></li>
<li><a href="#risc-v-exception-in-emulator">7 RISC-V Exception in Emulator</a><ul></ul></li>
<li><a href="#emulator-in-the-web-browser">8 Emulator in the Web Browser</a><ul></ul></li>
<li><a href="#machine-mode-vs-supervisor-mode">9 Machine Mode vs Supervisor Mode</a><ul></ul></li>
<li><a href="#emulate-ox64-bl808-sbc-with-tinyemu">10 Emulate Ox64 BL808 SBC with TinyEMU</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>31 Jan 2024</em></p>
<p><img src="https://lupyuen.github.io/images/tinyemu2-title.png" alt="Ox64 BL808 Emulator with TinyEMU RISC-V Emulator and Apache NuttX RTOS" /></p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><em>(Live Demo of Ox64 BL808 Emulator)</em></a></p>
<p>TODO: <a href="https://youtu.be/KYrdwzIsgeQ"><em>(Watch on YouTube)</em></a></p>
<p><em>In olden times we had Computer Games (plus Operating Systems) on 5.25-inch <strong>Floppy Disks</strong>. And we‚Äôd boot the Floppy Disks (clackety-clack) on <strong>Apple II Computers</strong> with 64 KB RAM.</em></p>
<p>Today (40 years later) we boot <strong>microSD Cards</strong> (clickety-click) on <a href="https://wiki.pine64.org/wiki/Ox64"><strong>Ox64 BL808</strong></a> RISC-V Single-Board Computers with 64 MB RAM. (Pic below)</p>
<p><em>What if we could turn it into a</em> <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Virtual Ox64 SBC</strong></a> <em>that boots in our</em> <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Web Browser</strong></a>? <em>(Pic above) Exactly like an</em> <a href="https://www.scullinsteel.com/apple2/#dos33master"><strong>Emulated Apple II</strong></a>!</p>
<p>In this article we‚Ä¶</p>
<ul>
<li>
<p>Take <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> precompiled for Ox64</p>
<p>(Without any modifications)</p>
</li>
<li>
<p>Boot it on the <a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU RISC-V Emulator</strong></a></p>
<p><a href="https://www.barebox.org/jsbarebox/?graphic=1">(Which runs in a <strong>Web Browser</strong>)</a></p>
</li>
<li>
<p>Create our own <a href="https://lupyuen.github.io/nuttx-tinyemu/ox64"><strong>Emulator for Ox64 SBC</strong></a></p>
<p>(With minor tweaks to TinyEMU)</p>
</li>
<li>
<p>And run everything in our <strong>Web Browser</strong></p>
<p>(Thanks to WebAssembly)</p>
</li>
</ul>
<p><em>Why NuttX?</em></p>
<p><a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358"><strong>Apache NuttX RTOS</strong></a> is a tiny operating system for <a href="https://lupyuen.github.io/articles/riscv"><strong>64-bit RISC-V Machines</strong></a>. (Also Arm, x64, ESP32, ‚Ä¶)</p>
<p>Which makes it easier to understand <strong>everything that happens</strong> as NuttX boots on our Ox64 Emulator.</p>
<p><img src="https://lupyuen.github.io/images/ox64-sd.jpg" alt="Pine64 Ox64 64-bit RISC-V SBC (Bouffalo Lab BL808)" /></p>
<h1 id="install-tinyemu-emulator"><a href="#install-tinyemu-emulator">1 Install TinyEMU Emulator</a></h1>
<p><em>What‚Äôs this TinyEMU?</em></p>
<p><a href="https://github.com/fernandotcl/TinyEMU"><strong>TinyEMU</strong></a> is a barebones <strong>64-bit RISC-V Emulator</strong>.</p>
<p>It doesn‚Äôt have all the features of QEMU Emulator. But TinyEMU runs in a <a href="https://www.barebox.org/jsbarebox/?graphic=1"><strong>Web Browser</strong></a> and it‚Äôs much simpler for modding!</p>
<p>We begin by installing (our modded) <strong>TinyEMU for the Command Line</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download TinyEMU modded for Ox64
git clone https://github.com/lupyuen/ox64-tinyemu
cd ox64-tinyemu

## For Ubuntu:
sudo apt install libcurl4-openssl-dev libssl-dev zlib1g-dev libsdl2-dev
make

## For macOS:
brew install openssl sdl2
make CFLAGS=-I$(brew --prefix)/opt/openssl/include LDFLAGS=-L$(brew --prefix)/opt/openssl/lib CONFIG_MACOS=y
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/.github/workflows/ci.yml">(See the <strong>Build Script</strong>)</a></p>
<p><em>What about TinyEMU for the Web Browser?</em></p>
<p>No Worries! Everything that runs in <strong>Command Line</strong> TinyEMU‚Ä¶ Will also run in <strong>Web Browser</strong> TinyEMU.</p>
<p>We tweak TinyEMU for Ox64‚Ä¶</p>
<h1 id="change-risc-v-addresses-in-tinyemu"><a href="#change-risc-v-addresses-in-tinyemu">2 Change RISC-V Addresses in TinyEMU</a></h1>
<p><em>TinyEMU needs to emulate our Ox64 BL808 SBC. What shall we tweak?</em></p>
<p>TinyEMU is hardcoded to run at <strong>Fixed RISC-V Addresses</strong>. (Yep it‚Äôs really barebones)</p>
<p>We tweak the RISC-V Addresses in TinyEMU, so that they match the <strong>Bouffalo Lab BL808 SoC</strong>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// RISC-V Addresses for TinyEMU (modded for Ox64 BL808)
#define LOW_RAM_SIZE    0x00010000ul  // 64 KB of Boot Code at Address 0x0
#define RAM_BASE_ADDR   0x50200000ul  // Our Kernel boots here
#define PLIC_BASE_ADDR  0xe0000000ul  // Platform-Level Interrupt Controller (PLIC)
#define PLIC_SIZE       0x00400000ul  // Address Range of PLIC
#define CLINT_BASE_ADDR 0x02000000ul  // TODO: CLINT is Unused
#define CLINT_SIZE      0x000c0000ul  // TODO: CLINT is Unused
...
#define PLIC_HART_BASE  0x201000  // Hart 0 S-Mode Priority Threshold in PLIC
#define PLIC_HART_SIZE  0x1000    // Address Range of Hart 0 PLIC
</code></pre></div>
<p>TODO: Where did we get the addresses?</p>
<p><em>What‚Äôs this Boot Code?</em></p>
<p>TinyEMU needs a tiny chunk of <strong>RISC-V Machine Code</strong> that will jump to our <strong>Kernel Image</strong> (and pass the Device Tree): <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L862-L872">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// At TinyEMU Startup: Init the Emulated RAM...
static void copy_bios(...) {
  ...
  // Init the TinyEMU Boot Code at Address 0x1000 (ram_ptr is 0x0)
  uint32_t *q = (uint32_t *)(ram_ptr + 0x1000);

  // Load into Register T0 the RAM_BASE_ADDR (0x5020_0000)
  // Load into Register A1 the Binary Device Tree
  q[0] = 0x297 + RAM_BASE_ADDR - 0x1000;    // auipc t0, jump_addr
  q[1] = 0x597;                             // auipc a1, dtb
  q[2] = 0x58593 + ((fdt_addr - 4) &lt;&lt; 20);  // addi  a1, a1, dtb

  // Load into Register A0 the Hart ID (RISC-V CPU ID: 0)
  // Jump to Register T0: Our Kernel at RAM_BASE_ADDR (0x5020_0000)
  q[3] = 0xf1402573;  // csrr a0, mhartid
  q[4] = 0x00028067;  // jalr zero, t0, jump_addr
</code></pre></div>
<p>And that‚Äôs our barebones Ox64 Emulator! Let‚Äôs run it‚Ä¶</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/commit/ff10a3065701d049f079ee5f1f6246e47a8345d6">(Remember to enable <strong>Exception Logging</strong>)</a></p>
<h1 id="run-tinyemu-emulator"><a href="#run-tinyemu-emulator">3 Run TinyEMU Emulator</a></h1>
<p><em>We modded TinyEMU to emulate Ox64. What happens when we run it?</em></p>
<p>We see signs of life‚Ä¶ <strong>NuttX Kernel</strong> is actually booting in our Ox64 Emulator!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Download the TinyEMU Config and NuttX Kernel Image
$ wget https://raw.githubusercontent.com/lupyuen/nuttx-tinyemu/main/docs/ox64/root-riscv64.cfg
$ wget https://github.com/lupyuen/nuttx-tinyemu/raw/main/docs/ox64/Image

## Boot TinyEMU with NuttX Kernel
$ temu root-riscv64.cfg | more

csr_write: csr=0x104 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200000000
csr_write: csr=0x140 val=0x50400cd0
csr_write: csr=0x180 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200002000
csr_write: csr=0x003 val=0x0
csr_write: csr=0x100 val=0x8000000200006000

target_read_slow:
  invalid physical address
  0x30002084
target_write_slow: 
  invalid physical address 
  0x30002088
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6dafe6052eef7c30450a30e4ce1f94fb">(See the <strong>Complete Log</strong>)</a></p>
<p><em>What‚Äôs root-riscv64.cfg?</em></p>
<p>It‚Äôs the <strong>TinyEMU Config</strong> that will boot NuttX Kernel in our Ox64 Emulator: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/ox64/root-riscv64.cfg">root-riscv64.cfg</a></p>
<div class="example-wrap"><pre class="language-json"><code>/* VM configuration file */
{
  version: 1,
  machine: &quot;riscv64&quot;,
  memory_size: 256,
  bios: &quot;Image&quot;,
}
</code></pre></div>
<p><strong><code>Image</code></strong> is the <strong>NuttX Kernel Image</strong> that comes from a typical <a href="https://github.com/lupyuen/nuttx-ox64/releases"><strong>NuttX Build for Ox64</strong></a>.</p>
<p><em>What are the CSR Writes?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>csr_write: csr=0x104 val=0x0
csr_write: csr=0x105 val=0x50200090
csr_write: csr=0x100 val=0x200000000
</code></pre></div>
<p>CSR refers to <a href="https://five-embeddev.com/quickref/csrs.html"><strong>Control and Status Registers</strong></a>. They‚Äôre the System Registers in our RISC-V SoC (BL808)‚Ä¶</p>
<ul>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-interrupt-registers-sip-and-sie"><strong>CSR <code>0x104</code></strong></a>: <strong>Supervisor-Mode Interrupt Enable</strong></p>
<p>(Enable or Disable Interrupts)</p>
</li>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#supervisor-trap-vector-base-address-register-stvec"><strong>CSR <code>0x105</code></strong></a>: <strong>Supervisor-Mode Trap Vector Base Address</strong></p>
<p>(Set the Interrupt Vector Table)</p>
</li>
<li>
<p><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sstatus"><strong>CSR <code>0x100</code></strong></a>: <strong>Supervisor-Mode Status</strong></p>
<p>TODO: (Set the Status)</p>
<p>(Why Supervisor-Mode? We‚Äôll find out later)</p>
</li>
</ul>
<p><em>Why is it writing to CSR Registers?</em></p>
<p>This comes from our <strong>NuttX Boot Code</strong></p>
<p>TODO: NuttX Boot Code</p>
<p>Let‚Äôs talk about the invalid reads and writes‚Ä¶</p>
<p>TODO: BL808 UART Registers</p>
<h1 id="uart-registers-for-bl808-soc"><a href="#uart-registers-for-bl808-soc">4 UART Registers for BL808 SoC</a></h1>
<p><em>What are 0x3000_2084 and 0x3000_2088? Why are they Invalid Addresses?</em></p>
<div class="example-wrap"><pre class="language-yaml"><code>target_read_slow:
  invalid physical address
  0x30002084

target_write_slow: 
  invalid physical address 
  0x30002088
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/6dafe6052eef7c30450a30e4ce1f94fb">(See the <strong>Complete Log</strong>)</a></p>
<p>We dig around the <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>BL808 Reference Manual</strong></a> (pic above) and we discover these <strong>UART Registers</strong>‚Ä¶</p>
<ul>
<li>
<p><strong><code>0x3000_2088</code></strong> is <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>uart_fifo_wdata</strong> (Page 428)</a> </p>
<p>We write to this UART Register to <strong>print a character</strong> to UART Output.</p>
</li>
<li>
<p><strong><code>0x3000_2084</code></strong> is <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>uart_fifo_config_1</strong> (Page 427)</a> </p>
<p>We read this UART Register to check if <strong>UART Transmit is ready</strong> (for more output).</p>
</li>
<li>
<p>Which explains why we always see ‚Äú<strong>read <code>0x3000_2084</code></strong>‚Äù before ‚Äú<strong>write <code>0x3000_2088</code></strong>‚Äù‚Ä¶</p>
<p>NuttX Kernel is trying to <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L594-L615"><strong>print something</strong></a> to the UART Console!</p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX sends a character to the UART Port...
void bl808_send(struct uart_dev_s *dev, int ch) {
  ...
  // Wait for Transmit FIFO to be empty.
  // FIFO_CONFIG_1 is 0x3000_2084
  // TX_CNT_MASK is 0x3F
  while ((getreg32(BL808_UART_FIFO_CONFIG_1(uart_idx)) &amp;
    UART_FIFO_CONFIG_1_TX_CNT_MASK) == 0) {}

  // Write character to Transmit FIFO.
  // FIFO_WDATA is 0x3000_2088
  putreg32(ch, BL808_UART_FIFO_WDATA(uart_idx));
</code></pre></div>
<p><a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf">(<code>0x3000_2000</code> is the <strong>UART3 Base Address</strong>, Page 41)</a></p>
<p><a href="https://lupyuen.github.io/articles/ox2#print-to-serial-console">(More about <strong>BL808 UART</strong>)</a>‚Ä¶</p>
</li>
</ul>
<p><em>But why are they Invalid Addresses?</em></p>
<p>We haven‚Äôt defined in TinyEMU the addresses for <strong>Memory-Mapped Input / Output</strong>. (Like for UART Registers)</p>
<p>That‚Äôs why TinyEMU <strong>won‚Äôt read and write</strong> our UART Registers. Let‚Äôs fix this‚Ä¶</p>
<h1 id="intercept-the-uart-registers"><a href="#intercept-the-uart-registers">5 Intercept the UART Registers</a></h1>
<p><em>NuttX tries to print something but fails‚Ä¶</em></p>
<p><em>How to fix the UART Registers in our Ox64 Emulator?</em></p>
<p>Inside TinyEMU, we intercept all ‚Äú<strong>read <code>0x3000_2084</code></strong>‚Äù and ‚Äú<strong>write <code>0x3000_2088</code></strong>‚Äù. And we pretend to be a <strong>UART Port</strong>‚Ä¶</p>
<h2 id="emulate-the-uart-status"><a href="#emulate-the-uart-status">5.1 Emulate the UART Status</a></h2>
<p>Earlier we said‚Ä¶</p>
<blockquote>
<p><strong><code>0x3000_2084</code></strong> is <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>uart_fifo_config_1</strong> (Page 427)</a> </p>
</blockquote>
<blockquote>
<p><em>We read this UART Register to check if <strong>UART Transmit is ready</strong> (for more output)</em></p>
</blockquote>
<p>In TinyEMU: We intercept ‚Äú<strong>read <code>0x3000_2084</code></strong>‚Äù and return the value <code>32</code>: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L377-L392">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU reads a Memory Address...
int target_read_slow(RISCVCPUState *s, mem_uint_t *pval, target_ulong addr, int size_log2) {
...
  // If the Memory Address is not mapped...
  pr = get_phys_mem_range(s-&gt;mem_map, paddr);
  if (!pr) {
    // Because of T-Head MMU Flags, Emulator might read from 0x4000000030002084 
    // https://lupyuen.github.io/articles/plic3#t-head-errata
    switch(paddr &amp; 0xfffffffffffful) {  

      // If we&#39;re reading uart_fifo_config_1:
      // Tell Emulator that UART Transmit is always ready
      case 0x30002084:
        ret = 32; break;

      // If Unknown Address:
      // Print &quot;target_read_slow: invalid physical address&quot;
      default:
        ...
</code></pre></div>
<p><em>Why 32?</em></p>
<p>Our <strong>NuttX UART Driver</strong> checks the lower bits of <strong><code>0x3000_2084</code></strong>: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/bl808/bl808_serial.c#L594-L615">bl808_serial.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX sends a character to the UART Port...
void bl808_send(struct uart_dev_s *dev, int ch) {
  ...
  // Wait for Transmit FIFO to be empty.
  // FIFO_CONFIG_1 is 0x3000_2084
  // TX_CNT_MASK is 0x3F
  while ((getreg32(BL808_UART_FIFO_CONFIG_1(uart_idx)) &amp;
    UART_FIFO_CONFIG_1_TX_CNT_MASK) == 0) {}

  // Omitted: Write character to Transmit FIFO.
</code></pre></div>
<p>And the <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>UART Transmit Buffer Size</strong> (Page 427)</a> defaults to <code>32</code>. Thus we always return <code>32</code>.</p>
<h2 id="emulate-the-uart-output"><a href="#emulate-the-uart-output">5.2 Emulate the UART Output</a></h2>
<p>Earlier we saw‚Ä¶</p>
<blockquote>
<p><strong><code>0x3000_2088</code></strong> is <a href="https://github.com/bouffalolab/bl_docs/blob/main/BL808_RM/en/BL808_RM_en_1.3.pdf"><strong>uart_fifo_wdata</strong> (Page 428)</a> </p>
</blockquote>
<blockquote>
<p><em>We write to this UART Register to <strong>print a character</strong> to UART Output</em></p>
</blockquote>
<p>In TinyEMU: We intercept all ‚Äú<strong>write <code>0x3000_2088</code></strong>‚Äù by printing the character: <a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L472-L490">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU writes to a Memory Address...
int target_write_slow(RISCVCPUState *s, target_ulong addr, mem_uint_t val, int size_log2) {
...
  // If the Memory Address is not mapped...
  pr = get_phys_mem_range(s-&gt;mem_map, paddr);
  if (!pr) {
    // Because of T-Head MMU Flags, Emulator might write to 0x4000000030002088
    // https://lupyuen.github.io/articles/plic3#t-head-errata
    switch(paddr &amp; 0xfffffffffffful) { 

      // If we&#39;re writing to uart_fifo_wdata:
      // Print the character
      case 0x30002088:
        char buf[1];
        buf[0] = val;
        print_console(NULL, buf, 1);
        break;

      // If Unknown Address:
      // Print &quot;target_write_slow: invalid physical address&quot;
      default:
        ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L1127-L1138">(<strong>print_console</strong> is defined here)</a></p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_machine.c#L956-L963">(<strong>riscv_machine_init</strong> inits the console)</a></p>
<h1 id="emulator-prints-to-console"><a href="#emulator-prints-to-console">6 Emulator Prints To Console</a></h1>
<p><em>We modded our Ox64 Emulator to handle UART Output. Does it work?</em></p>
<p>Yep, we see NuttX booting on our Ox64 Emulator yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>## Boot TinyEMU with NuttX Kernel
$ temu root-riscv64.cfg | more

ABC
nx_start: Entry
mm_initialize: Heap: name=Kmem, start=0x50407c00 size=2065408
mm_addregion:  [Kmem] Region 1: base=0x50407ea8 size=2064720
uart_register: Registering /dev/console
target_read_slow:  invalid physical address 0x0000000030002024
target_write_slow: invalid physical address 0x0000000030002024
work_start_lowpri: Starting low-priority kernel worker thread(s)

nx_start_application: Starting init task: /system/bin/init
mm_initialize: Heap: name=(null), start=0x80200000 size=528384
mm_addregion: [(null)] Region 1: base=0x802002a8 size=527696
up_exit: TCB=0x504098d0 exiting
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/efb6750b317f52b629c115ac16635177">(See the <strong>Complete Log</strong>)</a></p>
<p>Followed by this <strong>RISC-V Exception</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>raise_exception2: cause=8, tval=0x0
pc =00000000800019c6 ra =0000000080000086 sp =0000000080202bc0 gp =0000000000000000
tp =0000000000000000 t0 =0000000000000000 t1 =0000000000000000 t2 =0000000000000000
s0 =0000000000000001 s1 =0000000080202010 a0 =000000000000000d a1 =0000000000000000
a2 =0000000080202bc8 a3 =0000000080202010 a4 =0000000080000030 a5 =0000000000000000
a6 =0000000000000101 a7 =0000000000000000 s2 =0000000000000000 s3 =0000000000000000
s4 =0000000000000000 s5 =0000000000000000 s6 =0000000000000000 s7 =0000000000000000
s8 =0000000000000000 s9 =0000000000000000 s10=0000000000000000 s11=0000000000000000
t3 =0000000000000000 t4 =0000000000000000 t5 =0000000000000000 t6 =0000000000000000
priv=U mstatus=0000000a0006806
 mideleg=0000000000000000 mie=0000000000000000 mip=0000000000000080
raise_exception2: cause=2, tval=0x0
raise_exception2: cause=2, tval=0x0
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/efb6750b317f52b629c115ac16635177">(See the <strong>Complete Log</strong>)</a></p>
<p>Why? We investigate the alligator in the vest‚Ä¶</p>
<h1 id="risc-v-exception-in-emulator"><a href="#risc-v-exception-in-emulator">7 RISC-V Exception in Emulator</a></h1>
<p><em>What‚Äôs this RISC-V Exception?</em></p>
<div class="example-wrap"><pre class="language-yaml"><code>raise_exception2:
  cause=8, tval=0x0
  pc=800019c6
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/efb6750b317f52b629c115ac16635177">(See the <strong>Complete Log</strong>)</a></p>
<p>We look up the offending Code Address: <strong><code>0x8000_19C6</code></strong>.</p>
<p>This address comes from the Virtual Memory of a <strong>NuttX App</strong> (not the NuttX Kernel): <a href="https://github.com/lupyuen2/wip-pinephone-nuttx/blob/heapcrash/boards/risc-v/bl808/ox64/configs/nsh/defconfig#L17-L30">nsh/defconfig</a></p>
<div class="example-wrap"><pre class="language-bash"><code>## Virtual Memory of NuttX Apps:
## Code, Data and Heap
CONFIG_ARCH_TEXT_VBASE=0x80000000
CONFIG_ARCH_DATA_VBASE=0x80100000
CONFIG_ARCH_HEAP_VBASE=0x80200000
</code></pre></div>
<p><em>What NuttX App are we running?</em></p>
<p>The only NuttX App we‚Äôre running at Startup is the <strong>NuttX Shell</strong>.</p>
<p>Thus we look up the <strong>RISC-V Disassembly</strong> for the NuttX Shell: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/ox64/init.S#L45327-L45358">init.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>nuttx/syscall/proxies/PROXY_sched_getparam.c:8
  int sched_getparam(pid_t parm1, FAR struct sched_param * parm2) {
  ...
  nuttx/include/arch/syscall.h:229
    19c6: 00000073  ecall
</code></pre></div>
<p><em>What‚Äôs ecall?</em></p>
<p>At <code>0x19C6</code> we see the <strong>RISC-V ECALL Instruction</strong> that will jump from our NuttX App (RISC-V User Mode) to NuttX Kernel (RISC-V Supervisor Mode). </p>
<p>Hence our NuttX Shell is making a <strong>System Call</strong> to NuttX Kernel!</p>
<p>Why did it fail? We‚Äôll come back to this, first we surf the web‚Ä¶</p>
<p><a href="https://github.com/lupyuen/ox64-tinyemu/blob/main/riscv_cpu.c#L1142-L1147">(We quit if <strong>MCAUSE is 2</strong>, otherwise we loop forever)</a></p>
<h1 id="emulator-in-the-web-browser"><a href="#emulator-in-the-web-browser">8 Emulator in the Web Browser</a></h1>
<p><em>Will our Ox64 Emulator run in the Web Browser?</em></p>
<p>TODO</p>
<p>Let‚Äôs find out! First we fix the <a href="https://github.com/lupyuen/ox64-tinyemu/commit/170abb06b58a58328efa8a1874795f1daac0b7a7">TinyEMU Build for Emscripten</a>.</p>
<p><a href="https://lupyuen.github.io/nuttx-tinyemu/ox64/">And it runs OK in Web Browser yay!</a></p>
<p>TODO: Emulate BL808 GPIO to Blink an LED</p>
<h1 id="machine-mode-vs-supervisor-mode"><a href="#machine-mode-vs-supervisor-mode">9 Machine Mode vs Supervisor Mode</a></h1>
<p><em>Back to our earlier question: Why did our System Call fail?</em></p>
<p>Our NuttX App (NuttX Shell) tried to make a <strong>System Call (ECALL)</strong> to NuttX Kernel. And it failed: <a href="https://github.com/lupyuen/nuttx-tinyemu/blob/main/docs/ox64/init.S#L45327-L45358">init.S</a></p>
<div class="example-wrap"><pre class="language-c"><code>nuttx/syscall/proxies/PROXY_sched_getparam.c:8
  int sched_getparam(pid_t parm1, FAR struct sched_param * parm2) {
  ...
  // ECALL fails with a RISC-V Exception
  nuttx/include/arch/syscall.h:229
    19c6: 00000073  ecall
</code></pre></div>
<p>TODO: (See the <strong>Source Code</strong>)</p>
<p><em>What‚Äôs ECALL again?</em></p>
<p>The <strong>RISC-V ECALL Instruction</strong> normally jumps‚Ä¶</p>
<ul>
<li>
<p>From our <strong>NuttX App</strong></p>
<p>(In <strong>RISC-V User Mode</strong>)</p>
</li>
<li>
<p>To the <strong>NuttX Kernel</strong></p>
<p>(In <strong>RISC-V Supervisor Mode</strong>)</p>
</li>
<li>
<p>In order to make a <strong>System Call</strong></p>
<p>(Which failed)</p>
</li>
</ul>
<p><strong>System Calls</strong> are absolutely essential. That‚Äôs how our apps will execute system functions, like printing to the Console Output.</p>
<p><em>Why did ECALL fail?</em></p>
<p>That‚Äôs because our NuttX App is actually running in <strong>RISC-V Machine Mode</strong>, not User Mode!</p>
<p>Machine Mode is the <strong>most powerful mode</strong> in a RISC-V System, more powerful than Supervisor Mode and User Mode‚Ä¶</p>
<p>And Machine Mode <strong>can‚Äôt possibly make ECALLS</strong> to a Higher Mode!</p>
<p>TODO: Pic of Machine, Supervisor, User Modes. Start / System Call (ECALL)</p>
<p><em>Huh! How did that happen?</em></p>
<p>TinyEMU always <strong>starts in Machine Mode</strong>. Everything we saw today: That‚Äôs all running in (super-powerful) Machine Mode.</p>
<p>But a <strong>Real Ox64 SBC</strong> is a little different‚Ä¶</p>
<ol>
<li>
<p>Ox64 boots the <strong>OpenSBI Supervisor Binary Interface</strong> in <strong>Machine Mode</strong>‚Ä¶</p>
<p>(Think BIOS, but for RISC-V Machines)</p>
</li>
<li>
<p>Which starts the <strong>U-Boot Bootloader</strong> in <strong>Supervisor Mode</strong>‚Ä¶</p>
</li>
<li>
<p>Which starts the <strong>NuttX Kernel</strong>, also in <strong>Supervisor Mode</strong>‚Ä¶</p>
</li>
<li>
<p>And NuttX Kernel starts the <strong>NuttX Apps</strong> in <strong>User Mode</strong></p>
</li>
</ol>
<p>TODO: Pic of OpenSBI, U-Boot, Kernel, Apps</p>
<p><em>So we need to start NuttX Kernel in Supervisor Mode?</em></p>
<p>Yep, we need more tweaks in TinyEMU to start NuttX in Supervisor Mode. (Instead of Machine Mode)</p>
<p>TODO: Pic of TinyEMU, Kernel, Apps. Start / System Call (ECALL). Emulate OpenSBI Timer</p>
<p><em>Any other gotchas?</em></p>
<p>There‚Äôs a tiny quirk: NuttX Kernel will <strong>make an ECALL</strong> too‚Ä¶</p>
<p>NuttX Kernel makes a <strong>System Call to OpenSBI</strong> to set the System Timer. (Pic above)</p>
<p><em>Do we plan to boot OpenSBI on TinyEMU?</em></p>
<p>That‚Äôs not necessary. We‚Äôll <strong>emulate the OpenSBI</strong> System Timer in TinyEMU. (Pic above)</p>
<p>(It‚Äôs truly amazing we managed to boot so much in Machine Mode)</p>
<p>TODO</p>
<h1 id="emulate-ox64-bl808-sbc-with-tinyemu"><a href="#emulate-ox64-bl808-sbc-with-tinyemu">10 Emulate Ox64 BL808 SBC with TinyEMU</a></h1>
<p>TODO</p>
<p>Objective: Take the NuttX Kernel built for <a href="https://www.hackster.io/lupyuen/8-risc-v-sbc-on-a-real-time-operating-system-ox64-nuttx-474358">Ox64 BL808 SBC</a>. And boot it on TinyEMU RISC-V Emulator in the Web Browser!</p>
<ol>
<li>
<p>Fix these RISC-V Addresses in TinyEMU to follow BL808 Memory Map: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L66-L82">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define LOW_RAM_SIZE   0x00010000 /* 64KB */
#define RAM_BASE_ADDR  0x80000000
#define CLINT_BASE_ADDR 0x02000000
#define CLINT_SIZE      0x000c0000
#define DEFAULT_HTIF_BASE_ADDR 0x40008000
#define VIRTIO_BASE_ADDR 0x40010000
#define VIRTIO_SIZE      0x1000
#define VIRTIO_IRQ       1
#define PLIC_BASE_ADDR 0x40100000
#define PLIC_SIZE      0x00400000
#define FRAMEBUFFER_BASE_ADDR 0x41000000

#define RTC_FREQ 10000000
#define RTC_FREQ_DIV 16 /* arbitrary, relative to CPU freq to have a
                          10 MHz frequency */
</code></pre></div></li>
<li>
<p>Start TinyEMU in RISC-V Supervisor Mode (instead of Machine Mode)</p>
<p>(So we don‚Äôt need OpenSBI and U-Boot Bootloader)</p>
</li>
<li>
<p>Emulate <a href="https://lupyuen.github.io/articles/nim#appendix-opensbi-timer-for-nuttx">OpenSBI Timer</a></p>
<p>(Intercept the Supervisor-To-Machine Mode ECALL)</p>
</li>
<li>
<p>Emulate BL808 UART I/O (Memory Mapped I/O and PLIC Interrupts)</p>
<p>(So we can run NuttX Shell)</p>
</li>
<li>
<p>Emulate BL808 GPIO Output (Memory Mapped I/O)</p>
<p>(So we can test Nim Blinky)</p>
</li>
</ol>
<p>Let‚Äôs try booting NuttX Ox64 on TinyEMU‚Ä¶</p>
<p>TODO: Wrap TinyEMU with Zig for Memory Safety and WebAssembly?</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Other Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Older Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/tinyemu2.md"><strong>lupyuen.github.io/src/tinyemu2.md</strong></a></p>

    
</body>
</html>