<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Clickable) Call Graph for Apache NuttX Real-Time Operating System</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Clickable) Call Graph for Apache NuttX Real-Time Operating System"
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/unicorn2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Clickable) Call Graph for Apache NuttX Real-Time Operating System</h1>
    <nav id="TOC"><ul>
<li><a href="#intercept-code-execution-in-unicorn">1 Intercept Code Execution in Unicorn</a><ul></ul></li>
<li><a href="#map-address-to-function">2 Map Address to Function</a><ul></ul></li>
<li><a href="#dwarf-debug-symbols">3 DWARF Debug Symbols</a><ul></ul></li>
<li><a href="#clickable-mermaid-flowchart">4 Clickable Mermaid Flowchart</a><ul></ul></li>
<li><a href="#generate-call-graph">5 Generate Call Graph</a><ul></ul></li>
<li><a href="#pinephone-boots-nuttx">6 PinePhone Boots NuttX</a><ul>
<li><a href="#arm64-header">6.1 Arm64 Header</a><ul></ul></li>
<li><a href="#initialise-el1">6.2 Initialise EL1</a><ul></ul></li>
<li><a href="#primary-routine">6.3 Primary Routine</a><ul></ul></li>
<li><a href="#boot-chip">6.4 Boot Chip</a><ul></ul></li></ul></li>
<li><a href="#pinephone-continues-booting-nuttx">7 PinePhone Continues Booting NuttX</a><ul>
<li><a href="#after-boot-chip">7.1 After Boot Chip</a><ul></ul></li>
<li><a href="#after-primary-routine">7.2 After Primary Routine</a><ul></ul></li></ul></li>
<li><a href="#arm64-memory-management-fault">8 Arm64 Memory Management Fault</a><ul></ul></li>
<li><a href="#automated-daily-build-and-test">9 Automated Daily Build and Test</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-parse-dwarf-debug-symbols">11 Appendix: Parse DWARF Debug Symbols</a><ul></ul></li></ul></nav><p>üìù <em>10 Mar 2023</em></p>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<p>Last week we ran <a href="https://lupyuen.github.io/articles/what"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) on <a href="https://www.unicorn-engine.org/"><strong>Unicorn Emulator</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn"><strong>‚Äú(Possibly) Emulate PinePhone with Unicorn Emulator‚Äù</strong></a></li>
</ul>
<p>And we hit a baffling <a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>Arm64 Exception</strong></a> in the (Emulated) <strong>Memory Management Unit</strong>.</p>
<p>In this article we‚Äôll create some tools  to <strong>troubleshoot the Arm64 Exception</strong> in NuttX‚Ä¶</p>
<ul>
<li>
<p>Render the <a href="https://en.wikipedia.org/wiki/Call_graph"><strong>Dynamic Call Graph</strong></a> for Apache NuttX RTOS, to understand how it boots (pic above)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Make it Clickable</strong></a>, so we can browse the <strong>NuttX Source Code</strong> as we explore the Call Graph</p>
</li>
<li>
<p>We‚Äôll use a <strong>Block Execution Hook</strong> in Unicorn Emulator to generate the Call Graph with Rust</p>
</li>
<li>
<p>And call the Rust Libraries <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> to map the Code Addresses to NuttX Kernel Functions</p>
</li>
<li>
<p>Thanks to the (Clickable) Call Graph, we‚Äôll describe the complete <strong>Boot Sequence</strong> of NuttX RTOS on <a href="https://wiki.pine64.org/index.php/PinePhone"><strong>Pine64 PinePhone</strong></a></p>
</li>
<li>
<p>And explain how we might do <strong>Automated Daily Build and Test</strong> for NuttX on PinePhone</p>
</li>
</ul>
<p>CPU Emulators (like Unicorn) can be super helpful for understanding the internals of <strong>complex embedded programs</strong>‚Ä¶ Like Apache NuttX RTOS!</p>
<p>Let‚Äôs dive in and learn how‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn-code4.png" alt="Running Apache NuttX RTOS in Unicorn" /></p>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn"><em>Running Apache NuttX RTOS in Unicorn</em></a></p>
<h1 id="intercept-code-execution-in-unicorn"><a href="#intercept-code-execution-in-unicorn">1 Intercept Code Execution in Unicorn</a></h1>
<p><em>What‚Äôs Unicorn? How does it work with Apache NuttX RTOS?</em></p>
<p><a href="https://www.unicorn-engine.org/"><strong>Unicorn</strong></a> is a lightweight <strong>CPU Emulator Framework</strong> based on <a href="http://www.qemu.org/"><strong>QEMU Emulator</strong></a>.</p>
<p>In the <a href="https://lupyuen.github.io/articles/unicorn"><strong>last article</strong></a> we called Unicorn (in Rust) to run the <strong>Arm64 Machine Code</strong> for Apache NuttX RTOS‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Arm64 Machine Code for Apache NuttX RTOS
</span><span class="kw">let </span>arm64_code = <span class="macro">include_bytes!</span>(<span class="string">&quot;../nuttx/nuttx.bin&quot;</span>);

<span class="comment">// Init Unicorn Emulator in Arm64 mode
</span><span class="kw">let </span><span class="kw-2">mut </span>unicorn = Unicorn::new(
  Arch::ARM64,
  Mode::LITTLE_ENDIAN
).expect(<span class="string">&quot;failed to init Unicorn&quot;</span>);

<span class="comment">// Magical horse mutates to bird
</span><span class="kw">let </span>emu = <span class="kw-2">&amp;mut </span>unicorn;

<span class="comment">// Omitted: Map Executable Memory and I/O Memory in Unicorn
</span>...

<span class="comment">// Boot NuttX RTOS in Unicorn Emulator
</span><span class="kw">let </span>err = emu.emu_start(
  <span class="number">0x4008_0000</span>,  <span class="comment">// Begin Address
  </span><span class="number">0x4008_0000 </span>+ arm64_code.len() <span class="kw">as </span>u64,  <span class="comment">// End Address
  </span><span class="number">0</span>,  <span class="comment">// No Timeout
  </span><span class="number">0   </span><span class="comment">// Unlimited number of instructions
</span>);</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#apache-nuttx-rtos-in-unicorn">(Source)</a></p>
<p>And NuttX starts booting in the Unicorn Emulator!</p>
<p><em>So Unicorn works like QEMU Emulator?</em></p>
<p>Yes but with a fun new twist: Unicorn lets us <strong>intercept the Execution</strong> of Emulated Code by attaching a <strong>Hook Function</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Add Unicorn Hook that will intercept
// every Block of Arm64 Instructions
</span><span class="kw">let _ </span>= emu.add_block_hook(hook_block)
  .expect(<span class="string">&quot;failed to add block hook&quot;</span>);</code></pre></div>
<p>So we can <strong>trace the flow</strong> of the Emulated Code.</p>
<p>Here‚Äôs the <strong>Hook Function</strong> that will be called whenever Unicorn emulates a Block of Arm64 Instructions‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// TODO: Trace the flow of emulated code
  </span><span class="macro">println!</span>(<span class="string">&quot;hook_block:  address={address:#010x}, size={size:02}&quot;</span>);
}</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/unicorn#block-execution-hook">(Source)</a></p>
<p>Unicorn Emulator calls our Hook Function, passing the‚Ä¶</p>
<ul>
<li>
<p><strong>Address</strong> of the Arm64 Code Block being emulated</p>
</li>
<li>
<p><strong>Size</strong> of the Arm64 Code Block being emulated</p>
</li>
</ul>
<p>Let‚Äôs modify the Hook Function to tell us what code it‚Äôs emulating‚Ä¶</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#what-is-a-block-of-arm64-instructions">(What‚Äôs an Arm64 Code Block?)</a></p>
<h1 id="map-address-to-function"><a href="#map-address-to-function">2 Map Address to Function</a></h1>
<p><em>How do we use a Hook Function‚Ä¶</em></p>
<p><em>To tell us what code Unicorn is emulating?</em></p>
<p>Earlier we saw that Unicorn calls our Hook Function with the <strong>Address of the Arm64 Code</strong> that‚Äôs being emulated.</p>
<p>Let‚Äôs lookup the Arm64 Code Address to find the <strong>Name of the Function</strong> that‚Äôs running right now‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:  
  address=0x40080920
  arm64_chip_boot

hook_block:  
  address=0x40080e50
  arm64_mmu_init
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p><em>How will we map the Arm64 Address to the Function Name?</em></p>
<p>Let‚Äôs pretend we‚Äôre a Debugger (like GDB). The best way to map an Arm64 Address to the Function Name would be‚Ä¶</p>
<p>The <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Debug Symbols</strong></a> in the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF File</strong></a>!</p>
<p>Assuming we can <strong>parse the Debug Symbols</strong> (from our ELF File), our Hook Function will translate the Arm64 Address to Function Name like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L158">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Hook Function for Block Emulation.
// Called by Unicorn for every Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="macro">print!</span>(<span class="string">&quot;hook_block:  address={address:#010x}, size={size:02}&quot;</span>);

  <span class="comment">// Print the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  <span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="kw-2">ref </span>name) = function {  <span class="comment">// If we find the Function Name...
    </span><span class="macro">print!</span>(<span class="string">&quot;, {name}&quot;</span>);
  }

  <span class="comment">// Print the Source Filename, Line Number
  // and Column Number for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  <span class="kw">let </span>(<span class="kw-2">ref </span>file, line, col) = loc;
  <span class="kw">let </span>file = file.clone().unwrap_or(<span class="string">&quot;&quot;</span>.to_string());  <span class="comment">// Default filename is &quot;&quot;
  </span><span class="kw">let </span>line = line.unwrap_or(<span class="number">0</span>);  <span class="comment">// Default line is 0
  </span><span class="kw">let </span>col  = col.unwrap_or(<span class="number">0</span>);   <span class="comment">// Default column is 0
  </span><span class="macro">println!</span>(<span class="string">&quot;, {file}:{line}:{col}&quot;</span>);
}</code></pre></div>
<p><em>The Debug Symbols will tell us the Source Filename?</em></p>
<p>Yep the <strong>Source Filename, Line Number and Column Number</strong> are in the DWARF Debug Symbols too!</p>
<p>Later we‚Äôll print them to make the Call Graph clickable.</p>
<p>But first we look inside <strong>map_address_to_function</strong> and <strong>map_address_to_location</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-dwarf.png" alt="DWARF Debugging Format" /></p>
<p><a href="https://dwarfstd.org/doc/Debugging%20using%20DWARF-2012.pdf"><em>DWARF Debugging Format</em></a></p>
<h1 id="dwarf-debug-symbols"><a href="#dwarf-debug-symbols">3 DWARF Debug Symbols</a></h1>
<p><em>How will we load the Debug Symbols from our ELF File?</em></p>
<p>Our ELF File contains the Debug Symbols in <a href="https://en.wikipedia.org/wiki/DWARF"><strong>DWARF Format</strong></a>.</p>
<p>The Rust Crates <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> will parse the DWARF Debug Symbols in our ELF File.</p>
<p>This is how we call the crates to map an <strong>Arm64 Address to Function Name</strong>:  <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L174-L193">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Function Name 
/// by looking up the DWARF Debug Symbols
</span><span class="kw">fn </span>map_address_to_function(
  address: u64         <span class="comment">// Arm64 Code Address
</span>) -&gt; <span class="prelude-ty">Option</span>&lt;String&gt; {  <span class="comment">// Return the Function Name

  // Lookup the DWARF Frame for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span><span class="kw-2">mut </span>frames = context.find_frames(address)
    .expect(<span class="string">&quot;failed to find frames&quot;</span>);

  <span class="comment">// Return the Function Name
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(frame) = frames.next().unwrap() {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(func) = frame.function {
      <span class="kw">if let </span><span class="prelude-val">Ok</span>(name) = func.raw_name() {
        <span class="kw">let </span>s = String::from(name);
        <span class="kw">return </span><span class="prelude-val">Some</span>(s);
      }
    }    
  }

  <span class="comment">// Function Name not found.
  // Probably an Arm64 Assembly Routine.
  </span><span class="prelude-val">None
</span>}</code></pre></div>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong>. In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Frame</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Function Name</strong> from the DWARF Frame</p>
</li>
</ul>
<p>(We‚Äôll come back to <strong>ELF_CONTEXT</strong>)</p>
<p>This is how we map an <strong>Arm64 Address to Source Filename</strong>: 
<a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L195-L221">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Map the Arm64 Code Address to the Source Filename,
/// Line Number and Column Number
</span><span class="kw">fn </span>map_address_to_location(
  address: u64     <span class="comment">// Arm64 Code Address
</span>) -&gt; (             <span class="comment">// Return the...
  </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line Number
  </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column Number
</span>) {
  <span class="comment">// Lookup the Source Location for the Arm64 Code Address
  </span><span class="kw">let </span>context = ELF_CONTEXT.context.borrow();
  <span class="kw">let </span>loc = context.find_location(address)
    .expect(<span class="string">&quot;failed to find location&quot;</span>);

  <span class="comment">// Return the Source Filename, Line and Column
  </span><span class="kw">if let </span><span class="prelude-val">Some</span>(loc) = loc {
    <span class="kw">if let </span><span class="prelude-val">Some</span>(file) = loc.file {

      <span class="comment">// Shorten the path
      </span><span class="kw">let </span>s = String::from(file)
        .replace(<span class="string">&quot;/private/tmp/nuttx/nuttx/&quot;</span>, <span class="string">&quot;&quot;</span>)
        .replace(<span class="string">&quot;arch/arm64/src/chip&quot;</span>, <span class="string">&quot;arch/arm64/src/a64&quot;</span>);  <span class="comment">// TODO: Handle other chips
      </span>(<span class="prelude-val">Some</span>(s), loc.line, loc.column)
    } <span class="kw">else </span>{
      <span class="comment">// If Filename is missing, return the Line and Column
      </span>(<span class="prelude-val">None</span>, loc.line, loc.column)
    }
  } <span class="kw">else </span>{
    <span class="comment">// Filename, Line and Column are missing
    </span>(<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)
  }
}</code></pre></div>
<p>In the code above, we‚Ä¶</p>
<ul>
<li>
<p>Lookup the Parsed Debug Symbols to find the <strong>DWARF Location</strong> that matches the Arm64 Code Address</p>
</li>
<li>
<p>Extract the <strong>Source Filename, Line and Column</strong> from the DWARF Location</p>
</li>
</ul>
<p>Now that we‚Äôve extracted the <strong>Function Name and Source Filename</strong> from our ELF File, our <a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>Hook Function</strong></a> will print meaningful traces of our Emulated Program‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hook_block:
  address=0x40080920
  size=12
  arm64_chip_boot
  arch/arm64/src/chip/a64_boot.c:82:1

hook_block:  
  address=0x40080e50
  size=28
  arm64_mmu_init
  arch/arm64/src/common/arm64_mmu.c:584:1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a">(Source)</a></p>
<p>Which are super helpful for figuring out what‚Äôs happening inside Unicorn Emulator!</p>
<p><em>What‚Äôs ELF_CONTEXT?</em></p>
<p><strong>ELF_CONTEXT</strong> contains the <strong>Parsed Debug Symbols</strong> from our ELF File.</p>
<p>Here‚Äôs how we call the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a> and <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> libraries to parse the Debug Symbols‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn2#appendix-parse-dwarf-debug-symbols"><strong>‚ÄúParse DWARF Debug Symbols‚Äù</strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-title.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<h1 id="clickable-mermaid-flowchart"><a href="#clickable-mermaid-flowchart">4 Clickable Mermaid Flowchart</a></h1>
<p><em>As Unicorn Emulator runs, it prints a long list of Function Names‚Ä¶</em></p>
<p><em>How can we make sense of the Function Names?</em></p>
<p>Let‚Äôs transform the long list of <a href="https://gist.github.com/lupyuen/f2e883b2b8054d75fbac7de661f0ee5a"><strong>Function Names</strong></a>‚Ä¶</p>
<p>Into a <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Clickable Call Graph</strong></a> that shows exactly how the functions are called!</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos">(Like this)</a></p>
<p><em>Whoa! We need a special diagramming tool?</em></p>
<p>Actually we can render a <a href="https://mermaid.js.org/syntax/flowchart.html"><strong>Mermaid Flowchart</strong></a> (in Markdown Format) by simply printing this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>```mermaid
flowchart TD
START --&gt; arm64_head
arm64_head --&gt; a64_lowputc
arm64_head --&gt; arm64_boot_primary_c_routine
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(Source)</a></p>
<p>(<strong>TD</strong> means Top-Down Flowchart)</p>
<p>To make a <a href="https://mermaid.js.org/syntax/flowchart.html#interaction"><strong>Clickable Mermaid Flowchart</strong></a>, we print the URLs like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>click arm64_head href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L104&quot; &quot;arch/arm64/src/common/arm64_head.S&quot; _blank
</code></pre></div>
<p>This jumps to the <strong>NuttX Source Code</strong> when we click the Function Name.</p>
<p>(Second part of <strong>href</strong> is the Mouseover Tooltip)</p>
<p>To <strong>preview the flowchart</strong> and check the hyperlinks, we use this handy web tool‚Ä¶</p>
<ul>
<li><a href="https://mermaid.live/edit#pako:eNrtmstuozAUhl8FeXZVGsKdsBipUhez6Gqa1SgSMo4bULnJGDWZqu8-xmlKCCQpbWgh40UrIL_d7z_Hx3aKnwFKFhg4QJIewuQJ-ZBQaXY7jyXpfnbzeyZdX_-UIIlM3fUxXBTPy7vNh-yGtUxziopPURigx12NT_CDNAc-pWnmyPIyoH7ujVESyTCFyMdynFO6kr0w8eQIZhQTGRLky7wLOSNIZtooieWyz_H9jztlos8B6_e0lok4dsnZYOoVe0fzeW7Wm7zTY0Ft2E3QNeEWuR-RtqwBRtq2hhdpdWqLSItIi0iLSItIi0iLSH8g0nvY_NZLEuriUHGDOKADwK_w7vgIMm-fvio9s42i8zFiO0Dt9A5wo63YYLjvTUIhPRu8BwkJMMnGPttwHyMvhf0Ov278T-FvKt6UBBEkaxe5JMlpEOOhVHENnDuLcJRh2jiY6g26GlX2pN2o2kC3yMxrgw_wh4GXFb-QnFESxMvi2t10x9HNTUKOyt6bi40A-UHKVd-dFOUjpf5Gv-MoivLGWi-159tlbPGb6auqCvgWknOztOWpm8Ildin0Qpzto7-pzxx91m9Bb9jayeBz6auFGi93UQC6qxDSmom6vhsf-nTSysc-MbeBYIhy9gy7KfsJ4gVelU5qLToyolitjDQwn0hJU4tuvKi6-fmkFJALnCGXrlP89enQ26WjQsv5Y_zE5lIMwzBBG9bSRFXdURI0vZWDOu-J8dTQoBsnmmVfSI1r56nxA6XR3wKvV8fRdPSxPPo931qfLxC2YnNQ9rfRIw9_7yfdOvLpXcl-g44yMtUuZMoyTLEtuaRtyeFE9HHW7W9dWKpYysVSLpbyM01UF7MAXsCiISbdQexELqXKh1UcYkwNYUwJH8KH8HHUx6HXTz3dVw3_H-wXkohGG8dy0dPN4YH3HVkaBodrvLfvPJqwKzMWh91z09ioo-xMFFEswsb32mg-xIBjXhrFgQscKl9_hMFQjFYuqryHzuztqTpC19rNudXDeocC36tzeg3Rvrq6cn_d3M1cdvHVAdfbBByMQIRJBIMFcMBzgToH1McRngOHXS4geSxkL0wHc5rcr2MEHEpyPAJ5umBfWm8DuCQwAs4DDDP2NIXxnySJtiJ2C5xnsAKObowVbTpRpgYbEvrEHoE1cBR1bKi6PVUN1TJt1TS0lxH4y9sr44liqIqtT01NVU1NsV_-AeJmZMs"><strong>Mermaid Live Editor</strong></a></li>
</ul>
<p><em>How will we generate the Clickable Call Graph?</em></p>
<p>Remember our <a href="https://lupyuen.github.io/articles/unicorn2#intercept-code-execution-in-unicorn"><strong>Hook Function</strong></a> that intercepts every Block of Arm64 Instructions emulated by Unicorn?</p>
<p>Let‚Äôs <strong>print the Call Graph</strong> inside our Hook Function: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L159">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Hook Function for Block Emulation.
/// Called once for each Basic Block of Arm64 Instructions.
</span><span class="kw">fn </span>hook_block(
  <span class="kw">_</span>: <span class="kw-2">&amp;mut </span>Unicorn&lt;()&gt;,  <span class="comment">// Emulator
  </span>address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>size: u32      <span class="comment">// Size of Arm64 Code Block
</span>) {
  <span class="comment">// Get the Function Name for the Arm64 Address
  </span><span class="kw">let </span>function = map_address_to_function(address);
  ...

  <span class="comment">// Get the Source Filename for the Arm64 Address
  </span><span class="kw">let </span>loc = map_address_to_location(address);
  ...

  <span class="comment">// Print the Call Graph
  </span>call_graph(address, size, function, loc);
}</code></pre></div>
<p>Now we look inside the <strong>call_graph</strong> function‚Ä¶</p>
<h1 id="generate-call-graph"><a href="#generate-call-graph">5 Generate Call Graph</a></h1>
<p><em>Our Hook Function calls <strong>call_graph</strong> to print the Call Graph‚Ä¶</em></p>
<p><em>What‚Äôs inside <strong>call_graph</strong>?</em></p>
<p>Earlier we said that we‚Äôre generating this <strong>Clickable Call Graph</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>‚ÄúCall Graph for Apache NuttX RTOS‚Äù</strong></a></li>
</ul>
<p>Which needs a <strong>Mermaid Flowchart</strong> like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>```mermaid
flowchart TD
START --&gt; arm64_head
arm64_head --&gt; a64_lowputc
click arm64_head href &quot;https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_head.S#L104&quot; &quot;arch/arm64/src/common/arm64_head.S&quot; _blank
...
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(Source)</a></p>
<p>Our <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L130-L159"><strong>Hook Function</strong></a> calls <strong>call_graph</strong>, which prints the Mermaid Flowchart (line by line) like so: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L222-L265">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Print the Mermaid Call Graph for this Function Call:
/// cargo run | grep call_graph | cut -c 12-
</span><span class="kw">fn </span>call_graph(
  _address: u64,  <span class="comment">// Address of Arm64 Code Block
  </span>_size: u32,     <span class="comment">// Size of Arm64 Code Block
  </span>function: <span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Function Name
  </span>loc: (             <span class="comment">// Source Location
    </span><span class="prelude-ty">Option</span>&lt;String&gt;,  <span class="comment">// Filename
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;,     <span class="comment">// Line
    </span><span class="prelude-ty">Option</span>&lt;u32&gt;      <span class="comment">// Column
  </span>)
) {
  <span class="comment">// Get the Function Name
  </span><span class="kw">let </span>fname = <span class="kw">match </span>function {
    <span class="prelude-val">Some</span>(fname) =&gt; fname,
    <span class="prelude-val">None </span>=&gt; map_location_to_function(<span class="kw-2">&amp;</span>loc)
  };

  <span class="comment">// Skip if we are still in the same Function
  </span><span class="kw">let </span><span class="kw-2">mut </span>last_fname = LAST_FNAME.lock().unwrap();
  <span class="kw">let </span><span class="kw-2">mut </span>last_loc = LAST_LOC.lock().unwrap();
  <span class="kw">if </span>fname.eq(last_fname.as_str()) { <span class="kw">return</span>; }</code></pre></div>
<p><strong>call_graph</strong> receives the Function Name and Source Filename, which we have <a href="https://lupyuen.github.io/articles/unicorn2#map-address-to-function"><strong>loaded from the ELF File</strong></a>.</p>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L267-L280">(<strong>map_location_to_function</strong> is defined here)</a></p>
<p><em>What are last_fname and last_loc?</em></p>
<p>We remember the Previous Function Name (<strong>last_fname</strong>) and Previous Filename (<strong>last_loc</strong>)‚Ä¶</p>
<p>So we can connect the <strong>Calling Function</strong> with the <strong>Called Function</strong> in our Call Graph.</p>
<p>(OK this doesn‚Äôt always work‚Ä¶ But it‚Äôs good enough!)</p>
<p>This is how we <strong>start the Call Graph</strong>‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>  <span class="comment">// If this function has not been shown too often...
  </span><span class="kw">if </span>can_show_function(<span class="kw-2">&amp;</span>fname) {
    <span class="comment">// Print the Call Flow
    </span><span class="kw">if </span>last_fname.is_empty() {            
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  flowchart TD&quot;</span>);  <span class="comment">// Top-Down Flowchart
      </span><span class="macro">println!</span>(<span class="string">&quot;call_graph:  START --&gt; {fname}&quot;</span>);</code></pre></div>
<p><a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L282-L295">(<strong>can_show_function</strong> is defined here)</a></p>
<p>And this is how we <strong>connect the Calling Function</strong> with the Called Function‚Ä¶</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    } <span class="kw">else </span>{
      <span class="comment">// URL looks like https://github.com/apache/nuttx/blob/master/arch/arm64/src/common/arm64_mmu.c#L541
      </span><span class="kw">let </span>(file, line, <span class="kw">_</span>) = last_loc.clone();
      <span class="kw">let </span>file = file.unwrap_or(<span class="string">&quot;&quot;</span>.to_string());
      <span class="kw">let </span>line = line.unwrap_or(<span class="number">1</span>) - <span class="number">1</span>;
      <span class="kw">let </span>url = <span class="macro">format!</span>(<span class="string">&quot;https://github.com/apache/nuttx/blob/master/{file}#L{line}&quot;</span>);
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  {last_fname} --&gt; {fname}&quot;</span>);
      <span class="macro">println!</span>(<span class="string">&quot;call_graph:  click {last_fname} href \&quot;{url}\&quot; \&quot;{file} \&quot;&quot;</span>);
    }
  }

  <span class="comment">// Remember the Function Name and Source Location
  </span><span class="kw-2">*</span>last_fname = fname;
  <span class="kw-2">*</span>last_loc = loc;
}</code></pre></div>
<p>To <strong>generate the Call Graph</strong> (via Unicorn Emulator), we run this command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>cargo run \
  | grep call_graph \
  | cut -c 12-
</code></pre></div>
<p>(<strong>cut</strong> removes columns 1 to 11)</p>
<p>Unicorn Emulator runs our Arm64 Machine Code, intercepts every Arm64 Instruction and generates the Call Graph.</p>
<p><a href="https://gist.github.com/lupyuen/b0e4019801aaf9860bcb234c8a9c8584">(See the output)</a></p>
<p>Thus finally we get our super-informative <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Clickable Call Graph</strong></a>‚Ä¶ That tells us how every function gets called!</p>
<p>Now we analyse the Call Graph for NuttX RTOS‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph2.jpg" alt="Call Graph for Apache NuttX Real-Time Operating System" /></p>
<p><a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><em>Clickable Call Graph for Apache NuttX RTOS</em></a></p>
<h1 id="pinephone-boots-nuttx"><a href="#pinephone-boots-nuttx">6 PinePhone Boots NuttX</a></h1>
<p><em>NuttX halts with a Memory Management Fault when it boots‚Ä¶</em></p>
<p><em>What can the Call Graph tell us about the fault?</em></p>
<p>We click and walk through the <a href="https://github.com/lupyuen/pinephone-emulator#call-graph-for-apache-nuttx-rtos"><strong>Call Graph</strong></a> to find out what went wrong, from <strong>START</strong> to <strong>HALT</strong> (pic above)‚Ä¶</p>
<ol>
<li>
<p>NuttX starts at <a href="https://lupyuen.github.io/articles/unicorn2#arm64-header"><strong>arm64_head</strong></a></p>
<p>(To prepare Arm64 Exception Levels 1 and 2)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a></p>
<p>(To start the NuttX Kernel)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a></p>
<p>(To configure the Arm64 CPU)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_mmu_init</strong></a></p>
<p>(To initialise the Arm64 Memory Management Unit)</p>
</li>
<li>
<p>Which calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>setup_page_tables</strong></a></p>
<p>(To set up the Arm64 Memory Page Tables)</p>
</li>
<li>
<p>And calls <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>enable_mmu_el1</strong></a></p>
<p>(To enable the Arm64 Memory Management Unit)</p>
</li>
<li>
<p>Which halts with an Arm64 <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>Memory Management Fault</strong></a></p>
</li>
</ol>
<p>To understand what‚Äôs really happening, we dive into each of the above functions.</p>
<p><em>How is this relevant to PinePhone?</em></p>
<p>Unicorn Emulator runs the exact same Arm64 Machine Code as <strong>NuttX for PinePhone</strong>‚Ä¶</p>
<p>Whatever happens in Unicorn Emulator‚Ä¶ Will happen in PinePhone too!</p>
<p>Hence along the way we‚Äôll learn how exactly NuttX boots on PinePhone.</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph3.jpg" alt="Arm64 Header" /></p>
<h2 id="arm64-header"><a href="#arm64-header">6.1 Arm64 Header</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_head.S#L78-L227"><strong>arm64_head</strong></a> is the first thing that runs when NuttX boots on Unicorn Emulator. (And PinePhone)</p>
<p>(It looks like a <a href="https://lupyuen.github.io/articles/uboot#linux-kernel-header"><strong>Linux Kernel Header</strong></a>, hence the name)</p>
<p>The assembly code calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#initialise-el1"><strong>arm64_boot_el1_init</strong></a> to prepare <strong>Arm64 Exception Level 1</strong></p>
<p><a href="https://lupyuen.github.io/articles/interrupt#exception-levels">(What‚Äôs an Arm64 Exception Level?)</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a> to boot the <strong>NuttX Kernel</strong></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph4.jpg" alt="Initialise EL1" /></p>
<h2 id="initialise-el1"><a href="#initialise-el1">6.2 Initialise EL1</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L132-L162"><strong>arm64_boot_el1_init</strong></a> prepares <a href="https://lupyuen.github.io/articles/interrupt#exception-levels"><strong>Arm64 Exception Level 1 (EL1)</strong></a> for booting NuttX‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L135-L140"><strong>VBAR EL1</strong></a>: Set the <strong>EL1 Vector Table</strong> in the Vector Base Address Register</p>
<p><a href="https://lupyuen.github.io/articles/interrupt#arm64-vector-table-is-wrong">(More about <strong>VBAR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L140-L147"><strong>CPACR EL1</strong></a>: Set the Architectural Feature Access Control Register </p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-03/AArch64-Registers/CPACR-EL1--Architectural-Feature-Access-Control-Register">(More about <strong>CPACR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L147-L153"><strong>SCTLR EL1</strong></a>: Set the System Control Register</p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCTLR-EL1--System-Control-Register--EL1-">(More about <strong>SCTLR EL1</strong>)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L153-L155"><strong>CNTV CVAL EL0</strong></a>: Set the Counter-Timer Virtual Timer Compare-Value Register</p>
<p><a href="https://developer.arm.com/documentation/ddi0595/2021-12/AArch64-Registers/CNTV-CVAL-EL0--Counter-timer-Virtual-Timer-CompareValue-register">(More about <strong>CNTV CVAL EL0</strong>)</a></p>
</li>
</ul>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph5.jpg" alt="Primary Routine" /></p>
<h2 id="primary-routine"><a href="#primary-routine">6.3 Primary Routine</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L179-L184"><strong>arm64_boot_primary_c_routine</strong></a> starts the NuttX Kernel. It calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L164-L177"><strong>boot_early_memset</strong></a> to fill the <a href="https://en.wikipedia.org/wiki/.bss"><strong>BSS Section</strong></a> with 0</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a> to configure the Arm64 CPU</p>
</li>
</ul>
<p>And more‚Ä¶ We‚Äôll come back to the Primary Routine in the next chapter.</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph6.jpg" alt="Boot Chip" /></p>
<h2 id="boot-chip"><a href="#boot-chip">6.4 Boot Chip</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/a64/a64_boot.c#L73-L105"><strong>arm64_chip_boot</strong></a> configures the Arm64 CPU. It calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L577-L628"><strong>arm64_mmu_init</strong></a>: To initialise the Arm64 Memory Management Unit for Exception Level 1</p>
</li>
<li>
<p>Which calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L485-L524"><strong>setup_page_tables</strong></a>: To set up the Arm64 Memory Translation Tables</p>
</li>
<li>
<p>And calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L526-L552"><strong>enable_mmu_el1</strong></a>: To enable the Arm64 Memory Management Unit and Data Cache for Exception Level 1</p>
</li>
<li>
<p>Which halts with an Arm64 <a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>Memory Management Fault</strong></a>: Invalid Arm64 Address Translation or Caching at <code>0x400C</code> <code>3FFF</code></p>
</li>
</ul>
<p><em>What caused the Arm64 Memory Management Fault?</em></p>
<p>The fault happens <strong>only in Unicorn Emulator</strong>, not on PinePhone. So it might be caused by our configuration of Unicorn Emulator.</p>
<p>We‚Äôll come back to this in a while. First we talk about the rest of the NuttX Boot Sequence‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/terminal-title.jpg" alt="NuttX Terminal on PinePhone" /></p>
<h1 id="pinephone-continues-booting-nuttx"><a href="#pinephone-continues-booting-nuttx">7 PinePhone Continues Booting NuttX</a></h1>
<p><em>Suppose we fix the Arm64 Memory Management Fault‚Ä¶</em></p>
<p><em>What will happen next?</em></p>
<p>Right now we have an Arm64 <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>Memory Management Fault</strong></a> that gets tripped inside <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a>.</p>
<p>(Only in <strong>Unicorn Emulator</strong>, not on PinePhone)</p>
<p>When we fix the fault, we expect NuttX to boot successfully to the <strong>NSH Command Prompt</strong>.</p>
<p>(Just like on PinePhone, pic above)</p>
<p><em>But what happens between arm64_chip_boot and NSH Command Prompt?</em></p>
<p>Let‚Äôs trace the <strong>NuttX Boot Sequence</strong> after <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a>, so that we understand completely how PinePhone boots to the NSH Command Prompt‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph5.jpg" alt="Primary Routine" /></p>
<h2 id="after-boot-chip"><a href="#after-boot-chip">7.1 After Boot Chip</a></h2>
<p>Earlier we saw that <a href="https://lupyuen.github.io/articles/unicorn2#boot-chip"><strong>arm64_chip_boot</strong></a> initialises the Arm64 Memory Management Unit. After that, it calls‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/boards/arm64/a64/pinephone/src/pinephone_boardinit.c#L59-L85"><strong>a64_board_initialize</strong></a>: To initialise the PinePhone ‚ÄúBoard‚Äù (for LEDs)</p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/a64/a64_serial.c#L590-L619"><strong>a64_earlyserialinit</strong></a>: To configure the PinePhone Allwinner A64 UART Port (for Console Input / Output)</p>
</li>
</ul>
<p>And returns to <a href="https://lupyuen.github.io/articles/unicorn2#primary-routine"><strong>arm64_boot_primary_c_routine</strong></a>‚Ä¶</p>
<h2 id="after-primary-routine"><a href="#after-primary-routine">7.2 After Primary Routine</a></h2>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_boot.c#L179-L184"><strong>arm64_boot_primary_c_routine</strong></a> continues to boot NuttX Kernel and calls <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_start.c#L297-L699"><strong>nx_start</strong></a>, which initialises a whole bunch of things‚Ä¶</p>
<ul>
<li>
<p>Task Control Block (Idle Task)</p>
</li>
<li>
<p>Semaphore Facility</p>
</li>
<li>
<p>Memory Manager / Extra Heap</p>
</li>
<li>
<p>Input / Output Buffering</p>
</li>
<li>
<p>Unique Process IDs / Idle Group / Tasking Data Structures</p>
</li>
<li>
<p>File System</p>
</li>
<li>
<p>Interrupt Handling Subsystem</p>
</li>
<li>
<p>POSIX Timer Facility / Signal Facility</p>
</li>
<li>
<p>Named Message Queue Facility / System V Message Queue Facility</p>
</li>
<li>
<p>Networking System / Binary Loader System</p>
</li>
<li>
<p>Arm64 Hardware <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_initialize.c#L156-L222">(<strong>up_initialize</strong>)</a></p>
</li>
<li>
<p>Common Drivers / Early Board Initialisation</p>
</li>
</ul>
<p>Then <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_start.c#L297-L699"><strong>nx_start</strong></a> runs the NuttX Tasks‚Ä¶</p>
<ul>
<li>
<p>Start the remaining CPUs</p>
</li>
<li>
<p>Create the Initial Tasks</p>
</li>
<li>
<p>Bring Up the System <a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/sched/init/nx_bringup.c#L373-L458">(<strong>nx_bringup</strong>)</a></p>
</li>
<li>
<p>Enter the Idle Loop</p>
</li>
</ul>
<p>And the <strong>NSH Command Prompt</strong> appears. We‚Äôve just completed the entire Boot Sequence for NuttX on PinePhone!</p>
<p>Let‚Äôs head back to Unicorn Emulator and fix our Arm64 Exception‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/unicorn2-callgraph7.jpg" alt="Arm64 Memory Management Fault" /></p>
<h1 id="arm64-memory-management-fault"><a href="#arm64-memory-management-fault">8 Arm64 Memory Management Fault</a></h1>
<p><em>Now that we understand how NuttX boots on PinePhone‚Ä¶</em></p>
<p><em>Can we fix the Arm64 Memory Management Fault on Unicorn?</em></p>
<p>TODO: Based on our earlier investigation with Unicorn Emulator‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/unicorn#emulator-halts-with-mmu-fault"><strong>‚ÄúEmulator Halts with MMU Fault‚Äù</strong></a></li>
</ul>
<p>TODO: the Address Translation (or Caching) has failed in our Emulated Arm64 Memory Management Unit</p>
<p>These functions are probably sus‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L485-L524"><strong>setup_page_tables</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L415-L483"><strong>init_xlat_tables</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L288-L368"><strong>set_pte_block_desc</strong></a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/0f20888a0ececc5dc7419d57a01ac508ac3ace5b/arch/arm64/src/common/arm64_mmu.c#L238-L273"><strong>calculate_pte_index</strong></a></p>
</li>
</ul>
<p>TODO: Sprinkle some Debug Logs</p>
<h1 id="automated-daily-build-and-test"><a href="#automated-daily-build-and-test">9 Automated Daily Build and Test</a></h1>
<p>TODO</p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>This has been a fun educational exercise. Now we have a way to run <strong>Automated Daily Tests</strong> for Apache NuttX RTOS on PinePhone‚Ä¶ Kudos to the <strong>Maintainers of Unicorn Emulator</strong>!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/unicorn2.md"><strong>lupyuen.github.io/src/unicorn2.md</strong></a></p>
<h1 id="appendix-parse-dwarf-debug-symbols"><a href="#appendix-parse-dwarf-debug-symbols">11 Appendix: Parse DWARF Debug Symbols</a></h1>
<p>TODO</p>
<p>To run this, we need the <a href="https://crates.io/crates/addr2line"><strong>addr2line</strong></a>, <a href="https://crates.io/crates/gimli"><strong>gimli</strong></a> and <a href="https://crates.io/crates/once_cell"><strong>once_cell</strong></a> crates: <a href="https://github.com/lupyuen/pinephone-emulator/blob/465a68a10e3fdc23c5897c3302eb0950cc4db614/Cargo.toml#L8-L12">Cargo.toml</a></p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
addr2line = &quot;0.19.0&quot;
gimli = &quot;0.27.2&quot;
once_cell = &quot;1.17.1&quot;
unicorn-engine = &quot;2.0.0&quot;
</code></pre></div>
<p>At startup, we load the <a href="https://github.com/lupyuen/pinephone-emulator/blob/main/nuttx/nuttx"><strong>NuttX ELF File</strong></a> into <strong>ELF_CONTEXT</strong> as a <a href="https://docs.rs/once_cell/latest/once_cell/"><strong>Lazy Static</strong></a>: <a href="https://github.com/lupyuen/pinephone-emulator/blob/55e4366b1876ed39b1389e8673b262082bfb7074/src/main.rs#L288-L322">main.rs</a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::rc::Rc;
<span class="kw">use </span>std::cell::RefCell;
<span class="kw">use </span>once_cell::sync::Lazy;

<span class="doccomment">/// ELF File for mapping Addresses to Function Names and Filenames
</span><span class="kw">const </span>ELF_FILENAME: <span class="kw-2">&amp;</span>str = <span class="string">&quot;nuttx/nuttx&quot;</span>;

<span class="doccomment">/// ELF Context for mapping Addresses to Function Names and Filenames
</span><span class="kw">static </span>ELF_CONTEXT: Lazy&lt;ElfContext&gt; = Lazy::new(|| {
  <span class="comment">// Open the ELF File
  </span><span class="kw">let </span>path = std::path::PathBuf::from(ELF_FILENAME);
  <span class="kw">let </span>file_data = std::fs::read(path)
    .expect(<span class="string">&quot;failed to read ELF&quot;</span>);
  <span class="kw">let </span>slice = file_data.as_slice();

  <span class="comment">// Parse the ELF File
  </span><span class="kw">let </span>obj = addr2line::object::read::File::parse(slice)
    .expect(<span class="string">&quot;failed to parse ELF&quot;</span>);
  <span class="kw">let </span>context = addr2line::Context::new(<span class="kw-2">&amp;</span>obj)
    .expect(<span class="string">&quot;failed to parse debug info&quot;</span>);

  <span class="comment">// Set the ELF Context
  </span>ElfContext {
    context: RefCell::new(context),
  }
});

<span class="doccomment">/// Wrapper for ELF Context. Needed for `Lazy`
</span><span class="kw">struct </span>ElfContext {
  context: RefCell&lt;
    addr2line::Context&lt;
      gimli::EndianReader&lt;
        gimli::RunTimeEndian, 
        Rc&lt;[u8]&gt;  <span class="comment">// Doesn&#39;t implement Send / Sync
      </span>&gt;
    &gt;
  &gt;
}

<span class="doccomment">/// Send and Sync for ELF Context. Needed for `Lazy`
</span><span class="kw">unsafe impl </span>Send <span class="kw">for </span>ElfContext {}
<span class="kw">unsafe impl </span>Sync <span class="kw">for </span>ElfContext {}</code></pre></div>

    
</body>
</html>