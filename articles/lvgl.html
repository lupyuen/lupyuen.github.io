<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Build an LVGL Touchscreen App with Zig</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Build an LVGL Touchscreen App with Zig" 
    data-rh="true">
<meta property="og:description" 
    content="Can we use Zig to build an LVGL Touchscreen App for Apache NuttX RTOS? Also wrap the LVGL API in Zig to build simpler, safer LVGL Apps? Let's find out!"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/lvgl-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Build an LVGL Touchscreen App with Zig</h1>
    <nav id="TOC"><ul>
<li><a href="#lvgl-app-in-c">1 LVGL App in C</a><ul></ul></li>
<li><a href="#zig-lvgl-app">2 Zig LVGL App</a><ul></ul></li>
<li><a href="#zig-checks-null-pointers">3 Zig Checks Null Pointers</a><ul></ul></li>
<li><a href="#import-c-functions">4 Import C Functions</a><ul></ul></li>
<li><a href="#compile-zig-app">5 Compile Zig App</a><ul></ul></li>
<li><a href="#run-zig-app">6 Run Zig App</a><ul></ul></li>
<li><a href="#simplify-lvgl-api">7 Simplify LVGL API</a><ul></ul></li>
<li><a href="#wrap-lvgl-api">8 Wrap LVGL API</a><ul>
<li><a href="#get-active-screen">8.1 Get Active Screen</a><ul></ul></li>
<li><a href="#object-struct">8.2 Object Struct</a><ul></ul></li>
<li><a href="#label-struct">8.3 Label Struct</a><ul></ul></li>
<li><a href="#after-wrapping">8.4 After Wrapping</a><ul></ul></li></ul></li>
<li><a href="#zig-vs-bit-fields">9 Zig vs Bit Fields</a><ul></ul></li>
<li><a href="#zig-outcomes">10 Zig Outcomes</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">12 Notes</a><ul></ul></li>
<li><a href="#appendix-main-function">13 Appendix: Main Function</a><ul></ul></li>
<li><a href="#appendix-compiler-options">14 Appendix: Compiler Options</a><ul></ul></li>
<li><a href="#appendix-auto-translate-lvgl-app-to-zig">15 Appendix: Auto-Translate LVGL App to Zig</a><ul></ul></li>
<li><a href="#appendix-zig-auto-translation-is-incomplete">16 Appendix: Zig Auto-Translation is Incomplete</a><ul></ul></li>
<li><a href="#appendix-zig-opaque-types">17 Appendix: Zig Opaque Types</a><ul>
<li><a href="#fix-opaque-types">17.1 Fix Opaque Types</a><ul></ul></li>
<li><a href="#input-driver">17.2 Input Driver</a><ul></ul></li>
<li><a href="#color-type">17.3 Color Type</a><ul></ul></li></ul></li>
<li><a href="#appendix-auto-generate-zig-wrapper">18 Appendix: Auto-Generate Zig Wrapper</a><ul>
<li><a href="#object-oriented-wrapper-for-lvgl">18.1 Object-Oriented Wrapper for LVGL</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>12 Jul 2022</em></p>
<p><img src="https://lupyuen.github.io/images/lvgl-title.jpg" alt="LVGL Touchscreen App on Pine64‚Äôs PineDio Stack BL604" /></p>
<p><a href="https://docs.lvgl.io/master/"><strong>LVGL</strong></a> is a popular <strong>GUI Library</strong> in C that powers the User Interfaces of many Embedded Devices. <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/cloud#modify-the-pinetime-source-code">(Like smartwatches)</a></p>
<p><a href="https://ziglang.org"><strong>Zig</strong></a> is a new-ish Programming Language that works well with C. And it comes with built-in <a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>Safety Checks</strong></a> at runtime.</p>
<p><em>Can we use Zig to code an LVGL Touchscreen Application?</em></p>
<p><em>Maybe make LVGL a little safer and friendlier‚Ä¶ By wrapping the LVGL API in Zig?</em></p>
<p><em>Or will we get blocked by something beyond our control? (Like Bit Fields in LVGL Structs)</em></p>
<p>Let‚Äôs find out! We‚Äôll do this on Pine64‚Äôs <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604</strong></a> RISC-V Board (pic above) with <a href="https://nuttx.apache.org/docs/latest"><strong>Apache NuttX RTOS</strong></a>.</p>
<p>(The steps will be similar for other platforms)</p>
<p>Join me as we dive into our <strong>LVGL Touchscreen App in Zig</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/zig-lvgl-nuttx"><strong>lupyuen/zig-lvgl-nuttx</strong></a></li>
</ul>
<p><a href="https://lupyuen.github.io/articles/lvgl#zig-outcomes">(Spoiler: Answers are Yes, Maybe, Somewhat)</a></p>
<p><img src="https://lupyuen.github.io/images/lvgl-code1a.jpg" alt="LVGL App in C" /></p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L107-L148">(Source)</a> </p>
<h1 id="lvgl-app-in-c"><a href="#lvgl-app-in-c">1 LVGL App in C</a></h1>
<p>We begin with a barebones <strong>LVGL App in C</strong> that renders a line of text‚Ä¶</p>
<ul>
<li>
<p>Fetch the <strong>Active Screen</strong> from LVGL</p>
</li>
<li>
<p>Create a <strong>Label Widget</strong></p>
</li>
<li>
<p>Set the <strong>Properties, Text and Position</strong> of the Label</p>
</li>
</ul>
<p>(Like the pic at the top of this article)</p>
<div class="example-wrap"><pre class="language-c"><code>static void create_widgets(void) {

  // Get the Active Screen
  lv_obj_t *screen = lv_scr_act();

  // Create a Label Widget
  lv_obj_t *label = lv_label_create(screen, NULL);

  // Wrap long lines in the label text
  lv_label_set_long_mode(label, LV_LABEL_LONG_BREAK);

  // Interpret color codes in the label text
  lv_label_set_recolor(label, true);

  // Center align the label text
  lv_label_set_align(label, LV_LABEL_ALIGN_CENTER);

  // Set the label text and colors
  lv_label_set_text(
    label, 
    &quot;#ff0000 HELLO# &quot;    //  Red Text
    &quot;#00aa00 PINEDIO# &quot;  //  Green Text
    &quot;#0000ff STACK!# &quot;   //  Blue Text
  );

  // Set the label width
  lv_obj_set_width(label, 200);

  // Align the label to the center of the screen, shift 30 pixels up
  lv_obj_align(label, NULL, LV_ALIGN_CENTER, 0, -30);

  // Omitted: LVGL Canvas (we&#39;ll find out why)
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L107-L148">(Source)</a> </p>
<p><a href="https://docs.lvgl.io/7.11/widgets/label.html#">(Docs for LVGL Label)</a></p>
<p>In a while we shall convert this LVGL App to Zig.</p>
<p><em>What if we‚Äôre not familiar with Zig?</em></p>
<p>The following sections assume that we‚Äôre familiar with C.</p>
<p>The parts that look Zig-ish shall be explained with examples in C.</p>
<p><a href="https://lupyuen.github.io/articles/pinephone#appendix-learning-zig">(If we‚Äôre keen to learn Zig, see this)</a></p>
<p><em>Where‚Äôs the rest of the code that initialises LVGL?</em></p>
<p>We hit some complications converting the code to Zig, more about this in a while.</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code2a.jpg" alt="Zig LVGL App" /></p>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L147">(Source)</a></p>
<h1 id="zig-lvgl-app"><a href="#zig-lvgl-app">2 Zig LVGL App</a></h1>
<p>Now the same LVGL App, but <strong>in Zig</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>fn createWidgetsUnwrapped() !void {

  // Get the Active Screen
  const screen = c.lv_scr_act().?;

  // Create a Label Widget
  const label = c.lv_label_create(screen, null).?;

  // Wrap long lines in the label text
  c.lv_label_set_long_mode(label, c.LV_LABEL_LONG_BREAK);

  // Interpret color codes in the label text
  c.lv_label_set_recolor(label, true);

  // Center align the label text
  c.lv_label_set_align(label, c.LV_LABEL_ALIGN_CENTER);

  // Set the label text and colors.
  // `++` concatenates two strings or arrays.
  c.lv_label_set_text(
    label, 
    &quot;#ff0000 HELLO# &quot;   ++  // Red Text
    &quot;#00aa00 PINEDIO# &quot; ++  // Green Text
    &quot;#0000ff STACK!# &quot;      // Blue Text
  );

  // Set the label width
  c.lv_obj_set_width(label, 200);

  // Align the label to the center of the screen, shift 30 pixels up
  c.lv_obj_align(label, null, c.LV_ALIGN_CENTER, 0, -30);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L147">(Source)</a></p>
<p>Our Zig App calls the LVGL Functions imported from C, as denoted by ‚Äú<code>c.</code><em>something</em>‚Äù.</p>
<p><em>But this looks mighty similar to C!</em></p>
<p>Yep and we see that‚Ä¶</p>
<ul>
<li>
<p>We no longer specify <strong>Type Names</strong></p>
<p>(Like <strong>lv_obj_t</strong>)</p>
</li>
<li>
<p>We write ‚Äú<strong><code>.?</code></strong>‚Äù to catch <strong>Null Pointers</strong></p>
<p>(Coming up in the next section)</p>
</li>
</ul>
<p><em>What‚Äôs ‚Äú<code>!void</code>‚Äù?</em></p>
<p>‚Äú<strong><code>!void</code></strong>‚Äù is the Return Type for our Zig Function‚Ä¶</p>
<ul>
<li>
<p>Our Zig Function doesn‚Äôt return any value</p>
<p>(Hence ‚Äú<code>void</code>‚Äù)</p>
</li>
<li>
<p>But our function might return an <a href="https://ziglang.org/documentation/master/#Errors"><strong>Error</strong></a></p>
<p>(Hence the ‚Äú<code>!</code>‚Äù)</p>
</li>
</ul>
<p>Let‚Äôs talk about Null Pointers and Runtime Safety‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code3a.jpg" alt="LVGL App: C vs Zig" /></p>
<h1 id="zig-checks-null-pointers"><a href="#zig-checks-null-pointers">3 Zig Checks Null Pointers</a></h1>
<p>Earlier we saw our Zig App calling the <strong>LVGL Functions</strong> imported from C‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Zig calls a C function
const disp_drv = c.get_disp_drv().?;
</code></pre></div>
<p>Note that we write ‚Äú<strong><code>.?</code></strong>‚Äù to catch <strong>Null Pointers</strong> returned by C Functions.</p>
<p><em>What happens if the C Function returns a Null Pointer to Zig?</em></p>
<div class="example-wrap"><pre class="language-c"><code>// Suppose this C Function...
lv_disp_drv_t *get_disp_drv(void) {
  // Returns a Null Pointer to Zig
  return NULL;
}
</code></pre></div>
<p>When we run this code, we‚Äôll see a <strong>Zig Panic</strong> and a Stack Trace‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>!ZIG PANIC!
attempt to use null value
Stack Trace:
0x23023606
</code></pre></div>
<p>Looking up address <code>23023606</code> in the <a href="https://lupyuen.github.io/articles/auto#disassemble-the-firmware"><strong>RISC-V Disassembly</strong></a> for our firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>zig-lvgl-nuttx/lvgltest.zig:50
    const disp_drv = c.get_disp_drv().?;
230235f4: 23089537 lui   a0,0x23089
230235f8: 5ac50513 addi  a0,a0,1452 # 230895ac &lt;__unnamed_10&gt;
230235fc: 4581     li    a1,0
230235fe: 00000097 auipc ra,0x0
23023602: c92080e7 jalr  -878(ra) # 23023290 &lt;panic&gt;
23023606: ff042503 lw    a0,-16(s0)
2302360a: fea42623 sw    a0,-20(s0)
</code></pre></div>
<p>We discover that <code>23023606</code> points to the line of code that caught the Null Pointer.</p>
<p>Hence Zig is super helpful for writing <strong>safer programs</strong>.</p>
<p><em>What if we omit ‚Äú<code>.?</code>‚Äù and do this?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>const disp_drv = c.get_disp_drv();
</code></pre></div>
<p>This crashes with a <strong>RISC-V Exception</strong> when our program tries to dereference the Null Pointer in a <strong>later part</strong> of the code.</p>
<p>Which isn‚Äôt as helpful as an immediate Zig Panic (upon receiving the Null Pointer).</p>
<p>Thus we always write ‚Äú<code>.?</code>‚Äù to catch Null Pointers returned by C Functions.</p>
<p>(Hopefully someday we‚Äôll have a Zig Lint Tool that will warn us if we forget to use ‚Äú<code>.?</code>‚Äù)</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code5a.jpg" alt="Import C Functions and Macros" /></p>
<h1 id="import-c-functions"><a href="#import-c-functions">4 Import C Functions</a></h1>
<p><em>How do we import the C Functions and Macros for LVGL?</em></p>
<p>This is how we <strong>import the Functions and Macros</strong> from C into Zig: <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L9-L39">lvgltest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the LVGL Library from C
const c = @cImport({
  // NuttX Defines
  @cDefine(&quot;__NuttX__&quot;,  &quot;&quot;);
  @cDefine(&quot;NDEBUG&quot;,     &quot;&quot;);
  @cDefine(&quot;ARCH_RISCV&quot;, &quot;&quot;);
  @cDefine(&quot;LV_LVGL_H_INCLUDE_SIMPLE&quot;, &quot;&quot;);

  // This is equivalent to...
  // #define __NuttX__
  // #define NDEBUG
  // #define ARCH_RISCV
  // #define LV_LVGL_H_INCLUDE_SIMPLE
</code></pre></div>
<p><a href="https://ziglang.org/documentation/master/#Import-from-C-Header-File">(<strong>@cImport</strong> is documented here)</a></p>
<p>At the top of our Zig App we set the <strong>#define Macros</strong> that will be referenced by the C Header Files coming up.</p>
<p>The settings above are specific to Apache NuttX RTOS and the BL602 RISC-V SoC. <a href="https://lupyuen.github.io/articles/lvgl#appendix-compiler-options">(Here‚Äôs why)</a></p>
<p>Next comes a workaround for a <strong>C Macro Error</strong> that appears on Zig with Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Workaround for &quot;Unable to translate macro: undefined identifier `LL`&quot;
  @cDefine(&quot;LL&quot;, &quot;&quot;);
  @cDefine(&quot;__int_c_join(a, b)&quot;, &quot;a&quot;);  //  Bypass zig/lib/include/stdint.h
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-macro-error">(More about this)</a></p>
<p>We import the <strong>C Header Files</strong> for Apache NuttX RTOS‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // NuttX Header Files. This is equivalent to...
  // #include &quot;...&quot;;
  @cInclude(&quot;arch/types.h&quot;);
  @cInclude(&quot;../../nuttx/include/limits.h&quot;);
  @cInclude(&quot;stdio.h&quot;);
  @cInclude(&quot;nuttx/config.h&quot;);
  @cInclude(&quot;sys/boardctl.h&quot;);
  @cInclude(&quot;unistd.h&quot;);
  @cInclude(&quot;stddef.h&quot;);
  @cInclude(&quot;stdlib.h&quot;);
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(More about the includes)</a></p>
<p>Followed by the C Header Files for the <strong>LVGL Library</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // LVGL Header Files
  @cInclude(&quot;lvgl/lvgl.h&quot;);

  // App Header Files
  @cInclude(&quot;fbdev.h&quot;);
  @cInclude(&quot;lcddev.h&quot;);
  @cInclude(&quot;tp.h&quot;);
  @cInclude(&quot;tp_cal.h&quot;);
});
</code></pre></div>
<p>And our <strong>Application-Specific</strong> Header Files for LCD Display and Touch Panel.</p>
<p>That‚Äôs how we import the LVGL Library into our Zig App!</p>
<p><em>Why do we write ‚Äú<code>c.</code>something‚Äù when we call C functions? Like ‚Äúc.lv_scr_act()‚Äù?</em></p>
<p>Remember that we import all C Functions and Macros into the <strong>‚Äú<code>c</code>‚Äù Namespace</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import Functions and Macros into &quot;c&quot; Namespace
const c = @cImport({ ... });
</code></pre></div>
<p>That‚Äôs why we write ‚Äú<code>c.</code><em>something</em>‚Äù when we refer to C Functions and Macros.</p>
<p><em>What about the Main Function of our Zig App?</em></p>
<p>It gets complicated. We‚Äôll talk later about the Main Function.</p>
<h1 id="compile-zig-app"><a href="#compile-zig-app">5 Compile Zig App</a></h1>
<p>Below are the steps to <strong>compile our Zig LVGL App</strong> for Apache NuttX RTOS and BL602 RISC-V SoC.</p>
<p>First we download the latest version of <strong>Zig Compiler</strong> (0.10.0 or later), extract it and add to PATH‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/download/"><strong>Zig Compiler Downloads</strong></a></li>
</ul>
<p>Then we download and compile <strong>Apache NuttX RTOS</strong> for PineDio Stack BL604‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinedio2#build-nuttx"><strong>‚ÄúBuild NuttX‚Äù</strong></a></li>
</ul>
<p>After building NuttX, we download and compile our <strong>Zig LVGL App</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Download our Zig LVGL App for NuttX
git clone --recursive https://github.com/lupyuen/zig-lvgl-nuttx
cd zig-lvgl-nuttx

##  Compile the Zig App for BL602
##  (RV32IMACF with Hardware Floating-Point)
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
zig build-obj \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -I &quot;$HOME/nuttx/apps/examples/lvgltest&quot; \
  lvgltest.zig
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/86298a99cb87b43ac568c19daeb4081a">(See the Compile Log)</a></p>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p><em>How did we get the Compiler Options <code>-isystem</code> and <code>-I</code>?</em></p>
<p>Remember that we‚Äôll link our Compiled Zig App with <strong>Apache NuttX RTOS.</strong></p>
<p>Hence the <strong>Zig Compiler Options must be the same</strong> as the GCC Options used to compile NuttX.</p>
<p><a href="https://lupyuen.github.io/articles/lvgl#appendix-compiler-options">(See the GCC Options for NuttX)</a></p>
<p>Next comes a quirk specific to BL602: We must <strong>patch the ELF Header</strong> from Software Floating-Point ABI to Hardware Floating-Point ABI‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Patch the ELF Header of `lvgltest.o` 
##  from Soft-Float ABI to Hard-Float ABI
xxd -c 1 lvgltest.o \
  | sed &#39;s/00000024: 01/00000024: 03/&#39; \
  | xxd -r -c 1 - lvgltest2.o
cp lvgltest2.o lvgltest.o
</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/zig#patch-elf-header">(More about this)</a></p>
<p>Finally we inject our <strong>Compiled Zig App</strong> into the NuttX Project Directory and link it into the <strong>NuttX Firmware</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  Copy the compiled app to NuttX and overwrite `lvgltest.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cp lvgltest.o $HOME/nuttx/apps/examples/lvgltest/lvgltest*.o

##  Build NuttX to link the Zig Object from `lvgltest.o`
##  TODO: Change &quot;$HOME/nuttx&quot; to your NuttX Project Directory
cd $HOME/nuttx/nuttx
make

##  For WSL: Copy the NuttX Firmware to c:\blflash for flashing
mkdir /mnt/c/blflash
cp nuttx.bin /mnt/c/blflash
</code></pre></div>
<p>We‚Äôre ready to run our Zig App!</p>
<p><img src="https://lupyuen.github.io/images/lvgl-title.jpg" alt="LVGL Test App" /></p>
<h1 id="run-zig-app"><a href="#run-zig-app">6 Run Zig App</a></h1>
<p>Follow these steps to <strong>flash and boot NuttX</strong> (with our Zig App inside) on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><strong>‚ÄúFlash PineDio Stack‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#boot-pinedio-stack"><strong>‚ÄúBoot PineDio Stack‚Äù</strong></a></p>
</li>
</ul>
<p>In the NuttX Shell, enter this command to start our Zig App‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>lvgltest
</code></pre></div>
<p>We should see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Zig LVGL Test
tp_init: Opening /dev/input0
cst816s_get_touch_data: DOWN: id=0, touch=0, x=176, y=23
...
tp_cal result
offset x:23, y:14
range x:189, y:162
invert x/y:1, x:0, y:1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/795d7660679c3e0288e8fe5bec190890">(See the complete log)</a></p>
<p>Our Zig App responds to touch and correctly renders the LVGL Screen (pic above).</p>
<p>Yep we have successfully built an LVGL Touchscreen App with Zig!</p>
<p>(We‚Äôll talk about Touch Input in a while)</p>
<h1 id="simplify-lvgl-api"><a href="#simplify-lvgl-api">7 Simplify LVGL API</a></h1>
<p><em>Can we make LVGL a little friendlier with Zig? Such that this code‚Ä¶</em></p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen
const screen = c.lv_scr_act().?;

// Create a Label Widget
const label = c.lv_label_create(screen, null).?;

// Wrap long lines in the label text
c.lv_label_set_long_mode(label, c.LV_LABEL_LONG_BREAK);

// Interpret color codes in the label text
c.lv_label_set_recolor(label, true);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L114-L148">(Source)</a></p>
<p><em>Becomes this?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen
var screen = try lvgl.getActiveScreen();

// Create a Label Widget
var label = try screen.createLabel();

// Wrap long lines in the label text
label.setLongMode(c.LV_LABEL_LONG_BREAK);

// Interpret color codes in the label text
label.setRecolor(true);
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L150-L183">(Source)</a></p>
<p>Yes we can! By <strong>wrapping the LVGL API</strong> in Zig, which we‚Äôll do in the next section.</p>
<p>Note that we now use ‚Äú<strong><code>try</code></strong>‚Äù instead of ‚Äú<strong><code>.?</code></strong>‚Äù to check the values returned by LVGL‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Check that Active Screen is valid with `try`
var screen = try lvgl.getActiveScreen();
</code></pre></div>
<p><em>What happens if we forget to ‚Äú<code>try</code>‚Äù?</em></p>
<p>If we don‚Äôt ‚Äú<strong><code>try</code></strong>‚Äù, like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// Get the Active Screen without `try`
var screen = lvgl.getActiveScreen();

// Attempt to use the Active Screen
_ = screen;
</code></pre></div>
<p>Zig Compiler stops us with an error‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>./lvgltest.zig:109:9:
error: error is discarded. 
consider using `try`, `catch`, or `if`
  _ = screen;
      ^
</code></pre></div>
<p>Thus ‚Äú<strong><code>try</code></strong>‚Äù is actually safer than ‚Äú<code>.?</code>‚Äù, Zig Compiler mandates that we check for errors.</p>
<p><em>What if LVGL returns a Null Pointer to Zig?</em></p>
<p>Our app will fail gracefully with an <strong>Application Error</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>lv_scr_act failed
createWidgets failed: error.UnknownError
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L85-L93">(Because of this Error Handler)</a></p>
<h1 id="wrap-lvgl-api"><a href="#wrap-lvgl-api">8 Wrap LVGL API</a></h1>
<p>Earlier we saw the hypothetical <strong>LVGL API wrapped with Zig</strong>, let‚Äôs make it real in 3 steps‚Ä¶</p>
<ul>
<li>
<p>Write a function to fetch the <strong>Active Screen</strong> from LVGL</p>
</li>
<li>
<p>Create a Zig Struct that wraps an <strong>LVGL Screen</strong></p>
</li>
<li>
<p>And another Zig Struct that wraps an <strong>LVGL Label</strong></p>
</li>
</ul>
<h2 id="get-active-screen"><a href="#get-active-screen">8.1 Get Active Screen</a></h2>
<p>Below is the implementation of <strong>getActiveScreen</strong>, which fetches the Active Screen from LVGL‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Return the Active Screen
pub fn getActiveScreen() !Object {

  // Get the Active Screen
  const screen = c.lv_scr_act();

  // If successfully fetched...
  if (screen) |s| {
    // Wrap Active Screen as Object and return it
    return Object.init(s);
  } else {
    // Unable to get Active Screen
    std.log.err(&quot;lv_scr_act failed&quot;, .{});
    return LvglError.UnknownError;
  }
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L26-L41">(Source)</a></p>
<p><em>What‚Äôs this unusual <code>if</code> expression?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
  { ... } else { ... }
</code></pre></div>
<p>That‚Äôs how we check if <strong>screen</strong> is null.</p>
<p>If <strong>screen</strong> is not null, then <strong>s</strong> becomes the non-null value of <strong>screen</strong>. And we create an <strong>Object Struct</strong> with <strong>s</strong> inside‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
  { return Object.init(s); }
  ...
</code></pre></div>
<p>But if <strong>screen</strong> is null, we do the <strong>else</strong> clause and return an Error‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>if (screen) |s| 
  { ... }
else
  { return LvglError.UnknownError; }
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L117-L119">(<strong>LvglError</strong> is defined here)</a></p>
<p>That‚Äôs why the Return Type for our function is <strong>!Object</strong></p>
<div class="example-wrap"><pre class="language-zig"><code>pub fn getActiveScreen() !Object
  { ... }
</code></pre></div>
<p>It returns either an <strong>Object Struct</strong> or an <strong>Error</strong>. (‚Äú<code>!</code>‚Äù means Error)</p>
<p>Let‚Äôs talk about the Object Struct‚Ä¶</p>
<h2 id="object-struct"><a href="#object-struct">8.2 Object Struct</a></h2>
<p><strong>Object</strong> is a Zig Struct that wraps around an LVGL Object (like the Active Screen).</p>
<p>It defines 2 Methods‚Ä¶</p>
<ul>
<li>
<p><strong>init</strong>: Initialise the LVGL Object</p>
</li>
<li>
<p><strong>createLabel</strong>: Create an LVGL Label as a child of the Object</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-zig"><code>/// LVGL Object
pub const Object = struct {

  /// Pointer to LVGL Object
  obj: *c.lv_obj_t,

  /// Init the Object
  pub fn init(obj: *c.lv_obj_t) Object {
    return .{ .obj = obj };
  }

  /// Create a Label as a child of the Object
  pub fn createLabel(self: *Object) !Label {

    // Assume we won&#39;t copy from another Object 
    const copy: ?*const c.lv_obj_t = null;

    // Create the Label
    const label = c.lv_label_create(self.obj, copy);

    // If successfully created...
    if (label) |l| {
      // Wrap as Label and return it
      return Label.init(l);
    } else {
      // Unable to create Label
      std.log.err(&quot;lv_label_create failed&quot;, .{});
      return LvglError.UnknownError;
    }
  }
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L43-L73">(Source)</a></p>
<h2 id="label-struct"><a href="#label-struct">8.3 Label Struct</a></h2>
<p>Finally we have <strong>Label</strong>, a Zig Struct that wraps around an LVGL Label.</p>
<p>It defines a whole bunch of Methods to set the <strong>Label Properties, Text and Position</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// LVGL Label
pub const Label = struct {

  /// Pointer to LVGL Label
  obj: *c.lv_obj_t,

  /// Init the Label
  pub fn init(obj: *c.lv_obj_t) Label {
    return .{ .obj = obj };
  }

  /// Set the wrapping of long lines in the label text
  pub fn setLongMode(self: *Label, long_mode: c.lv_label_long_mode_t) void {
    c.lv_label_set_long_mode(self.obj, long_mode);
  }

  /// Set the label text alignment
  pub fn setAlign(self: *Label, alignment: c.lv_label_align_t) void {
    c.lv_label_set_align(self.obj, alignment);
  }

  /// Enable or disable color codes in the label text
  pub fn setRecolor(self: *Label, en: bool) void {
    c.lv_label_set_recolor(self.obj, en);
  }

  /// Set the label text and colors
  pub fn setText(self: *Label, text: [*c]const u8) void {
    c.lv_label_set_text(self.obj, text);
  }

  /// Set the object width
  pub fn setWidth(self: *Label, w: c.lv_coord_t) void {
    c.lv_obj_set_width(self.obj, w);
  }

  /// Set the object alignment
  pub fn alignObject(self: *Label, alignment: c.lv_align_t, x_ofs: c.lv_coord_t, y_ofs: c.lv_coord_t) void {
    const base: ?*const c.lv_obj_t = null;
    c.lv_obj_align(self.obj, base, alignment, x_ofs, y_ofs);
  }
};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig#L75-L116">(Source)</a></p>
<p>Let‚Äôs call the wrapped LVGL API‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/lvgl-code4a.jpg" alt="Our app calling the LVGL API wrapped with Zig" /></p>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L150-L183">(Source)</a></p>
<h2 id="after-wrapping"><a href="#after-wrapping">8.4 After Wrapping</a></h2>
<p>With the <strong>wrapped LVGL API</strong>, our Zig App looks neater and safer‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>/// Create the LVGL Widgets that will be rendered on the display. Calls the
/// LVGL API that has been wrapped in Zig. Based on
/// https://docs.lvgl.io/7.11/widgets/label.html#label-recoloring-and-scrolling
fn createWidgetsWrapped() !void {

  // Get the Active Screen
  var screen = try lvgl.getActiveScreen();

  // Create a Label Widget
  var label = try screen.createLabel();

  // Wrap long lines in the label text
  label.setLongMode(c.LV_LABEL_LONG_BREAK);

  // Interpret color codes in the label text
  label.setRecolor(true);

  // Center align the label text
  label.setAlign(c.LV_LABEL_ALIGN_CENTER);

  // Set the label text and colors
  label.setText(
    &quot;#ff0000 HELLO# &quot; ++    // Red Text
    &quot;#00aa00 PINEDIO# &quot; ++  // Green Text
    &quot;#0000ff STACK!# &quot;      // Blue Text
  );

  // Set the label width
  label.setWidth(200);

  // Align the label to the center of the screen, shift 30 pixels up
  label.alignObject(c.LV_ALIGN_CENTER, 0, -30);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L150-L183">(Source)</a></p>
<p><a href="https://lupyuen.github.io/articles/lvgl#zig-lvgl-app">(Compare with earlier unwrapped version)</a></p>
<p>No more worries about catching <strong>Null Pointers!</strong></p>
<p>(Someday <strong>LV_LABEL_LONG_BREAK</strong> and the other constants will become Enums)</p>
<p><em>Wrapping the LVGL API in Zig sounds like a lot of work?</em></p>
<p>Yep probably. Here are some ways to <strong>Auto-Generate the Zig Wrapper</strong> for LVGL‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#appendix-auto-generate-zig-wrapper"><strong>‚ÄúAuto-Generate Zig Wrapper‚Äù</strong></a></li>
</ul>
<p>Also remember that LVGL is <strong>Object-Oriented</strong>. Designing the right wrapper with Zig might be challenging‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#object-oriented-wrapper-for-lvgl"><strong>‚ÄúObject-Oriented Wrapper for LVGL‚Äù</strong></a></li>
</ul>
<h1 id="zig-vs-bit-fields"><a href="#zig-vs-bit-fields">9 Zig vs Bit Fields</a></h1>
<p><em>Zig sounds amazing! Is there anything that Zig won‚Äôt do?</em></p>
<p>Sadly Zig won‚Äôt import <strong>C Structs containing Bit Fields</strong>.</p>
<p>Zig calls it an <a href="https://ziglang.org/documentation/master/#Translation-failures"><strong>Opaque Type</strong></a> because Zig can‚Äôt access the fields inside these structs.</p>
<p>Any struct that <strong>contains an Opaque Type</strong> also becomes an Opaque Type. So yeah this quirk snowballs quickly.</p>
<p><a href="https://github.com/ziglang/zig/issues/1499">(Zig Compiler version 0.10.0 has this Bit Field limitation, it might have been fixed in later versions of the compiler)</a></p>
<p><em>LVGL uses Bit Fields?</em></p>
<p>If we look at LVGL‚Äôs Color Type <strong>lv_color_t</strong> (for 16-bit color)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Color Type (16-bit color)
typedef union {
  struct {
    // Bit Fields for RGB Color
    uint16_t blue  : 5;
    uint16_t green : 6;
    uint16_t red   : 5;
  } ch;
  uint16_t full;
} lv_color16_t;
</code></pre></div>
<p>It uses <strong>Bit Fields</strong> to represent the RGB Colors.</p>
<p>Which means Zig can‚Äôt access the <strong>red / green / blue</strong> fields of the struct.</p>
<p>(But passing a pointer to the struct is OK)</p>
<p><em>Which LVGL Structs are affected?</em></p>
<p>So far we have identified these <strong>LVGL Structs</strong> that contain Bit Fields‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#color-type"><strong>Color</strong></a> (lv_color_t)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#appendix-zig-opaque-types"><strong>Display Buffer</strong></a> (lv_disp_buf_t)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#appendix-zig-opaque-types"><strong>Display Driver</strong></a> (lv_disp_drv_t)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#input-driver"><strong>Input Driver</strong></a> (lv_indev_drv_t)</p>
</li>
</ul>
<p><em>Is there a workaround?</em></p>
<p>Our workaround is to access the structs for Color, Display Buffer, Display Driver and Input Driver <strong>inside C Functions</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>‚ÄúFix Opaque Type‚Äù</strong></a></li>
</ul>
<p>And we pass the <strong>Struct Pointers</strong> to Zig.</p>
<p>Which explains why we see pointers to LVGL Structs in our <strong>Main Function</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#appendix-main-function"><strong>‚ÄúMain Function‚Äù</strong></a></li>
</ul>
<p>Also that‚Äôs why we handle <strong>Touch Input in C</strong> (instead of Zig), until we find a better solution.</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Input Calibration in our Zig LVGL App" /></p>
<h1 id="zig-outcomes"><a href="#zig-outcomes">10 Zig Outcomes</a></h1>
<p><em>Have we gained anything by coding our LVGL App in Zig?</em></p>
<p>The parts coded in Zig will benefit from the <strong>Safety Checks</strong> enforced by Zig at runtime: Overflow, Underflow, Array Out-of-Bounds, ‚Ä¶</p>
<ul>
<li><a href="https://ziglang.org/documentation/master/#Undefined-Behavior"><strong>‚ÄúZig Undefined Behavior‚Äù</strong></a></li>
</ul>
<p>We‚Äôve seen earlier that Zig works well at catching <strong>Null Pointers</strong> and <strong>Application Errors</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#zig-checks-null-pointers"><strong>‚ÄúZig Checks Null Pointers‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#simplify-lvgl-api"><strong>‚ÄúSimplify LVGL API‚Äù</strong></a></p>
</li>
</ul>
<p>And that it‚Äôs possible (with some effort) to create a <strong>friendlier, safer interface</strong> for LVGL‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#wrap-lvgl-api"><strong>‚ÄúWrap LVGL API‚Äù</strong></a></li>
</ul>
<p><em>What about the downsides of Zig?</em></p>
<p>Zig doesn‚Äôt validate pointers (like with a Borrow Checker) so it isn‚Äôt <strong>Memory Safe</strong> (yet)‚Ä¶</p>
<ul>
<li><a href="https://www.scattered-thoughts.net/writing/how-safe-is-zig"><strong>‚ÄúHow safe is zig?‚Äù</strong></a></li>
</ul>
<p>Zig (version 0.10.0) has a serious limitation: It won‚Äôt work with <strong>C Structs containing Bit Fields</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#zig-vs-bit-fields"><strong>‚ÄúZig vs Bit Fields‚Äù</strong></a></li>
</ul>
<p>We found a crude workaround: Handle these structs in C and pass the <strong>Struct Pointers</strong> to Zig‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>‚ÄúFix Opaque Type‚Äù</strong></a></li>
</ul>
<p>But this might become a showstopper as we work with <strong>Complex LVGL Widgets</strong>. <a href="https://lupyuen.github.io/articles/lvgl#color-type">(Like LVGL Canvas)</a></p>
<p>I‚Äôll run more experiments with LVGL on Zig and report the outcome.</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>I hope this article has inspired you to create LVGL Apps in Zig!</p>
<p>(But if you prefer to wait for Zig 1.0‚Ä¶ That‚Äôs OK too!)</p>
<p>Here are some tips for learning Zig‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinephone#appendix-learning-zig"><strong>‚ÄúLearning Zig‚Äù</strong></a></li>
</ul>
<p>Check out my earlier work on Zig, NuttX and LoRaWAN‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/zig"><strong>‚ÄúZig on RISC-V BL602: Quick Peek with Apache NuttX RTOS‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot"><strong>‚ÄúBuild an IoT App with Zig and LoRaWAN‚Äù</strong></a></p>
</li>
</ul>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Zig/comments/vwii9n/build_an_lvgl_touchscreen_app_with_zig/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/lvgl.md"><strong>lupyuen.github.io/src/lvgl.md</strong></a></p>
<h1 id="notes"><a href="#notes">12 Notes</a></h1>
<ol>
<li>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1543395925116088320"><strong>this Twitter Thread</strong></a></li>
</ol>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="Touch Input Calibration in our Zig LVGL App" /></p>
<h1 id="appendix-main-function"><a href="#appendix-main-function">13 Appendix: Main Function</a></h1>
<p>Below is our <strong>Main Function</strong> in Zig that does the following‚Ä¶</p>
<ul>
<li>
<p>Initialise the <strong>LVGL Library</strong></p>
</li>
<li>
<p>Initialise the <strong>Display Buffer, Display Driver and LCD Driver</strong></p>
</li>
<li>
<p>Register the <strong>Display Driver</strong> with LVGL</p>
</li>
<li>
<p>Initialise the <strong>Touch Panel and Input Driver</strong></p>
</li>
<li>
<p>Create the <strong>LVGL Widgets</strong> for display</p>
</li>
<li>
<p>Start the <strong>Touch Panel Calibration</strong></p>
</li>
<li>
<p>Forever handle <strong>LVGL Events</strong></p>
</li>
</ul>
<p>We begin by importing the libraries and declaring our Main Function: <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L44-L109">lvgltest.zig</a></p>
<div class="example-wrap"><pre class="language-zig"><code>/// Import the Zig Standard Library
const std = @import(&quot;std&quot;);

/// Import our Wrapped LVGL Module
const lvgl = @import(&quot;lvgl.zig&quot;);

/// Omitted: Import the LVGL Library from C
const c = @cImport({ ... });

/// Main Function that will be called by NuttX. We render an LVGL Screen and
/// handle Touch Input.
pub export fn lvgltest_main(
    _argc: c_int, 
    _argv: [*]const [*]const u8
) c_int {
  debug(&quot;Zig LVGL Test&quot;, .{});
  // Command-line args are not used
  _ = _argc;
  _ = _argv;
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgl.zig">(<strong>lvgl.zig</strong> is located here)</a></p>
<p><em>Why is argv declared as ‚Äú[*]const [*]const u8‚Äù?</em></p>
<p>That‚Äôs because‚Ä¶</p>
<ul>
<li>
<p>‚Äú<strong>[*]const u8</strong>‚Äù is a Pointer to an Unknown Number of Unsigned Bytes</p>
<p>(Like ‚Äúconst uint8_t *‚Äù in C)</p>
</li>
<li>
<p>‚Äú<strong>[*]const [*]const u8</strong>‚Äù is a Pointer to an Unknown Number of the above Pointers</p>
<p>(Like ‚Äúconst uint8_t *[]‚Äù in C)</p>
</li>
</ul>
<p><a href="https://ziglang.org/documentation/master/#Pointers">(More about Zig Pointers)</a></p>
<p><em>Why the ‚Äú<code>_ = </code>something‚Äù?</em></p>
<p>This tells the Zig Compiler that we‚Äôre <strong>not using the value</strong> of ‚Äúsomething‚Äù.</p>
<p>The Zig Compiler helpfully stops us if we forget to use a Variable (like _<strong>argc</strong>) or the Returned Value for a Function (like for <strong>lv_task_handler</strong>).</p>
<p>Next we initialise the <strong>LVGL Library</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Init LVGL Library
  c.lv_init();

  // Init Display Buffer
  const disp_buf = c.get_disp_buf().?;
  c.init_disp_buf(disp_buf);

  // Init Display Driver
  const disp_drv = c.get_disp_drv().?;
  c.init_disp_drv(disp_drv, disp_buf, monitorCallback);
</code></pre></div>
<p>Because Zig won‚Äôt work with <a href="https://lupyuen.github.io/articles/lvgl#zig-vs-bit-fields"><strong>C Structs containing Bit Fields</strong></a>, we handle them in C instead‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>get_disp_buf</strong></a>: Get Display Buffer</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>init_disp_buf</strong></a>: Init Display Buffer</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>get_disp_drv</strong></a>: Get Display Driver</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#fix-opaque-types"><strong>init_disp_drv</strong></a>: Init Display Driver</p>
</li>
</ul>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L188-L198">(<strong>monitorCallback</strong> is defined here)</a></p>
<p>We initialise the <strong>LCD Driver</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Init LCD Driver
  if (c.lcddev_init(disp_drv) != c.EXIT_SUCCESS) {

    // If failed, try Framebuffer Driver
    if (c.fbdev_init(disp_drv) != c.EXIT_SUCCESS) {

      // No possible drivers left, fail
      return c.EXIT_FAILURE;
    }
  }

  // Register Display Driver with LVGL
  _ = c.lv_disp_drv_register(disp_drv);

  // Init Touch Panel
  _ = c.tp_init();
</code></pre></div>
<p>These C Functions are specific to <strong>Apache NuttX RTOS</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lcddev.c#L244-L333"><strong>lcddev_init</strong></a>: Init LCD Driver</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/fbdev.c#L351-L469"><strong>fbdev_init</strong></a>: Init Framebuffer Driver</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L62-L99"><strong>tp_init</strong></a>: Init Touch Panel</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-zig"><code>  // Init Input Driver. tp_read will be called periodically
  // to get the touched position and state
  const indev_drv = c.get_indev_drv().?;
  c.init_indev_drv(indev_drv, c.tp_read);
</code></pre></div>
<p>Again, Zig won‚Äôt work with the <strong>Input Driver</strong> because the C Struct contains Bit Fields, so we handle it in C‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#input-driver"><strong>get_indev_drv</strong></a>: Get Input Driver</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#input-driver"><strong>init_indev_drv</strong></a>: Init Input Driver</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L100-L200"><strong>tp_read</strong></a>: Read Touch Input</p>
</li>
</ul>
<p>We create the <strong>LVGL Widgets</strong> (the wrapped or unwrapped way)‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Create the widgets for display
  createWidgetsUnwrapped()
    catch |e| {
      // In case of error, quit
      std.log.err(&quot;createWidgets failed: {}&quot;, .{e});
      return c.EXIT_FAILURE;
    };

  // To call the LVGL API that&#39;s wrapped in Zig, change
  // `createWidgetsUnwrapped` above to `createWidgetsWrapped`
</code></pre></div>
<p>We‚Äôve seen these Zig Functions earlier‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#zig-lvgl-app"><strong>createWidgetsUnwrapped</strong></a>: Create LVGL Widgets without Zig Wrapper</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#after-wrapping"><strong>createWidgetsWrapped</strong></a>: Create LVGL Widgets with Zig Wrapper</p>
</li>
</ul>
<p>We prepare the <strong>Touch Panel Calibration</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Start Touch Panel calibration
  c.tp_cal_create();
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp_cal.c#L244-L332">(<strong>tp_cal_create</strong> is defined here)</a></p>
<p>This renders (in C) the LVGL Widgets for <strong>Touch Panel Calibration</strong>, as shown in the pic above.</p>
<p><a href="https://www.youtube.com/shorts/2Nzjrlp5lcE">(Watch the calibration demo on YouTube)</a></p>
<p>(Can this be done in Zig? Needs exploration)</p>
<p>Finally we loop forever handling <strong>LVGL Events</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>  // Loop forever handing LVGL tasks
  while (true) {

    // Handle LVGL tasks
    _ = c.lv_task_handler();

    // Sleep a while
    _ = c.usleep(10000);
  }
  return 0;
}
</code></pre></div>
<p>Our Zig App includes a <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L225-L257"><strong>Custom Logger</strong></a> and <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/lvgltest.zig#L199-L225"><strong>Panic Handler</strong></a>.</p>
<p>They are explained below‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-logging"><strong>‚ÄúLogging‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-panic-handler"><strong>‚ÄúPanic Handler‚Äù</strong></a></p>
</li>
</ul>
<h1 id="appendix-compiler-options"><a href="#appendix-compiler-options">14 Appendix: Compiler Options</a></h1>
<p>For the <strong>LVGL App in C</strong>, Apache NuttX RTOS compiles it with this GCC Command‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  App Source Directory
cd $HOME/nuttx/apps/examples/lvgltest

##  Compile lvgltest.c with GCC
riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -fstack-protector-all \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv32imafc \
  -mabi=ilp32f \
  -mno-relax \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -pipe \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -DLV_LVGL_H_INCLUDE_SIMPLE \
  -Wno-format \
  -Dmain=lvgltest_main \
  -lvgltest.c \
  -o lvgltest.c.home.user.nuttx.apps.examples.lvgltest.o
</code></pre></div>
<p>(As observed from ‚Äú<code>make --trace</code>‚Äù)</p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c">(<strong>lvgltest.c</strong> is located here)</a></p>
<p>The above options for ‚Äú<strong><code>-isystem</code></strong>‚Äù and ‚Äú<strong><code>-I</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>-isystem &quot;$HOME/nuttx/nuttx/include&quot;
-I &quot;$HOME/nuttx/apps/graphics/lvgl&quot;
-I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot;
-I &quot;$HOME/nuttx/apps/include&quot;
</code></pre></div>
<p>Were passed to the <strong>Zig Compiler</strong> when compiling our Zig App‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#compile-zig-app"><strong>‚ÄúCompile Zig App‚Äù</strong></a></li>
</ul>
<p>As for the above ‚Äú<strong><code>#defines</code></strong>‚Äù‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>-D__NuttX__
-DNDEBUG
-DARCH_RISCV
-DLV_LVGL_H_INCLUDE_SIMPLE
</code></pre></div>
<p>We set them at the top of our <strong>Zig Program</strong>‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#import-c-functions"><strong>‚ÄúImport C Functions‚Äù</strong></a></li>
</ul>
<p>The GCC Options above were also passed to the Zig Compiler for Auto-Translating the LVGL App from C to Zig‚Ä¶</p>
<h1 id="appendix-auto-translate-lvgl-app-to-zig"><a href="#appendix-auto-translate-lvgl-app-to-zig">15 Appendix: Auto-Translate LVGL App to Zig</a></h1>
<p>Zig Compiler can <strong>Auto-Translate C code to Zig</strong>. <a href="https://ziglang.org/documentation/master/#C-Translation-CLI">(See this)</a></p>
<p>We used the Auto-Translation as a Reference when converting our LVGL App from C to Zig.</p>
<p>Here‚Äôs how we Auto-Translate our LVGL App <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c"><strong>lvgltest.c</strong></a> from C to Zig‚Ä¶</p>
<ul>
<li>
<p>Take the <strong>GCC Command</strong> from the previous section</p>
</li>
<li>
<p>Change ‚Äú<strong>riscv64-unknown-elf-gcc</strong>‚Äù to ‚Äú<strong>zig translate-c</strong>‚Äù</p>
</li>
<li>
<p>Add the target‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>-target riscv32-freestanding-none \
-mcpu=baseline_rv32-d \
</code></pre></div></li>
<li>
<p>Remove ‚Äú<strong>-march=rv32imafc</strong>‚Äù</p>
</li>
<li>
<p>Surround the C Flags by ‚Äú<strong>-cflags ‚Ä¶ ‚Äì</strong>‚Äù</p>
</li>
</ul>
<p>Like this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>##  App Source Directory
cd $HOME/nuttx/apps/examples/lvgltest

##  Auto-translate lvgltest.c from C to Zig
zig translate-c \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -cflags \
    -fno-common \
    -Wall \
    -Wstrict-prototypes \
    -Wshadow \
    -Wundef \
    -Os \
    -fno-strict-aliasing \
    -fomit-frame-pointer \
    -fstack-protector-all \
    -ffunction-sections \
    -fdata-sections \
    -g \
    -mabi=ilp32f \
    -mno-relax \
    -Wno-format \
  -- \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -D__NuttX__ \
  -DNDEBUG \
  -DARCH_RISCV  \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -DLV_LVGL_H_INCLUDE_SIMPLE \
  -Dmain=lvgltest_main  \
  lvgltest.c \
  &gt;lvgltest.zig
</code></pre></div>
<p>Note that <strong>target</strong> and <strong>mcpu</strong> are specific to BL602‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/zig#zig-target"><strong>‚ÄúZig Target‚Äù</strong></a></li>
</ul>
<p>Zig Compiler internally uses <strong>Clang</strong> (instead of GCC) to interpret our C code.</p>
<p>We made 2 fixes to our C code to support Clang‚Ä¶</p>
<ul>
<li>
<p>We inserted this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>#if defined(__NuttX__) &amp;&amp; defined(__clang__)  //  Workaround for NuttX with zig cc
#include &lt;arch/types.h&gt;
#include &quot;../../nuttx/include/limits.h&quot;
#define FAR
#endif  //  defined(__NuttX__) &amp;&amp; defined(__clang__)
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L25-L29">(Source)</a></p>
<p><a href="https://lupyuen.github.io/articles/iot#appendix-zig-compiler-as-drop-in-replacement-for-gcc">(Here‚Äôs why)</a></p>
</li>
<li>
<p>And changed this‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static void monitor_cb(lv_disp_drv_t * disp_drv, uint32_t time, uint32_t px)
{
#ifndef __clang__  //  Doesn&#39;t compile with zig cc
ginfo(&quot;%&quot; PRIu32 &quot; px refreshed in %&quot; PRIu32 &quot; ms\n&quot;, px, time);
#endif  //  __clang__
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L83-L98">(Source)</a></p>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/commit/1e8b0501c800209f0fa3f35f54b3742498d0e302">(See the changes)</a></p>
</li>
</ul>
<p>Here‚Äôs the original C code: <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c">lvgltest.c</a></p>
<p>And the Auto-Translation from C to Zig: <a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L5898-L5942">translated/lvgltest.zig</a></p>
<p>The Auto-Translation looks <strong>way too verbose</strong> for a Zig Program, but it‚Äôs a good start for converting our LVGL App from C to Zig.</p>
<p>We hit some issues with Opaque Types in the Auto-Translation, this is how we fixed them‚Ä¶</p>
<h1 id="appendix-zig-auto-translation-is-incomplete"><a href="#appendix-zig-auto-translation-is-incomplete">16 Appendix: Zig Auto-Translation is Incomplete</a></h1>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p>The Auto-Translation from C to Zig was initially <strong>missing 2 key functions</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>lvgltest_main</strong>: Main Function</p>
</li>
<li>
<p><strong>create_widgets</strong>: Create Widgets Function </p>
</li>
</ul>
<p>The Auto-Translated Zig code shows‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// lvgltest.c:129:13: warning: unable to translate function, demoted to extern
pub extern fn create_widgets() callconv(.C) void;
// lvgltest.c:227:17: warning: local variable has opaque type

// (no file):353:14: warning: unable to translate function, demoted to extern
pub extern fn lvgltest_main(arg_argc: c_int, arg_argv: [*c][*c]u8) c_int;
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/9e95d800f3a429c5f35970ca35cd43bd8fbd9529/translated/lvgltest.zig#L5901-L5904">(Source)</a></p>
<p>When we look up <a href="https://github.com/lupyuen/lvgltest-nuttx/blob/1e8b0501c800209f0fa3f35f54b3742498d0e302/lvgltest.c#L225-L228">lvgltest.c</a> line 227‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int lvgltest_main(int argc, FAR char *argv[]) {
  // lvgltest.c:227:17: warning: local variable has opaque type
  lv_disp_drv_t disp_drv;
  lv_disp_buf_t disp_buf;
  ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/1e8b0501c800209f0fa3f35f54b3742498d0e302/lvgltest.c#L225-L228">(Source)</a></p>
<p>We see that Zig couldn‚Äôt import the struct for LVGL Display Driver <strong>lv_disp_drv_t</strong> because it‚Äôs an Opaque Type.</p>
<p>Let‚Äôs find out why‚Ä¶</p>
<h1 id="appendix-zig-opaque-types"><a href="#appendix-zig-opaque-types">17 Appendix: Zig Opaque Types</a></h1>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p><em>What‚Äôs an Opaque Type in Zig?</em></p>
<p><strong>Opaque Types</strong> are Zig Structs with unknown, inaccessible fields.</p>
<p>When we import into Zig a <strong>C Struct that contains Bit Fields</strong>, it becomes an Opaque Type‚Ä¶</p>
<ul>
<li>
<p><a href="https://ziglang.org/documentation/master/#Translation-failures"><strong>‚ÄúTranslation Failures‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://zig.news/kristoff/extend-a-c-c-project-with-zig-55di"><strong>‚ÄúExtend a C/C++ Project with Zig‚Äù</strong></a></p>
</li>
</ul>
<p>For example, LVGL‚Äôs <strong>Color Type</strong> contains Bit Fields. It becomes an Opaque Type when we import into Zig‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Color Type (16-bit color)
typedef union {
  struct {
    // Bit Fields for RGB Color
    uint16_t blue  : 5;
    uint16_t green : 6;
    uint16_t red   : 5;
  } ch;
  uint16_t full;
} lv_color16_t;
</code></pre></div>
<p><em>What‚Äôs wrong with Opaque Types?</em></p>
<p>Zig Compiler won‚Äôt let us access the <strong>fields of an Opaque Type</strong>. But it‚Äôs OK to pass a <strong>pointer to an Opaque Type</strong>.</p>
<p>Any struct that contains a (non-pointer) Opaque Type, also becomes an Opaque Type.</p>
<p><em>How do we discover Opaque Types?</em></p>
<p>In the previous section, Zig Compiler has identified the LVGL Display Driver <strong>lv_disp_drv_t</strong> as an Opaque Type‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// warning: local variable has opaque type
lv_disp_drv_t disp_drv;
</code></pre></div>
<p>To find out why, we search for <strong>lv_disp_drv_t</strong> in the Auto-Translated Zig code‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// nuttx/apps/graphics/lvgl/lvgl/src/lv_hal/lv_hal_disp.h:154:9: 
// warning: struct demoted to opaque type - has bitfield
pub const lv_disp_drv_t = struct__disp_drv_t; 
pub const struct__disp_drv_t = opaque {};

// nuttx/apps/graphics/lvgl/lvgl/src/lv_hal/lv_hal_disp.h:59:23: 
// warning: struct demoted to opaque type - has bitfield
pub const lv_disp_t = struct__disp_t;
pub const struct__disp_t = opaque {};

pub const lv_disp_buf_t = opaque {};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/9e95d800f3a429c5f35970ca35cd43bd8fbd9529/translated/lvgltest.zig#L700-L704">(Source)</a></p>
<p>Which says that <strong>lv_disp_drv_t</strong> contains Bit Fields.</p>
<p>To verify, we look up the C definitions of <strong>lv_disp_drv_t</strong>, <strong>lv_disp_t</strong> and <strong>lv_disp_buf_t</strong> from LVGL‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Display Driver
typedef struct _disp_drv_t {
  uint32_t rotated : 1;
  uint32_t dpi     : 10;
  ...
} lv_disp_drv_t;

// LVGL Display
typedef struct _disp_t {
  uint8_t del_prev  : 1;
  uint32_t inv_p    : 10;
  ...
} lv_disp_t;

// LVGL Display Buffer
typedef struct {
  volatile uint32_t last_area : 1;
  volatile uint32_t last_part : 1;
  ...
} lv_disp_buf_t;
</code></pre></div>
<p>We‚Äôre now certain that Zig Compiler couldn‚Äôt import the structs because they indeed contain <strong>Bit Fields</strong>.</p>
<p>Let‚Äôs fix the Opaque Types, by passing them as pointers‚Ä¶</p>
<h2 id="fix-opaque-types"><a href="#fix-opaque-types">17.1 Fix Opaque Types</a></h2>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p>Earlier we saw that Zig couldn‚Äôt import these C Structs because they contain <strong>Bit Fields</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>lv_disp_drv_t</strong>: LVGL Display Driver</p>
</li>
<li>
<p><strong>lv_disp_buf_t</strong>: LVGL Display Buffer</p>
</li>
</ul>
<p>Instead of creating and accessing these structs in Zig, we <strong>do it in C instead</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Return the static instance of Display Driver, because Zig can&#39;t
// allocate structs wth bitfields inside.
lv_disp_drv_t *get_disp_drv(void) {
  static lv_disp_drv_t disp_drv;
  return &amp;disp_drv;
}

// Return the static instance of Display Buffer, because Zig can&#39;t
// allocate structs wth bitfields inside.
lv_disp_buf_t *get_disp_buf(void) {
  static lv_disp_buf_t disp_buf;
  return &amp;disp_buf;
}

// Initialise the Display Driver, because Zig can&#39;t access its fields.
void init_disp_drv(lv_disp_drv_t *disp_drv,
  lv_disp_buf_t *disp_buf,
  void (*monitor_cb)(struct _disp_drv_t *, uint32_t, uint32_t)) {
  assert(disp_drv != NULL);
  assert(disp_buf != NULL);
  assert(monitor_cb != NULL);

  lv_disp_drv_init(disp_drv);
  disp_drv-&gt;buffer = disp_buf;
  disp_drv-&gt;monitor_cb = monitor_cb;
}

// Initialise the Display Buffer, because Zig can&#39;t access the fields.
void init_disp_buf(lv_disp_buf_t *disp_buf) {
  assert(disp_buf != NULL);
  lv_disp_buf_init(disp_buf, buffer1, buffer2, DISPLAY_BUFFER_SIZE);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lcddev.c#L335-L398">(Source)</a></p>
<p>Then we modify our C Main Function to access these structs <strong>via pointers</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>int lvgltest_main(int argc, FAR char *argv[]) {
  // Fetch pointers to Display Driver and Display Buffer
  lv_disp_drv_t *disp_drv = get_disp_drv();
  lv_disp_buf_t *disp_buf = get_disp_buf();
  ...
  // Init Display Buffer and Display Driver as pointers
  init_disp_buf(disp_buf);
  init_disp_drv(disp_drv, disp_buf, monitor_cb);
  ...
  // Init Input Driver as pointer
  lv_indev_drv_t *indev_drv = get_indev_drv();
  init_indev_drv(indev_drv, tp_read);
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L214-L293">(Source)</a></p>
<p>(<strong>get_indev_drv</strong> and <strong>init_indev_drv</strong> are explained in the next section)</p>
<p>After this modification, our Auto-Translation from C to Zig now contains the 2 missing functions‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L5913-L5944"><strong>lvgltest_main</strong></a>: Main Function</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L5903-L5912"><strong>create_widgets</strong></a>: Create Widgets Function</p>
</li>
</ul>
<p>Which we used as a reference to convert our LVGL App from C to Zig.</p>
<p>That‚Äôs why our <strong>Zig Main Function</strong> passes pointers to the Display Buffer and Display Driver, instead of working directly with the structs‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#appendix-main-function"><strong>‚ÄúMain Function‚Äù</strong></a></li>
</ul>
<h2 id="input-driver"><a href="#input-driver">17.2 Input Driver</a></h2>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p>LVGL Input Driver <strong>lv_indev_drv_t</strong> is another Opaque Type because it contains Bit Fields.</p>
<p>We fix <strong>lv_indev_drv_t</strong> the same way as other Opaque Types: We allocate and initialise the structs in C (instead of Zig)‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Return the static instance of Input Driver, because Zig can&#39;t
// allocate structs wth bitfields inside.
lv_indev_drv_t *get_indev_drv(void) {
  static lv_indev_drv_t indev_drv;
  return &amp;indev_drv;
}

// Initialise the Input Driver, because Zig can&#39;t access its fields.
void init_indev_drv(lv_indev_drv_t *indev_drv,
  bool (*read_cb)(struct _lv_indev_drv_t *, lv_indev_data_t *)) {
  assert(indev_drv != NULL);
  assert(read_cb != NULL);

  lv_indev_drv_init(indev_drv);
  indev_drv-&gt;type = LV_INDEV_TYPE_POINTER;

  // This function will be called periodically (by the library) to get the
  // mouse position and state.
  indev_drv-&gt;read_cb = read_cb;
  lv_indev_drv_register(indev_drv);
}
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c#L282-L320">(Source)</a></p>
<p>These functions are called by our <strong>Zig Main Function</strong> during initialisation‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lvgl#appendix-main-function"><strong>‚ÄúMain Function‚Äù</strong></a></li>
</ul>
<h2 id="color-type"><a href="#color-type">17.3 Color Type</a></h2>
<p><a href="https://github.com/ziglang/zig/issues/1499"><em>(Note: We observed this issue with Zig Compiler version 0.10.0, it might have been fixed in later versions of the compiler)</em></a></p>
<p>We fixed all references to LVGL Color Type <strong>lv_color_t</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Canvas Demo doesn&#39;t work with zig cc because of `lv_color_t`
#if defined(CONFIG_USE_LV_CANVAS) &amp;&amp; !defined(__clang__)  

  // Set the Canvas Buffer (Warning: Might take a lot of RAM!)
  static lv_color_t cbuf[LV_CANVAS_BUF_SIZE_TRUE_COLOR(CANVAS_WIDTH, CANVAS_HEIGHT)];
  ...
</code></pre></div>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/lvgltest.c#L149-L156">(Source)</a></p>
<p>That‚Äôs because <strong>lv_color_t</strong> is another Opaque Type‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>// From Zig Auto-Translation
pub const lv_color_t = lv_color16_t;

pub const lv_color16_t = extern union {
  ch: struct_unnamed_7,
  full: u16,
};

// nuttx/apps/graphics/lvgl/lvgl/src/lv_core/../lv_draw/../lv_misc/lv_color.h:240:18:
// warning: struct demoted to opaque type - has bitfield
const struct_unnamed_7 = opaque {};
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/blob/main/translated/lvgltest.zig#L520-L537">(Source)</a></p>
<p>That contains <strong>Bit Fields</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// LVGL Color Type (16-bit color)
typedef union {
  struct {
    // Bit fields for lv_color16_t (aliased to lv_color_t)
    uint16_t blue : 5;
    uint16_t green : 6;
    uint16_t red : 5;
  } ch;
  uint16_t full;
} lv_color16_t;
</code></pre></div>
<p>Hence we can‚Äôt work directly with the LVGL Color Type in Zig. (But we can pass pointers to it)</p>
<p><em>Is that a problem?</em></p>
<p>Some LVGL Widgets need us to <strong>specify the LVGL Color</strong>. (Like for LVGL Canvas)</p>
<p>This gets tricky in Zig, since we can‚Äôt manipulate LVGL Color.</p>
<p><a href="https://docs.lvgl.io/7.11/widgets/canvas.html">(More about LVGL Canvas)</a></p>
<p><em>Why not fake the LVGL Color Type in Zig?</em></p>
<div class="example-wrap"><pre class="language-zig"><code>// Fake the LVGL Color Type in Zig
const lv_color16_t = extern union {
  ch:   u16,  // Bit Fields add up to 16 bits
  full: u16,
};
</code></pre></div>
<p>We could, but then the LVGL Types in Zig would become <strong>out of sync</strong> with the original LVGL Definitions in C.</p>
<p>This might cause problems when we upgrade the LVGL Library.</p>
<h1 id="appendix-auto-generate-zig-wrapper"><a href="#appendix-auto-generate-zig-wrapper">18 Appendix: Auto-Generate Zig Wrapper</a></h1>
<p><em>Can we auto-generate the Zig Wrapper for LVGL?</em></p>
<p>Earlier we talked about the <strong>Zig Wrapper for LVGL</strong> that will make LVGL a little safer and friendlier‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#simplify-lvgl-api"><strong>‚ÄúSimplify LVGL API‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lvgl#wrap-lvgl-api"><strong>‚ÄúWrap LVGL API‚Äù</strong></a></p>
</li>
</ul>
<p>To Auto-Generate the LVGL Wrapper, we might use <strong>Type Reflection</strong> in Zig‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/zig-bl602-nuttx/blob/main/README.md#zig-type-reflection"><strong>‚ÄúZig Type Reflection‚Äù</strong></a></li>
</ul>
<p>Or we can look up the <strong>Type Info JSON</strong> generated by Zig Compiler‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Emit IR (LLVM), BC (LLVM) and Type Info JSON
zig build-obj \
  -femit-llvm-ir \
  -femit-llvm-bc \
  -femit-analysis \
  --verbose-cimport \
  -target riscv32-freestanding-none \
  -mcpu=baseline_rv32-d \
  -isystem &quot;$HOME/nuttx/nuttx/include&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/graphics/lvgl/lvgl&quot; \
  -I &quot;$HOME/nuttx/apps/include&quot; \
  -I &quot;$HOME/nuttx/apps/examples/lvgltest&quot; \
  lvgltest.zig
</code></pre></div>
<p>This produces the <strong>IR (LLVM), BC (LLVM) and Type Info JSON</strong> files‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>lvgltest.ll
lvgltest.bc
lvgltest-analysis.json
</code></pre></div>
<p><a href="https://github.com/lupyuen/zig-lvgl-nuttx/releases/tag/v1.0.0">(See the files)</a></p>
<p>Let‚Äôs look up the Type Info for the LVGL Function <strong>lv_obj_align</strong>.</p>
<p>We search for <strong>lv_obj_align</strong> in <a href="https://github.com/lupyuen/zig-lvgl-nuttx/releases/download/v1.0.0/lvgltest-analysis.json">lvgltest-analysis.json</a></p>
<div class="example-wrap"><pre class="language-json"><code>&quot;decls&quot;:
  ...
  {
   &quot;import&quot;: 99,
   &quot;src&quot;: 1962,
   &quot;name&quot;: &quot;lv_obj_align&quot;,
   &quot;kind&quot;: &quot;const&quot;,
   &quot;type&quot;: 148,  // lv_obj_align has Type 148
   &quot;value&quot;: 60
  },
</code></pre></div>
<p>Then we look up <strong>Type 148</strong> in <a href="https://github.com/lupyuen/zig-lvgl-nuttx/releases/download/v1.0.0/lvgltest-analysis.json">lvgltest-analysis.json</a></p>
<div class="example-wrap"><pre class="language-bash"><code>$ jq &#39;.types[148]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 18,
  &quot;name&quot;: &quot;fn(?*.cimport:10:11.struct__lv_obj_t, ?*const .cimport:10:11.struct__lv_obj_t, u8, i16, i16) callconv(.C) void&quot;,
  &quot;generic&quot;: false,
  &quot;ret&quot;: 70,
  &quot;args&quot;: [
    79,  // First Para has Type 79
    194,
    95,
    134,
    134
  ]
}
</code></pre></div>
<p>The First Parameter has <strong>Type 79</strong>, so we look up <a href="https://github.com/lupyuen/zig-lvgl-nuttx/releases/download/v1.0.0/lvgltest-analysis.json">lvgltest-analysis.json</a> and follow the trail‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ jq &#39;.types[79]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 13,
  &quot;child&quot;: 120
}
## Kind 13 is `?` (Optional)

$ jq &#39;.types[120]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 6,
  &quot;elem&quot;: 137
}
## Kind 6 is `*` (Pointer)

$ jq &#39;.types[137]&#39; lvgltest-analysis.json
{
  &quot;kind&quot;: 20,
  &quot;name&quot;: &quot;.cimport:10:11.struct__lv_obj_t&quot;
}
## Kind 20 is `struct`???
</code></pre></div>
<p>Which gives us the complete type of the <strong>First Parameter</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-zig"><code>?*.cimport:10:11.struct__lv_obj_t
</code></pre></div>
<p>With this Type Info, we could generate the Zig Wrapper for all LVGL Functions.</p>
<p>We don‚Äôt have the Parameter Names though, we might need to parse the ‚Äú.cimport‚Äù file.</p>
<p><a href="https://stedolan.github.io/jq/manual/">(More about jq)</a></p>
<h2 id="object-oriented-wrapper-for-lvgl"><a href="#object-oriented-wrapper-for-lvgl">18.1 Object-Oriented Wrapper for LVGL</a></h2>
<p><em>Is LVGL really Object-Oriented?</em></p>
<p>Yep the LVGL API is actually <strong>Object-Oriented</strong> since it uses Inheritance.</p>
<p>All LVGL Widgets (Labels, Buttons, etc) have the same Base Type: <strong>lv_obj_t</strong>. </p>
<p>But some LVGL Functions will work only for <strong>specific Widgets</strong>, whereas some LVGL Functions will work on <strong>any Widget</strong>‚Ä¶</p>
<ul>
<li>
<p><strong>lv_label_set_text</strong> works only for Labels</p>
</li>
<li>
<p><strong>lv_obj_set_width</strong> works for any Widget</p>
</li>
</ul>
<p>The LVGL Docs also say that LVGL is <strong>Object-Oriented</strong>‚Ä¶</p>
<ul>
<li><a href="https://docs.lvgl.io/latest/en/html/widgets/obj.html"><strong>‚ÄúBase object lv_obj‚Äù</strong></a></li>
</ul>
<p>Designing an Object-Oriented Zig Wrapper for LVGL might be challenging‚Ä¶</p>
<p>Our Zig Wrapper needs to support <strong>setWidth</strong> (and similar methods) for <strong>all LVGL Widgets</strong>.</p>
<p>To do this we might use <strong>Zig Interfaces</strong> and <a href="https://ziglang.org/documentation/master/#fieldParentPtr"><strong>@fieldParentPtr</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://zig.news/david_vanderson/interfaces-in-zig-o1c"><strong>‚ÄúInterfaces in Zig‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://www.nmichaels.org/zig/interfaces.html"><strong>‚ÄúZig Interfaces for the Uninitiated‚Äù</strong></a></p>
</li>
</ul>
<p>Which look somewhat similar to <strong>VTables in C++</strong>‚Ä¶</p>
<ul>
<li><a href="https://pithlessly.github.io/allocgate.html"><strong>‚ÄúAllocgate is coming in Zig 0.9‚Äù</strong></a></li>
</ul>
<p><em>Are there any Object-Oriented Bindings for LVGL?</em></p>
<p>The official <strong>Python Bindings</strong> for LVGL seem to be Object-Oriented. This could inspire our Object-Oriented Wrapper in Zig‚Ä¶</p>
<ul>
<li><a href="https://github.com/lvgl/lv_binding_micropython"><strong>Python Bindings for LVGL</strong></a></li>
</ul>
<p>However the Python Bindings are <strong>Dynamically Typed</strong>, might be tricky implementing them as Static Types in Zig.</p>
<p>The LVGL Wrapper in this article was inspired by the <a href="https://github.com/zenith391/zgt"><strong>zgt GUI Library</strong></a>, which wraps the GUI APIs for GTK, Win32 and WebAssembly‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/pinephone"><strong>‚ÄúBuild a PinePhone App with Zig and zgt‚Äù</strong></a></li>
</ul>

    
</body>
</html>