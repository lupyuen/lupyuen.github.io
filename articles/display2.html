<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Star64 JH7110: Inside the Display Controller</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Star64 JH7110: Inside the Display Controller" 
    data-rh="true">
<meta property="og:description" 
    content="Let's take a walk inside the Display Controller for Pine64's Star64 JH7110 RISC-V SBC... And find out how we'll create the Display Driver for Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's take a walk inside the Display Controller for Pine64's Star64 JH7110 RISC-V SBC... And find out how we'll create the Display Driver for Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/display2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Star64 JH7110: Inside the Display Controller</h1>
    <nav id="TOC"><ul>
<li><a href="#jh7110-docs-and-source-code">1 JH7110 Docs and Source Code</a><ul></ul></li>
<li><a href="#dc8200-display-controller">2 DC8200 Display Controller</a><ul></ul></li>
<li><a href="#dc8200-driver-for-direct-rendering-manager">3 DC8200 Driver for Direct Rendering Manager</a><ul>
<li><a href="#drm-operations">3.1 DRM Operations</a><ul></ul></li>
<li><a href="#drm-sub-drivers">3.2 DRM Sub-Drivers</a><ul></ul></li>
<li><a href="#file-operations">3.3 File Operations</a><ul></ul></li></ul></li>
<li><a href="#inside-the-display-driver">4 Inside the Display Driver</a><ul></ul></li>
<li><a href="#dc8200-display-controller-driver">5 DC8200 Display Controller Driver</a><ul></ul></li>
<li><a href="#dc8200-display-hardware-driver">6 DC8200 Display Hardware Driver</a><ul></ul></li>
<li><a href="#setup-display-pipeline">7 Setup Display Pipeline</a><ul></ul></li>
<li><a href="#commit-display-pipeline">8 Commit Display Pipeline</a><ul></ul></li>
<li><a href="#update-display-plane">9 Update Display Plane</a><ul></ul></li>
<li><a href="#dc8200-framebuffer-driver">10 DC8200 Framebuffer Driver</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-jh7110-display-clock-and-reset">12 Appendix: JH7110 Display Clock and Reset</a><ul>
<li><a href="#dc_bind">12.1 dc_bind</a><ul></ul></li>
<li><a href="#dc_init">12.2 dc_init</a><ul></ul></li>
<li><a href="#vs_dc_enable">12.3 vs_dc_enable</a><ul></ul></li></ul></li>
<li><a href="#appendix-jh7110-hdmi-controller">13 Appendix: JH7110 HDMI Controller</a><ul></ul></li>
<li><a href="#appendix-jh7110-hdmi-testing">14 Appendix: JH7110 HDMI Testing</a><ul></ul></li>
<li><a href="#appendix-jh7110-lcd-panel-configuration">15 Appendix: JH7110 LCD Panel Configuration</a><ul></ul></li>
<li><a href="#appendix-dc8200-virtual-display-driver">16 Appendix: DC8200 Virtual Display Driver</a><ul></ul></li>
<li><a href="#appendix-inno-hdmi-controller-driver">17 Appendix: Inno HDMI Controller Driver</a><ul></ul></li></ul></nav><p>üìù <em>16 Aug 2023</em></p>
<p><img src="https://lupyuen.github.io/images/display2-title.jpg" alt="Display Driver for StarFive JH7110 SoC" /></p>
<p>Today we look inside the <strong>Display Controller</strong> of the <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>RISC-V StarFive JH7110 SoC</strong></a> and figure out how it works.</p>
<p><em>But the JH7110 Display Controller is NOT documented!</em></p>
<p>Indeed! The <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Official JH7110 Doc</strong></a> only points to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Linux Driver Source Code</strong></a>.</p>
<p>(Plus a smattering of <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/dom_vout_syscon.html"><strong>Display Registers</strong></a>)</p>
<p><em>Sounds a little disturbing?</em></p>
<p>Yeah goodbye olden days of <a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>Documented Display Registers</strong></a>! (Like for <a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>Allwinner A64</strong></a>)</p>
<p>But no worries! We‚Äôre here to decipher the <strong>Driver Source Code</strong> and document everything ourselves‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs inside the <strong>Direct Rendering Manager (DRM) Driver</strong> for JH7110</p>
</li>
<li>
<p>How it controls the <strong>Display Registers</strong></p>
</li>
<li>
<p>To handle the <strong>Display Pipeline</strong>, <strong>Display Planes</strong> and <strong>Framebuffers</strong></p>
</li>
<li>
<p>And how it talks to <strong>HDMI and MIPI DSI</strong> (Display Serial Interface)</p>
</li>
<li>
<p>Also how we might <strong>implement the driver</strong> ourselves (without Linux)</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>We‚Äôre building a <strong>HDMI Display Driver</strong> for <a href="https://lupyuen.github.io/articles/release"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) on the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> SBC. (Based on JH7110, just like VisionFive2)</p>
<p>Our analysis today will be super useful for creating our <strong>HDMI Driver for NuttX</strong> on Star64. (Pic below)</p>
<p>And hopefully this article will be helpful for <strong>porting other Operating Systems</strong> to JH7110!</p>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Pine64 Star64 RISC-V SBC" /></p>
<h1 id="jh7110-docs-and-source-code"><a href="#jh7110-docs-and-source-code">1 JH7110 Docs and Source Code</a></h1>
<p><em>What exactly is documented for JH7110 Display Controller?</em></p>
<p>Officially these are the <strong>JH7110 Display Controller</strong> docs‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/display_subsystem.html"><strong>Display Subsystem</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_Display/"><strong>Display Controller Developing Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_HDMI/"><strong>SDK for HDMI</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_LCD/"><strong>MIPI LCD Developing and Porting Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_GPU/"><strong>GPU Developing and Porting Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_Multimedia/"><strong>Multimedia Developing Guide</strong></a></p>
</li>
</ul>
<p>But the <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/detail_info_display.html"><strong>crucial docs are confidential</strong></a>. (Sigh)</p>
<p><em>What about the Driver Source Code?</em></p>
<p>We have the official <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Linux Drivers</strong></a> for the Display Controller‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c"><strong>vs_dc.c</strong></a>: Display Controller</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c"><strong>vs_dc_hw.c</strong></a>: Framebuffer and Overlay (similar to A64 Display Engine)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c"><strong>vs_drv.c</strong></a>: Device for Direct Rendering Manager</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c"><strong>vs_crtc.c</strong></a>: Display Pipeline (Colour / Gamma / LUT)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c"><strong>vs_plane.c</strong></a>: Display Plane</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_simple_enc.c"><strong>vs_simple_enc.c</strong></a>: <a href="https://software-dl.ti.com/processor-sdk-linux/esd/docs/06_03_00_106/linux/Foundational_Components/Kernel/Kernel_Drivers/Display/DSS.html">Display Subsystem (DSS)</a> Encoder</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_gem.c"><strong>vs_gem.c</strong></a>: <a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Graphics_Execution_Manager">Graphics Execution Manager</a> (Memory Management Framework)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c"><strong>vs_virtual.c</strong></a>: Virtual Display</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_dec.c"><strong>vs_dc_dec.c</strong></a>: Bitmap Decompression</p>
<p><a href="https://github.com/starfive-tech/linux/tree/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon">(Build Instructions)</a></p>
</li>
</ul>
<p><em>Phew so many Source Files!</em></p>
<p>Yeah but they‚Äôre super helpful for understanding the Inner Workings of our Display Controller!</p>
<p>We‚Äôll decipher the Driver Source Code in a while.</p>
<p><img src="https://lupyuen.github.io/images/display2-vout_block_diagram18.png" alt="JH7110 Display Subsystem Block Diagram" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/block_diagram_display.html"><em>JH7110 Display Subsystem Block Diagram</em></a></p>
<h1 id="dc8200-display-controller"><a href="#dc8200-display-controller">2 DC8200 Display Controller</a></h1>
<p><em>What‚Äôs this DC8200?</em></p>
<p>From the pic above, we see that JH7110 uses a <strong>VeriSilicon DC8200 Dual Display Controller</strong> to drive these displays‚Ä¶</p>
<ul>
<li>
<p><strong>MIPI DPHY / DSI</strong>: Display Serial Interface</p>
<p>(For most LCD Panels, like in PineTab-V)</p>
</li>
<li>
<p><strong>DPI</strong>: Display Parallel Interface</p>
<p>(For LCD Panels with Parallel RGB Interface)</p>
</li>
<li>
<p><strong>HDMI Video Output</strong></p>
</li>
</ul>
<p>The Display Output Ports are named <strong>DPI0 and DPI1</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/Network_on_a_chip">(NoC means <strong>Network-on-Chip</strong>)</a></p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">(AXI is the <strong>Advanced eXtensible Interface</strong>)</a></p>
<p>These are the <strong>Clock and Reset Signals</strong> for the Display Controller‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-vout_clkrst18.png" alt="JH7110 Display Subsystem Clock and Reset" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/clock_n_reset_display.html"><em>JH7110 Display Subsystem Clock and Reset</em></a></p>
<p><a href="https://lupyuen.github.io/articles/display2#appendix-jh7110-display-clock-and-reset">(Remember to <strong>Enable the Clocks</strong> and <strong>Deassert the Resets</strong>!)</a></p>
<p>The DC8200 Display Controller outputs to <strong>2 displays simultaneously</strong> (like MIPI DSI + HDMI)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-Display_Block_Diagram.png" alt="Block Diagram of DC8200 Display Controller" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/block_diagram_display.html"><em>Block Diagram of DC8200 Display Controller</em></a></p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">(AXI is the <strong>Advanced eXtensible Interface</strong>)</a></p>
<p>With support for‚Ä¶</p>
<ul>
<li>
<p><strong>Display Layers</strong>: Overlays for Cursor, Video, Graphics</p>
</li>
<li>
<p><strong>Output Control</strong>: Blending, Gamma, 3D LUT, RGB-to-YUV, Dithering</p>
</li>
</ul>
<p>We‚Äôll explain the Display Layers (Overlays) in a while.</p>
<p><em>How are the Display Outputs mapped to MIPI DSI and HDMI?</em></p>
<p>The <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/device_tree_config_display.html"><strong>Linux Device Tree</strong></a> configures the mapping of Display Outputs to the Display Devices‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Configure DC8200 Display Controller
&amp;dc8200 {

  ## Display Outputs are mapped to...
  dc_out: port {

    ## DPI0: HDMI
    dc_out_dpi0: endpoint@0 {
      reg = &lt;0&gt;;
      remote-endpoint = &lt;&amp;hdmi_input0&gt;;
    };

    ## DPI1: HDMI LCDC
    dc_out_dpi1: endpoint@1 {
      reg = &lt;1&gt;;
      remote-endpoint = &lt;&amp;hdmi_in_lcdc&gt;;
    };

    ## DPI2: MIPI DSI
    dc_out_dpi2: endpoint@2 {
      reg = &lt;2&gt;;
      remote-endpoint = &lt;&amp;mipi_in&gt;;
    };
</code></pre></div>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/device_tree_config_display.html">(Source)</a></p>
<p>Let‚Äôs dive into the Display Driver Code!</p>
<p><img src="https://lupyuen.github.io/images/jh7110-display.jpg" alt="JH7110 Linux Display Driver" /></p>
<h1 id="dc8200-driver-for-direct-rendering-manager"><a href="#dc8200-driver-for-direct-rendering-manager">3 DC8200 Driver for Direct Rendering Manager</a></h1>
<p><em>What‚Äôs this DRM?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager"><strong>Direct Rendering Manager (DRM)</strong></a> is the Linux Subsystem that talks to Display Controllers. (Like the DC8200 Display Controller in JH7110)</p>
<p>The pic above shows the <strong>DC8200 Driver for DRM</strong> (top left). It works like a fa√ßade for the other DC8200 Driver Modules. (Rest of the pic)</p>
<p>(Not to be confused with <a href="https://en.wikipedia.org/wiki/Digital_rights_management"><strong>the other DRM</strong></a>, which is also video-related)</p>
<h2 id="drm-operations"><a href="#drm-operations">3.1 DRM Operations</a></h2>
<p>The DRM Driver for DC8200 is named <strong>‚Äústarfive‚Äù</strong>. These are the <strong>DRM Operations</strong> supported by the driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L125-L143">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// DRM Driver for DC8200 Display Controller
static struct drm_driver vs_drm_driver = {
  .driver_features    = DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_GEM,
  .lastclose          = drm_fb_helper_lastclose,
  .prime_handle_to_fd = drm_gem_prime_handle_to_fd,
  .prime_fd_to_handle = drm_gem_prime_fd_to_handle,
  .gem_prime_import   = vs_gem_prime_import,
  .gem_prime_import_sg_table = vs_gem_prime_import_sg_table,
  .gem_prime_mmap     = vs_gem_prime_mmap,
  .dumb_create        = vs_gem_dumb_create,
#ifdef CONFIG_DEBUG_FS
  .debugfs_init       = vs_debugfs_init,
#endif
  .fops  = &amp;fops,
  .name  = &quot;starfive&quot;,
  .desc  = &quot;VeriSilicon DRM driver&quot;,
  .date  = &quot;20191101&quot;,
  .major = DRV_MAJOR,
  .minor = DRV_MINOR,
};
</code></pre></div>
<p>(Nothing to see here, mostly DRM Boilerplate)</p>
<p>(We‚Äôll come back to <strong>fops</strong>)</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Graphics_Execution_Manager">(<strong>Graphics Execution Manager ‚ÄúGEM‚Äù</strong> handles Memory Buffers)</a></p>
<p>TODO: vs_gem_prime_import, vs_gem_prime_import_sg_table, vs_gem_prime_mmap, vs_gem_dumb_create</p>
<p>TODO: DRV_MAJOR, DRV_MINOR</p>
<p>TODO: Pic of Sub-Drivers</p>
<h2 id="drm-sub-drivers"><a href="#drm-sub-drivers">3.2 DRM Sub-Drivers</a></h2>
<p><em>Where are the fun bits of our Display Driver?</em></p>
<p>Remember our DRM Driver is only a fa√ßade. Most of the work is done by the <strong>Sub-Drivers for DC8200</strong>: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L301-L315">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Sub-Drivers for DC8200 Display Controller
static struct platform_driver *drm_sub_drivers[] = {

  // Display Controller Driver
  &amp;dc_platform_driver,

#ifdef CONFIG_STARFIVE_INNO_HDMI
  // HDMI Controller Driver:
  // Inno HDMI 2.0 Transmitter for TSMC28HPC+
  &amp;inno_hdmi_driver,
#endif

  // Simple Encoder Driver
  &amp;simple_encoder_driver,

#ifdef CONFIG_VERISILICON_VIRTUAL_DISPLAY
  // Virtual Display Driver
  &amp;virtual_display_platform_driver,
#endif
};
</code></pre></div>
<p>We‚Äôll see the <strong>Display Controller Driver</strong> in a while.</p>
<p><em>Who starts the Sub-Drivers?</em></p>
<p>At startup, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L459-L472"><strong>vs_drm_init</strong></a> (in the DRM Driver) registers two things‚Ä¶</p>
<ul>
<li>
<p><strong>DC8200 Sub-Drivers: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L301-L315">drm_sub_drivers</a></strong></p>
</li>
<li>
<p><strong>DC8200 DRM Plaform Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L448-L457">vs_drm_platform_driver</a></strong></p>
</li>
</ul>
<p>That‚Äôs how the Sub-Drivers are started.</p>
<h2 id="file-operations"><a href="#file-operations">3.3 File Operations</a></h2>
<p><em>What‚Äôs inside fops?</em></p>
<p><strong>fops</strong> defines the <strong>File Operations</strong> supported by our DRM Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L54-L63">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// File Operations for DC8200 Display Controller
static const struct file_operations fops = {
  .owner     = THIS_MODULE,
  .open      = drm_open,
  .release   = drm_release,
  .unlocked_ioctl = drm_ioctl,
  .compat_ioctl   = drm_compat_ioctl,
  .poll      = drm_poll,
  .read      = drm_read,
  .mmap      = vs_gem_mmap,
};
</code></pre></div>
<p>(Looks fairly standard for a DRM Driver)</p>
<p>TODO: vs_gem_mmap</p>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Display Driver renders graphics to a Display Device" /></p>
<h1 id="inside-the-display-driver"><a href="#inside-the-display-driver">4 Inside the Display Driver</a></h1>
<p><em>What‚Äôs inside a typical Display Driver?</em></p>
<p><em>How does it talk to the Display Hardware?</em></p>
<p>Before we dive too deep into our Driver Code, let‚Äôs talk about <strong>Display Drivers</strong> and how they control the <strong>Display Hardware</strong>.</p>
<p>The pic above shows how a typical Display Driver will <strong>render graphics</strong> to a Display Device‚Ä¶</p>
<ul>
<li>
<p>Our Apps will write the pixels into a <strong>RAM Framebuffer</strong></p>
</li>
<li>
<p>Inside the SoC is a <strong>Display Engine</strong> that reads the Framebuffer (over DMA)</p>
</li>
<li>
<p>And pushes a continuous stream of pixels to a <strong>Display Device</strong></p>
<p>(Over HDMI or MIPI Display Serial Interface)</p>
</li>
</ul>
<p><em>What‚Äôs a Framebuffer?</em></p>
<p>A <strong>Framebuffer</strong> is just a region of RAM that stores pixels in a Colour Format. (Like ARGB 8888)</p>
<p><img src="https://lupyuen.github.io/images/de2-fb.jpg" alt="Framebuffer" /></p>
<p><strong>Multiple Framebuffers</strong> are supported. Framebuffers can be rendered as <strong>Opaque or Semi-Transparent Overlays</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de2-overlay.jpg" alt="Overlays" /></p>
<p>To do this, we configure the <strong>Display Pipeline</strong> to Blend the Framebuffers‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de2-blender.jpg" alt="Blender" /></p>
<p>Internally, the Display Driver will manipulate the <strong>Display Registers</strong> to‚Ä¶</p>
<ol>
<li>
<p>Configure the <strong>Framebuffers</strong> (and their RAM Addresses)</p>
</li>
<li>
<p>Configure the <strong>Display Pipelines</strong> (for Overlay Blending)</p>
</li>
<li>
<p>Configure the <strong>Display Output</strong> (for the Display Device)</p>
</li>
<li>
<p><strong>Commit the Display Configuration</strong> (to the Display Controller)</p>
</li>
</ol>
<p>And that‚Äôs how a typical Display Driver works in a Modern SoC!</p>
<p><a href="https://lupyuen.github.io/articles/de3">(Like for <strong>Allwinner A64</strong>)</a></p>
<p>Heading back to our scheduled programming‚Ä¶</p>
<p>TODO: Pic of Display Controller dc_bind</p>
<h1 id="dc8200-display-controller-driver"><a href="#dc8200-display-controller-driver">5 DC8200 Display Controller Driver</a></h1>
<p>The <strong>DC8200 Display Controller Driver</strong> is called by the the DC8200 DRM Driver. The driver exposes the Display Functions for‚Ä¶</p>
<ul>
<li>
<p>Initialisation of <strong>Display Controller</strong></p>
</li>
<li>
<p>Setup and Configuration of <strong>Display Pipeline</strong></p>
</li>
<li>
<p>Update of <strong>Display Plane</strong></p>
</li>
</ul>
<p>The Display Controller Driver is named <strong>‚Äúvs-dc‚Äù</strong> (for VeriSilicon Display Controller): <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1642-L1649">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>struct platform_driver dc_platform_driver = {
  .probe  = dc_probe,
  .remove = dc_remove,
  .name   = &quot;vs-dc&quot;
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1595-L1629">(<strong>dc_probe</strong> is defined here)</a></p>
<p>TODO: dc_remove</p>
<p>These are the <strong>Component Functions</strong> exposed by the Display Controller Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1584-L1587">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>const struct component_ops dc_component_ops = {
  .bind   = dc_bind,
  .unbind = dc_unbind,
};
</code></pre></div>
<p><em>What happens at startup?</em></p>
<p>At startup, the DRM Driver calls our <strong>Display Controller Driver</strong> at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1421-L1573"><strong>dc_bind</strong></a> and <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L644-L722"><strong>dc_init</strong></a> to setup the <a href="https://lupyuen.github.io/articles/display2#appendix-jh7110-display-clock-and-reset"><strong>Clock and Reset Signals</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/display2#appendix-jh7110-display-clock-and-reset">(More about <strong>dc_bind</strong> and <strong>dc_init</strong>)</a></p>
</li>
</ul>
<p>Which calls our <strong>Display Hardware Driver</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1301-L1361"><strong>dc_hw_init</strong></a> to update the <strong>Display Registers</strong></li>
</ul>
<p>As we‚Äôll see in the next section.</p>
<p><em>That‚Äôs all for our Display Controller Driver?</em></p>
<p>There‚Äôs more! We‚Äôll come back to our Display Controller Driver for handling the Display Pipeline and Display Plane.</p>
<p>TODO: Pic of dc_hw_init</p>
<h1 id="dc8200-display-hardware-driver"><a href="#dc8200-display-hardware-driver">6 DC8200 Display Hardware Driver</a></h1>
<p><em>Now we do the exciting bit?</em></p>
<p>Finally! The <strong>Display Hardware Driver</strong> is called by the Display Controller Driver (previous section) to manipulate the Display Hardware Registers and‚Ä¶</p>
<ul>
<li>
<p>Initialise the <strong>Display Controller</strong></p>
</li>
<li>
<p>Setup and Configure the <strong>Display Pipeline</strong></p>
</li>
<li>
<p>Update the <strong>Display Plane</strong></p>
</li>
</ul>
<p>(This is the driver that we‚Äôll reimplement in NuttX!)</p>
<p>Earlier we saw <a href="https://lupyuen.github.io/articles/display2#dc8200-display-controller-driver"><strong>dc_init</strong></a> (from Display Controller Driver) calling the Display Hardware Driver at startup.</p>
<p>Here‚Äôs what happens inside <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1301-L1361"><strong>dc_hw_init</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Read the <strong>Hardware Revision and Chip ID</strong></p>
</li>
<li>
<p>Initialise every <strong>Display Plane</strong> (Layer)</p>
</li>
<li>
<p>Initialise every <strong>Display Panel</strong> (Cursor)</p>
</li>
</ol>
<p><em>Why read the Hardware Revision?</em></p>
<p>Depending on the <strong>Hardware Revision</strong>, the DC8200 Display Controller works a little differently.</p>
<p>Assuming that our Display Controller is <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.h#L237-L241"><strong>DC_REV_2</strong></a> (HW_REV_5721_310)‚Ä¶</p>
<ul>
<li>
<p><strong><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1129-L1149">dc_info</a> (Display Controller Info)</strong> says that 2 Display Panels and 8 Display Planes (Layers) are supported‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Display Controller Info
static const struct vs_dc_info dc_info[] = {
  ...
  {
    // For DC_REV_2:
    .name      = &quot;DC8200&quot;,
    .panel_num = 2,
    .plane_num = 8,
    .planes    = dc_hw_planes[DC_REV_2],
    .layer_num = 6,
    .max_bpc   = 10,
    .color_formats =
      DRM_COLOR_FORMAT_RGB444 |
      DRM_COLOR_FORMAT_YCRCB444 |
      DRM_COLOR_FORMAT_YCRCB422 |
      DRM_COLOR_FORMAT_YCRCB420,
    .gamma_size   = GAMMA_EX_SIZE,
    .gamma_bits   = 12,
    .pitch_alignment = 128,
    .pipe_sync    = false,
    .mmu_prefetch = false,
    .background   = true,
    .panel_sync   = true,
    .cap_dec      = false,
  }
</code></pre></div></li>
<li>
<p><strong><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L863-L1083">dc_hw_planes</a> (Display Planes Info)</strong> defines the 8 Display Planes (Layers)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Z Pos</th><th style="text-align: left">Layer</th><th style="text-align: center">Min Size</th><th style="text-align: center">Max Size</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">Primary</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">Overlay</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">Overlay_1</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">Primary_1</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left">Overlay_2</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left">Overlay_3</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">255</td><td style="text-align: left">Cursor</td><td style="text-align: center">32 x 32</td><td style="text-align: center">64 x 64</td></tr>
<tr><td style="text-align: center">255</td><td style="text-align: left">Cursor_1</td><td style="text-align: center">32 x 32</td><td style="text-align: center">64 x 64</td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L863-L1083">(Plus a bunch of <strong>Other Properties</strong>)</a></p>
</li>
</ul>
<p><em>Why are the layers interleaved?</em></p>
<p>That‚Äôs because the Display Planes (Layers) will be rendered to <strong>2 separate displays</strong> (HDMI + MIPI DSI)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Display 0</th><th style="text-align: left">Display 1</th></tr></thead><tbody>
<tr><td style="text-align: left">Primary</td><td style="text-align: left">Primary_1</td></tr>
<tr><td style="text-align: left">Overlay</td><td style="text-align: left">Overlay_2</td></tr>
<tr><td style="text-align: left">Overlay_1</td><td style="text-align: left">Overlay_3</td></tr>
<tr><td style="text-align: left">Cursor</td><td style="text-align: left">Cursor_1</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/display2-Display_Block_Diagram.png" alt="Block Diagram of DC8200 Display Controller" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/block_diagram_display.html"><em>Block Diagram of DC8200 Display Controller</em></a></p>
<p>Our Display Hardware Driver will do other fun things! Let‚Äôs talk about the Display Pipelines and Display Planes‚Ä¶</p>
<p>TODO: Pic of Setup Display Pipeline</p>
<h1 id="setup-display-pipeline"><a href="#setup-display-pipeline">7 Setup Display Pipeline</a></h1>
<p>Earlier we talked about <a href="https://lupyuen.github.io/articles/display2#inside-the-display-driver"><strong>Display Pipelines</strong></a> and how they‚Ä¶</p>
<ul>
<li>
<p><strong>Read pixels</strong> from one or more Framebuffers over DMA</p>
</li>
<li>
<p><strong>Blend the Framebuffers</strong> / Display Planes / Layers into a single image</p>
</li>
<li>
<p><strong>Apply bitmap effects</strong> like Gamma Correction</p>
</li>
<li>
<p><strong>Push the image pixels</strong> to the Display Device (HDMI or MIPI DSI)</p>
</li>
</ul>
<p>In Linux Direct Rendering Manager (DRM), the Display Pipeline is implemented as <a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#KMS_device_model"><strong>CRTC Functions</strong></a>: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1400-L1408">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Display Pipeline Functions for DC8200 Display Controller
static const struct vs_crtc_funcs dc_crtc_funcs = {
  .enable        = vs_dc_enable,
  .disable       = vs_dc_disable,
  .mode_fixup    = vs_dc_mode_fixup,
  .set_gamma     = vs_dc_set_gamma,
  .enable_gamma  = vs_dc_enable_gamma,
  .enable_vblank = vs_dc_enable_vblank,
  .commit        = vs_dc_commit,
};
</code></pre></div>
<p><em>How do we create a Display Pipeline?</em></p>
<p>From above, we see that DRM <strong>creates the Display Pipeline</strong> by calling our Display Controller Driver at‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/display2#vs_dc_enable"><strong>vs_dc_enable</strong></a>, to prepare the Clock and Reset Signals</li>
</ul>
<p>Which calls‚Ä¶</p>
<ul>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1480-L1487"><strong>dc_hw_setup_display</strong></a>, from our Display Hardware Driver</li>
</ul>
<p><em>What‚Äôs inside dc_hw_setup_display?</em></p>
<p>In our Display Hardware Driver, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1480-L1487"><strong>dc_hw_setup_display</strong></a> will‚Ä¶</p>
<ol>
<li>Copy the <strong>Display Struct</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1971-L2030"><strong>setup_display_ex</strong></a></li>
</ol>
<p>Then <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1971-L2030"><strong>setup_display_ex</strong></a> will‚Ä¶</p>
<ol>
<li>Set the <strong>Colour Format</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1865-L1969"><strong>setup_display</strong></a></li>
</ol>
<p>Finally <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1865-L1969"><strong>setup_display</strong></a> will do most of the work‚Ä¶</p>
<ol>
<li>Set the <strong>DPI Config</strong></li>
<li>Disable the <strong>Display Panel</strong></li>
<li>Set the <strong>Horizontal Resolution and Sync</strong></li>
<li>Set the <strong>Vertical Resolution and Sync</strong></li>
<li>Configure the <strong>Framebuffer Sync Mode</strong></li>
<li>Set the <strong>Framebuffer Background Colour</strong></li>
<li>Set the <strong>Display Dither</strong></li>
<li>Enable the <strong>Display Panel</strong></li>
<li>Set the <strong>Overlay Configuration</strong></li>
<li>Set the <strong>Cursor Configuration</strong></li>
</ol>
<p><em>Who creates the Display Pipeline?</em></p>
<p>To create the Display Pipeline, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L740-L826"><strong>vs_dc_enable</strong></a> (from above) is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L265-L276"><strong>vs_crtc_atomic_enable</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// DC8200 Display Pipeline Helper Functions
static const struct drm_crtc_helper_funcs vs_crtc_helper_funcs = {
  .mode_fixup     = vs_crtc_mode_fixup,
  .atomic_enable  = vs_crtc_atomic_enable,
  .atomic_disable = vs_crtc_atomic_disable,
  .atomic_begin   = vs_crtc_atomic_begin,
  .atomic_flush   = vs_crtc_atomic_flush,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L338-L344">(Source)</a></p>
<p>Which is called by the Linux <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L1323-L1408"><strong>DRM Atomic Helper</strong></a>.</p>
<p>(We‚Äôll see <strong>vs_crtc_atomic_flush</strong> in the next section)</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Atomic_Display">(More about <strong>Atomic Display</strong>)</a></p>
<p>And that‚Äôs how we create a Display Pipeline! Now we commit the Display Pipeline‚Ä¶</p>
<p>TODO: Pic of Commit Display Pipeline</p>
<h1 id="commit-display-pipeline"><a href="#commit-display-pipeline">8 Commit Display Pipeline</a></h1>
<p><em>Why will we Commit a Display Pipeline?</em></p>
<p>A Display Pipeline won‚Äôt render any pixels‚Ä¶ Until we <strong>Commit the Display Pipeline</strong>!</p>
<p>To Commit the Display Pipeline, the Linux Direct Rendering Manager (DRM) calls our Display Controller Driver at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1381-L1398"><strong>vs_dc_commit</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L2038-L2076"><strong>dc_hw_commit</strong></a>, from our Display Hardware Driver</p>
</li>
</ul>
<p><em>What‚Äôs inside dc_hw_commit?</em></p>
<p>In our Display Hardware Driver, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L2038-L2076"><strong>dc_hw_commit</strong></a> will‚Ä¶</p>
<ol>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1548-L1574"><strong>gamma_ex_commit</strong></a> to commit the Gamma Correction</li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1768-L1863"><strong>plane_ex_commit</strong></a> commit the Display Plane</li>
<li>Update the <strong>Cursor and QoS</strong></li>
</ol>
<p><em>What happens in plane_ex_commit?</em></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1768-L1863"><strong>plane_ex_commit</strong></a> will‚Ä¶</p>
<ol>
<li>Set the <strong>Colour Space</strong></li>
<li>Set the <strong>Gamma Correction</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1576-L1766"><strong>plane_commit</strong></a></li>
</ol>
<p>Then <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1576-L1766"><strong>plane_commit</strong></a> will do this for every <strong>Display Plane</strong> (Layer)‚Ä¶</p>
<ol>
<li>Set the <strong>Framebuffer YUV Address and Stride</strong></li>
<li>Set the <strong>Framebuffer Width and Height</strong></li>
<li><strong>Clear the Framebuffer</strong></li>
<li>Configure the <strong>Primary and Non-Primary Framebuffers</strong></li>
<li>Enable <strong>Framebuffer Scaling</strong> (X and Y)</li>
<li>Set the <strong>Framebuffer Offset</strong> (X and Y)</li>
<li>Set the <strong>Framebuffer Blending</strong></li>
<li>Set the <strong>Colour Key</strong> (Transparency)</li>
<li>Set the <strong>ROI</strong></li>
</ol>
<p><em>Who Commits the Display Pipeline?</em></p>
<p>To Commit the Display Pipeline, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1381-L1398"><strong>vs_dc_commit</strong></a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L320-L336"><strong>vs_crtc_atomic_flush</strong></a>‚Ä¶</p>
<p>Which is called by the Linux <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L2445-L2570"><strong>DRM Atomic Helper</strong></a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Atomic_Display">(More about <strong>Atomic Display</strong>)</a></p>
<p>TODO: Pic of Update Display Plane</p>
<h1 id="update-display-plane"><a href="#update-display-plane">9 Update Display Plane</a></h1>
<p>One last thing for today: How to <strong>Update the Display Plane</strong>.</p>
<p>(Remember a Display Plane is a <strong>Layer of Pixels</strong> that will be blended into the final image by a Display Pipeline)</p>
<p>Our Display Controller Driver exposes these <strong>Display Plane Functions</strong>: 
<a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1410-L1414">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct vs_plane_funcs dc_plane_funcs = {
  .update  = vs_dc_update_plane,
  .disable = vs_dc_disable_plane,
  .check   = vs_dc_check_plane,
};
</code></pre></div>
<p>To update the Display Plane, the Linux Direct Rendering Manager (DRM) calls our Display Controller Driver at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1262-L1280"><strong>vs_dc_update_plane</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1153-L1196"><strong>update_plane</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1368-L1399"><strong>dc_hw_update_plane</strong></a></p>
</li>
</ul>
<p>TODO: <strong>vs_dc_update_plane</strong> calls update_qos and update_cursor_plane</p>
<p>TODO: update_plane calls update_fb, update_roi, update_scale, update_degamma</p>
<p>Set Start and End Position</p>
<p>Set Blending Alpha and Mode</p>
<p>update_color_mgmt</p>
<p>dc_hw_update_plane</p>
<p>TODO: Display Hardware</p>
<p>Update Display Plane: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1368-L1399">dc_hw_update_plane</a></p>
<ul>
<li>Copy Framebuffer</li>
<li>Copy Scale</li>
<li>Copy Position</li>
<li>Copy Blend</li>
</ul>
<p><em>Who calls our driver to update the Display Plane?</em></p>
<p>TODO</p>
<p>Update Display Plane <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1262-L1280">vs_dc_update_plane</a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c#L268-L301">vs_plane_atomic_update</a></p>
<p>Which is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L2445-L2570">drm_atomic_helper</a></p>
<div class="example-wrap"><pre class="language-c"><code>const struct drm_plane_helper_funcs vs_plane_helper_funcs = {
  .atomic_check   = vs_plane_atomic_check,
  .atomic_update  = vs_plane_atomic_update,
  .atomic_disable = vs_plane_atomic_disable,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c#L314-L318">(Source)</a></p>
<h1 id="dc8200-framebuffer-driver"><a href="#dc8200-framebuffer-driver">10 DC8200 Framebuffer Driver</a></h1>
<p>TODO</p>
<p>At startup, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L193-L271">vs_drm_bind</a> calls <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L178-L191">vs_mode_config_init</a> to register the Framebuffer Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L166-L172">vs_mode_config_funcs</a>.</p>
<p>Which is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_mode_config_funcs vs_mode_config_funcs = {
  .fb_create       = vs_fb_create,
  .get_format_info = vs_get_format_info,
  .output_poll_changed = drm_fb_helper_output_poll_changed,
  .atomic_check    = drm_atomic_helper_check,
  .atomic_commit   = drm_atomic_helper_commit,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L166-L172">(Source)</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L60-L123">vs_fb_create</a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_framebuffer.c#L286-L329">drm_framebuffer</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L155-L164">vs_get_format_info</a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_fourcc.c#L302-L325">drm_fourcc</a></p>
<p>Framebuffer Formats: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L134-L139">vs_formats</a></p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Prototype new driver in Zig</p>
<p>Slightly annoying that New Zig won‚Äôt run on my Old Mac</p>
<p><a href="https://fosstodon.org/@Fishwaldo/110902984442385966">Fishwaldo suggests uboot</a></p>
<p><a href="https://fosstodon.org/@Fishwaldo/110902984462760802">the panel is not a Jadard panel, whoever wrote the factory image just hacked a existing driver. The panel in PtV (and PT2) is a BOE TH101MB31IG002-28A</a></p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Other Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/display2.md"><strong>lupyuen.github.io/src/display2.md</strong></a></p>
<p><img src="https://lupyuen.github.io/images/display2-vout_clkrst18.png" alt="JH7110 Display Subsystem Clock and Reset" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/clock_n_reset_display.html"><em>JH7110 Display Subsystem Clock and Reset</em></a></p>
<h1 id="appendix-jh7110-display-clock-and-reset"><a href="#appendix-jh7110-display-clock-and-reset">12 Appendix: JH7110 Display Clock and Reset</a></h1>
<p>TODO</p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/dom_vout_crg.html">DOM VOUT CRG</a></p>
<h2 id="dc_bind"><a href="#dc_bind">12.1 dc_bind</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1421-L1573"><strong>dc_bind</strong></a></p>
<ul>
<li>
<p>dc_init</p>
</li>
<li>
<p>vs_drm_iommu_attach_device: </p>
<p>Attach I/O MMU Device</p>
</li>
<li>
<p>For Each Panel: vs_crtc_create: </p>
<p>Create Display Pipeline</p>
</li>
<li>
<p>For Each Plane: vs_plane_create: </p>
<p>Create Display Plane</p>
</li>
<li>
<p>vs_drm_update_pitch_alignment: </p>
<p>Update Pitch Alignment</p>
</li>
<li>
<p>clk_disable_unprepare(vout_top_lcd): </p>
<p>Disable Clock vout_top_lcd (clk_dom_vout_top_lcd_clk?)</p>
</li>
<li>
<p>dc8200 asrt: vs_dc8200_reset_assert: </p>
<p>Assert DC8200 Reset</p>
</li>
<li>
<p>dc8200 clk disable: vs_dc_dc8200_clock_disable: </p>
<p>Disable DC8200 Clock</p>
</li>
<li>
<p>vouttop clk disable: vs_dc_vouttop_clock_disable: </p>
<p>Disable Clock vouttop</p>
</li>
<li>
<p>vout clk disable: vs_dc_clock_disable: </p>
<p>Disable DC Clock vout</p>
</li>
</ul>
<h2 id="dc_init"><a href="#dc_init">12.2 dc_init</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L644-L722"><strong>dc_init</strong></a></p>
<ul>
<li>
<p>dc_vout_clk_enable: </p>
<p>Enable Clock dc_vout_clk</p>
</li>
<li>
<p>vs_dc8200_reset_deassert: </p>
<p>Deassert DC8200 Reset</p>
</li>
<li>
<p>clk_prepare_enable(vout_top_lcd): </p>
<p>Enable Clock vout_top_lcd</p>
</li>
<li>
<p>vs_vout_reset_deassert: </p>
<p>Deassert vout_reset</p>
</li>
<li>
<p>mystery code:</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_DRM_I2C_NXP_TDA998X//tda998x-rgb2hdmi
  regmap_update_bits(dc-&gt;dss_regmap, 0x4, BIT(20), 1&lt;&lt;20);
#endif

#ifdef CONFIG_STARFIVE_DSI
  regmap_update_bits(dc-&gt;dss_regmap, 0x8, BIT(3), 1&lt;&lt;3);
#endif
</code></pre></div></li>
<li>
<p>dc_hw_init</p>
</li>
</ul>
<h2 id="vs_dc_enable"><a href="#vs_dc_enable">12.3 vs_dc_enable</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L740-L826">vs_dc_enable</a> (from Display Controller Driver)</p>
<ul>
<li>
<p>dc_vout_clk_enable</p>
</li>
<li>
<p>vs_dc8200_reset_deassert</p>
</li>
<li>
<p>clk_prepare_enable(dc-&gt;vout_top_lcd);</p>
</li>
<li>
<p>regmap_update_bits(dc-&gt;dss_regmap, 0x4, BIT(20), 1&lt;&lt;20);</p>
</li>
<li>
<p>regmap_update_bits(dc-&gt;dss_regmap, 0x8, BIT(3), 1&lt;&lt;3);</p>
</li>
<li>
<p>dc_hw_init</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-c"><code>	display.bus_format = crtc_state-&gt;output_fmt;
	display.h_active = mode-&gt;hdisplay;
	display.h_total = mode-&gt;htotal;
	display.h_sync_start = mode-&gt;hsync_start;
	display.h_sync_end = mode-&gt;hsync_end;
	if (mode-&gt;flags &amp; DRM_MODE_FLAG_PHSYNC)
		display.h_sync_polarity = true;
	else
		display.h_sync_polarity = false;

	display.v_active = mode-&gt;vdisplay;
	display.v_total = mode-&gt;vtotal;

	if (crtc_state-&gt;encoder_type == DRM_MODE_ENCODER_DSI){
		display.v_sync_start = mode-&gt;vsync_start + 1;
		display.v_sync_end = mode-&gt;vsync_end - 1;
	}else{
		display.v_sync_start = mode-&gt;vsync_start;
		display.v_sync_end = mode-&gt;vsync_end;
	}

	if (mode-&gt;flags &amp; DRM_MODE_FLAG_PVSYNC)
		display.v_sync_polarity = true;
	else
		display.v_sync_polarity = false;

	display.sync_mode = crtc_state-&gt;sync_mode;
	display.bg_color = crtc_state-&gt;bg_color;

	display.id = to_vs_display_id(dc, crtc);
	display.sync_enable = crtc_state-&gt;sync_enable;
	display.dither_enable = crtc_state-&gt;dither_enable;
</code></pre></div><div class="example-wrap"><pre class="language-c"><code>	if(display.id == 1)
	{
    // MIPI DSI
		clk_set_rate(dc-&gt;dc8200_pix0, mode-&gt;clock * 1000);
		clk_set_parent(dc-&gt;dc8200_clk_pix1, dc-&gt;dc8200_pix0);
		clk_set_parent(dc-&gt;vout_top_lcd, dc-&gt;dc8200_clk_pix1_out);
	}else{
    // HDMI
		clk_set_parent(dc-&gt;dc8200_clk_pix0, dc-&gt;hdmitx0_pixelclk);
	}
</code></pre></div>
<ul>
<li>dc_hw_setup_display</li>
</ul>
<h1 id="appendix-jh7110-hdmi-controller"><a href="#appendix-jh7110-hdmi-controller">13 Appendix: JH7110 HDMI Controller</a></h1>
<p>TODO</p>
<p>The HDMI Controller for JH7110 is <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/detail_info_display.html">Inno HDMI 2.0 Transmitter For TSMC28HPC+</a>.</p>
<p>HDMI I2C Encoder in JH7110 is the <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/kernel_menu_config_diplay.html">NXP Semiconductors TDA998X HDMI Encoder</a></p>
<p>Based on <a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/source_code_structure_hdmi.html">JH7110 HDMI Developing Guide</a>, the Linux Drivers for JH7110 HDMI (VeriSilicon Inno HDMI) are‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/inno_hdmi.c">inno_hdmi.c</a></p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/inno_hdmi.h">inno_hdmi.h</a></p>
</li>
</ul>
<p>The <a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/device_tree_hdmi.html">Linux Device Tree</a> looks like‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>hdmi: hdmi@29590000 {
    compatible = &quot;starfive,jh7100-hdmi&quot;,&quot;inno,hdmi&quot;;
      reg = &lt;0x0 0x29590000 0x0 0x4000&gt;;
      interrupts = &lt;99&gt;;
      status = &quot;disabled&quot;;
      clocks = &lt;&amp;clkvout JH7110_U0_HDMI_TX_CLK_SYS&gt;,
        &lt;&amp;clkvout JH7110_U0_HDMI_TX_CLK_MCLK&gt;,
        &lt;&amp;clkvout JH7110_U0_HDMI_TX_CLK_BCLK&gt;,
        &lt;&amp;hdmitx0_pixelclk&gt;;
      clock-names = &quot;sysclk&quot;, &quot;mclk&quot;,&quot;bclk&quot;,&quot;pclk&quot;;
      resets = &lt;&amp;rstgen RSTN_U0_HDMI_TX_HDMI&gt;;
      reset-names = &quot;hdmi_tx&quot;;
    };
...
&amp;hdmi {
  status = &quot;okay&quot;;
  pinctrl-names = &quot;default&quot;;
  pinctrl-0 = &lt;&amp;inno_hdmi_pins&gt;;

  hdmi_in: port {
    #address-cells = &lt;1&gt;;
    #size-cells = &lt;0&gt;;
    hdmi_in_lcdc: endpoint@0 {
      reg = &lt;0&gt;;
      remote-endpoint = &lt;&amp;dc_out_dpi1&gt;;
    };
  };
};
</code></pre></div>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/device_tree_hdmi.html">(Source)</a></p>
<p>We see the <a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/initialization_process.html">HDMI Initialization Process</a>‚Ä¶</p>
<p><img src="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/Image/JH7110_SDK/HDMI_Init.svg" alt="HDMI Initialization Process" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/initialization_process.html">(Source)</a></p>
<p>And the <a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/plug_n_unplug_process.html">HDMI Plug and Unplug Process</a>‚Ä¶</p>
<p><img src="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/Image/JH7110_SDK/HDMI_Pug_Unplug.svg" alt="HDMI Plug and Unplug Process" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_HDMI/JH7110_SDK/plug_n_unplug_process.html">(Source)</a></p>
<h1 id="appendix-jh7110-hdmi-testing"><a href="#appendix-jh7110-hdmi-testing">14 Appendix: JH7110 HDMI Testing</a></h1>
<p>TODO</p>
<p><em>How will we test the HDMI Display for Star64 JH7110?</em></p>
<p>We run the <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/test_example_display.html"><code>modetest</code> command to test HDMI</a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>modetest \
  -M starfive \
  -D 0 \
  -a \
  -s 116@31:1920x1080 \
  -P 39@31:1920x1080@RG16 \
  -Ftiles 
</code></pre></div>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/test_example_display.html">(Source)</a></p>
<p><code>116@31:1920x1080</code> means <code>&lt;Connector ID&gt;@&lt;CRTC ID&gt;: &lt;Resolution&gt;</code></p>
<p><code>39@31:1920x1080@RG16</code> means <code>&lt;Plane ID&gt;@&lt;CRTC ID&gt;: &lt;Resolution&gt;@&lt;Format&gt;</code></p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#KMS_device_model">(CRTC ‚ÄúCRT Controller‚Äù refers to the Display Pipeline)</a></p>
<p>See also‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/before_debug.html">Before Debug</a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/debug_hdmi.html">Debug Display</a></p>
</li>
</ul>
<p>TODO: What‚Äôs inside the modetest app? <a href="https://gitlab.freedesktop.org/mesa/drm/-/blob/main/tests/modetest/modetest.c">modetest.c</a></p>
<p>TODO: What parameters does modetest pass to the DC8200 Driver?</p>
<p>TODO: Can we create a simpler modetest for our own testing on NuttX?</p>
<h1 id="appendix-jh7110-lcd-panel-configuration"><a href="#appendix-jh7110-lcd-panel-configuration">15 Appendix: JH7110 LCD Panel Configuration</a></h1>
<p>TODO</p>
<p>Also in the JH7110 Display Docs: How to connect an LCD Panel to JH7110.</p>
<p>JH7110‚Äôs MIPI DSI Controller is <a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/ic_specification_lcd.html">Cadence MIPI DSI v1.3.1 TX Controller IP (DSITX)</a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-ic_spec.png" alt="Cadence MIPI DSI v1.3.1 TX Controller IP (DSITX)" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/ic_specification_lcd.html">(Source)</a></p>
<p>JH7110‚Äôs MIPI DPHY Controller is <a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/ic_specification_lcd.html">MIPI DPHY M31 (M31DPHYRX611TL028D_00151501)</a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-MIPI_DPHY_M31.png" alt="MIPI DPHY M31 (M31DPHYRX611TL028D_00151501)" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/ic_specification_lcd.html">(Source)</a></p>
<p>Refer to the‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/display_driver_locations_lcd.html">Linux Display Driver</a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/device_tree_configuration_lcd.html">Linux Device Tree</a></p>
</li>
</ul>
<p>See also the Sample LCD Panel Code for Seeed LCD Panel‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/enable_lcd.html">Enable LCD</a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/disable_lcd.html">Disable LCD</a></p>
</li>
<li>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/obtain_lcd_information.html">Obtain LCD Information</a></p>
</li>
</ul>
<p>Here‚Äôs the <a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/initalization_lcd.html">LCD Initialisation Process</a></p>
<p><img src="https://doc-en.rvspace.org/VisionFive2/DG_LCD/Image/JH7110_SDK/LCD_Init.svg" alt="LCD Initialisation Process" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/initalization_lcd.html">(Source)</a></p>
<p>And the <a href="https://doc-en.rvspace.org/VisionFive2/DG_LCD/JH7110_SDK/mipi_configuration.html">MIPI Parameter Configuration</a> for 1C2L (2-lane MIPI DSI) and 1C4L (4-lane MIPI DSI).</p>
<h1 id="appendix-dc8200-virtual-display-driver"><a href="#appendix-dc8200-virtual-display-driver">16 Appendix: DC8200 Virtual Display Driver</a></h1>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_connector_helper_funcs vd_connector_helper_funcs = {
  .get_modes    = vd_get_modes,
  .mode_valid   = vd_mode_valid,
  .best_encoder = vd_best_encoder,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c#L197-L201">(Source)</a></p>
<p>Display Resolutions: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c#L153-L181">vd_get_modes</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_connector_funcs vd_connector_funcs = {
  .fill_modes = drm_helper_probe_single_connector_modes,
  .destroy    = vd_connector_destroy,
  .detect     = vd_connector_detect,
  .atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
  .atomic_destroy_state   = drm_atomic_helper_connector_destroy_state,
  .reset = drm_atomic_helper_connector_reset,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c#L215-L222">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>const struct component_ops vd_component_ops = {
  .bind   = vd_bind,
  .unbind = vd_unbind,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c#L311-L314">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>// name = &quot;vs-virtual-display&quot;
struct platform_driver virtual_display_platform_driver = {
  .probe  = vd_probe,
  .remove = vd_remove,
  ...
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c#L353-L360">(Source)</a></p>
<p>Display Pipelines:</p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_crtc_funcs vs_crtc_funcs = {
  .set_config = drm_atomic_helper_set_config,
  .destroy    = vs_crtc_destroy,
  .page_flip  = drm_atomic_helper_page_flip,
  .reset      = vs_crtc_reset,
  .atomic_duplicate_state = vs_crtc_atomic_duplicate_state,
  .atomic_destroy_state   = vs_crtc_atomic_destroy_state,
  .atomic_set_property    = vs_crtc_atomic_set_property,
  .atomic_get_property    = vs_crtc_atomic_get_property,
  //.gamma_set    = drm_atomic_helper_legacy_gamma_set,
  .late_register  = vs_crtc_late_register,
  .enable_vblank  = vs_crtc_enable_vblank,
  .disable_vblank = vs_crtc_disable_vblank,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L207-L220">(Source)</a></p>
<p>Simple Encoder Driver:</p>
<div class="example-wrap"><pre class="language-c"><code>// name = &quot;vs-simple-encoder&quot;
struct platform_driver simple_encoder_driver = {
  .probe  = encoder_probe,
  .remove = encoder_remove,
  ...
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_simple_enc.c#L300-L307">(Source)</a></p>
<h1 id="appendix-inno-hdmi-controller-driver"><a href="#appendix-inno-hdmi-controller-driver">17 Appendix: Inno HDMI Controller Driver</a></h1>
<p>TODO</p>
<div class="example-wrap"><pre class="language-c"><code>// name = &quot;innohdmi-starfive&quot;
struct platform_driver inno_hdmi_driver = {
  .probe  = inno_hdmi_probe,
  .remove = inno_hdmi_remove,
  ...
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/inno_hdmi.c#L1155-L1163">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_encoder_helper_funcs inno_hdmi_encoder_helper_funcs = {
  .enable     = inno_hdmi_encoder_enable,
  .disable    = inno_hdmi_encoder_disable,
  .mode_fixup = inno_hdmi_encoder_mode_fixup,
  .mode_set   = inno_hdmi_encoder_mode_set,
  .atomic_check = inno_hdmi_encoder_atomic_check,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/inno_hdmi.c#L651-L657">(Source)</a></p>
<p>MIPI DSI:</p>
<div class="example-wrap"><pre class="language-c"><code>// name = &quot;dw-mipi-dsi&quot;
struct platform_driver dw_mipi_dsi_driver = {
  .probe  = dsi_probe,
  .remove = dsi_remove,
  ...
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/dw_mipi_dsi.c#L1066-L1073">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>// name = &quot;cdns-dsi&quot;
static struct platform_driver cdns_dsi_platform_driver = {
  .probe  = cdns_dsi_drm_probe,
  .remove = cdns_dsi_drm_remove,
  ...
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/starfive_drm_dsi.c#L1679-L1687">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct component_ops dsi_component_ops = {
  .bind   = dsi_bind,
  .unbind = dsi_unbind,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/dw_mipi_dsi.c#L998-L1001">(Source)</a></p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_bridge_funcs dw_mipi_dsi_bridge_funcs = {
  .mode_set  = bridge_mode_set,
  .enable    = bridge_enable,
  .post_disable = bridge_post_disable,
  .attach     = bridge_attach,
  .mode_fixup = bridge_mode_fixup,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/dw_mipi_dsi.c#L869-L875">(Source)</a></p>

    
</body>
</html>