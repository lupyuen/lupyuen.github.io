<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Star64 JH7110: Inside the Display Controller</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Star64 JH7110: Inside the Display Controller" 
    data-rh="true">
<meta property="og:description" 
    content="Let's take a walk inside the Display Controller for Pine64's Star64 JH7110 RISC-V SBC... And find out how we'll create the Display Driver for Apache NuttX RTOS"
    data-rh="true">
<meta name="description" 
    content="Let's take a walk inside the Display Controller for Pine64's Star64 JH7110 RISC-V SBC... And find out how we'll create the Display Driver for Apache NuttX RTOS">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/display2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Star64 JH7110: Inside the Display Controller</h1>
    <nav id="TOC"><ul>
<li><a href="#jh7110-docs-and-source-code">1 JH7110 Docs and Source Code</a><ul></ul></li>
<li><a href="#dc8200-display-controller">2 DC8200 Display Controller</a><ul></ul></li>
<li><a href="#dc8200-driver-for-direct-rendering-manager">3 DC8200 Driver for Direct Rendering Manager</a><ul>
<li><a href="#drm-operations">3.1 DRM Operations</a><ul></ul></li>
<li><a href="#drm-sub-drivers">3.2 DRM Sub-Drivers</a><ul></ul></li>
<li><a href="#file-operations">3.3 File Operations</a><ul></ul></li></ul></li>
<li><a href="#inside-the-display-driver">4 Inside the Display Driver</a><ul></ul></li>
<li><a href="#dc8200-display-controller-driver">5 DC8200 Display Controller Driver</a><ul></ul></li>
<li><a href="#dc8200-display-hardware-driver">6 DC8200 Display Hardware Driver</a><ul></ul></li>
<li><a href="#setup-display-pipeline">7 Setup Display Pipeline</a><ul></ul></li>
<li><a href="#commit-display-pipeline">8 Commit Display Pipeline</a><ul></ul></li>
<li><a href="#update-display-plane">9 Update Display Plane</a><ul></ul></li>
<li><a href="#unsolved-mysteries">10 Unsolved Mysteries</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-dc8200-framebuffer-driver">12 Appendix: DC8200 Framebuffer Driver</a><ul></ul></li>
<li><a href="#appendix-jh7110-display-clock-and-reset">13 Appendix: JH7110 Display Clock and Reset</a><ul>
<li><a href="#dc_bind">13.1 dc_bind</a><ul></ul></li>
<li><a href="#dc_init">13.2 dc_init</a><ul></ul></li>
<li><a href="#vs_dc_enable">13.3 vs_dc_enable</a><ul></ul></li></ul></li></ul></nav><p>üìù <em>16 Aug 2023</em></p>
<p><img src="https://lupyuen.github.io/images/display2-title.jpg" alt="Display Driver for StarFive JH7110 SoC" /></p>
<p>Today we look deep inside the <strong>Display Controller</strong> of the <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>RISC-V StarFive JH7110 SoC</strong></a> and figure out how it works.</p>
<p><em>But the JH7110 Display Controller is NOT documented!</em></p>
<p>Indeed! The <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Official JH7110 Doc</strong></a> only points to the <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Linux Driver Source Code</strong></a>.</p>
<p>(Plus a smattering of <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/dom_vout_syscon.html"><strong>Display Registers</strong></a>)</p>
<p><em>Sounds a little disturbing?</em></p>
<p>Yeah goodbye olden days of <a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>Documented Display Registers</strong></a>! (Like for <a href="https://lupyuen.github.io/articles/de#appendix-programming-the-allwinner-a64-display-engine"><strong>Allwinner A64</strong></a>)</p>
<p>But no worries! We‚Äôre here to decipher the <strong>Driver Source Code</strong> and document everything ourselves‚Ä¶</p>
<ul>
<li>
<p>What‚Äôs inside the <strong>Direct Rendering Manager (DRM) Driver</strong> for JH7110</p>
</li>
<li>
<p>How it controls the <strong>Display Registers</strong></p>
</li>
<li>
<p>To handle the <strong>Display Pipeline</strong>, <strong>Display Planes</strong> and <strong>Framebuffers</strong></p>
</li>
<li>
<p>And how it talks to <strong>HDMI and MIPI DSI</strong> (Display Serial Interface)</p>
</li>
<li>
<p>Also how we might <strong>implement the driver</strong> ourselves (without Linux)</p>
</li>
</ul>
<p><em>Why are we doing this?</em></p>
<p>We‚Äôre building a <strong>HDMI Display Driver</strong> for <a href="https://lupyuen.github.io/articles/release"><strong>Apache NuttX Real-Time Operating System</strong></a> (RTOS) on the <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> SBC. (Based on JH7110, just like VisionFive2)</p>
<p>Our analysis today will be super useful for creating our <strong>HDMI Driver for NuttX</strong> on Star64. (Pic below)</p>
<p>And hopefully this article will be helpful for <strong>porting other Operating Systems</strong> to JH7110!</p>
<p><img src="https://lupyuen.github.io/images/linux-title.jpg" alt="Pine64 Star64 RISC-V SBC" /></p>
<h1 id="jh7110-docs-and-source-code"><a href="#jh7110-docs-and-source-code">1 JH7110 Docs and Source Code</a></h1>
<p><em>What exactly is documented for JH7110 Display Controller?</em></p>
<p>Officially these are the <strong>JH7110 Display Controller</strong> docs‚Ä¶</p>
<ul>
<li>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/display_subsystem.html"><strong>Display Subsystem</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_Display/"><strong>Display Controller Developing Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_HDMI/"><strong>SDK for HDMI</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_LCD/"><strong>MIPI LCD Developing and Porting Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_GPU/"><strong>GPU Developing and Porting Guide</strong></a></p>
</li>
<li>
<p><a href="http://doc-en.rvspace.org/VisionFive2/DG_Multimedia/"><strong>Multimedia Developing Guide</strong></a></p>
</li>
</ul>
<p>But the <a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/detail_info_display.html"><strong>crucial docs are confidential</strong></a>. (Sigh)</p>
<p><em>What about the Driver Source Code?</em></p>
<p>We have the official <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/source_code_structure_display.html"><strong>Linux Drivers</strong></a> for the Display Controller‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c"><strong>vs_dc.c</strong></a>: Display Controller</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c"><strong>vs_dc_hw.c</strong></a>: Framebuffer and Overlay (similar to A64 Display Engine)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c"><strong>vs_drv.c</strong></a>: Device for Direct Rendering Manager</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c"><strong>vs_crtc.c</strong></a>: Display Pipeline (Colour / Gamma / LUT)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c"><strong>vs_plane.c</strong></a>: Display Plane</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_simple_enc.c"><strong>vs_simple_enc.c</strong></a>: <a href="https://software-dl.ti.com/processor-sdk-linux/esd/docs/06_03_00_106/linux/Foundational_Components/Kernel/Kernel_Drivers/Display/DSS.html">Display Subsystem (DSS)</a> Encoder</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_gem.c"><strong>vs_gem.c</strong></a>: <a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Graphics_Execution_Manager">Graphics Execution Manager</a> (Memory Management Framework)</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_virtual.c"><strong>vs_virtual.c</strong></a>: Virtual Display</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_dec.c"><strong>vs_dc_dec.c</strong></a>: Bitmap Decompression</p>
<p><a href="https://github.com/starfive-tech/linux/tree/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon">(Build Instructions)</a></p>
</li>
</ul>
<p><em>Phew so many Source Files!</em></p>
<p>Yeah but they‚Äôre super helpful for understanding the Inner Workings of our Display Controller!</p>
<p>We‚Äôll decipher the Driver Source Code in a while.</p>
<p><img src="https://lupyuen.github.io/images/display2-vout_block_diagram18.png" alt="JH7110 Display Subsystem Block Diagram" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/block_diagram_display.html"><em>JH7110 Display Subsystem Block Diagram</em></a></p>
<h1 id="dc8200-display-controller"><a href="#dc8200-display-controller">2 DC8200 Display Controller</a></h1>
<p><em>What‚Äôs this DC8200?</em></p>
<p>From the pic above, we see that JH7110 uses a <strong>VeriSilicon DC8200 Dual Display Controller</strong> to drive these displays‚Ä¶</p>
<ul>
<li>
<p><strong>MIPI DPHY / DSI</strong>: Display Serial Interface</p>
<p>(For most LCD Panels, like in PineTab-V)</p>
</li>
<li>
<p><strong>DPI</strong>: Display Parallel Interface</p>
<p>(For LCD Panels with Parallel RGB Interface)</p>
</li>
<li>
<p><strong>HDMI Video Output</strong></p>
</li>
</ul>
<p>The Display Output Ports are named <strong>DPI0 and DPI1</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/Network_on_a_chip">(NoC means <strong>Network-on-Chip</strong>)</a></p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">(AXI is the <strong>Advanced eXtensible Interface</strong>)</a></p>
<p>These are the <strong>Clock and Reset Signals</strong> for the Display Controller‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-vout_clkrst18.png" alt="JH7110 Display Subsystem Clock and Reset" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/clock_n_reset_display.html"><em>JH7110 Display Subsystem Clock and Reset</em></a></p>
<p><a href="https://lupyuen.github.io/articles/display2#appendix-jh7110-display-clock-and-reset">(Remember to <strong>Enable the Clocks</strong> and <strong>Deassert the Resets</strong>!)</a></p>
<p>The DC8200 Display Controller outputs to <strong>2 displays simultaneously</strong> (like MIPI DSI + HDMI)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/display2-Display_Block_Diagram.png" alt="Block Diagram of DC8200 Display Controller" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/block_diagram_display.html"><em>Block Diagram of DC8200 Display Controller</em></a></p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_eXtensible_Interface">(AXI is the <strong>Advanced eXtensible Interface</strong>)</a></p>
<p>With support for‚Ä¶</p>
<ul>
<li>
<p><strong>Display Layers</strong>: Overlays for Cursor, Video, Graphics</p>
</li>
<li>
<p><strong>Output Control</strong>: Blending, Gamma, 3D LUT, RGB-to-YUV, Dithering</p>
</li>
</ul>
<p>We‚Äôll explain the Display Layers (Overlays) in a while.</p>
<p><em>How are the Display Outputs mapped to MIPI DSI and HDMI?</em></p>
<p>The <a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/device_tree_config_display.html"><strong>Linux Device Tree</strong></a> configures the mapping of Display Outputs to the Display Devices‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>## Configure DC8200 Display Controller
&amp;dc8200 {

  ## Display Outputs are mapped to...
  dc_out: port {

    ## DPI0: HDMI
    dc_out_dpi0: endpoint@0 {
      reg = &lt;0&gt;;
      remote-endpoint = &lt;&amp;hdmi_input0&gt;;
    };

    ## DPI1: HDMI LCDC
    dc_out_dpi1: endpoint@1 {
      reg = &lt;1&gt;;
      remote-endpoint = &lt;&amp;hdmi_in_lcdc&gt;;
    };

    ## DPI2: MIPI DSI
    dc_out_dpi2: endpoint@2 {
      reg = &lt;2&gt;;
      remote-endpoint = &lt;&amp;mipi_in&gt;;
    };
</code></pre></div>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/device_tree_config_display.html">(Source)</a></p>
<p>Let‚Äôs dive into the Display Driver Code!</p>
<p><img src="https://lupyuen.github.io/images/jh7110-display.jpg" alt="JH7110 Linux Display Driver" /></p>
<h1 id="dc8200-driver-for-direct-rendering-manager"><a href="#dc8200-driver-for-direct-rendering-manager">3 DC8200 Driver for Direct Rendering Manager</a></h1>
<p><em>What‚Äôs this DRM?</em></p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager"><strong>Direct Rendering Manager (DRM)</strong></a> is the Linux Subsystem that talks to Display Controllers. (Like the DC8200 Display Controller in JH7110)</p>
<p>The pic above shows the <strong>DC8200 Driver for DRM</strong> (top left). It works like a fa√ßade for the other DC8200 Driver Modules. (Rest of the pic)</p>
<p>(Not to be confused with <a href="https://en.wikipedia.org/wiki/Digital_rights_management"><strong>the other DRM</strong></a>, which is also video-related)</p>
<h2 id="drm-operations"><a href="#drm-operations">3.1 DRM Operations</a></h2>
<p>The DRM Driver for DC8200 is named <strong>‚Äústarfive‚Äù</strong>. These are the <strong>DRM Operations</strong> supported by the driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L125-L143">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// DRM Driver for DC8200 Display Controller
static struct drm_driver vs_drm_driver = {
  .driver_features    = DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_GEM,
  .lastclose          = drm_fb_helper_lastclose,
  .prime_handle_to_fd = drm_gem_prime_handle_to_fd,
  .prime_fd_to_handle = drm_gem_prime_fd_to_handle,
  .gem_prime_import   = vs_gem_prime_import,
  .gem_prime_import_sg_table = vs_gem_prime_import_sg_table,
  .gem_prime_mmap     = vs_gem_prime_mmap,
  .dumb_create        = vs_gem_dumb_create,
#ifdef CONFIG_DEBUG_FS
  .debugfs_init       = vs_debugfs_init,
#endif
  .fops  = &amp;fops,
  .name  = &quot;starfive&quot;,
  .desc  = &quot;VeriSilicon DRM driver&quot;,
  .date  = &quot;20191101&quot;,
  .major = 1,
  .minor = 0,
};
</code></pre></div>
<p>(Nothing to see here, mostly DRM Boilerplate)</p>
<p>(We‚Äôll come back to <strong>fops</strong>)</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Graphics_Execution_Manager">(<strong>Graphics Execution Manager ‚ÄúGEM‚Äù</strong> handles Memory Buffers)</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_gem.c">(<strong>vs_gem</strong> functions are here)</a></p>
<p>TODO: Pic of Sub-Drivers</p>
<h2 id="drm-sub-drivers"><a href="#drm-sub-drivers">3.2 DRM Sub-Drivers</a></h2>
<p><em>Where are the fun bits of our Display Driver?</em></p>
<p>Remember our DRM Driver is only a fa√ßade. Most of the work is done by the <strong>Sub-Drivers for DC8200</strong>: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L301-L315">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Sub-Drivers for DC8200 Display Controller
static struct platform_driver *drm_sub_drivers[] = {

  // Display Controller Driver
  &amp;dc_platform_driver,

#ifdef CONFIG_STARFIVE_INNO_HDMI
  // HDMI Controller Driver:
  // Inno HDMI 2.0 Transmitter for TSMC28HPC+
  &amp;inno_hdmi_driver,
#endif

  // Simple Encoder Driver
  &amp;simple_encoder_driver,

#ifdef CONFIG_VERISILICON_VIRTUAL_DISPLAY
  // Virtual Display Driver
  &amp;virtual_display_platform_driver,
#endif
};
</code></pre></div>
<p>We‚Äôll see the <strong>Display Controller Driver</strong> in a while.</p>
<p><em>Who starts the Sub-Drivers?</em></p>
<p>At startup, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L459-L472"><strong>vs_drm_init</strong></a> (in the DRM Driver) registers two things‚Ä¶</p>
<ul>
<li>
<p><strong>DC8200 Sub-Drivers: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L301-L315">drm_sub_drivers</a></strong></p>
</li>
<li>
<p><strong>DC8200 DRM Plaform Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L448-L457">vs_drm_platform_driver</a></strong></p>
</li>
</ul>
<p>That‚Äôs how the Sub-Drivers are started.</p>
<h2 id="file-operations"><a href="#file-operations">3.3 File Operations</a></h2>
<p><em>What‚Äôs inside fops?</em></p>
<p><strong>fops</strong> defines the <strong>File Operations</strong> supported by our DRM Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L54-L63">vs_drv.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// File Operations for DC8200 Display Controller
static const struct file_operations fops = {
  .owner     = THIS_MODULE,
  .open      = drm_open,
  .release   = drm_release,
  .unlocked_ioctl = drm_ioctl,
  .compat_ioctl   = drm_compat_ioctl,
  .poll      = drm_poll,
  .read      = drm_read,
  .mmap      = vs_gem_mmap,
};
</code></pre></div>
<p>(Looks fairly standard for a DRM Driver)</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_gem.c#L546-L561">(<strong>vs_gem_mmap</strong> is defined here)</a></p>
<p><img src="https://lupyuen.github.io/images/dsi3-steps.jpg" alt="Display Driver renders graphics to a Display Device" /></p>
<h1 id="inside-the-display-driver"><a href="#inside-the-display-driver">4 Inside the Display Driver</a></h1>
<p><em>What‚Äôs inside a typical Display Driver?</em></p>
<p><em>How does it talk to the Display Hardware?</em></p>
<p>Before we dive too deep into our Driver Code, let‚Äôs talk about <strong>Display Drivers</strong> and how they control the <strong>Display Hardware</strong>.</p>
<p>The pic above shows how a typical Display Driver will <strong>render graphics</strong> to a Display Device‚Ä¶</p>
<ul>
<li>
<p>Our Apps will write the pixels into a <strong>RAM Framebuffer</strong></p>
</li>
<li>
<p>Inside the SoC is a <strong>Display Engine</strong> that reads the Framebuffer (over DMA)</p>
</li>
<li>
<p>And pushes a continuous stream of pixels to a <strong>Display Device</strong></p>
<p>(Over HDMI or MIPI Display Serial Interface)</p>
</li>
</ul>
<p><em>What‚Äôs a Framebuffer?</em></p>
<p>A <strong>Framebuffer</strong> is just a region of RAM that stores pixels in a Colour Format. (Like ARGB 8888)</p>
<p><img src="https://lupyuen.github.io/images/de2-fb.jpg" alt="Framebuffer" /></p>
<p><strong>Multiple Framebuffers</strong> are supported. Framebuffers can be rendered as <strong>Opaque or Semi-Transparent Overlays</strong>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de2-overlay.jpg" alt="Overlays" /></p>
<p>To do this, we configure the <strong>Display Pipeline</strong> to Blend the Framebuffers‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/de2-blender.jpg" alt="Blender" /></p>
<p>Internally, the Display Driver will manipulate the <strong>Display Registers</strong> to‚Ä¶</p>
<ol>
<li>
<p>Configure the <strong>Framebuffers</strong> (and their RAM Addresses)</p>
</li>
<li>
<p>Configure the <strong>Display Pipelines</strong> (for Overlay Blending)</p>
</li>
<li>
<p>Configure the <strong>Display Output</strong> (for the Display Device)</p>
</li>
<li>
<p><strong>Commit the Display Configuration</strong> (to the Display Controller)</p>
</li>
</ol>
<p>And that‚Äôs how a typical Display Driver works in a Modern SoC!</p>
<p><a href="https://lupyuen.github.io/articles/de3">(Like for <strong>Allwinner A64</strong>)</a></p>
<p>Heading back to our scheduled programming‚Ä¶</p>
<p>TODO: Pic of Display Controller dc_bind</p>
<h1 id="dc8200-display-controller-driver"><a href="#dc8200-display-controller-driver">5 DC8200 Display Controller Driver</a></h1>
<p>The <strong>DC8200 Display Controller Driver</strong> is called by the the DC8200 DRM Driver. The driver exposes the Display Functions for‚Ä¶</p>
<ul>
<li>
<p>Initialisation of <strong>Display Controller</strong></p>
</li>
<li>
<p>Setup and Configuration of <strong>Display Pipeline</strong></p>
</li>
<li>
<p>Update of <strong>Display Plane</strong></p>
</li>
</ul>
<p>The Display Controller Driver is named <strong>‚Äúvs-dc‚Äù</strong> (for VeriSilicon Display Controller): <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1642-L1649">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>struct platform_driver dc_platform_driver = {
  .probe  = dc_probe,
  .remove = dc_remove,
  .name   = &quot;vs-dc&quot;
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1595-L1629">(<strong>dc_probe</strong> is defined here)</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1631-L1640">(<strong>dc_remove</strong> is defined here)</a></p>
<p>These are the <strong>Component Functions</strong> exposed by the Display Controller Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1584-L1587">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>const struct component_ops dc_component_ops = {
  .bind   = dc_bind,
  .unbind = dc_unbind,
};
</code></pre></div>
<p><em>What happens at startup?</em></p>
<p>At startup, the DRM Driver calls our <strong>Display Controller Driver</strong> at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1421-L1573"><strong>dc_bind</strong></a> and <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L644-L722"><strong>dc_init</strong></a> to setup the <a href="https://lupyuen.github.io/articles/display2#appendix-jh7110-display-clock-and-reset"><strong>Clock and Reset Signals</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/display2#dc_bind">(More about <strong>dc_bind</strong>)</a></p>
<p><a href="https://lupyuen.github.io/articles/display2#dc_init">(And <strong>dc_init</strong>)</a></p>
</li>
</ul>
<p>Which calls our <strong>Display Hardware Driver</strong> at‚Ä¶</p>
<ul>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1301-L1361"><strong>dc_hw_init</strong></a> to update the <strong>Display Registers</strong></li>
</ul>
<p>As we‚Äôll see in the next section.</p>
<p><em>That‚Äôs all for our Display Controller Driver?</em></p>
<p>There‚Äôs more! We‚Äôll come back to our Display Controller Driver for handling the Display Pipeline and Display Plane.</p>
<p>TODO: Pic of dc_hw_init</p>
<h1 id="dc8200-display-hardware-driver"><a href="#dc8200-display-hardware-driver">6 DC8200 Display Hardware Driver</a></h1>
<p><em>Now we do the exciting bit?</em></p>
<p>Finally! The <strong>Display Hardware Driver</strong> is called by the Display Controller Driver (previous section) to manipulate the Display Hardware Registers and‚Ä¶</p>
<ul>
<li>
<p>Initialise the <strong>Display Controller</strong></p>
</li>
<li>
<p>Setup and Configure the <strong>Display Pipeline</strong></p>
</li>
<li>
<p>Update the <strong>Display Plane</strong></p>
</li>
</ul>
<p>(This is the driver that we‚Äôll reimplement in NuttX!)</p>
<p>Earlier we saw <a href="https://lupyuen.github.io/articles/display2#dc8200-display-controller-driver"><strong>dc_init</strong></a> (from Display Controller Driver) calling the Display Hardware Driver at startup.</p>
<p>Here‚Äôs what happens inside <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1301-L1361"><strong>dc_hw_init</strong></a>‚Ä¶</p>
<ol>
<li>
<p>Read the <strong>Hardware Revision and Chip ID</strong></p>
</li>
<li>
<p>Initialise every <strong>Display Plane</strong> (Layer)</p>
</li>
<li>
<p>Initialise every <strong>Display Panel</strong> (and Cursor)</p>
</li>
</ol>
<p><em>Why read the Hardware Revision?</em></p>
<p>Depending on the <strong>Hardware Revision</strong>, the DC8200 Display Controller works a little differently.</p>
<p>Assuming that our Display Controller is <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.h#L237-L241"><strong>DC_REV_2</strong></a> (HW_REV_5721_310)‚Ä¶</p>
<ul>
<li>
<p><strong><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1129-L1149">dc_info</a> (Display Controller Info)</strong> says that 2 Display Panels and 8 Display Planes (Layers) are supported‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// Display Controller Info
static const struct vs_dc_info dc_info[] = {
  ...
  {
    // For DC_REV_2:
    .name      = &quot;DC8200&quot;,
    .panel_num = 2,
    .plane_num = 8,
    .planes    = dc_hw_planes[DC_REV_2],
    .layer_num = 6,
    .max_bpc   = 10,
    .color_formats =
      DRM_COLOR_FORMAT_RGB444 |
      DRM_COLOR_FORMAT_YCRCB444 |
      DRM_COLOR_FORMAT_YCRCB422 |
      DRM_COLOR_FORMAT_YCRCB420,
    .gamma_size   = GAMMA_EX_SIZE,
    .gamma_bits   = 12,
    .pitch_alignment = 128,
    .pipe_sync    = false,
    .mmu_prefetch = false,
    .background   = true,
    .panel_sync   = true,
    .cap_dec      = false,
  }
</code></pre></div></li>
<li>
<p><strong><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L863-L1083">dc_hw_planes</a> (Display Planes Info)</strong> defines the 8 Display Planes (Layers)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Z Pos</th><th style="text-align: left">Layer</th><th style="text-align: center">Min Size</th><th style="text-align: center">Max Size</th></tr></thead><tbody>
<tr><td style="text-align: center">0</td><td style="text-align: left">Primary</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: left">Overlay</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: left">Overlay_1</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">3</td><td style="text-align: left">Primary_1</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: left">Overlay_2</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: left">Overlay_3</td><td style="text-align: center">0 x 0</td><td style="text-align: center">4096 x 4096</td></tr>
<tr><td style="text-align: center">255</td><td style="text-align: left">Cursor</td><td style="text-align: center">32 x 32</td><td style="text-align: center">64 x 64</td></tr>
<tr><td style="text-align: center">255</td><td style="text-align: left">Cursor_1</td><td style="text-align: center">32 x 32</td><td style="text-align: center">64 x 64</td></tr>
</tbody></table>
</div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L863-L1083">(Plus a bunch of <strong>Other Properties</strong>)</a></p>
</li>
</ul>
<p><em>Why are the layers interleaved?</em></p>
<p>That‚Äôs because the Display Planes (Layers) will be rendered to <strong>2 separate displays</strong> (HDMI + MIPI DSI)‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Display 0</th><th style="text-align: left">Display 1</th></tr></thead><tbody>
<tr><td style="text-align: left">Primary</td><td style="text-align: left">Primary_1</td></tr>
<tr><td style="text-align: left">Overlay</td><td style="text-align: left">Overlay_2</td></tr>
<tr><td style="text-align: left">Overlay_1</td><td style="text-align: left">Overlay_3</td></tr>
<tr><td style="text-align: left">Cursor</td><td style="text-align: left">Cursor_1</td></tr>
</tbody></table>
</div>
<p><img src="https://lupyuen.github.io/images/display2-Display_Block_Diagram.png" alt="Block Diagram of DC8200 Display Controller" /></p>
<p><a href="https://doc-en.rvspace.org/VisionFive2/DG_Display/JH7110_SDK/block_diagram_display.html"><em>Block Diagram of DC8200 Display Controller</em></a></p>
<p>Our Display Hardware Driver will do other fun things! Let‚Äôs talk about the Display Pipelines and Display Planes‚Ä¶</p>
<p>TODO: Pic of Setup Display Pipeline</p>
<h1 id="setup-display-pipeline"><a href="#setup-display-pipeline">7 Setup Display Pipeline</a></h1>
<p>Earlier we talked about <a href="https://lupyuen.github.io/articles/display2#inside-the-display-driver"><strong>Display Pipelines</strong></a> and how they‚Ä¶</p>
<ul>
<li>
<p><strong>Read pixels</strong> from one or more Framebuffers over DMA</p>
</li>
<li>
<p><strong>Blend the Framebuffers</strong> / Display Planes / Layers into a single image</p>
</li>
<li>
<p><strong>Apply bitmap effects</strong> like Gamma Correction</p>
</li>
<li>
<p><strong>Push the image pixels</strong> to the Display Device (HDMI or MIPI DSI)</p>
</li>
</ul>
<p>In Linux Direct Rendering Manager (DRM), the Display Pipeline is implemented as <a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#KMS_device_model"><strong>CRTC Functions</strong></a>: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1400-L1408">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Display Pipeline Functions for DC8200 Display Controller
static const struct vs_crtc_funcs dc_crtc_funcs = {
  .enable        = vs_dc_enable,
  .disable       = vs_dc_disable,
  .mode_fixup    = vs_dc_mode_fixup,
  .set_gamma     = vs_dc_set_gamma,
  .enable_gamma  = vs_dc_enable_gamma,
  .enable_vblank = vs_dc_enable_vblank,
  .commit        = vs_dc_commit,
};
</code></pre></div>
<p><em>How do we create a Display Pipeline?</em></p>
<p>From above, we see that DRM <strong>creates the Display Pipeline</strong> by calling our Display Controller Driver at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L740-L827"><strong>vs_dc_enable</strong></a>, to prepare the Clock and Reset Signals</p>
<p><a href="https://lupyuen.github.io/articles/display2#vs_dc_enable">(More about <strong>vs_dc_enable</strong>)</a></p>
</li>
</ul>
<p>Which calls‚Ä¶</p>
<ul>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1480-L1487"><strong>dc_hw_setup_display</strong></a>, from our Display Hardware Driver</li>
</ul>
<p><em>What‚Äôs inside dc_hw_setup_display?</em></p>
<p>In our Display Hardware Driver, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1480-L1487"><strong>dc_hw_setup_display</strong></a> will‚Ä¶</p>
<ol>
<li>Copy the <strong>Display Struct</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1971-L2030"><strong>setup_display_ex</strong></a></li>
</ol>
<p>Then <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1971-L2030"><strong>setup_display_ex</strong></a> will‚Ä¶</p>
<ol>
<li>Set the <strong>Colour Format</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1865-L1969"><strong>setup_display</strong></a></li>
</ol>
<p>Finally <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1865-L1969"><strong>setup_display</strong></a> will do most of the work‚Ä¶</p>
<ol>
<li>Set the <strong>DPI Config</strong></li>
<li>Disable the <strong>Display Panel</strong></li>
<li>Set the <strong>Horizontal Resolution and Sync</strong></li>
<li>Set the <strong>Vertical Resolution and Sync</strong></li>
<li>Configure the <strong>Framebuffer Sync Mode</strong></li>
<li>Set the <strong>Framebuffer Background Colour</strong></li>
<li>Set the <strong>Display Dither</strong></li>
<li>Enable the <strong>Display Panel</strong></li>
<li>Set the <strong>Overlay Configuration</strong></li>
<li>Set the <strong>Cursor Configuration</strong></li>
</ol>
<p><em>Who creates the Display Pipeline?</em></p>
<p>To create the Display Pipeline, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L740-L826"><strong>vs_dc_enable</strong></a> (from above) is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L265-L276"><strong>vs_crtc_atomic_enable</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// DC8200 Display Pipeline Helper Functions
static const struct drm_crtc_helper_funcs vs_crtc_helper_funcs = {
  .mode_fixup     = vs_crtc_mode_fixup,
  .atomic_enable  = vs_crtc_atomic_enable,
  .atomic_disable = vs_crtc_atomic_disable,
  .atomic_begin   = vs_crtc_atomic_begin,
  .atomic_flush   = vs_crtc_atomic_flush,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L338-L344">(Source)</a></p>
<p>Which is called by the Linux <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L1323-L1408"><strong>DRM Atomic Helper</strong></a>.</p>
<p>(We‚Äôll see <strong>vs_crtc_atomic_flush</strong> in the next section)</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Atomic_Display">(More about <strong>DRM Atomic Display</strong>)</a></p>
<p>And that‚Äôs how we create a Display Pipeline! Now we commit the Display Pipeline‚Ä¶</p>
<p>TODO: Pic of Commit Display Pipeline</p>
<h1 id="commit-display-pipeline"><a href="#commit-display-pipeline">8 Commit Display Pipeline</a></h1>
<p><em>Why will we Commit a Display Pipeline?</em></p>
<p>A Display Pipeline won‚Äôt render any pixels‚Ä¶ Until we <strong>Commit the Display Pipeline</strong>!</p>
<p>To Commit the Display Pipeline, the Linux Direct Rendering Manager (DRM) calls our Display Controller Driver at‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1381-L1398"><strong>vs_dc_commit</strong></a>, which calls‚Ä¶</p>
</li>
<li>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L2038-L2076"><strong>dc_hw_commit</strong></a>, from our Display Hardware Driver</p>
</li>
</ul>
<p><em>What‚Äôs inside dc_hw_commit?</em></p>
<p>In our Display Hardware Driver, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L2038-L2076"><strong>dc_hw_commit</strong></a> will‚Ä¶</p>
<ol>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1548-L1574"><strong>gamma_ex_commit</strong></a> to commit the Gamma Correction</li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1768-L1863"><strong>plane_ex_commit</strong></a> commit the Display Plane</li>
<li>Update the <strong>Cursor and QoS</strong></li>
</ol>
<p><em>What happens in plane_ex_commit?</em></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1768-L1863"><strong>plane_ex_commit</strong></a> will‚Ä¶</p>
<ol>
<li>Set the <strong>Colour Space</strong></li>
<li>Set the <strong>Gamma Correction</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1576-L1766"><strong>plane_commit</strong></a></li>
</ol>
<p>Then <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1576-L1766"><strong>plane_commit</strong></a> will do this for every <strong>Display Plane</strong> (Layer)‚Ä¶</p>
<ol>
<li>Set the <strong>Framebuffer YUV Address and Stride</strong></li>
<li>Set the <strong>Framebuffer Width and Height</strong></li>
<li><strong>Clear the Framebuffer</strong></li>
<li>Configure the <strong>Primary and Non-Primary Framebuffers</strong></li>
<li>Enable <strong>Framebuffer Scaling</strong> (X and Y)</li>
<li>Set the <strong>Framebuffer Offset</strong> (X and Y)</li>
<li>Set the <strong>Framebuffer Blending</strong></li>
<li>Set the <strong>Colour Key</strong> (Transparency)</li>
<li>Set the <strong>ROI</strong></li>
</ol>
<p><em>Who Commits the Display Pipeline?</em></p>
<p>To Commit the Display Pipeline, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1381-L1398"><strong>vs_dc_commit</strong></a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_crtc.c#L320-L336"><strong>vs_crtc_atomic_flush</strong></a>‚Ä¶</p>
<p>Which is called by the Linux <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L2445-L2570"><strong>DRM Atomic Helper</strong></a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Atomic_Display">(More about <strong>DRM Atomic Display</strong>)</a></p>
<p>TODO: Pic of Update Display Plane</p>
<h1 id="update-display-plane"><a href="#update-display-plane">9 Update Display Plane</a></h1>
<p>One last thing for today: How to <strong>Update the Display Plane</strong>.</p>
<p>(A Display Plane is a Layer of Pixels / Framebuffer that will be blended into the final image by a Display Pipeline)</p>
<p>Our Display Controller Driver exposes these <strong>Display Plane Functions</strong>: 
<a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1410-L1414">vs_dc.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Display Plane Functions for DC8200
static const struct vs_plane_funcs dc_plane_funcs = {
  .update  = vs_dc_update_plane,
  .disable = vs_dc_disable_plane,
  .check   = vs_dc_check_plane,
};
</code></pre></div>
<p>To update the Display Plane, the Linux Direct Rendering Manager (DRM) calls our Display Controller Driver at‚Ä¶</p>
<ul>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1262-L1280"><strong>vs_dc_update_plane</strong></a></li>
</ul>
<p>Which calls‚Ä¶</p>
<ol>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1153-L1196"><strong>update_plane</strong></a> (Update Plane)</li>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1198-L1220"><strong>update_qos</strong></a> (Update QoS) </li>
<li><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1241-L1260"><strong>update_cursor_plane</strong></a> (Update Cursor Plane)</li>
</ol>
<p><em>What‚Äôs inside update_plane?</em></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1153-L1196"><strong>update_plane</strong></a> (from our Display Controller Driver) will update the Display Plane‚Ä¶</p>
<ol>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L973-L1014"><strong>update_fb</strong></a> to set the <strong>Framebuffer Addresses</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1097-L1127"><strong>update_roi</strong></a> to set the <strong>ROI</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L936-L971"><strong>update_scale</strong></a> to set the <strong>Scaling</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1090-L1095"><strong>update_degamma</strong></a> to set the <strong>Degamma Correction</strong></li>
<li>Set the <strong>Start and End Position</strong> (X and Y)</li>
<li>Set the <strong>Blending Alpha and Mode</strong></li>
<li>Set the <strong>Colour Management</strong></li>
<li>Call <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1368-L1399"><strong>dc_hw_update_plane</strong></a> </li>
</ol>
<p>Then <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc_hw.c#L1368-L1399"><strong>dc_hw_update_plane</strong></a> (from our Display Hardware Driver) will‚Ä¶</p>
<ol>
<li>Copy the <strong>Framebuffer</strong></li>
<li>Copy the <strong>Scaling</strong></li>
<li>Copy the <strong>Position</strong></li>
<li>Copy the <strong>Blending</strong></li>
</ol>
<p><em>Who calls our driver to update the Display Plane?</em></p>
<p>To update the Display Plane, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1262-L1280"><strong>vs_dc_update_plane</strong></a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c#L268-L301"><strong>vs_plane_atomic_update</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>// DC8200 Display Plane Helper Functions
const struct drm_plane_helper_funcs vs_plane_helper_funcs = {
  .atomic_check   = vs_plane_atomic_check,
  .atomic_update  = vs_plane_atomic_update,
  .atomic_disable = vs_plane_atomic_disable,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_plane.c#L314-L318">(Source)</a></p>
<p>Which is called by the Linux <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_atomic_helper.c#L2445-L2570"><strong>DRM Atomic Helper</strong></a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Direct_Rendering_Manager#Atomic_Display">(More about <strong>DRM Atomic Display</strong>)</a></p>
<h1 id="unsolved-mysteries"><a href="#unsolved-mysteries">10 Unsolved Mysteries</a></h1>
<p><em>We‚Äôre ready to build our NuttX Display Driver for JH7110?</em></p>
<p>Not quite. We have a bit more to explore, like the <strong>HDMI Controller for JH7110</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#hdmi-display-for-star64-jh7110"><strong>HDMI Display for JH7110</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#hdmi-controller-for-star64-jh7110"><strong>HDMI Controller for JH7110</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#call-flow-for-hdmi-controller-driver"><strong>HDMI Controller Driver</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#test-hdmi-for-star64-jh7110"><strong>Test HDMI for JH7110</strong></a></p>
<p><a href="https://fosstodon.org/@Fishwaldo/110902984442385966">(<strong>Justin / Fishwaldo</strong> suggests that we check the HDMI Driver in U-Boot)</a></p>
</li>
</ul>
<p>When we port NuttX to the <strong>PineTab-V Tablet</strong>, we‚Äôll need drivers for MIPI DSI and LCD Panel‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#lcd-panel-for-star64-jh7110"><strong>LCD Panel for Star64 JH7110</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#pinetab-v-factory-test-code"><strong>PineTab-V Factory Test Code</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64#call-flow-for-dc8200-virtual-display-driver"><strong>DC8200 Virtual Display Driver</strong></a></p>
<p><a href="https://fosstodon.org/@Fishwaldo/110902984462760802">(LCD Panel in PineTab-V is BOE TH101MB31IG002-28A)</a></p>
</li>
</ul>
<p>TODO</p>
<p>Prototype new driver in Zig</p>
<p>Slightly annoying that New Zig won‚Äôt run on my Old Mac</p>
<h1 id="whats-next"><a href="#whats-next">11 What‚Äôs Next</a></h1>
<p>TODO</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Other Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/display2.md"><strong>lupyuen.github.io/src/display2.md</strong></a></p>
<p>TODO: Pic of Framebuffer Driver</p>
<h1 id="appendix-dc8200-framebuffer-driver"><a href="#appendix-dc8200-framebuffer-driver">12 Appendix: DC8200 Framebuffer Driver</a></h1>
<p>TODO</p>
<p>At startup, <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_drv.c#L193-L271">vs_drm_bind</a> calls <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L178-L191">vs_mode_config_init</a> to register the Framebuffer Driver: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L166-L172">vs_mode_config_funcs</a>.</p>
<p>Which is defined as‚Ä¶</p>
<div class="example-wrap"><pre class="language-c"><code>static const struct drm_mode_config_funcs vs_mode_config_funcs = {
  .fb_create       = vs_fb_create,
  .get_format_info = vs_get_format_info,
  .output_poll_changed = drm_fb_helper_output_poll_changed,
  .atomic_check    = drm_atomic_helper_check,
  .atomic_commit   = drm_atomic_helper_commit,
};
</code></pre></div>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L166-L172">(Source)</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L60-L123">vs_fb_create</a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_framebuffer.c#L286-L329">drm_framebuffer</a></p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L155-L164">vs_get_format_info</a> is called by <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/drm_fourcc.c#L302-L325">drm_fourcc</a></p>
<p>Framebuffer Formats: <a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_fb.c#L134-L139">vs_formats</a></p>
<p><img src="https://lupyuen.github.io/images/display2-vout_clkrst18.png" alt="JH7110 Display Subsystem Clock and Reset" /></p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/clock_n_reset_display.html"><em>JH7110 Display Subsystem Clock and Reset</em></a></p>
<h1 id="appendix-jh7110-display-clock-and-reset"><a href="#appendix-jh7110-display-clock-and-reset">13 Appendix: JH7110 Display Clock and Reset</a></h1>
<p>TODO: Reconcile the Clock and Reset Names</p>
<p><a href="https://doc-en.rvspace.org/JH7110/TRM/JH7110_TRM/dom_vout_crg.html">DOM VOUT CRG</a></p>
<p>TODO: Pic of dc_bind</p>
<h2 id="dc_bind"><a href="#dc_bind">13.1 dc_bind</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L1421-L1573"><strong>dc_bind</strong></a></p>
<ol>
<li>
<p>Call dc_init</p>
</li>
<li>
<p>Attach I/O MMU Device</p>
</li>
<li>
<p>For Each Panel: Create Display Pipeline</p>
</li>
<li>
<p>For Each Plane: Create Display Plane</p>
</li>
<li>
<p>Update Pitch Alignment</p>
</li>
<li>
<p>Disable Clock vout_top_lcd</p>
</li>
<li>
<p>Assert DC8200 Reset</p>
</li>
<li>
<p>Disable DC8200 Clock</p>
</li>
<li>
<p>Disable Clock v_out_top</p>
</li>
<li>
<p>Disable Clock DC vout</p>
</li>
</ol>
<p>TODO: Pic of dc_init</p>
<h2 id="dc_init"><a href="#dc_init">13.2 dc_init</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L644-L722"><strong>dc_init</strong></a></p>
<ol>
<li>
<p>Enable Clock dc_vout_clk</p>
</li>
<li>
<p>Deassert DC8200 Reset</p>
</li>
<li>
<p>Enable Clock vout_top_lcd</p>
</li>
<li>
<p>Deassert vout_reset</p>
</li>
<li>
<p>Update the DSS Registers with this Mystery Code:</p>
<div class="example-wrap"><pre class="language-c"><code>#ifdef CONFIG_DRM_I2C_NXP_TDA998X
  // tda998x-rgb2hdmi. For HDMI only?
  regmap_update_bits(dc-&gt;dss_regmap, 0x4, BIT(20), 1&lt;&lt;20);
#endif

#ifdef CONFIG_STARFIVE_DSI
  // For DSI only?
  regmap_update_bits(dc-&gt;dss_regmap, 0x8, BIT(3), 1&lt;&lt;3);
#endif
</code></pre></div></li>
<li>
<p>Call dc_hw_init</p>
</li>
</ol>
<p>TODO: Pic of vs_dc_enable</p>
<h2 id="vs_dc_enable"><a href="#vs_dc_enable">13.3 vs_dc_enable</a></h2>
<p>TODO</p>
<p><a href="https://github.com/starfive-tech/linux/blob/JH7110_VisionFive2_devel/drivers/gpu/drm/verisilicon/vs_dc.c#L740-L827">vs_dc_enable</a> (from Display Controller Driver)</p>
<ol>
<li>
<p>Enable Clock dc_vout_clk</p>
</li>
<li>
<p>Deassert DC8200 Reset</p>
</li>
<li>
<p>Enable Clock vout_top_lcd</p>
</li>
<li>
<p>Update the DSS Registers with this Mystery Code:</p>
<div class="example-wrap"><pre class="language-c"><code>regmap_update_bits(dc-&gt;dss_regmap, 0x4, BIT(20), 1&lt;&lt;20);
regmap_update_bits(dc-&gt;dss_regmap, 0x8, BIT(3), 1&lt;&lt;3);
</code></pre></div>
<p>(Similar to dc_init)</p>
</li>
<li>
<p>Call dc_hw_init</p>
</li>
<li>
<p>Set the Display Struct: Bus Format, Horz Sync, Vert Sync, Sync Mode, Background Colour, Sync Enable and Dither Enable</p>
</li>
<li>
<p>If Display is MIPI DSI: Set the Clock Rate for dc8200_pix0, dc8200_clk_pix1 and vout_top_lcd</p>
</li>
<li>
<p>If Display is HDMI: Set the Clock hdmitx0_pixelclk</p>
</li>
<li>
<p>Call dc_hw_setup_display</p>
</li>
</ol>

    
</body>
</html>