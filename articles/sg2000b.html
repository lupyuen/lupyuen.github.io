<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)" 
    data-rh="true">
<meta property="og:description" 
    content=""
    data-rh="true">
<meta name="description" 
    content="">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/sg2000b-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<link rel="canonical"
    href="https://lupyuen.codeberg.page/articles/sg2000b.html" />
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
    <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">RISC-V Emulator for Sophgo SG2000 SoC (Pine64 Oz64 / Milk-V Duo S)</h1>
    <nav id="TOC"><ul>
<li><a href="#update-the-memory-map">1 Update the Memory Map</a><ul></ul></li>
<li><a href="#auipc-overflow-in-boot-code">2 <code>auipc</code> Overflow in Boot Code</a><ul></ul></li>
<li><a href="#change-auipc-to-li-in-boot-code">3 Change <code>auipc</code> to <code>li</code> in Boot Code</a><ul></ul></li>
<li><a href="#emulate-the-16550-uart-controller">4 Emulate the 16550 UART Controller</a><ul></ul></li>
<li><a href="#emulate-the-uart-output-registers">5 Emulate the UART Output Registers</a><ul></ul></li>
<li><a href="#emulate-the-uart-input-registers">6 Emulate the UART Input Registers</a><ul></ul></li>
<li><a href="#uart-input-triggers-segfault">7 UART Input triggers SegFault</a><ul></ul></li>
<li><a href="#increase-tinyemu-irqs-from-32-to-64">8 Increase TinyEMU IRQs from 32 to 64</a><ul></ul></li>
<li><a href="#emulate-the-sg2000-peripherals">9 Emulate the SG2000 Peripherals</a><ul></ul></li>
<li><a href="#daily-automated-testing">10 Daily Automated Testing</a><ul></ul></li>
<li><a href="#whats-next">11 What‚Äôs Next</a><ul></ul></li></ul></nav><p>üìù <em>7 Jul 2024</em></p>
<p><img src="https://lupyuen.github.io/images/sg2000b-title.jpg" alt="TODO" /></p>
<p>Recently we created a RISC-V Emulator for <strong>Ox64 BL808 SBC</strong>. We built it by customising <strong>TinyEMU RISC-V Emulator</strong> (not the small flightless bird)‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/tinyemu3"><strong>‚ÄúAutomated Testing with Ox64 BL808 Emulator‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://youtu.be/JlEo3lfi0CU"><strong>Watch the Presentation (YouTube)</strong></a></p>
</li>
</ul>
<p>Can we create a RISC-V Emulator for <a href="TODO"><strong>Sophgo SG2000 SoC</strong></a>? So we can run Daily Automated Tests for <a href="TODO"><strong>Pine64 Oz64 SBC</strong></a> and <a href="TODO"><strong>Milk-V Duo S SBC</strong></a>?</p>
<ol>
<li>
<p>We take <strong>TinyEMU Emulator</strong> for Ox64 BL808 SBC</p>
</li>
<li>
<p>Update its <strong>RISC-V Memory Map</strong> to match Sophgo SG2000 SoC</p>
</li>
<li>
<p>TODO</p>
</li>
</ol>
<p>TODO: <a href="https://github.com/lupyuen2/sg2000-emulator">sg2000-emulator</a></p>
<p>TODO: Let‚Äôs create a Software Emulator for Sophgo SG2000 SoC and Milk-V Duo S SBC! It runs every day for our <a href="https://github.com/lupyuen/nuttx-sg2000#nuttx-automated-daily-build-for-sg2000">Daily Automated Testing</a> of Apache NuttX RTOS for SG2000.</p>
<h1 id="update-the-memory-map"><a class="doc-anchor" href="#update-the-memory-map">¬ß</a>1 Update the Memory Map</h1>
<p>We begin with the <a href="https://lupyuen.github.io/articles/tinyemu3"><strong>TinyEMU RISC-V Emulator</strong></a> for Ox64 BL808 SBC. And we tweak it for SG2000.</p>
<p>This is how we update the <strong>RISC-V Memory Map</strong> for SG2000: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/d36190c63c1db116a206a26f3bc27dfacf5c8298">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Base Addresss of System RAM, Core Local Interrupt Controller (unused)
// And Platform-Level Interrupt Controller
#define RAM_BASE_ADDR   0x80200000ul
#define CLINT_BASE_ADDR 0x74000000ul
#define PLIC_BASE_ADDR  0x70000000ul
</code></pre></div>
<p>Then we build and run TinyEMU‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## Build SG2000 Emulator for macOS
## For Linux: See https://github.com/lupyuen/nuttx-sg2000/blob/main/.github/workflows/sg2000-test.yml#L29-L45
cd $HOME
git clone https://github.com/lupyuen2/sg2000-emulator
cd $HOME/sg2000-emulator
make clean
make \
  CFLAGS=&quot;-I$(brew --prefix)/opt/openssl/include -I$(brew --prefix)/opt/sdl2/include&quot; \
  LDFLAGS=&quot;-L$(brew --prefix)/opt/openssl/lib -L$(brew --prefix)/opt/sdl2/lib&quot; \
  CONFIG_MACOS=y

## Build NuttX for SG2000
## https://lupyuen.github.io/articles/sg2000#appendix-build-nuttx-for-sg2000
cd $HOME/nuttx
tools/configure.sh milkv_duos:nsh
make
## Omitted: Create the `Image` file for SG2000 NuttX

## Boot TinyEMU with NuttX for SG2000
cd $HOME/nuttx
wget https://raw.githubusercontent.com/lupyuen/nuttx-sg2000/main/nuttx.cfg
$HOME/sg2000-emulator/temu nuttx.cfg
</code></pre></div>
<p>TODO: Pic of crash</p>
<p>Our Emulator crashes at a strange address‚Ä¶</p>
<h1 id="auipc-overflow-in-boot-code"><a class="doc-anchor" href="#auipc-overflow-in-boot-code">¬ß</a>2 <code>auipc</code> Overflow in Boot Code</h1>
<p>When we <strong>Boot our Emulator</strong> with SG2000 NuttX, it crashes‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg

TinyEMU Emulator for Sophgo SG2000 SoC
raise_exception2:
  cause=1
  tval= 0xffffffff_80200000
  pc=   0xffffffff_80200000

tinyemu:
  Illegal instruction, quitting
</code></pre></div>
<p><em>What just happened?</em></p>
<p>Our Emulator tried to execute the code at MTVAL <em>0xffffffff_80200000</em>. And crashed because it‚Äôs <strong>not a valid address!</strong></p>
<p><em>0xffffffff_80200000</em> looks sus, it seems related to <strong>RAM Base Address</strong> <em>0x80200000</em>.</p>
<p><em>Our Emulator is booting the wrong address?</em></p>
<p>We check the <strong>Original TinyEMU</strong> Boot Code: <a href="https://github.com/fernandotcl/TinyEMU/blob/master/riscv_machine.c#L857-L861">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // `q` points to the Boot Code
  q = (uint32_t *)(ram_ptr + 0x1000);

  // Load `RAM_BASE_ADDR` into Register T0:
  // `auipc t0, RAM_BASE_ADDR`
  // `RAM_BASE_ADDR` is 0x80000000
  q[0] = 0x297 + RAM_BASE_ADDR - 0x1000;

  // Later: Jump to Register T0
</code></pre></div>
<p>To load the <strong>RAM Base Address</strong> into Register T0: TinyEMU tries to assemble this RISC-V Instruction (into our Boot Code)‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>auipc t0, 0x80200000
</code></pre></div>
<p><em>Maybe auipc has a problem?</em></p>
<p>We verify with the <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a>.</p>
<p>When we assemble the <strong><code>auipc</code></strong> instruction above, the Online Assembler fails with an error‚Ä¶</p>
<div class="example-wrap"><pre class="language-yaml"><code>Error: lui expression not in range 0..1048575
Error: value of 0000080200000000 too large
  for field of 4 bytes at 0000000000000000
</code></pre></div>
<p>Aha <em>0x80200000</em> is too big to assemble as an <strong><code>auipc</code> Address!</strong></p>
<p><em>But 0x80200000 is a perfectly valid address?</em></p>
<p>Remember that RISC-V is a <strong>RISC Platform</strong> after all. Some operations won‚Äôt fit into 4 bytes of Machine Code.</p>
<p>We upsize to 8 bytes of Machine Code‚Ä¶</p>
<p>TODO: Pic of RISC-V Online Assembler</p>
<h1 id="change-auipc-to-li-in-boot-code"><a class="doc-anchor" href="#change-auipc-to-li-in-boot-code">¬ß</a>3 Change <code>auipc</code> to <code>li</code> in Boot Code</h1>
<p>We load <em>0x80200000</em> into Register t0 in another way, with the <strong><code>li</code> Instruction</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>li  t0, 0x80200000
</code></pre></div>
<p>When we feed this above into <a href="https://riscvasm.lucasteske.dev/#"><strong>RISC-V Online Assembler</strong></a>, we see the resulting (8-byte) <strong>Machine Code</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>4010029b  addiw  t0, zero, 1025
01529293  slli   t0, t0,   0x15
</code></pre></div>
<p>That‚Äôs because <strong><code>li</code></strong> is a Pseudo-Instruction that expands into two RISC-V Instructions‚Ä¶</p>
<ul>
<li>
<p><strong><code>addiw</code></strong>: Add zero to <code>1025</code> and store into T0</p>
</li>
<li>
<p><strong><code>slli</code></strong>: Shift-Left T0 by <code>0x15</code> bits</p>
</li>
<li>
<p>Producing: <code>1025</code> &lt;&lt; <code>0x15</code> = <code>0x8020_0000</code></p>
</li>
</ul>
<p>Thus we copy the above Machine Code into our TinyEMU Boot Code: <a href="https://github.com/lupyuen2/sg2000-emulator/commit/b2d5cf63c5d6d1d0d4eafa5d400216d1f76a6e21">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// Init the TinyEMU Boot Code
static void copy_bios(...) {
  ...
  // Load `RAM_BASE_ADDR` into Register T0:
  // `li  t0, 0x80200000`
  // Which is assembled as...
  q[pc++] = 0x4010029b;  // addiw t0, zero, 1025
  q[pc++] = 0x01529293;  // slli  t0, t0,   0x15

  // TODO: Remove the hardcoding of 0x80200000
</code></pre></div>
<p>Our Emulator now boots NuttX correctly at <em>0x80200000</em>!</p>
<p>TODO: Pic of Supervisor Mode</p>
<p><em>So TinyEMU will jump directly to 0x80200000?</em></p>
<p>Not quite. TinyEMU boots in <strong>RISC-V Machine Mode</strong>, but NuttX expects to boot in <a href="TODO"><strong>RISC-V Supervisor Mode</strong></a>!</p>
<p>That‚Äôs why we customised the TinyEMU Boot Code, so that it jumps from Machine Mode to Supervisor Mode via the <a href="TODO"><strong>MRET Instruction</strong></a>.</p>
<p>(Which will start NuttX at <em>0x80200000</em>)</p>
<p>TODO: Pic of UART Emulator</p>
<h1 id="emulate-the-16550-uart-controller"><a class="doc-anchor" href="#emulate-the-16550-uart-controller">¬ß</a>4 Emulate the 16550 UART Controller</h1>
<p><em>Nothing appears when we boot NuttX?</em></p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg

TinyEMU Emulator for Sophgo SG2000 SoC
(...crickets...)
</code></pre></div>
<p>That‚Äôs because we haven‚Äôt emulated the <strong>16550 UART Controller</strong> in TinyEMU!</p>
<p>To figure out what‚Äôs needed, we refer to the <strong>16550 UART Driver</strong> in NuttX: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L1602-L1671">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// To send one byte to UART Output...
void u16550_send(struct uart_dev_s *dev, int ch) {
  ...
  // We write the byte to the 16550 UART Register...
  u16550_serialout(
    priv,             // UART Device
    UART_THR_OFFSET,  // UART Register: Transmit Holding Register (THR)
    ch                // Byte to be sent
  );
}

// To check if the UART Transmit FIFO is ready...
bool u16550_txready(struct uart_dev_s *dev) {
  ...
  // We read the 16550 UART Register...
  return ((
    u16550_serialin(
      priv,            // UART Device
      UART_LSR_OFFSET  // UART Register: Line Status Register (LSR)
    ) &amp; UART_LSR_THRE  // And check the THRE Bit (Transmit Holding Register Empty)
  ) != 0);
}
</code></pre></div>
<p>Which says that‚Ä¶</p>
<ul>
<li>
<p><strong>UART_THR</strong>: Transmit Holding Register</p>
<p>Will receive the byte that NuttX is transmitting</p>
</li>
<li>
<p><strong>UART_LSR</strong>: Line Status Register</p>
<p>Will be read by NuttX to check if the Transmit FIFO is Empty</p>
</li>
<li>
<p><strong>UART_LSR_THRE</strong>: Transmit Holding Register Empty</p>
<p>This is the bit in <strong>UART_LSR</strong> that will indicate whether Transmit FIFO is Empty</p>
</li>
</ul>
<p>Let‚Äôs emulate the above in TinyEMU‚Ä¶</p>
<p>TODO: Pic of UART Output Registers</p>
<h1 id="emulate-the-uart-output-registers"><a class="doc-anchor" href="#emulate-the-uart-output-registers">¬ß</a>5 Emulate the UART Output Registers</h1>
<p><em>How will we emulate the 16550 UART Registers in TinyEMU?</em></p>
<p>When TinyEMU needs to Read or Write a Memory Address, it will call the functions below.</p>
<p>This is how we <strong>Intercept the Memory Writes</strong> to emulate the <strong>UART Output Register</strong> (Transmit Holding): <a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L536-L550">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Writes
int target_write_slow(...) {
  ...
  // If TinyEMU is writing to this address...
  switch(paddr) {

    // Address is UART Transmit Holding Register
    case UART0_BASE_ADDR + UART_THR_OFFSET:

      // Print the character that&#39;s written by NuttX
      char buf[1] = { val };
      print_console(NULL, buf, 1);
</code></pre></div>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411">(<strong>UART Addresses</strong> are here)</a></p>
<p>And this is how we <strong>Intercept the Memory Reads</strong> to emulate the <strong>UART Status Register</strong> (Line Status): <a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L390-L420">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Reads
int target_read_slow(...) {
  ...
  // If TinyEMU is reading from this address...
  switch(paddr) {

    // Address is UART Line Status Register
    case UART0_BASE_ADDR + UART_LSR_OFFSET:

      // Always tell NuttX that
      // Transmit Holding Register is Empty
      ret = UART_LSR_THRE;

      // If UART Input is available:
      // Tell NuttX that Receive Data is Available
      if (read_input() != 0) {
        ret |= UART_LSR_DR;
      }
</code></pre></div>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L395-L411">(<strong>UART Addresses</strong> are here)</a></p>
<p>(More about UART Input in a while)</p>
<p><em>What happens when we run this?</em></p>
<p>Now we see the NuttX Shell yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg 

TinyEMU Emulator for Sophgo SG2000 SoC
NuttShell (NSH) NuttX-12.5.1
nsh&gt;
</code></pre></div>
<p>Next we fix the UART Input‚Ä¶</p>
<p>TODO: Pic of UART Input Registers</p>
<h1 id="emulate-the-uart-input-registers"><a class="doc-anchor" href="#emulate-the-uart-input-registers">¬ß</a>6 Emulate the UART Input Registers</h1>
<p><em>What about UART Input? How to emulate the UART Registers?</em></p>
<p>Again we refer to the <strong>NuttX Driver</strong> for 16550 UART, to discover the inner workings of UART Input: <a href="https://github.com/apache/nuttx/blob/master/drivers/serial/uart_16550.c#L979-L1282">uart_16550.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// NuttX Interrupt Handler for 16550 UART
int u16550_interrupt(int irq, FAR void *context, FAR void *arg) {
  ...
  // Loop until no characters to be transferred
  for (passes = 0; passes &lt; 256; passes++) {

    // Get the current UART Status
    status = u16550_serialin(priv, UART_IIR_OFFSET);

    // If no Pending Interrupts, exit
    if ((status &amp; UART_IIR_INTSTATUS) != 0) { break; }

    // Handle the UART Interrupt
    switch (status &amp; UART_IIR_INTID_MASK) {

      // If UART Input is available,
      // receive the Input Data
      case UART_IIR_INTID_RDA:
        uart_recvchars(dev);
        break;
  ...
}

// Receive one character from UART.
// Called by the above Interrupt Handler.
int u16550_receive(struct uart_dev_s *dev, unsigned int *status) {
  ...
  // Return the Line Status and Receive Buffer
  *status = u16550_serialin(priv, UART_LSR_OFFSET);
  rbr     = u16550_serialin(priv, UART_RBR_OFFSET);
  return rbr;
}
</code></pre></div>
<p>Which says that‚Ä¶</p>
<ul>
<li>
<p><strong>UART_IIR</strong>: Interrupt ID Register</p>
<p>Should return <strong>INTID_RDA</strong> (data available)</p>
<p>Followed by <strong>IIR_INTSTATUS</strong> (no more data)</p>
</li>
<li>
<p><strong>UART_LSR</strong>: Line Status Register</p>
<p>Should return <strong>LSR_DR</strong> (data available)</p>
<p>Followed by 0 (no more data)</p>
</li>
<li>
<p><strong>UART_RBR</strong>: Receiver Buffer Register</p>
<p>Should return the UART Input Data</p>
</li>
</ul>
<p>Thus we emulate the above UART Registers in TinyEMU: <a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L421-L444">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Reads
int target_read_slow(...) {
  ...
  // If TinyEMU is reading from this address...
  switch(paddr) {

    // Address is UART Interrupt ID Register
    case UART0_BASE_ADDR + UART_IIR_OFFSET:

      // If the Input Buffer is Empty:
      // Then Receive Data is NOT Available
      if (read_input() == 0) {
        ret = UART_IIR_INTSTATUS;
      } else {
        // Otherwise Receive Data is Available
        ret = UART_IIR_INTID_RDA;
      }
      break;

    // Address is UART Receive Buffer Register
    case UART0_BASE_ADDR + UART_RBR_OFFSET:

      // Return the Input Buffer
      ret = read_input();

      // Clear the Input Buffer and UART Interrupt
      set_input(0);
      virtio_ack_irq(NULL);
      break;
</code></pre></div>
<p><a href="TODO">(<strong>virtio_ack_irq</strong> is here)</a></p>
<p><em>What about UART_LSR? (Line Status Register)</em></p>
<p>Check out our earlier implementation of <a href="TODO"><strong>target_read_slow</strong></a>.</p>
<p>TODO: Pic of Seg Fault</p>
<h1 id="uart-input-triggers-segfault"><a class="doc-anchor" href="#uart-input-triggers-segfault">¬ß</a>7 UART Input triggers SegFault</h1>
<p><em>So UART Input is all hunky dory?</em></p>
<p>Not quite. When we press a key: TinyEMU crashes with a <strong>Segmentation Fault</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg    

NuttShell (NSH) NuttX-12.5.1
nsh&gt; 
[1] segmentation fault
</code></pre></div>
<p><em>Maybe we got the Wrong Interrupt Number for UART?</em></p>
<p>We check our <a href="TODO"><strong>NuttX Config</strong></a>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## NuttX IRQ for UART0 is 69
CONFIG_16550_UART0_IRQ=69
</code></pre></div>
<ul>
<li>
<p><a href="TODO"><strong>NuttX IRQ Offset</strong></a> is <strong>25</strong></p>
</li>
<li>
<p>Which means <strong>Actual RISC-V IRQ</strong> is 69 - 25 = <strong>44</strong></p>
</li>
<li>
<p>Which matches the <a href="https://github.com/sophgo/sophgo-doc/releases"><strong>SG2000 Reference Manual</strong></a> (Page 13)‚Ä¶</p>
<blockquote>
<p><em><strong>3.1 Interrupt Subsystem</strong></em></p>
</blockquote>
<blockquote>
<p><em><strong>Int #44:</strong> UART0</em></p>
</blockquote>
</li>
<li>
<p>And matches the <strong>VirtIO IRQ</strong> in TinyEMU: <a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_machine.c#L146-L158">riscv_machine.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>#define VIRTIO_IRQ 44  // UART0 IRQ
</code></pre></div></li>
</ul>
<p>Something seriously sinister is wrecking our rojak‚Ä¶</p>
<p>TODO: Pic of TinyEMU IRQs</p>
<h1 id="increase-tinyemu-irqs-from-32-to-64"><a class="doc-anchor" href="#increase-tinyemu-irqs-from-32-to-64">¬ß</a>8 Increase TinyEMU IRQs from 32 to 64</h1>
<p>After <a href="TODO"><strong>lots of headscratching</strong></a>: We discover that TinyEMU supports only <strong>32 RISC-V External Interrupts</strong>‚Ä¶ Which is too few for our UART Controller! (IRQ 44)</p>
<p>TODO: 32 IRQs in TinyEMU</p>
<p>So we increase the TinyEMU IRQs from 32 to 64‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/commit/c6ce6bdbbdaf7585ce18f77b2b2f25a2317914be"><strong>Increase the IRQs from 32 to MAX_IRQ</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_machine.c#L45-L48"><strong>Set MAX_IRQ to 64</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen2/sg2000-emulator/commit/78ac3ad75f1ec0b54f5bee10488731c7a21fb9ea"><strong>Increase the IRQ Size from 32-bit to 64-bit</strong></a></p>
</li>
</ul>
<p>Finally it works OK yay!</p>
<div class="example-wrap"><pre class="language-bash"><code>$ sg2000-emulator/temu nuttx.cfg

TinyEMU Emulator for Sophgo SG2000 SoC
virtio_console_init
Patched DCACHE.IALL (Invalidate all Page Table Entries in the D-Cache) at 0x80200a28
Patched SYNC.S (Ensure that all Cache Operations are completed) at 0x80200a2c
Found ECALL (Start System Timer) at 0x8020b2c6
Patched RDTIME (Read System Time) at 0x8020b2cc
elf_len=0
virtio_console_resize_event
ABC
NuttShell (NSH) NuttX-12.5.1
nsh&gt; uname -a
NuttX 12.5.1 50fadb93f2 Jun 18 2024 09:20:31 risc-v milkv_duos
nsh&gt; 
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/ac80b426f67ad38f6a59ae563b0ecb9f">(<strong>OSTest</strong> works OK too)</a></p>
<p><em>SG2000 Emulator seems slower than Ox64 BL808 Emulator?</em></p>
<p>Yeah probably because SG2000 runs on <a href="https://github.com/lupyuen2/wip-nuttx/commit/bb4906c976e44a05237f91944844cd1c68ef5d5b">MTIMER_FREQ of 25000000</a>.</p>
<p>When we execute <code>sleep 10</code>, it completes in 25 seconds. We might need to adjust the TinyEMU System Timer.</p>
<p>(CPU-bound operations like <code>getprime</code> won‚Äôt have this timing delay)</p>
<p>TODO: Pic of Simulated LED</p>
<h1 id="emulate-the-sg2000-peripherals"><a class="doc-anchor" href="#emulate-the-sg2000-peripherals">¬ß</a>9 Emulate the SG2000 Peripherals</h1>
<p><em>Our SG2000 Emulator looks incomplete?</em></p>
<p>Yeah we need to emulate the <strong>SG2000 Peripherals!</strong> GPIO, I2C, SPI, ‚Ä¶</p>
<p>Based on the <a href="TODO"><strong>SG2000 Reference Manual</strong></a>: We will probably emulate GPIO like this: <a href="https://github.com/lupyuen2/sg2000-emulator/blob/main/riscv_cpu.c#L551-L562">riscv_cpu.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>// TinyEMU calls this function to execute Memory Writes
int target_write_slow(...) {
  ...
  // If TinyEMU is writing to this address...
  switch(paddr) {

    // Address is GPIOA Base Address
    // with Offset 0 (GPIO_SWPORTA_DR)
    case 0x03020000: 

      // Check if GPIOA1 is Off or On (Bit 1)
      // `val` is the value written by NuttX to 0x03020000
      const uint8_t gpio = 1;
      const uint32_t mask = (1 &lt;&lt; gpio);
      const char b =
        ((val &amp; mask) == 0)
        ? &#39;0&#39; : &#39;1&#39;;

      // Send an Emulator Notification to the Console: 
      // {&quot;nuttxemu&quot;:{&quot;gpioa1&quot;:1}}
      char notify[] = &quot;{\&quot;nuttxemu\&quot;:{\&quot;gpioa1\&quot;:0}}\r\n&quot;;
      notify[strlen(notify) - 5] = b;
      print_console(NULL, notify, strlen(notify));
</code></pre></div>
<p><em>What‚Äôs this nuttxemu?</em></p>
<p><strong><code>nuttxemu</code></strong> will be printed on the TinyEMU Console to notify the caller that GPIOA1 is set to On or Off.</p>
<p>When we run TinyEMU in a Web Browser (via WebAssembly), our Web Browser can intercept this notification and visualise a <a href="TODO"><strong>Simulated LED on GPIOA1</strong></a>.</p>
<p>TODO: Pic of Daily Automated Testing</p>
<h1 id="daily-automated-testing"><a class="doc-anchor" href="#daily-automated-testing">¬ß</a>10 Daily Automated Testing</h1>
<p><em>Why are we doing all this?</em></p>
<ol>
<li>
<p>SG2000 Emulator will be helpful for testing <strong>NuttX Drivers and App</strong>, without a Real SBC</p>
</li>
<li>
<p>We‚Äôre running SG2000 Emulator for <strong>Daily Automated Testing</strong> at GitHub Actions: <a href="https://github.com/lupyuen/nuttx-sg2000/blob/main/.github/workflows/sg2000-test.yml">sg2000-test.yml</a></p>
</li>
</ol>
<div class="example-wrap"><pre class="language-bash"><code>## Checkout the Source Files
git clone https://github.com/lupyuen2/sg2000-emulator

## Build the SG2000 Emulator
cd sg2000-emulator
make
cp temu ..

## Download the NuttX Daily Build and Test Script
wget https://github.com/lupyuen/nuttx-sg2000/releases/download/nuttx-sg2000-$date/Image
wget https://github.com/lupyuen/nuttx-sg2000/releases/download/nuttx-sg2000-$date/nuttx.hash
wget https://github.com/lupyuen/nuttx-sg2000/raw/main/nuttx.cfg
wget https://github.com/lupyuen/nuttx-sg2000/raw/main/nuttx.exp

## Run the NuttX Test
chmod +x nuttx.exp
./nuttx.exp
</code></pre></div>
<p>Which calls this <strong>Expect Script</strong> to execute <strong>OSTest</strong> (and validate everything in NuttX): <a href="https://github.com/lupyuen/nuttx-sg2000/blob/main/nuttx.exp">nuttx.exp</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#!/usr/bin/expect
## Expect Script for Testing NuttX with SG2000 Emulator

## Wait at most 300 seconds
set timeout 300

## For every 1 character sent, wait 0.01 milliseconds
set send_slow {1 0.01}

## Start the SG2000 Emulator
spawn ./temu nuttx.cfg

## Wait for the prompt and enter `uname -a`
expect &quot;nsh&gt; &quot;
send -s &quot;uname -a\r&quot;

## Wait for the prompt and enter `ostest`
expect &quot;nsh&gt; &quot;
send -s &quot;ostest\r&quot;

## Check the response...
expect {
  ## If we see this message, exit normally
  &quot;ostest_main: Exiting with status 0&quot; { exit 0 }

  ## If timeout, exit with an error
  timeout { exit 1 }
}
</code></pre></div>
<p><em>Isn‚Äôt it safer to run Daily Tests on a Real SG2000 SBC?</em></p>
<p>Oh yes we‚Äôre doing it too! Check out the article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/sg2000a"><strong>‚ÄúDaily Automated Testing for Milk-V Duo S RISC-V SBC (IKEA TRETAKT / Apache NuttX RTOS)‚Äù</strong></a></li>
</ul>
<p>TODO: Pic of IKEA</p>
<h1 id="whats-next"><a class="doc-anchor" href="#whats-next">¬ß</a>11 What‚Äôs Next</h1>
<p>TODO: SoC Makers please provide an Emulator!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> (and the awesome NuttX Community) for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-sg2000"><strong>My Current Project: ‚ÄúApache NuttX RTOS for Sophgo SG2000‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-ox64"><strong>My Other Project: ‚ÄúNuttX for Ox64 BL808‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx-star64"><strong>Older Project: ‚ÄúNuttX for Star64 JH7110‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>Olderer Project: ‚ÄúNuttX for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/sg2000b.md"><strong>lupyuen.github.io/src/sg2000b.md</strong></a></p>

    
    <!-- Begin scripts/rustdoc-after.html: Post-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker and Prism Theme -->
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker and Prism Theme -->

    <!-- End scripts/rustdoc-after.html -->
    

</body>
</html>