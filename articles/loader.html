<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>BL602 EFlash Loader: Reverse Engineered with Ghidra</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="BL602 EFlash Loader: Reverse Engineered with Ghidra" 
    data-rh="true">
<meta property="og:description" 
    content="What's inside the EFlash Loader that flashes all firmware to the BL602 RISC-V SoC"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/loader-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">BL602 EFlash Loader: Reverse Engineered with Ghidra</h1>
    <nav id="TOC"><ul>
<li><a href="#about-eflash-loader">1 About EFlash Loader</a><ul>
<li><a href="#thank-you-elf">1.1 Thank You ELF</a><ul></ul></li></ul></li>
<li><a href="#decompile-with-ghidra">2 Decompile with Ghidra</a><ul>
<li><a href="#export-to-c">2.1 Export To C</a><ul></ul></li>
<li><a href="#rv32gc-vs-rv32imacf">2.2 RV32GC vs RV32IMACF</a><ul></ul></li></ul></li>
<li><a href="#decompiled-main-function">3 Decompiled Main Function</a><ul>
<li><a href="#call-graph">3.1 Call Graph</a><ul></ul></li></ul></li>
<li><a href="#decompiled-main-loop">4 Decompiled Main Loop</a><ul>
<li><a href="#execute-flashing-command">4.1 Execute Flashing Command</a><ul></ul></li></ul></li>
<li><a href="#decipher-flashing-commands">5 Decipher Flashing Commands</a><ul>
<li><a href="#list-of-flashing-commands">5.1 List of Flashing Commands</a><ul></ul></li></ul></li>
<li><a href="#flashing-states">6 Flashing States</a><ul></ul></li>
<li><a href="#match-flashing-states-and-commands">7 Match Flashing States and Commands</a><ul></ul></li>
<li><a href="#flash-program">8 Flash Program</a><ul>
<li><a href="#write-to-flash">8.1 Write To Flash</a><ul></ul></li></ul></li>
<li><a href="#how-the-train-goes">9 How The Train Goes</a><ul></ul></li>
<li><a href="#whats-next">10 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">11 Notes</a><ul></ul></li></ul></nav><p>üìù <em>2 Feb 2022</em></p>
<p><img src="https://lupyuen.github.io/images/loader-title.jpg" alt="Pine64 PineDio Stack BL604 RISC-V Board" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><em>Pine64 PineDio Stack BL604 RISC-V Board</em></a></p>
<p>Something special happens when we <strong>flash firmware</strong> to <a href="https://lupyuen.github.io/articles/pinecone"><strong>BL602 and BL604</strong></a> RISC-V boards‚Ä¶</p>
<p>It starts a tiny program <strong>inside the board</strong> to make flashing possible: The <strong>EFlash Loader</strong>.</p>
<p>Step by step we shall <strong>uncover what‚Äôs inside</strong> EFlash Loader, thanks to <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a> the popular tool for Software Reverse Engineering.</p>
<p><em>Why are we doing this?</em></p>
<ul>
<li>
<p>EFlash Loader is a critical part of the <strong>Flashing Process</strong></p>
<p>(Good to understand how it works)</p>
</li>
<li>
<p><strong>No Source Code</strong> is available for EFlash Loader</p>
<p><a href="https://github.com/search?q=bflb_eflash_loader_cmd_write_flash&amp;type=code">(According to GitHub Code Search)</a></p>
</li>
<li>
<p>EFlash Loader is <strong>small</strong> (37 KB) and <strong>self-contained</strong></p>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">(32-bit RISC-V, specifically RV32IMACF)</a></p>
</li>
<li>
<p>EFlash Loader gets <strong>updated occasionally</strong>, so it‚Äôs good for us to see what‚Äôs changed</p>
</li>
</ul>
<p>This is my first time using Ghidra so this might be a fun and educational exercise!</p>
<p>(But please bear with my ignorance üôè)</p>
<p><img src="https://lupyuen.github.io/images/pinecone-jumperh.jpg" alt="Pine64 PineCone BL602 RISC-V Board" /></p>
<p><a href="https://lupyuen.github.io/articles/pinecone"><em>Pine64 PineCone BL602 RISC-V Board</em></a></p>
<h1 id="about-eflash-loader"><a href="#about-eflash-loader">1 About EFlash Loader</a></h1>
<p><em>How does EFlash Loader flash firmware to BL602?</em></p>
<p>Here‚Äôs what happens when we run a <strong>Firmware Flasher</strong> on our computer to flash BL602‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/loader-flow.jpg" alt="EFlash Loader Flow" /></p>
<ol>
<li>
<p>Firmware Flasher <strong>sends the EFlash Loader</strong> executable to BL602</p>
<p>(Via USB UART, in 4 KB chunks)</p>
</li>
<li>
<p>BL602 receives and <strong>starts the EFlash Loader</strong></p>
<p>(Assuming BL602 is in Flashing Mode)</p>
</li>
<li>
<p>Firmware Flasher <strong>sends the Flashing Image</strong> to EFlash Loader</p>
<p>(In 8 KB chunks)</p>
</li>
<li>
<p>EFlash Loader <strong>writes the Flashing Image</strong> to BL602‚Äôs Embedded Flash</p>
</li>
<li>
<p>Firmware Flasher verifies with EFlash Loader that the Flashing Image was <strong>written correctly</strong></p>
<p>(With SHA256 hashing)</p>
</li>
</ol>
<p>Flashing firmware to BL602 with <a href="https://github.com/spacemeowx2/blflash"><strong>blflash</strong></a> looks like this‚Ä¶</p>
<ul>
<li>
<p><a href="https://youtu.be/JtnOyl5cYjo"><strong>Watch the demo on YouTube</strong></a></p>
<p>(First 20 seconds)</p>
</li>
</ul>
<div class="example-wrap"><pre class="language-text"><code>$ blflash flash nuttx.bin  \
  --port /dev/ttyUSB0

Start connection...
5ms send count 55
handshake sent elapsed 252¬µs
Connection Succeed

Sending eflash_loader...
Finished 2s 11KiB/s

5ms send count 500
handshake sent elapsed 5ms
Entered eflash_loader

Erase flash addr: 10000 size: 346432
Program flash... 
Program done 4s 82KiB/s
Success
</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/release-2022-01-25">(Source)</a></p>
<p>We see that blflash sends the <strong>EFlash Loader</strong> to BL602, followed by the <strong>Flashing Image</strong>.</p>
<p>(Which gets written to BL602‚Äôs Embedded Flash by EFlash Loader)</p>
<p>We have Source Code for everything <strong>except EFlash Loader</strong>‚Ä¶ What‚Äôs really happening inside EFlash Loader?</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/loader-files.jpg" alt="ELF Executable for EFlash Loader" /></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/tree/master/flash_tool/chips/bl602/eflash_loader">(Source)</a></p>
</blockquote>
<h2 id="thank-you-elf"><a href="#thank-you-elf">1.1 Thank You ELF</a></h2>
<p><em>Can we uncover the inner workings of EFlash Loader?</em></p>
<p>Yes we can!</p>
<p>Bouffalo Lab (creator of BL602) has recently uploaded the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"><strong>ELF Executable</strong></a> for EFlash Loader (pic above). Which makes Reverse Engineering much easier.</p>
<p>(Because of the debugging symbols inside)</p>
<ul>
<li>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf"><strong>EFlash Loader ELF: eflash_loader.elf</strong></a></p>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/5fa118c59ef89adb319583ea277ea54e27d60fbb/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf">(Dated 17 Jan 2022)</a></p>
</li>
</ul>
<p>Let‚Äôs decompile the EFlash Loader ELF with Ghidra!</p>
<p><img src="https://lupyuen.github.io/images/loader-ghidra.jpg" alt="EFlash Loader decompiled with Ghidra" /></p>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf">(Source)</a></p>
<h1 id="decompile-with-ghidra"><a href="#decompile-with-ghidra">2 Decompile with Ghidra</a></h1>
<p>This is how we decompile the EFlash Loader ELF <a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf"><strong>eflash_loader.elf</strong></a> with <a href="https://ghidra-sre.org/"><strong>Ghidra</strong></a>‚Ä¶</p>
<ul>
<li><a href="https://youtu.be/3Ikn8Y775Lk"><strong>Watch the video on YouTube</strong></a></li>
</ul>
<p>(Works for any ELF file actually)</p>
<ol>
<li>
<p>Install <a href="https://adoptium.net/releases.html?variant=openjdk11&amp;jvmVariant=hotspot"><strong>Java Dev Kit (JDK) 11</strong></a> (64-bit)</p>
</li>
<li>
<p>Download a <a href="https://github.com/NationalSecurityAgency/ghidra/releases"><strong>Ghidra Release File</strong></a>.</p>
<p>Extract the Ghidra Release File.</p>
</li>
<li>
<p>Launch Ghidra‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>## For Linux and macOS
./ghidraRun

## For Windows
ghidraRun.bat
</code></pre></div></li>
<li>
<p>The <strong>Ghidra Help Window</strong> appears, with plenty of useful info that‚Äôs not available elsewhere.</p>
<p>Minimise the Ghidra Help Window for now.</p>
<p>(But remember to browse it when we have the time!)</p>
</li>
<li>
<p>In the <strong>Ghidra Main Window</strong>, click <strong>File</strong> ‚Üí <strong>New Project</strong></p>
<p>For <strong>Project Type</strong>: Select <strong>Non-Shared Project</strong></p>
<p>For <strong>Project Name</strong>: Enter <strong>‚ÄúMy Project‚Äù</strong></p>
</li>
<li>
<p>Click <strong>File</strong> ‚Üí <strong>Import File</strong></p>
<p>Select our ELF File: <a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf"><strong>eflash_loader.elf</strong></a></p>
</li>
<li>
<p>Ghidra detects that our RISC-V Executable is <strong>RV32GC</strong>.</p>
<p>Click <strong>OK</strong> and <strong>OK</strong> again.</p>
</li>
<li>
<p>Double-click our ELF File: <strong>eflash_loader.elf</strong></p>
<p>The <strong>CodeBrowser Window</strong> appears.</p>
<p>(With a dragon-like spectre)</p>
</li>
<li>
<p>When prompted to analyze, click <strong>Yes</strong> and <strong>Analyze</strong>.</p>
<p>Ignore the warnings.</p>
<p>(We‚Äôll browse the decompiled C code shortly)</p>
</li>
</ol>
<p>And we‚Äôre done with the decompilation! (Screenshot above)</p>
<p>In case of problems, check these docs‚Ä¶</p>
<ul>
<li>
<p><a href="https://htmlpreview.github.io/?https://github.com/NationalSecurityAgency/ghidra/blob/stable/GhidraDocs/InstallationGuide.html"><strong>‚ÄúGhidra Installation Guide‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://git.mst.edu/slbnmc/ici-wiki/-/wikis/Tool-Guides/An-Introduction-to-Ghidra"><strong>‚ÄúAn Introduction to Ghidra‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://github.com/NationalSecurityAgency/ghidra"><strong>Ghidra Repo</strong></a></p>
</li>
</ul>
<p>Also check the Ghidra Help Window that we have minimised.</p>
<p><img src="https://lupyuen.github.io/images/loader-export.png" alt="Export to C" /></p>
<h2 id="export-to-c"><a href="#export-to-c">2.1 Export To C</a></h2>
<p>Ghidra has decompiled our ELF File into C code. To <strong>export the C code</strong> to a file‚Ä¶</p>
<ol>
<li>
<p>In the <strong>CodeBrowser Window</strong>, click <strong>File</strong> ‚Üí <strong>Export Program</strong></p>
</li>
<li>
<p>For <strong>Format</strong>: Select <strong>C / C++</strong></p>
</li>
<li>
<p>Click <strong>OK</strong></p>
<p>(Pic above)</p>
</li>
</ol>
<p>We‚Äôll get a C Source File with roughly <strong>10,000 lines of code</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c"><strong>eflash_loader.c</strong></a></li>
</ul>
<p>Which is rather cumbersome to navigate, so we‚Äôll use the <strong>Ghidra CodeBrowser</strong> to browse our C code in a while.</p>
<h2 id="rv32gc-vs-rv32imacf"><a href="#rv32gc-vs-rv32imacf">2.2 RV32GC vs RV32IMACF</a></h2>
<p><em>Ghidra says our executable is RV32GC. Shouldn‚Äôt it be RV32IMACF?</em></p>
<p>BL602 Executables are compiled for the <strong>RV32IMACF</strong> RISC-V Instruction Set and Extensions‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">Designation</th><th style="text-align: left">Meaning</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong><code>RV32I</code></strong></td><td style="text-align: left">32-bit RISC-V with Base Integer Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>M</code></strong></td><td style="text-align: left">Integer Multiplication + Division</td></tr>
<tr><td style="text-align: center"><strong><code>A</code></strong></td><td style="text-align: left">Atomic Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>C</code></strong></td><td style="text-align: left">Compressed Instructions</td></tr>
<tr><td style="text-align: center"><strong><code>F</code></strong></td><td style="text-align: left">Single-Precision Floating-Point</td></tr>
</tbody></table>
</div>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">(Source)</a></p>
<p>Ghidra thinks our executable is <strong>RV32GC</strong>, which is all of the above plus <strong>Double-Precision Floating-Point</strong>.</p>
<p>That‚Äôs probably OK for our Reverse Engineering, since our executable won‚Äôt have any Double-Precision Floating-Point instructions.</p>
<p>(If we import an ESP32-C3 RISC-V ELF, will Ghidra say it‚Äôs RV32IMC? Lemme know!)</p>
<p><img src="https://lupyuen.github.io/images/loader-symboltree.png" alt="Ghidra Symbol Tree" /></p>
<h1 id="decompiled-main-function"><a href="#decompiled-main-function">3 Decompiled Main Function</a></h1>
<p>Let‚Äôs locate the <strong>Main Function</strong> in our decompiled code‚Ä¶</p>
<ol>
<li>
<p>In the <strong>CodeBrowser Window</strong>, look for the <strong>Symbol Tree Pane</strong> at left centre</p>
<p>(Pic above)</p>
</li>
<li>
<p>Expand <strong>‚ÄúFunctions‚Äù</strong></p>
</li>
<li>
<p>Double-click on <strong>‚Äúentry‚Äù</strong></p>
<p><a href="https://youtu.be/3Ikn8Y775Lk?t=61"><strong>Watch the video on YouTube</strong></a></p>
</li>
</ol>
<p><strong>entry</strong> is located at <code>0x2201 0000</code>, the start address of executable code. Thus it‚Äôs the <strong>first thing that runs</strong> when EFlash Loader starts.</p>
<p>In the <strong>Decompile Pane</strong> (pic above, right side), we see the decompiled code for the <strong>entry</strong> function: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2663-L2672">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  EFlash Loader starts here
void entry(void) {

  //  Init BL602 hardware
  SystemInit();

  //  Init BL602 memory
  start_load();

  //  Run the EFlash Loader
  main();
</code></pre></div>
<p>Aha we found the Main function! Double-click on <strong>‚Äúmain‚Äù</strong>.</p>
<p>The Decompile Pane jumps to the <strong>Main Function</strong>: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2803-L2863">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Main Function for EFlash Loader
int main(void) {
  //  Init BL602 Clock
  HBN_Set_ROOT_CLK_Sel(...);
  ...
  //  Init EFlash Loader
  bflb_eflash_loader_interface_init();
  bflb_set_low_speed_flash_clock();
  ...
  //  Init Embedded Flash
  SFlash_Init(...);
  bflb_spi_flash_init(...);
  SFlash_GetJedecId(...);
  SFlash_Qspi_Enable(...);
  ...
  //  Run the EFlash Loader
  bflb_eflash_loader_main();
</code></pre></div>
<p>The Decompiled Main Function is surprisingly readable (pic below). Kudos to the Ghidra Team!</p>
<p>This code suggests that all the exciting action happens inside <strong>bflb_eflash_loader_main</strong>. Which we‚Äôll examine in a while.</p>
<p><img src="https://lupyuen.github.io/images/loader-code.png" alt="Main Function" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2803-L2863">(Source)</a></p>
<h2 id="call-graph"><a href="#call-graph">3.1 Call Graph</a></h2>
<p><em>All this verbose code hurts my eyes. Can we browse the code graphically?</em></p>
<p>Yes we can! Follow these steps to render the <strong>Call Graph</strong> for our Decompiled Function‚Ä¶</p>
<ol>
<li>
<p>Click <strong>Graph</strong> ‚Üí <strong>Calls</strong></p>
</li>
<li>
<p>Click the <strong>Arrangement</strong> drop-down box</p>
<p>(Second drop-down from the right)</p>
</li>
<li>
<p>Select <strong>‚ÄúCompact Radial‚Äù</strong></p>
</li>
</ol>
<p>We‚Äôll see the Call Graph below. Which kinda suggests that something exciting happens inside <strong>bflb_eflash_loader_main</strong>.</p>
<p>Let‚Äôs go there now!</p>
<p><img src="https://lupyuen.github.io/images/loader-call.png" alt="Call Graph" /></p>
<h1 id="decompiled-main-loop"><a href="#decompiled-main-loop">4 Decompiled Main Loop</a></h1>
<p>Let‚Äôs continue the trail from the Main Function.</p>
<p>In the <strong>Decompile Pane</strong> (right pane), double-click on <strong>bflb_eflash_loader_main</strong>.</p>
<p>Inside the decompiled function we see a loop that <strong>receives and executes Flashing Commands</strong>: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L4031-L4108">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Main Loop for EFlash Loader
int32_t bflb_eflash_loader_main(void) {    
  //  Do Handshake
  do {
    i = boot_if_handshake_poll(...);
  } while (i == 0xfffe);

  //  If Handshake is OK...
  if (i == 0) {

    //  Init Flashing Commands
    bflb_eflash_loader_cmd_init();

NextCommand:
    do {
      //  Receive Flashing Command over UART
      do {
        boot_if_recv(...);
      } while (...);

      //  Execute Flashing Command
      i = bflb_eflash_loader_cmd_process(...);

      //  Process next command
      goto NextCommand;

    } while (...);
  }
}
</code></pre></div>
<p>The code above calls <strong>bflb_eflash_loader_cmd_process</strong> to execute the Flashing Command received over UART (from the Firmware Flasher).</p>
<p>Let‚Äôs find out how it executes Flashing Commands.</p>
<p><img src="https://lupyuen.github.io/images/loader-code2.png" alt="Main Loop" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L4031-L4108">(Source)</a></p>
<h2 id="execute-flashing-command"><a href="#execute-flashing-command">4.1 Execute Flashing Command</a></h2>
<p>Double-click on <strong>bflb_eflash_loader_cmd_process</strong>. This code appears: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3814-L3844">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Execute a Flashing Command with the specified Command ID and parameters
int32_t bflb_eflash_loader_cmd_process(uint8_t cmdid, uint8_t *data, uint16_t len) {
  
  //  Omitted: Lookup the Command ID 
  //  in list of Flashing Commands
  ...

  //  If Flashing Command is enabled...
  if (eflash_loader_cmds[i].enabled == 1 &amp;&amp; ...) {
    
    //  Execute the Flashing Command
    ret = (*eflash_loader_cmds[i].cmd_process)();
    return ret;
  }
</code></pre></div>
<p>Interesting! We see that EFlash Loader has a list of Flashing Commands: <strong>eflash_loader_cmds</strong>.</p>
<p>The code above looks up <strong>eflash_loader_cmds</strong> for the Flashing Command (by Command ID).  And executes the command by calling <strong>cmd_process</strong>.</p>
<p><img src="https://lupyuen.github.io/images/loader-code3.png" alt="Execute Flashing Command" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3814-L3844">(Source)</a></p>
<p>What are the Flashing Commands supported by EFlash Loader? We‚Äôll find out next.</p>
<p><img src="https://lupyuen.github.io/images/loader-flow2a.jpg" alt="Flashing Commands" /></p>
<h1 id="decipher-flashing-commands"><a href="#decipher-flashing-commands">5 Decipher Flashing Commands</a></h1>
<p>Recall that <strong>eflash_loader_cmds</strong> defines the list of Flashing Commands supported by EFlash Loader.</p>
<p>In the <strong>Decompile Pane</strong> (right pane), double-click on <strong>eflash_loader_cmds</strong>.</p>
<p>This appears in the <strong>Listing Pane</strong> (centre pane)‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/loader-commands2.png" alt="24 Flashing Commands" /></p>
<p>Hover our mouse over <strong>eflash_loader_cmds</strong>.</p>
<p>Ghidra says that <strong>24 Flashing Commands</strong> are defined inside the array. Let‚Äôs decipher them‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/loader-commands3.png" alt="Flashing Commands deciphered by Ghidra" /></p>
<ol>
<li>
<p>Expand the array <strong>eflash_loader_cmds</strong> to see all 24 Flashing Commands</p>
<p>(See pic above)</p>
</li>
<li>
<p>For each Flashing Command, hover our mouse as shown above</p>
<p>(Or double-click it)</p>
</li>
<li>
<p>Ghidra reveals the function that handles the Flashing Command</p>
<p>(Like <strong>bflb_eflash_loader_cmd_get_bootinfo</strong>)</p>
</li>
</ol>
<p>Now we know all 24 Flashing Commands. Neat!</p>
<h2 id="list-of-flashing-commands"><a href="#list-of-flashing-commands">5.1 List of Flashing Commands</a></h2>
<p>Here are all <strong>24 Flashing Commands</strong> supported by EFlash Loader, as decoded by Ghidra from <strong>eflash_loader_cmds</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">ID</th><th style="text-align: center">ASCII</th><th>Flashing Command</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>10</code></td><td style="text-align: center"><code>LF</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2867-L2879">*_<strong>get_bootinfo</strong></a></td></tr>
<tr><td style="text-align: center"><code>21</code></td><td style="text-align: center"><code>!</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2939-L2950">*_<strong>reset</strong></a></td></tr>
<tr><td style="text-align: center"><code>30</code></td><td style="text-align: center"><code>0</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3133-L3194">*_<strong>erase_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>31</code></td><td style="text-align: center"><code>1</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3258-L3300">*_<strong>write_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>3F</code></td><td style="text-align: center"><code>?</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3693-L3798">*_<strong>write_flash_with_decompress</strong></a></td></tr>
<tr><td style="text-align: center"><code>32</code></td><td style="text-align: center"><code>2</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3374-L3427">*_<strong>read_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>34</code></td><td style="text-align: center"><code>4</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3434-L3487">*_<strong>xip_read_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>3A</code></td><td style="text-align: center"><code>:</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3001-L3008">*_<strong>write_flash_check</strong></a></td></tr>
<tr><td style="text-align: center"><code>3B</code></td><td style="text-align: center"><code>;</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3635-L3689">*_<strong>set_flash_para</strong></a></td></tr>
<tr><td style="text-align: center"><code>3C</code></td><td style="text-align: center"><code>&lt;</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3113-L3129">*_<strong>flash_chip_erase</strong></a></td></tr>
<tr><td style="text-align: center"><code>3D</code></td><td style="text-align: center"><code>=</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3491-L3544">*_<strong>readSha_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>3E</code></td><td style="text-align: center"><code>&gt;</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3548-L3601">*_<strong>xip_readSha_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>40</code></td><td style="text-align: center"><code>@</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3065-L3109">*_<strong>write_efuse</strong></a></td></tr>
<tr><td style="text-align: center"><code>41</code></td><td style="text-align: center"><code>A</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3014-L3058">*_<strong>read_efuse</strong></a></td></tr>
<tr><td style="text-align: center"><code>42</code></td><td style="text-align: center"><code>B</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3605-L3629">*_<strong>read_mac_addr</strong></a></td></tr>
<tr><td style="text-align: center"><code>50</code></td><td style="text-align: center"><code>P</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2975-L2997">*_<strong>write_mem</strong></a></td></tr>
<tr><td style="text-align: center"><code>51</code></td><td style="text-align: center"><code>Q</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3213-L3254">*_<strong>read_mem</strong></a></td></tr>
<tr><td style="text-align: center"><code>71</code></td><td style="text-align: center"><code>q</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2897-L2909">*_<strong>read_log</strong></a></td></tr>
<tr><td style="text-align: center"><code>60</code></td><td style="text-align: center">`</td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2913-L2922">*_<strong>xip_read_flash_start</strong></a></td></tr>
<tr><td style="text-align: center"><code>61</code></td><td style="text-align: center"><code>a</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2926-L2935">*_<strong>xip_read_flash_finish</strong></a></td></tr>
<tr><td style="text-align: center"><code>36</code></td><td style="text-align: center"><code>6</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2883-L2893">*_<strong>read_jedec_id</strong></a></td></tr>
<tr><td style="text-align: center"><code>37</code></td><td style="text-align: center"><code>7</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3339-L3367">*_<strong>read_status_register</strong></a></td></tr>
<tr><td style="text-align: center"><code>38</code></td><td style="text-align: center"><code>8</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3306-L3335">*_<strong>write_status_register</strong></a></td></tr>
<tr><td style="text-align: center"><code>33</code></td><td style="text-align: center"><code>3</code></td><td><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3198-L3209">*_<strong>flash_boot</strong></a></td></tr>
</tbody></table>
</div>
<p>(<strong><code>*</code></strong> denotes <strong>bflb_eflash_loader_cmd</strong>)</p>
<p>7 of the above Flashing Commands are documented in the <a href="https://github.com/bouffalolab/bl_docs/tree/main/BL602_ISP/en"><strong>BL602 ISP Protocol</strong></a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">ID</th><th>Documented Command</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>10</code></td><td>Get Boot Info</td></tr>
<tr><td style="text-align: center"><code>3C</code></td><td>Chip Erase</td></tr>
<tr><td style="text-align: center"><code>30</code></td><td>Flash Erase</td></tr>
<tr><td style="text-align: center"><code>31</code></td><td>Flash Program</td></tr>
<tr><td style="text-align: center"><code>3A</code></td><td>Flash Program Check</td></tr>
<tr><td style="text-align: center"><code>32</code></td><td>Flash Read</td></tr>
<tr><td style="text-align: center"><code>3D</code></td><td>SHA256 Read</td></tr>
</tbody></table>
</div>
<p>The other 17 Flashing Commands are undocumented.</p>
<p>(Which might be interesting for future exploration!)</p>
<p><img src="https://lupyuen.github.io/images/loader-flow2b.jpg" alt="Flashing States" /></p>
<h1 id="flashing-states"><a href="#flashing-states">6 Flashing States</a></h1>
<p>You can‚Äôt tell which way the train went by looking at the tracks‚Ä¶ So let‚Äôs switch over to the (already documented) <strong>Firmware Flasher</strong> and understand how it calls the Flashing Commands.</p>
<ul>
<li><a href="https://github.com/bouffalolab/BLOpenFlasher"><strong>bouffalolab/BLOpenFlasher</strong></a></li>
</ul>
<p>The Firmware Flasher works like a <strong>State Machine</strong>. Each <strong>Flashing State</strong> triggers a Flashing Command‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/loader-flasher.png" alt="Flashing States" /></p>
<p><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L195-L245">(Source)</a></p>
<p>Below are the <strong>Flashing States</strong> and Flashing Command IDs derived from <a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go"><strong>util_program.go</strong></a>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: left">Flashing State</th><th style="text-align: left">ID</th><th style="text-align: left">On Success</th></tr></thead><tbody>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L118-L133"><strong>ConfigReset</strong></a></td><td style="text-align: left"></td><td style="text-align: left">*Reset</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L135-L193">*<strong>Reset</strong></a></td><td style="text-align: left"></td><td style="text-align: left">*ShakeHand</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L195-L206">*<strong>ShakeHand</strong></a></td><td style="text-align: left"><code>55</code></td><td style="text-align: left">*BootInfo</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L208-L215">*<strong>BootInfo</strong></a></td><td style="text-align: left"><code>10</code></td><td style="text-align: left">*BootHeader</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L217-L230">*<strong>BootHeader</strong></a></td><td style="text-align: left"><code>11</code></td><td style="text-align: left">*SegHeader</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L232-L245">*<strong>SegHeader</strong></a></td><td style="text-align: left"><code>17</code></td><td style="text-align: left">*SegData</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L247-L264">*<strong>SegData</strong></a></td><td style="text-align: left"><code>18</code></td><td style="text-align: left">*CheckImage</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L266-L274">*<strong>CheckImage</strong></a></td><td style="text-align: left"><code>19</code></td><td style="text-align: left">*RunImage</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L276-L284">*<strong>RunImage</strong></a></td><td style="text-align: left"><code>1A</code></td><td style="text-align: left">*Reshake</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L286-L300">*<strong>Reshake</strong></a></td><td style="text-align: left"><code>55</code></td><td style="text-align: left">*LoadFile</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L302-L344">*<strong>LoadFile</strong></a></td><td style="text-align: left"></td><td style="text-align: left">*EraseFlash^</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L353-L378">*<strong>EraseFlash</strong></a></td><td style="text-align: left"><code>30</code></td><td style="text-align: left">*ProgramFlash</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L380-L408">*<strong>ProgramFlash</strong></a></td><td style="text-align: left"><code>31</code></td><td style="text-align: left">*ProgramOK^</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L410-L418">*<strong>ProgramOK</strong></a></td><td style="text-align: left"><code>3A</code></td><td style="text-align: left">*Sha256</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L420-L449">*<strong>Sha256</strong></a></td><td style="text-align: left"><code>3D</code></td><td style="text-align: left">*LoadFile</td></tr>
<tr><td style="text-align: left"><a href="https://github.com/bouffalolab/BLOpenFlasher/blob/main/utils/util_program.go#L451-L468">*<strong>ProgramFinish</strong></a></td><td style="text-align: left"><code>55</code></td><td style="text-align: left">*ProgramFinish</td></tr>
</tbody></table>
</div>
<p><strong><code>*</code></strong> denotes <strong>Cmd</strong> (like <strong>CmdReset</strong>)</p>
<p><strong><code>^</code></strong> denotes multiple states</p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader#flashing-states">(See the complete table)</a></p>
<p>Now that we have the Flashing States and the Flashing Commands, let‚Äôs match them.</p>
<p><img src="https://lupyuen.github.io/images/loader-flow2c.jpg" alt="Match Flashing States and Commands" /></p>
<h1 id="match-flashing-states-and-commands"><a href="#match-flashing-states-and-commands">7 Match Flashing States and Commands</a></h1>
<p>Right now we have two interesting lists‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader#flashing-commands"><strong>Flashing Commands</strong></a> supported by the EFlash Loader</p>
<p>(As uncovered by Ghidra)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader#flashing-states"><strong>Flashing States</strong></a> for the Firmware Flasher‚Äôs State Machine</p>
<p>(By reading the BLOpenFlasher source code)</p>
</li>
</ul>
<p>Let‚Äôs match the two lists and find out which Flashing Commands are <strong>actually called during flashing</strong>‚Ä¶</p>
<div><table><thead><tr><th style="text-align: center">ID</th><th style="text-align: center">ASCII</th><th>Flashing Command</th></tr></thead><tbody>
<tr><td style="text-align: center"><code>10</code></td><td style="text-align: center"><code>LF</code></td><td>Get Boot Info<br><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L2867-L2879">*_<strong>get_bootinfo</strong></a></td></tr>
<tr><td style="text-align: center"><code>30</code></td><td style="text-align: center"><code>0</code></td><td>Flash Erase<br><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3133-L3194">*_<strong>erase_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>31</code></td><td style="text-align: center"><code>1</code></td><td>Flash Program<br><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3258-L3300">*_<strong>write_flash</strong></a></td></tr>
<tr><td style="text-align: center"><code>3A</code></td><td style="text-align: center"><code>:</code></td><td>Flash Program Check<br><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3001-L3008">*_<strong>write_flash_check</strong></a></td></tr>
<tr><td style="text-align: center"><code>3D</code></td><td style="text-align: center"><code>=</code></td><td>SHA256 Read<br><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3491-L3544">*_<strong>readSha_flash</strong></a></td></tr>
</tbody></table>
</div>
<p>(<strong><code>*</code></strong> denotes <strong>bflb_eflash_loader_cmd</strong>)</p>
<p>Out of 24 commands, only <strong>5 Flashing Commands</strong> are actually called during flashing!</p>
<p>(<code>3C</code> Chip Erase and <code>32</code> Flash Read aren‚Äôt used while flashing BL602, according to BLOpenFlasher)</p>
<p>And out of the 5 Flashing Commands, only 1 looks interesting‚Ä¶</p>
<ul>
<li><strong>Flash Program: bflb_eflash_loader_cmd_write_flash</strong></li>
</ul>
<p>Let‚Äôs study the Decompiled Code and find out how it writes to the Embedded Flash.</p>
<p><img src="https://lupyuen.github.io/images/loader-match2.jpg" alt="Match Flashing States and Commands" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader">(Source)</a></p>
<h1 id="flash-program"><a href="#flash-program">8 Flash Program</a></h1>
<p>In the <strong>Symbol Tree Pane</strong> (left centre), enter this into the <strong>Filter Box</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>bflb_eflash_loader_cmd_write_flash
</code></pre></div>
<p>Double-click on the function <strong>bflb_eflash_loader_cmd_write_flash</strong>.</p>
<p>This is the decompiled Flashing Command that <strong>writes the Flashing Image</strong> (received via UART) to Embedded Flash: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3258-L3300">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Flashing Command that writes Flashing Image to Embedded Flash
int32_t bflb_eflash_loader_cmd_write_flash(uint16_t cmd,uint8_t *data,uint16_t len) {

  //  Write Flashing Image to Embedded Flash
  bflb_spi_flash_program(...);

  //  Return result to Firmware Flasher
  bflb_eflash_loader_cmd_ack(...);
</code></pre></div>
<p>The code above calls <strong>bflb_spi_flash_program</strong> to write the Flashing Image to the Embedded Flash.</p>
<p>Let‚Äôs look inside the function‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/loader-code4.png" alt="Flashing Command that writes Flashing Image to Embedded Flash" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L3258-L3300">(Source)</a></p>
<h2 id="write-to-flash"><a href="#write-to-flash">8.1 Write To Flash</a></h2>
<p>In the <strong>Decompile Pane</strong> (right pane), double-click on <strong>bflb_spi_flash_program</strong>. This appears: <a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L4901-L4910">eflash_loader.c</a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Write Flashing Image to Embedded Flash
int32_t bflb_spi_flash_program(uint32_t addr,uint8_t *data,uint32_t len) {
  
  //  Call BL602 ROM to write to Embedded Flash
  SFlash_Program(...);
</code></pre></div>
<p>This function calls <strong>SFlash_Program</strong> to write to Embedded Flash.</p>
<p><strong>SFlash_Program</strong> is defined in the <strong>BL602 ROM</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/components/platform/soc/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_romapi.c#L539-L542"><strong>SFlash_Program (BL602 ROM)</strong></a></li>
</ul>
<p>Source Code is available in the <strong>BL602 IoT SDK</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/components/platform/soc/bl602/bl602_std/bl602_std/StdDriver/Src/bl602_sflash.c#L581-L662"><strong>SFlash_Program (BL602 IoT SDK)</strong></a></li>
</ul>
<p>We‚Äôre all done with our Reverse Engineering of BL602 EFlash Loader! üéâ</p>
<p><img src="https://lupyuen.github.io/images/loader-code5.jpg" alt="Write Flashing Image to Embedded Flash" /></p>
<p><a href="https://github.com/lupyuen/bl602-eflash-loader/blob/main/eflash_loader.c#L4901-L4910">(Source)</a></p>
<h1 id="how-the-train-goes"><a href="#how-the-train-goes">9 How The Train Goes</a></h1>
<p>Thanks to Ghidra we now know everything about EFlash Loader‚Ä¶</p>
<ul>
<li>
<p>We discovered <a href="https://lupyuen.github.io/articles/loader#decipher-flashing-commands"><strong>24 Flashing Commands</strong></a> supported by EFlash Loader</p>
<p>(17 Flashing Commands are undocumented)</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/loader#flashing-states"><strong>Firmware Flasher</strong></a> runs a State Machine that <strong>sends Flashing Commands</strong> to EFlash Loader over UART</p>
</li>
<li>
<p>When EFlash Loader receives the <a href="https://lupyuen.github.io/articles/loader#flash-program"><strong>‚ÄúFlash Program‚Äù</strong></a> command from Firmware Flasher, it calls <a href="https://lupyuen.github.io/articles/loader#write-to-flash"><strong>BL602 ROM</strong></a> to write the received image to Embedded Flash</p>
</li>
<li>
<p>Source Code for <a href="https://lupyuen.github.io/articles/loader#write-to-flash"><strong>BL602 ROM</strong></a> is available, so we already understand how it works</p>
</li>
</ul>
<p>Over the past year we speculated on the inner workings of EFlash Loader‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/flash"><strong>‚ÄúFlashing Firmware to BL602‚Äù</strong></a></li>
</ul>
<p>Finally we know what‚Äôs inside!</p>
<p><em>What happens after the Flashing Image has been written to Embedded Flash?</em></p>
<p>The Flashing Image is compressed with XZ Compression.</p>
<p>The image is decompressed and mapped to XIP Memory (Executable in Place) by the BL602 Bootloader‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/boot"><strong>‚ÄúBL602 Bootloader‚Äù</strong></a></li>
</ul>
<p>And the new firmware starts running on BL602.</p>
<h1 id="whats-next"><a href="#whats-next">10 What‚Äôs Next</a></h1>
<p>I had fun reverse enginnering the BL602 EFlash Loader‚Ä¶ My first time using Ghidra!</p>
<p>And I hope you found this article useful for real-world reverse engineering with Ghidra.</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen">Sponsor me a coffee</a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/ReverseEngineering/comments/sht2hj/bl602_eflash_loader_reverse_engineered_with_ghidra/">Discuss this article on Reddit</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book">Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io">Check out my articles</a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/loader.md"><code>lupyuen.github.io/src/loader.md</code></a></p>
<h1 id="notes"><a href="#notes">11 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1486187004232867842">this Twitter Thread</a></p>
</li>
<li>
<p>Many thanks to <a href="https://github.com/BraveHeartFLOSSDev"><strong>BraveHeartFLOSSDev</strong></a> for the inspiration! We previously collaborated on this article‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/wifi"><strong>‚ÄúReverse Engineering WiFi on RISC-V BL602‚Äù</strong></a></p>
</li>
<li>
<p>There are 2 versions of the EFlash Loader ELF File‚Ä¶</p>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/5fa118c59ef89adb319583ea277ea54e27d60fbb/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf"><strong>eflash_loader.elf</strong> (17 Jan 2022)</a></p>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/blob/07ceb89192cd720e1645e6c37081c85960a33580/flash_tool/chips/bl602/eflash_loader/eflash_loader.elf"><strong>eflash_loader.elf</strong> (1 Nov 2021)</a></p>
<p>Might be interesting to compare the decompiled code and discover the changes!</p>
<p><a href="https://github.com/spacemeowx2/blflash/issues/9#issuecomment-1026808893">(Here‚Äôs why)</a></p>
</li>
<li>
<p>Does Firmware Flasher send the EFlash Loader ELF to BL602?</p>
<p>Nope it sends the stripped binary for the EFlash Loader, which is easier to load and run on BL602: <a href="https://github.com/bouffalolab/bl_iot_sdk/blob/master/flash_tool/chips/bl602/eflash_loader/eflash_loader_40m.bin">eflash_loader_40m.bin</a></p>
<p>Bouffalo Lab used to provide only the stripped binary for EFlash Loader, not the ELF‚Ä¶</p>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk/tree/master/flash_tool/chips/bl602/eflash_loader">bl_iot_sdk/flash_tool/chips/ bl602/eflash_loader</a></p>
<p>But since Nov 2021 they started uploading the ELF. Which is how we did the reverse engineering with Ghidra. Lucky us ;-)</p>
</li>
</ol>

    
</body>
</html>