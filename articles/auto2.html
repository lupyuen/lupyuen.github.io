<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>(Mostly) Automated Testing of Apache NuttX RTOS on PineDio Stack BL604 RISC-V Board</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="(Mostly) Automated Testing of Apache NuttX RTOS on PineDio Stack BL604 RISC-V Board" 
    data-rh="true">
<meta property="og:description" 
    content="Pine64 is about to launch the PineDio Stack BL604 RISC-V Board with LoRa and Touch Screen... Here's how we automatically flash and test every new release of Apache NuttX RTOS for PineDio Stack"
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/auto2-title.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">(Mostly) Automated Testing of Apache NuttX RTOS on PineDio Stack BL604 RISC-V Board</h1>
    <nav id="TOC"><ul>
<li><a href="#testing-checkpoints">1 Testing Checkpoints</a><ul></ul></li>
<li><a href="#connect-pinedio-stack-to-sbc">2 Connect PineDio Stack to SBC</a><ul></ul></li>
<li><a href="#run-automated-test">3 Run Automated Test</a><ul>
<li><a href="#automated-nuttx-build">3.1 Automated NuttX Build</a><ul></ul></li></ul></li>
<li><a href="#nuttx-must-boot">4 NuttX Must Boot</a><ul>
<li><a href="#checkpoint-alpha">4.1 Checkpoint Alpha</a><ul></ul></li></ul></li>
<li><a href="#nuttx-must-not-crash">5 NuttX Must Not Crash</a><ul>
<li><a href="#checkpoint-bravo">5.1 Checkpoint Bravo</a><ul></ul></li></ul></li>
<li><a href="#spi-test">6 SPI Test</a><ul>
<li><a href="#checkpoint-charlie">6.1 Checkpoint Charlie</a><ul></ul></li></ul></li>
<li><a href="#lorawan-test">7 LoRaWAN Test</a><ul>
<li><a href="#checkpoint-delta">7.1 Checkpoint Delta</a><ul></ul></li></ul></li>
<li><a href="#touch-panel-test">8 Touch Panel Test</a><ul>
<li><a href="#checkpoint-echo">8.1 Checkpoint Echo</a><ul></ul></li></ul></li>
<li><a href="#upload-test-log">9 Upload Test Log</a><ul></ul></li>
<li><a href="#merge-updates-from-nuttx">10 Merge Updates From NuttX</a><ul>
<li><a href="#pinecone-to-pinedio-stack">10.1 PineCone to PineDio Stack</a><ul></ul></li>
<li><a href="#pinedio-stack-to-pinecone">10.2 PineDio Stack to PineCone</a><ul></ul></li>
<li><a href="#merge-conflicts">10.3 Merge Conflicts</a><ul></ul></li></ul></li>
<li><a href="#why-nuttx">11 Why NuttX</a><ul></ul></li>
<li><a href="#whats-next">12 What‚Äôs Next</a><ul></ul></li>
<li><a href="#notes">13 Notes</a><ul></ul></li>
<li><a href="#appendix-select-usb-device">14 Appendix: Select USB Device</a><ul></ul></li></ul></nav><p>üìù <em>22 May 2022</em></p>
<p><img src="https://lupyuen.github.io/images/auto2-title.jpg" alt="PineDio Stack BL604 (left, with unglam rubber band) and PineCone BL602 (right) connected to Single-Board Computer for Automated Testing" /></p>
<p><em>PineDio Stack BL604 (left, with unglam rubber band) and PineCone BL602 (right) connected to Single-Board Computer for Automated Testing</em></p>
<p>Pine64 is about to launch their most exciting RISC-V IoT gadget: <a href="https://lupyuen.github.io/articles/pinedio2"><strong>PineDio Stack BL604 RISC-V Board</strong></a> with Touch Screen, LoRa and many other features.</p>
<p>This is a cautionary tale concerning Alice, Bob and Chow, the <strong>(Hypothetical) Embedded Devs</strong> collaborating remotely on the newly-released PineDio Stack‚Ä¶</p>
<blockquote>
<p><strong>Alice</strong>: Hi All! I‚Äôm building an <strong>I2C Driver</strong> for PineDio Stack‚Äôs Accelerometer. Where can I get the latest build of <a href="https://lupyuen.github.io/articles/pinedio2"><strong>Apache NuttX RTOS</strong></a> for PineDio Stack?</p>
</blockquote>
<blockquote>
<p><strong>Bob</strong>: You‚Äôll have to compile it yourself from the <a href="https://github.com/lupyuen/nuttx/tree/pinedio"><strong>source code here</strong></a>. But beware‚Ä¶ Some folks reported (unconfirmed) that it might run differently depending on the RISC-V Compiler Toolchain.</p>
</blockquote>
<blockquote>
<p><strong>Chow</strong>: OH CR*P! PineDio Stack‚Äôs <a href="https://lupyuen.github.io/articles/touch"><strong>I2C Touch Panel</strong></a> is no longer responding to touch! What changed?!</p>
</blockquote>
<blockquote>
<p><strong>Alice</strong>: Is it because of the I2C Accelerometer Driver that I just committed to the repo?</p>
</blockquote>
<blockquote>
<p><strong>Bob</strong>: Uhhh I think it might be the BL602 Updates from <a href="https://github.com/apache/nuttx"><strong>NuttX Mainline</strong></a> that I merged last night. I <strong>forgot to test</strong> the changes. I think <a href="https://lupyuen.github.io/articles/lorawan3"><strong>SPI and LoRaWAN</strong></a> are broken too. Sorry!</p>
</blockquote>
<p>Sounds like a nightmare, but this story could be real. <a href="https://www.robertlipe.com/"><strong>Robert Lipe</strong></a> and I are already facing similar challenges today.</p>
<p>Let‚Äôs intervene and rewrite the narrative‚Ä¶</p>
<blockquote>
<p><strong>Alice</strong>: Hi All! I‚Äôm building an <strong>I2C Driver</strong> for PineDio Stack‚Äôs Accelerometer. Where can I get the latest build of <a href="https://lupyuen.github.io/articles/pinedio2"><strong>Apache NuttX RTOS</strong></a> for PineDio Stack?</p>
</blockquote>
<blockquote>
<p><strong>Bob</strong>: Just download the Compiled Firmware from the <a href="https://github.com/lupyuen/nuttx/releases?q=%22download%2Fpinedio%22&amp;expanded=true"><strong>GitHub Releases here</strong></a>. It was <a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml#L33-L76"><strong>built automatically</strong></a> by GitHub Actions with the same RISC-V Compiler Toolchain that we‚Äôre all using.</p>
</blockquote>
<blockquote>
<p><strong>Chow</strong>: Hmmm PineDio Stack‚Äôs <a href="https://lupyuen.github.io/articles/touch"><strong>I2C Touch Panel</strong></a> works a little wonky today. What changed?</p>
</blockquote>
<blockquote>
<p><strong>Alice</strong>: It can‚Äôt be caused by my new I2C Accelerometer Driver. My changes to the repo are still awaiting <strong>Automated Testing</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Bob</strong>: I merged the BL602 Updates from <a href="https://github.com/apache/nuttx"><strong>NuttX Mainline</strong></a> last night. The I2C Touch Panel worked perfectly OK during Automated Testing, here‚Äôs the evidence: <a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10"><strong>Automated Testing Log</strong></a>. Maybe we do some static discharge? Switch off the AC, open the windows, remove all metal objects, ‚Ä¶</p>
</blockquote>
<p><img src="https://lupyuen.github.io/images/auto2-release.jpg" alt="Automated Testing Log for PineDio Stack" /></p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10"><em>Automated Testing Log for PineDio Stack</em></a></p>
<p>This article explains how we accomplished all that with PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><strong>Fully Automated Testing</strong> of all <strong>NuttX Releases</strong> for PineDio Stack: GPIO, SPI, Timers, Multithreading, LoRaWAN</p>
<p><a href="https://youtu.be/JX7rWqWTOW4">(Watch the demo on YouTube)</a></p>
</li>
<li>
<p>Includes Automated Testing of <strong>NuttX Mainline Updates</strong></p>
</li>
<li>
<p>Mostly Automated Testing of <strong>I2C Touch Panel</strong></p>
<p>(Needs one Human Touch, in lieu of a Robot Finger)</p>
</li>
<li>
<p><strong>Firmware Builds</strong> are auto-downloaded from <strong>GitHub Releases</strong> for testing</p>
<p>(Auto-published by GitHub Actions)</p>
</li>
<li>
<p><strong>Testing Logs</strong> are auto-uploaded to GitHub Releases as Release Notes</p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(See the Testing Log)</a></p>
</li>
</ul>
<p>Let‚Äôs dive into the <strong>Auto Flash and Test Script</strong> for PineDio Stack‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/remote-bl602"><strong><code>lupyuen/remote-bl602</code></strong></a></li>
</ul>
<p><img src="https://lupyuen.github.io/images/auto2-pinedio2.jpg" alt="PineDio Stack BL604 connected to LoRa Antenna (swiped from the IoT Course I used to teach)" /></p>
<p><em>PineDio Stack BL604 connected to LoRa Antenna (swiped from the IoT Course I used to teach)</em></p>
<h1 id="testing-checkpoints"><a href="#testing-checkpoints">1 Testing Checkpoints</a></h1>
<p>Before we study the script, let‚Äôs break down the Automated Testing into a series of <strong>Testing Checkpoints</strong>.</p>
<p>These are our success criteria for NuttX on PineDio Stack‚Ä¶</p>
<ul>
<li>
<p><strong>NuttX must boot</strong> on PineDio Stack, with NuttX Drivers loaded <em>(Checkpoint Alpha)</em></p>
</li>
<li>
<p><strong>NuttX must not crash</strong> on PineDio Stack <em>(Checkpoint Bravo)</em></p>
<p>(If NuttX crashes, our script runs a Crash Analysis)</p>
</li>
<li>
<p><strong>SPI Transmit and Receive</strong> must work <em>(Checkpoint Charlie)</em></p>
</li>
<li>
<p><strong>GPIO Input, Output and Interrupt</strong> must work <em>(Checkpoint Delta)</em></p>
<p>(Also Timers and Multithreading with SX1262 LoRa Transceiver)</p>
</li>
<li>
<p><strong>I2C Transmit and Receive</strong> must work <em>(Checkpoint Echo)</em></p>
<p>(With CST816S Touch Panel)</p>
</li>
</ul>
<p>To run the above tests automatically, let‚Äôs connect PineDio Stack to a <strong>Single-Board Computer</strong>.</p>
<p><img src="https://lupyuen.github.io/images/auto2-pinedio3a.jpg" alt="GPIO 8, Reset and Ground on PineDio Stack BL604" /></p>
<p><em>GPIO 8, Reset and Ground on PineDio Stack BL604</em></p>
<h1 id="connect-pinedio-stack-to-sbc"><a href="#connect-pinedio-stack-to-sbc">2 Connect PineDio Stack to SBC</a></h1>
<p>Our <strong>Automated Testing Script</strong> runs on a Single-Board Computer (SBC) to‚Ä¶</p>
<ul>
<li>
<p>Control the <strong>Flashing and Testing</strong> of PineDio Stack</p>
<p>(Via USB, GPIO 8 and Reset)</p>
</li>
<li>
<p>Capture the <strong>Test Log</strong> and upload to the GitHub Release</p>
<p>(Over USB)</p>
</li>
</ul>
<p>We <strong>connect PineDio Stack</strong> to our SBC like so‚Ä¶</p>
<div><table><thead><tr><th>SBC</th><th>BL604</th><th>Function</th></tr></thead><tbody>
<tr><td>GPIO 5</td><td>GPIO 8 <em>(GPIO Port)</em></td><td>Flashing Mode</td></tr>
<tr><td>GPIO 6</td><td>RST <em>(JTAG Port)</em></td><td>Reset</td></tr>
<tr><td>GND</td><td>GND <em>(JTAG Port)</em></td><td>Ground</td></tr>
<tr><td>USB</td><td>USB Port</td><td>USB UART</td></tr>
</tbody></table>
</div>
<p><strong>GPIO 8</strong> is exposed on the GPIO Port (inside PineDio Stack). <strong>Reset and Ground</strong> are exposed on the JTAG Port (outside PineDio Stack).</p>
<p>(See the pic above)</p>
<p>The <strong>GPIO 8 Jumper</strong> must be set to <strong>Low (Non-Flashing Mode)</strong>‚Ä¶</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/auto2-jumper.jpg" alt="GPIO 8 Jumper must be set to Low (Non-Flashing Mode)" /></p>
</blockquote>
<p>(Or the LoRaWAN Test will fail because the timers get triggered too quickly, not sure why)</p>
<p>Remember to connect a <strong>LoRa Antenna</strong>! <a href="https://lupyuen.github.io/images/auto2-pinedio2.jpg">(See this)</a></p>
<p>Close the <strong>Back Cover</strong> of PineDio Stack, without the GPS Base Board.</p>
<p>We‚Äôll see something similar to the pic below. We‚Äôre ready to run our Automated Testing Script!</p>
<p><em>So PineDio Stack will be permanently connected to our SBC?</em></p>
<p>Yep I have a <strong>Spare PineDio Stack</strong> permanently connected to my SBC.</p>
<p>This PineDio Stack has a faulty ST7789 Display (hence it‚Äôs a spare), so we <strong>can‚Äôt auto-test the ST7789 Display</strong>.</p>
<p>(But since ST7789 Display and SX1262 LoRa Transceiver are connected to the same SPI Bus, it should be OK to test only the SX1262 Transceiver)</p>
<p><img src="https://lupyuen.github.io/images/auto2-pinedio.jpg" alt="PineDio Stack BL604 connected to SBC" /></p>
<p><em>PineDio Stack BL604 connected to SBC</em></p>
<h1 id="run-automated-test"><a href="#run-automated-test">3 Run Automated Test</a></h1>
<p>To run the <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh"><strong>Automated Testing Script</strong></a> on our Single-Board Computer‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Allow the user to access the GPIO and UART ports
sudo usermod -a -G gpio    $USER
sudo usermod -a -G dialout $USER

#  Logout and login to refresh the permissions
logout

#  TODO: Install rustup, select default option.
#  See https://rustup.rs

#  Install blflash for flashing PineDio Stack
#  https://github.com/spacemeowx2/blflash
cargo install blflash

#  Download the flash and test script
git clone --recursive https://github.com/lupyuen/remote-bl602/

#  Always sync the clock before running the script
sudo apt install ntpdate
sudo ntpdate -u time.nist.gov
date

#  Run the script for Auto Flash and Test for PineDio Stack BL604.
#  Capture the Test Log in /tmp/release.log
script -c remote-bl602/scripts/pinedio.sh /tmp/release.log

#  TODO: Install the GitHub CLI for uploading Release Notes: https://cli.github.com
#  Log in a GitHub Token that has &quot;repo&quot; and &quot;read:org&quot; permissions

#  Optional: Upload the Test Log to the GitHub Release Notes
remote-bl602/scripts/upload.sh</code></pre></div>
<p><a href="https://youtu.be/JX7rWqWTOW4">(Watch the demo on YouTube)</a></p>
<p>This will download and test <strong>Today‚Äôs Build</strong> of NuttX for PineDio Stack (published on GitHub Releases).</p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Here‚Äôs the build for 2022-05-10)</a></p>
<p>If the Automated Test succeeds, we‚Äôll see‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Download the latest pinedio NuttX build for 2022-05-10
Flash BL602 over USB UART with blflash
...
All OK! BL602 has successfully joined the LoRaWAN Network
All OK! BL604 has responded to touch</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(See the Test Log)</a></p>
<p>Beware: The script <strong>fails silently</strong> if there‚Äôs no NuttX Build for today. (Sorry!)</p>
<p><em>Can we pick a different NuttX Build?</em></p>
<p>We pick a <strong>NuttX Build</strong> from this list‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/releases?q=%22download%2Fpinedio%22&amp;expanded=true"><strong>NuttX Builds for PineDio Stack</strong></a></li>
</ul>
<p>Then we set <strong>BUILD_DATE</strong> like so‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Tell the script to download the build for 2022-05-10
export BUILD_DATE=2022-05-10

#  Run the script for Auto Flash and Test for PineDio Stack BL604.
#  Capture the Test Log in /tmp/release.log
script -c remote-bl602/scripts/pinedio.sh /tmp/release.log</code></pre></div>
<p><em>Will this work over SSH?</em></p>
<p>Yep we may run the Automated Test <strong>remotely over SSH</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>ssh my-sbc remote-bl602/scripts/pinedio.sh</code></pre></div><h2 id="automated-nuttx-build"><a href="#automated-nuttx-build">3.1 Automated NuttX Build</a></h2>
<p><em>How is NuttX for PineDio Stack built and published to GitHub Releases?</em></p>
<p>Whenever we commit changes to the <a href="https://github.com/lupyuen/nuttx/tree/pinedio"><strong>NuttX Repo for PineDio Stack</strong></a>, GitHub Actions will trigger a new NuttX Build and <strong>publish the built firmware</strong> to GitHub Releases‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml"><strong>GitHub Actions Workflow for PineDio Stack</strong></a></p>
<p><a href="https://lupyuen.github.io/articles/auto#appendix-build-nuttx-with-github-actions">(More about the GitHub Actions Workflow)</a></p>
</li>
</ul>
<p>Our script <strong>downloads the NuttX Firmware</strong> from GitHub Releases for Automated Testing: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L14-L42">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  BUILD_PREFIX is &quot;pinedio&quot;
#  BUILD_DATE defaults to today&#39;s date, like &quot;2022-05-10&quot;

#  Download the NuttX Firmware from GitHub Releases
wget -q https://github.com/lupyuen/nuttx/releases/download/$BUILD_PREFIX-$BUILD_DATE/nuttx.zip -O /tmp/nuttx.zip
pushd /tmp
unzip -o nuttx.zip
popd

#  Write the Release Tag for uploading the Test Log later:
#  &quot;pinedio-2022-05-10&quot;
echo &quot;$BUILD_PREFIX-$BUILD_DATE&quot; &gt;/tmp/release.tag</code></pre></div>
<p>We‚Äôll see <strong>release.tag</strong> later when we upload the Test Log to the GitHub Release.</p>
<p>Let‚Äôs walk through the Automated Testing Script and find out how it implements each Testing Checkpoint.</p>
<blockquote>
<p><img src="https://lupyuen.github.io/images/auto2-boot1.png" alt="NuttX booting on PineDio Stack" /></p>
</blockquote>
<blockquote>
<p><em>NuttX booting on PineDio Stack</em></p>
</blockquote>
<h1 id="nuttx-must-boot"><a href="#nuttx-must-boot">4 NuttX Must Boot</a></h1>
<p><em>(Checkpoint Alpha)</em></p>
<p>Earlier we saw our Automated Testing Script downloading the NuttX Firmware from GitHub Releases.</p>
<p>At the first checkpoint, our script <strong>flashes the NuttX Firmware</strong> to PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Set GPIO 5 to High (BL602 Flashing Mode)
Toggle GPIO 6 High-Low-High (Reset BL602)
BL602 is now in Flashing Mode

Flash BL602 over USB UART with blflash
+ blflash flash /tmp/nuttx.bin --port /dev/ttyUSB0
Sending eflash_loader...
Program flash... 
Success</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Source)</a></p>
<p>Our script restarts PineDio Stack in <strong>Flashing Mode</strong> and calls <strong>blflash</strong> to flash the NuttX Firmware.</p>
<p><a href="https://lupyuen.github.io/articles/flash#flash-bl602-firmware-with-linux-macos-and-windows">(<strong>blflash</strong> is explained here)</a></p>
<p>Next our script restarts PineDio Stack in <strong>Normal Mode</strong> to start the NuttX Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Set GPIO 5 to Low (BL602 Normal Mode)
Toggle GPIO 6 High-Low-High (Reset BL602)
BL602 is now in Normal Mode

NuttShell (NSH) NuttX-10.3.0-RC0
nsh&gt;</code></pre></div>
<p>The NuttX Shell appears. Our script sends this command to reveal the <strong>NuttX Commit ID</strong> and Build Timestamp‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; uname -a
NuttX 10.3.0-RC0 3e60d2211d May 10 2022 01:55:54 risc-v bl602evb</code></pre></div>
<p>Then it lists the <strong>Device Drivers</strong> loaded on NuttX‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; ls /dev
/dev:
 console  i2c0
 gpio10   input0
 gpio12   lcd0
 gpio14   null
 gpio15   spi0
 gpio19   spitest0
 gpio20   timer0
 gpio21   urandom
 gpio3    zero
 gpio9</code></pre></div>
<p>Shown above are these <strong>NuttX Device Drivers</strong>: <a href="https://lupyuen.github.io/articles/expander"><strong>GPIO Expander</strong></a>, <a href="https://lupyuen.github.io/articles/bme280"><strong>I2C</strong></a>, <a href="https://lupyuen.github.io/articles/touch"><strong>Touch Input</strong></a>, <a href="https://lupyuen.github.io/articles/st7789"><strong>LCD Display</strong></a>, <a href="https://lupyuen.github.io/articles/spi2"><strong>SPI Test</strong></a>, <a href="https://lupyuen.github.io/articles/lorawan3#appendix-posix-timers-and-message-queues"><strong>Timer</strong></a> and <a href="https://lupyuen.github.io/articles/lorawan3#appendix-random-number-generator-with-entropy-pool"><strong>Random Number Generator</strong></a>.</p>
<p>Yep NuttX has successfully booted on PineDio Stack! Let‚Äôs dive into our Automated Testing Script and see the implementation of the operations above.</p>
<p><img src="https://lupyuen.github.io/images/nuttx-flash2.png" alt="Flashing NuttX to PineDio Stack" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#flash-pinedio-stack"><em>Flashing NuttX to PineDio Stack</em></a></p>
<h2 id="checkpoint-alpha"><a href="#checkpoint-alpha">4.1 Checkpoint Alpha</a></h2>
<p>Our script controls PineDio Stack through GPIO 5 and 6 on our SBC‚Ä¶</p>
<ul>
<li>
<p><strong>SBC GPIO 5</strong>: Selects Flashing Mode or Normal Mode on PineDio Stack</p>
<p>(Connected to PineDio Stack GPIO 8)</p>
</li>
<li>
<p><strong>SBC GPIO 6</strong>: Restarts PineDio Stack</p>
<p>(Connected to PineDio Stack Reset Pin)</p>
</li>
</ul>
<p>This is how our script <strong>configures GPIO 5 and 6</strong> on our SBC: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L44-L110">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Enable GPIO 5 and 6
if [ ! -d /sys/class/gpio/gpio5 ]; then
  echo 5 &gt;/sys/class/gpio/export ; sleep 1  ##  Must sleep or next GPIO command will fail with &quot;Permission Denied&quot;
fi
if [ ! -d /sys/class/gpio/gpio6 ]; then
  echo 6 &gt;/sys/class/gpio/export ; sleep 1  ##  Must sleep or next GPIO command will fail with &quot;Permission Denied&quot;
fi

#  Set GPIO 5 and 6 as output
echo out &gt;/sys/class/gpio/gpio5/direction
echo out &gt;/sys/class/gpio/gpio6/direction</code></pre></div>
<p>To switch PineDio Stack to <strong>Flashing Mode</strong>, we set GPIO 5 to High and restart PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Set GPIO 5 to High (BL602 Flashing Mode)
echo 1 &gt;/sys/class/gpio/gpio5/value ; sleep 1

#  Toggle GPIO 6 High-Low-High (Reset BL602)
echo 1 &gt;/sys/class/gpio/gpio6/value ; sleep 1
echo 0 &gt;/sys/class/gpio/gpio6/value ; sleep 1
echo 1 &gt;/sys/class/gpio/gpio6/value ; sleep 1</code></pre></div>
<p>We run the <strong>blflash</strong> command to flash the NuttX Firmware‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  BL602 is now in Flashing Mode
#  Flash BL602 over USB UART with blflash
set -x  ##  Enable echo
blflash flash /tmp/nuttx.bin --port /dev/ttyUSB0
set +x  ##  Disable echo
sleep 1</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/flash#flash-bl602-firmware-with-linux-macos-and-windows">(<strong>blflash</strong> is explained here)</a></p>
<p>After flashing NuttX, we switch PineDio Stack back to <strong>Normal Mode</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Set GPIO 5 to Low (BL602 Normal Mode)
echo 0 &gt;/sys/class/gpio/gpio5/value ; sleep 1

#  Toggle GPIO 6 High-Low-High (Reset BL602)
echo 1 &gt;/sys/class/gpio/gpio6/value ; sleep 1
echo 0 &gt;/sys/class/gpio/gpio6/value ; sleep 1
echo 1 &gt;/sys/class/gpio/gpio6/value ; sleep 1</code></pre></div>
<p>We configure the USB Port for 2 Mbps and <strong>capture the Console Output</strong> from PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Set USB UART to 2 Mbps
stty -F /dev/ttyUSB0 raw 2000000

#  Show the BL602 output and capture to /tmp/test.log.
#  Run this in the background so we can kill it later.
cat /dev/ttyUSB0 | tee /tmp/test.log &amp;</code></pre></div>
<p>Finally we send the <strong>uname</strong> and <strong>ls</strong> commands, to show the NuttX Build Details and the loaded Device Drivers‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  If BL602 has not crashed, send the test command to BL602
echo &quot;uname -a&quot; &gt;/dev/ttyUSB0 ; sleep 1
echo &quot;ls /dev&quot;  &gt;/dev/ttyUSB0 ; sleep 1</code></pre></div>
<p>Let‚Äôs move on to the second checkpoint.</p>
<p><img src="https://lupyuen.github.io/images/auto-stack.jpg" alt="NuttX Stack Trace" /></p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/upstream-2022-01-17"><em>NuttX Register and Stack Dump</em></a></p>
<h1 id="nuttx-must-not-crash"><a href="#nuttx-must-not-crash">5 NuttX Must Not Crash</a></h1>
<p><em>(Checkpoint Bravo)</em></p>
<p><em>What happens when NuttX crashes during testing?</em></p>
<p>NuttX shows a <strong>Register and Stack Dump</strong>, like the pic above‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>irq_unexpected_isr: ERROR irq: 1
up_assert: Assertion failed at file:irq/irq_unexpectedisr.c line: 51 task: Idle Task
riscv_registerdump: EPC: deadbeee
riscv_registerdump: A0: 00000002 A1: 420146b0 A2: 42015140 A3: 420141c
...
riscv_stackdump: 420144a0: 00001fe0 23011000 420144f0 230053a0 deadbeef deadbeef 23010ca4 00000033
riscv_stackdump: 420144c0: deadbeef 00000001 4201fa38 23007000 00000001 42012510 42015000 00000001</code></pre></div>
<p>Our script can‚Äôt proceed with the Automated Testing, but it can help us make sense of these numbers to <strong>understand why NuttX crashed</strong>.</p>
<p>Our script detects the crash and does a <strong>Crash Analysis</strong> (pic below)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>----- Crash Analysis
Code Address 230053a0:
arch/risc-v/src/common/riscv_assert.c:364
  if (CURRENT_REGS)
    sp = CURRENT_REGS[REG_SP];

Code Address 230042e2:
libs/libc/assert/lib_assert.c:37
  exit(EXIT_FAILURE);</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/upstream-2022-01-17">(Source)</a></p>
<p>Through this Crash Analysis, we get some idea <strong>which lines of code</strong> caused the crash.</p>
<p>And hopefully we can heal NuttX on PineDio Stack!</p>
<p><img src="https://lupyuen.github.io/images/auto-stack3.png" alt="NuttX Crash Analysis" /></p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/upstream-2022-01-17"><em>NuttX Crash Analysis</em></a></p>
<h2 id="checkpoint-bravo"><a href="#checkpoint-bravo">5.1 Checkpoint Bravo</a></h2>
<p>Over to the implementation. Our script detects that NuttX has crashed when it sees the <strong>registerdump</strong> keyword: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L102-L105">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Check whether BL602 has crashed
set +e  ##  Don&#39;t exit when any command fails
match=$(grep &quot;registerdump&quot; /tmp/test.log)
set -e  ##  Exit when any command fails

#  If NuttX has booted properly, run the LoRaWAN Test
if [ &quot;$match&quot; != &quot;&quot; ]; then
  ...
else
  #  If NuttX has crashed, do the Crash Analysis
  ...</code></pre></div>
<p>Then it proceeds to <strong>decode the Stack Dump</strong> by matching the addresses with the <strong>RISC-V Disassembly</strong>: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L153-L211">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  If NuttX has crashed, do the Crash Analysis.
#  Find all code addresses 23?????? in the Output Log, remove duplicates, skip 23007000.
#  Returns a newline-delimited list of addresses: &quot;23011000\n230053a0\n...&quot;
grep --extended-regexp \
  --only-matching \
  &quot;23[0-9a-f]{6}&quot; \
  /tmp/test.log \
  | grep -v &quot;23007000&quot; \
  | uniq \
  &gt;/tmp/test.addr

#  For every address, show the corresponding line in the disassembly
for addr in $(cat /tmp/test.addr); do
  #  Skip addresses that don&#39;t match
  match=$(grep &quot;$addr:&quot; /tmp/nuttx.S)
  if [ &quot;$match&quot; != &quot;&quot; ]; then
    echo &quot;----- Code Address $addr&quot;
    grep \
      --context=5 \
      --color=auto \
      &quot;$addr:&quot; \
      /tmp/nuttx.S
    echo
  fi
done</code></pre></div>
<p>The Crash Analysis is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/auto#nuttx-crash-analysis"><strong>‚ÄúNuttX Crash Analysis‚Äù</strong></a></li>
</ul>
<p>There‚Äôs a <strong>Design Flaw</strong> in our script that needs fixing‚Ä¶ It doesn‚Äôt detect crashes while running the SPI, LoRaWAN and Touch Panel Tests. <a href="https://gist.github.com/lupyuen/02764452fde605e04b626614be4562ed">(See this)</a></p>
<p>(We should probably use a <strong>State Machine</strong> instead of a long chain of hacky ‚Äúif-else‚Äù statements)</p>
<p><img src="https://lupyuen.github.io/images/pinedio-spi2.jpg" alt="Shared SPI Bus on PineDio Stack" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#appendix-shared-spi-bus"><em>Shared SPI Bus on PineDio Stack</em></a></p>
<h1 id="spi-test"><a href="#spi-test">6 SPI Test</a></h1>
<p><em>(Checkpoint Charlie)</em></p>
<p>PineDio Stack has a complex <strong>SPI Bus</strong> that‚Äôs shared by <strong>3 SPI Devices</strong> (pic above)‚Ä¶</p>
<ul>
<li>
<p><strong>SPI Flash</strong></p>
</li>
<li>
<p><strong>SX1262 LoRa Transceiver</strong></p>
</li>
<li>
<p><strong>ST7789 Display</strong></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#swap-miso--mosi">(MISO and MOSI are swapped for ST7789)</a></p>
</li>
</ul>
<p>That‚Äôs why we created an <a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a> to manage the SPI Devices. </p>
<p><em>How do we test the SPI Bus and the SPI Device Table?</em></p>
<p>Our script sends an SPI Command to the SX1262 LoRa Transceiver to <strong>read an SX1262 Register</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; spi_test2
Get Status: received
  a2 22 
SX1262 Status is 2
Read Register 8: received
  a2 a2 a2 a2 80 
SX1262 Register 8 is 0x80
SX1262 is OK</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Source)</a></p>
<p><strong>spi_test2</strong> says that <strong>SX1262 Register 8</strong> has value <strong><code>0x80</code></strong>, which is correct.</p>
<p>If we receive any other value for SX1262 Register 8‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>SX1262 Register 8 is 0x00
Error: SX1262 is NOT OK. Check the SPI connection</code></pre></div>
<p>Then our script halts with an error.</p>
<p>Let‚Äôs look at the implementation of the checkpoint.</p>
<h2 id="checkpoint-charlie"><a href="#checkpoint-charlie">6.1 Checkpoint Charlie</a></h2>
<p>Our script executes the SPI Test by sending the <strong>spi_test2</strong> command to PineDio Stack: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L108-L111">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>echo &quot;spi_test2&quot; &gt;/dev/ttyUSB0 ; sleep 2</code></pre></div>
<p>And verifies that the result is correct: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L122-L130">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Check whether SX1262 is OK
set +e  ##  Don&#39;t exit when any command fails
match=$(grep &quot;SX1262 Register 8 is 0x80&quot; /tmp/test.log)
set +e  ##  Don&#39;t exit when any command fails

#  If SX1262 is not OK, quit
if [ &quot;$match&quot; == &quot;&quot; ]; then
  echo; echo &quot;===== Error: SX1262 is NOT OK. Check the SPI connection&quot;
  test_status=unknown</code></pre></div>
<p>Source code for <strong>spi_test2</strong> is located here‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx-apps/blob/pinedio/examples/spi_test2/spi_test2_main.c"><strong>examples/spi_test2</strong></a></li>
</ul>
<p>Note that <strong>spi_test2</strong> calls the <strong>SPI Test Driver ‚Äú/dev/spitest0‚Äù</strong> which is explained here‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/spi2#inside-the-spi-test-driver"><strong>‚ÄúInside the SPI Test Driver‚Äù</strong></a></li>
</ul>
<p><em>Why doesn‚Äôt it call the standard SPI Driver ‚Äú/dev/spi0‚Äù instead?</em></p>
<p>That‚Äôs because the SPI Test Driver presents a <a href="https://lupyuen.github.io/articles/spi2#inside-the-spi-test-app"><strong>simpler interface</strong></a> when we access the SPI Port from our NuttX App (in User Space).</p>
<p>At the next checkpoint, the LoRaWAN Test App will call the SPI Test Driver to talk to the SX1262 LoRa Transceiver.</p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#sx1262-chip-select">(We might switch to ‚Äú/dev/spitest1‚Äù to fix an SPI Race Condition)</a></p>
<p><em>What about testing the SPI Flash and ST7789 Display?</em></p>
<p>In future we might test the <strong>SPI Flash</strong> by reading the JEDEC ID.</p>
<p>Testing the <strong>ST7789 Display</strong> will be more tricky because it needs visual inspection. If you have any ideas, lemme know!</p>
<p><img src="https://lupyuen.github.io/images/lorawan3-title.jpg" alt="PineDio Stack talking LoRaWAN to RAKwireless WisGate LoRaWAN Gateway" /></p>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><em>PineDio Stack talking LoRaWAN to RAKwireless WisGate LoRaWAN Gateway</em></a></p>
<h1 id="lorawan-test"><a href="#lorawan-test">7 LoRaWAN Test</a></h1>
<p><em>(Checkpoint Delta)</em></p>
<p>Now comes the most complicated checkpoint: <strong>LoRaWAN Test</strong>.</p>
<p>For this test our script shall do some wireless comms‚Ä¶</p>
<ol>
<li>
<p>Send a <strong>Join LoRaWAN Network</strong> Request</p>
<p>(To our ChirpStack LoRaWAN Gateway)</p>
</li>
<li>
<p>Wait for the <strong>Join Network Response</strong> from gateway</p>
</li>
<li>
<p>Then send a <strong>LoRaWAN Data Packet</strong> to the gateway</p>
</li>
</ol>
<p><em>How will we know if LoRa and LoRaWAN are working OK on PineDio Stack?</em></p>
<p>Step 3 will succeed only if‚Ä¶</p>
<ul>
<li>
<p>PineDio Stack <strong>correctly transmits</strong> the Join Network Request over LoRa and LoRaWAN</p>
<p>(Step 1)</p>
</li>
<li>
<p>And PineDio Stack <strong>correctly receives</strong> the Join Network Response over LoRa and LoRaWAN</p>
<p>(Step 2)</p>
</li>
</ul>
<p>Thus our script works well for verifying that both LoRa and LoRaWAN work OK on PineDio Stack.</p>
<p><em>Which NuttX features will be tested in the LoRaWAN Test?</em></p>
<p>Plenty! We‚Äôll test these features in the LoRaWAN Test‚Ä¶</p>
<ul>
<li>
<p><strong>GPIO Input</strong>: Read the Busy Status from SX1262 via GPIO Expander <a href="https://lupyuen.github.io/articles/sx1262#check-busy-state">(See this)</a></p>
</li>
<li>
<p><strong>GPIO Output</strong>: Enable Chip Select for SX1262 via GPIO Expander <a href="https://lupyuen.github.io/articles/sx1262#spi-interface">(See this)</a></p>
</li>
<li>
<p><strong>GPIO Interrupt</strong>: Triggered when SX1262 transmits or receives a LoRa Packet <a href="https://lupyuen.github.io/articles/sx1262#handle-dio1-interrupt">(See this)</a></p>
</li>
<li>
<p><strong>SPI</strong>: Transfer data and commands to SX1262 via SPI Test Driver <a href="https://lupyuen.github.io/articles/sx1262#spi-interface">(See this)</a></p>
</li>
<li>
<p><strong>ADC and Internal Temperature Sensor</strong>: Seed the Strong Random Number Generator <a href="https://lupyuen.github.io/articles/auto#appendix-fix-lorawan-nonce">(See this)</a></p>
</li>
<li>
<p><strong>Timers</strong>: Detect timeouts for transmit and receive <a href="https://lupyuen.github.io/articles/lorawan3#lorawan-event-loop">(See this)</a></p>
</li>
<li>
<p><strong>Multithreading</strong>: Background thread handles received LoRa Packets <a href="https://lupyuen.github.io/articles/sx1262#start-dio1-thread">(See this)</a></p>
</li>
<li>
<p><strong>Message Queue</strong>: Handles received LoRa Packets <a href="https://lupyuen.github.io/articles/sx1262#event-queue">(See this)</a></p>
</li>
<li>
<p><strong>Strong Random Number Generator</strong>: Generate the LoRaWAN Nonce <a href="https://lupyuen.github.io/articles/lorawan3#lorawan-nonce">(See this)</a></p>
</li>
</ul>
<p><em>Alright let‚Äôs run the LoRaWAN Test already!</em></p>
<p>Our script starts the LoRaWAN Test by sending the <strong>lorawan_test</strong> command to PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lorawan_test
init_entropy_pool
temperature = 25.667484 Celsius</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Source)</a></p>
<p>The test begins by reading BL604‚Äôs <a href="https://lupyuen.github.io/articles/auto#appendix-fix-lorawan-nonce"><strong>Internal Temperature Sensor</strong></a> and using the temperature value to seed the <a href="https://lupyuen.github.io/articles/lorawan3#lorawan-nonce"><strong>Strong Random Number Generator</strong></a>.</p>
<p>Then we send the <strong>Join LoRaWAN Network</strong> Request to our LoRaWAN Gateway (ChirpStack)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>=========== MLME-Request ============
              MLME_JOIN              
=====================================
STATUS      : OK</code></pre></div>
<p>We receive the correct <strong>Join Network Response</strong> from our LoRaWAN Gateway‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>=========== MLME-Confirm ============
STATUS      : OK
===========   JOINED     ============
OTAA
DevAddr     : 00F76FBF
DATA RATE   : DR_2</code></pre></div>
<p>PineDio Stack has successfully joined the LoRaWAN Network!</p>
<p>We proceed to send a <strong>LoRaWAN Data Packet</strong> <em>(‚ÄúHi NuttX‚Äù)</em> to our LoRaWAN Gateway‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>=========== MCPS-Confirm ============
STATUS      : OK
=====   UPLINK FRAME        1   =====
CLASS       : A
TX PORT     : 1
TX DATA     : UNCONFIRMED
48 69 20 4E 75 74 74 58 00
DATA RATE   : DR_3
U/L FREQ    : 923400000
TX POWER    : 0
CHANNEL MASK: 0003</code></pre></div>
<p>Finally our script reports that the LoRaWAN Test has succeeded‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>All OK! BL602 has successfully joined the LoRaWAN Network</code></pre></div>
<p>Which means that GPIO Input / Ouput / Interrupt, SPI, ADC, Timers, Multithreading, Message Queues and Strong Random Number Generator are all working OK!</p>
<h2 id="checkpoint-delta"><a href="#checkpoint-delta">7.1 Checkpoint Delta</a></h2>
<p>To run the LoRaWAN Test, our script sends the <strong>lorawan_test</strong> command to PineDio Stack: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L132-L134">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Send the LoRaWAN Test Command
echo &quot;lorawan_test&quot; &gt;/dev/ttyUSB0

#  Wait 20 seconds to join the LoRaWAN Network
sleep 20</code></pre></div>
<p>And checks whether PineDio Stack has successfully <strong>joined the LoRaWAN Network</strong>: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L139-L146">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Check whether BL602 has joined the LoRaWAN Network
set +e  ##  Don&#39;t exit when any command fails
match=$(grep &quot;JOINED&quot; /tmp/test.log)
set -e  ##  Exit when any command fails

#  If BL602 has joined the LoRaWAN Network, then everything is super hunky dory!
if [ &quot;$match&quot; != &quot;&quot; ]; then
  echo; echo &quot;===== All OK! BL602 has successfully joined the LoRaWAN Network&quot;</code></pre></div>
<p><em>What happens if PineDio Stack fails to join the LoRaWAN Network?</em></p>
<p>PineDio Stack will <strong>retry repeatedly</strong> until it hits the timeout after 20 seconds.</p>
<p>Be sure that the <strong>LoRaWAN Gateway Settings</strong> are correct! The gateway will silently drop invalid requests without notifying our device.</p>
<p>(More about this in a while)</p>
<p><em>What‚Äôs inside lorawan_test?</em></p>
<p><strong>lorawan_test</strong> is the LoRaWAN Test App that‚Äôs described in this article‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3"><strong>‚ÄúLoRaWAN on Apache NuttX OS‚Äù</strong></a></li>
</ul>
<p>The app was ported from <a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/apps/LoRaMac/fuota-test-01/B-L072Z-LRWAN1/main.c"><strong>Semtech‚Äôs LoRaWAN Stack</strong></a> to NuttX and calls these <strong>NuttX Libraries</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/LoRaMac-node-nuttx"><strong>LoRaWAN Library</strong></a> (ported from Semtech)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/lora-sx1262/tree/lorawan"><strong>SX1262 Library</strong></a> (also ported from Semtech)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nimble-porting-nuttx"><strong>NimBLE Porting Layer</strong></a> (for Timers, Multithreading and Message Queues)</p>
</li>
</ul>
<p>The <strong>Device Drivers</strong> called by the app are‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/spi2#spi-test-app-and-driver"><strong>SPI Test Driver</strong></a>: /dev/spitest0</p>
<p>(Which calls the SPI Driver and <a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a>)</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/bl602_expander"><strong>GPIO Expander</strong></a>: </p>
<ul>
<li>/dev/gpio10 (SX1262 Busy)</li>
<li>/dev/gpio15 (SX1262 Chip Select)</li>
<li>/dev/gpio19 (SX1262 DIO1)</li>
</ul>
</li>
</ul>
<p><em>What about the ChirpStack LoRaWAN Gateway? What needs to be configured?</em></p>
<p>For the LoRaWAN Test to succeed, we must configure the <strong>Device EUI, Join EUI and App Key</strong> from the ChirpStack LoRaWAN Gateway‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3#device-eui-join-eui-and-app-key"><strong>‚ÄúDevice EUI, Join EUI and App Key‚Äù</strong></a></li>
</ul>
<p>Also verify that the <strong>LoRaWAN Frequency</strong> is correct‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.github.io/articles/lorawan3#lorawan-frequency"><strong>‚ÄúLoRaWAN Frequency‚Äù</strong></a></li>
</ul>
<p><em>Isn‚Äôt the LoRaWAN Test testing way too much? GPIO, SPI, ADC, Timers, Multithreading, ‚Ä¶</em></p>
<p>Yeah someday we ought to build <strong>smaller tests for specific features</strong> like GPIO, ADC, Timers, Multithreading, ‚Ä¶ Similar to our SPI Test.</p>
<p>But for now we‚Äôll have to live with the inconvenience of identifying which specific feature could have caused the LoRaWAN Test to fail.</p>
<p><img src="https://lupyuen.github.io/images/touch-title.jpg" alt="LVGL Test App for testing the Touch Panel" /></p>
<p><a href="https://lupyuen.github.io/articles/touch"><em>LVGL Test App for testing the Touch Panel</em></a></p>
<h1 id="touch-panel-test"><a href="#touch-panel-test">8 Touch Panel Test</a></h1>
<p><em>(Checkpoint Echo)</em></p>
<p>For our final checkpoint we shall test‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/bme280"><strong>I2C Driver ‚Äú/dev/i2c0‚Äù</strong></a> from NuttX</p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch"><strong>CST816S Touch Panel ‚Äú/dev/input0‚Äù</strong></a> connected to the I2C Bus</p>
</li>
</ul>
<p><em>Why not test the I2C Accelerometer instead?</em></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2#accelerometer"><strong>PineDio Stack‚Äôs Accelerometer</strong></a> is connected to the same I2C Bus as the Touch Panel.</p>
<p>But we‚Äôre not testing the Accelerometer because‚Ä¶</p>
<ul>
<li>
<p>We don‚Äôt have a <strong>NuttX Driver</strong> for the Accelerometer</p>
</li>
<li>
<p>Touch Panel is <strong>probably more important</strong> than the Accelerometer for most devs</p>
</li>
</ul>
<p><em>How do we test the Touch Panel and I2C Bus?</em></p>
<p>Our <a href="https://lupyuen.github.io/articles/touch#run-the-driver"><strong>LVGL Test App</strong></a> includes a <strong>Touchscreen Calibration</strong> step that records the points touched on the Touch Panel.</p>
<p>We‚Äôll run the app, tap the screen and verify that the Touch Panel generates <strong>valid Touch Data</strong> over I2C when touched.</p>
<p><em>So this isn‚Äôt automated?</em></p>
<p>Well our script starts the app automatically, but we need to run over and <strong>tap the screen</strong> when prompted. Here‚Äôs how it works‚Ä¶</p>
<p>Our script sends the <strong>lvgltest</strong> command to start the LVGL Test App‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>nsh&gt; lvgltest
tp_init: Opening /dev/input0
cst816s_open: 
HELLO HUMAN: TOUCH PINEDIO STACK NOW</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Source)</a></p>
<p>The script prompts us to touch the screen.</p>
<p>When we touch the screen, the <strong>CST816S Touch Panel Driver</strong> shows a <strong>Touch Down Event</strong> with the coordinates of the touched point (read over I2C)‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>DOWN: id=0, touch=0, x=83, y=106</code></pre></div>
<p>As we lift our finger off the screen, the driver shows a <strong>Touch Up Event</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>Invalid touch data: id=9, touch=2, x=639, y=1688
UP: id=0, touch=2, x=83, y=106</code></pre></div>
<p><a href="https://lupyuen.github.io/articles/touch#touch-up-event">(Why the Touch Data is invalid)</a></p>
<p>Our script <strong>detects the Touch Up Event</strong> and reports that the test has succeeded‚Ä¶</p>
<div class="example-wrap"><pre class="language-text"><code>All OK! BL604 has responded to touch</code></pre></div>
<p>Yep PineDio Stack‚Äôs Touch Panel and I2C Bus are working OK!</p>
<h2 id="checkpoint-echo"><a href="#checkpoint-echo">8.1 Checkpoint Echo</a></h2>
<p>The Touch Panel Test lives in a separate script: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio2.sh"><strong>pinedio2.sh</strong></a></p>
<p>We <strong>launch the second script</strong> after completing the LoRaWAN Test: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio.sh#L219-L222">pinedio.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Start the second script: pinedio2.sh
SCRIPT_PATH=&quot;${BASH_SOURCE}&quot;
SCRIPT_DIR=&quot;$(cd -P &quot;$(dirname -- &quot;${SCRIPT_PATH}&quot;)&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; pwd)&quot;
$SCRIPT_DIR/pinedio2.sh</code></pre></div>
<p>The second script sends the <strong>lvgltest</strong> command to start the LVGL Test App: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio2.sh#L102-L108">pinedio2.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Send command to PineDio Stack: lvgltest
echo &quot;lvgltest&quot; &gt;/dev/ttyUSB0 ; sleep 1
echo ; echo &quot;----- HELLO HUMAN: TOUCH PINEDIO STACK NOW&quot; ; sleep 2

#  Wait 30 seconds for the screen to be tapped
sleep 30</code></pre></div>
<p>And prompts us to tap the screen.</p>
<p>30 seconds later our script searches for a <strong>Touch Up Event</strong>: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/pinedio2.sh#L110-L117">pinedio2.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Check whether BL604 has responded to touch
set +e  ##  Don&#39;t exit when any command fails
match=$(grep &quot;cst816s_get_touch_data: UP: id=0, touch=&quot; /tmp/test.log)
set -e  ##  Exit when any command fails

#  If BL604 has responded to touch, then everything is super hunky dory!
if [ &quot;$match&quot; != &quot;&quot; ]; then
  echo; echo &quot;===== All OK! BL604 has responded to touch&quot;</code></pre></div>
<p>And reports that the test has succeeded.</p>
<p><em>What‚Äôs inside lvgltest?</em></p>
<p><strong>lvgltest</strong> is our Test App for the <strong>LVGL Graphics Library</strong>‚Ä¶</p>
<ul>
<li><a href="https://github.com/lupyuen/lvgltest-nuttx"><strong>LVGL Test App</strong></a></li>
</ul>
<p>When the app starts, it runs a <strong>Touchscreen Calibration</strong>‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/lvgltest-nuttx/blob/main/tp.c"><strong>Source Code for Touchscreen Calibration</strong></a></p>
</li>
<li>
<p><a href="https://youtube.com/shorts/2Nzjrlp5lcE?feature=share"><strong>Watch the Demo on YouTube</strong></a></p>
</li>
</ul>
<p>Which we‚Äôre using to test PineDio Stack‚Äôs Touch Panel.</p>
<p><em>But the Touchreen Calibration needs us to tap the 4 corners. Our script only watches for one tap?</em></p>
<p>Yeah remember that my Spare PineDio Stack has a defective ST7789 Display. So we can‚Äôt see the 4 corners anyway.</p>
<p>Hopefully <strong>tapping the screen once</strong> in the centre will be sufficient for testing the Touch Panel.</p>
<p>(Our script should probably validate that the reported coordinates are close to the centre of the screen)</p>
<p><em>Can we fully automate the Touch Panel Test? And do away with the Manual Tapping?</em></p>
<p>Yep we need some kind of <strong>Robot Finger</strong> to tap the screen.</p>
<p>The finger thingy needs to apply <strong>sufficient pressure</strong> to the screen (but not too much) in order to wake up the Touch Panel. <a href="https://lupyuen.github.io/articles/touch#cst816s-touch-panel">(See this)</a></p>
<p>We could use a <a href="https://web.archive.org/web/20220518023458/https://www.aliexpress.com/item/1005002449391401.html"><strong>Motorised Controller</strong></a> with an attached <a href="https://web.archive.org/web/20220518023454/https://www.aliexpress.com/item/32831863881.html"><strong>Stylus</strong></a>.</p>
<p>Or a <a href="https://www.seeedstudio.com/Grove-Servo.html"><strong>Servo Motor</strong></a> wrapped with an <a href="https://youtu.be/mb3zcacDGPc"><strong>Electrostatic Discharge Bag</strong></a>.</p>
<p>Hope it fits inside our Automated Testing Enclosure: <a href="https://www.ikea.com/sg/en/p/ikea-365-food-container-with-lid-rectangular-plastic-s69276794/"><strong>IKEA 365+ 5.2L Food Container</strong></a>‚Ä¶</p>
<p><img src="https://lupyuen.github.io/images/auto2-box.jpg" alt="Our Automated Testing Enclosure: IKEA 365+ 5.2L Food Container" /></p>
<h1 id="upload-test-log"><a href="#upload-test-log">9 Upload Test Log</a></h1>
<p>The lesson we learnt from Alice, Bob and Chow: It‚Äôs super helpful to <strong>preserve the Automated Test Logs</strong> for every NuttX Release!</p>
<ul>
<li><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10"><strong>Automated Test Log for PineDio Stack</strong></a></li>
</ul>
<p>(Especially when collaborating across time zones)</p>
<p><img src="https://lupyuen.github.io/images/auto2-release.jpg" alt="Automated Test Log for PineDio Stack" /></p>
<p><a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-10">(Source)</a></p>
<p>This how we <strong>upload the Automated Test Log</strong> to GitHub Release Notes‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Run the script for Auto Flash and Test for PineDio Stack BL604.
#  Capture the Test Log in /tmp/release.log
script -c remote-bl602/scripts/pinedio.sh /tmp/release.log

#  TODO: Install the GitHub CLI for uploading Release Notes: https://cli.github.com
#  Log in a GitHub Token that has &quot;repo&quot; and &quot;read:org&quot; permissions

#  Optional: Upload the Test Log to the GitHub Release Notes
remote-bl602/scripts/upload.sh</code></pre></div>
<p>The <strong>script</strong> command runs our Automated Testing Script and captures the Automated Test Log into <strong>/tmp/release.log</strong>.</p>
<p>Our Upload Script <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/upload.sh"><strong>upload.sh</strong></a> reads the Automated Test Log and <strong>uploads to GitHub Release Notes</strong>.</p>
<p><em>So the Upload Script needs write access to GitHub Release Notes?</em></p>
<p>Yes our Upload Script calls the <strong>GitHub CLI</strong> to upload the Automated Test Log to GitHub Release Notes‚Ä¶</p>
<ul>
<li><a href="https://cli.github.com"><strong>GitHub CLI</strong></a></li>
</ul>
<p>We need to install the GitHub CLI and log in with a <strong>GitHub Token</strong> that has permission to update the Release Notes‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  TODO: Create a new GitHub Token at 
#  https://github.com/settings/tokens/new
#  Token must have &quot;repo&quot; and &quot;read:org&quot; permissions

#  Log in with the GitHub Token
gh auth login --with-token

#  Verify that GitHub CLI can access GitHub Releases
gh release list --repo lupyuen/nuttx</code></pre></div>
<p><em>What‚Äôs inside our Upload Script?</em></p>
<p>Our Upload Script assumes that the <a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml"><strong>GitHub Actions Workflow</strong></a> has published a <a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml#L93-L100"><strong>GitHub Release</strong></a> with <a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml#L100"><strong>Auto-Generated Release Notes</strong></a>.</p>
<p>The script begins by calling the <strong>GitHub CLI to download</strong> the Auto-Generated Release Notes: <a href="https://github.com/lupyuen/remote-bl602/blob/main/scripts/upload.sh">upload.sh</a></p>
<div class="example-wrap"><pre class="language-bash"><code>#  Assumes the following files are present...
#  /tmp/release.log: Test Log
#  /tmp/release.tag: Release Tag (like pinedio-2022-05-10)

#  Preserve the Auto-Generated GitHub Release Notes.
#  Fetch the current GitHub Release Notes and extract the body text, like:
#  &quot;Merge updates from master by @lupyuen in https://github.com/lupyuen/nuttx/pull/82&quot;
gh release view \
  `cat /tmp/release.tag` \
  --json body \
  --jq &#39;.body&#39; \
  --repo lupyuen/nuttx \
  &gt;/tmp/release.old</code></pre></div>
<p><a href="https://cli.github.com/manual/gh_release_view">(‚Äú<strong>gh release view</strong>‚Äù is explained here)</a></p>
<p>In case the script is run twice, we search for the <strong>Previous Automated Test Log</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Find the position of the Previous Test Log, starting with &quot;```&quot;
cat /tmp/release.old \
  | grep &#39;```&#39; --max-count=1 --byte-offset \
  | sed &#39;s/:.*//g&#39; \
  &gt;/tmp/previous-log.txt
prev=`cat /tmp/previous-log.txt`</code></pre></div>
<p>And we <strong>remove the Previous Test Log</strong>, while retaining the Auto-Generated Release Notes‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  If Previous Test Log exists, discard it
if [ &quot;$prev&quot; != &#39;&#39; ]; then
  cat /tmp/release.old \
    | head --bytes=$prev \
    &gt;&gt;/tmp/release2.log
else
  #  Else copy the entire Release Notes
  cat /tmp/release.old \
    &gt;&gt;/tmp/release2.log
  echo &quot;&quot; &gt;&gt;/tmp/release2.log
fi</code></pre></div>
<p>Just before adding the Automated Test Log, we insert the <strong>Test Status</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Show the Test Status, like &quot;All OK! BL602 has successfully joined the LoRaWAN Network&quot;
grep &quot;^===== &quot; /tmp/release.log \
  | colrm 1 6 \
  &gt;&gt;/tmp/release2.log</code></pre></div>
<p>Then we <strong>embed the Automated Test Log</strong>, taking care of the Special Characters‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Enquote the Test Log without Carriage Return and Terminal Control Characters
#  https://stackoverflow.com/questions/17998978/removing-colors-from-output
echo &#39;```text&#39; &gt;&gt;/tmp/release2.log
cat /tmp/release.log \
  | tr -d &#39;\r&#39; \
  | sed &#39;s/\x1B[@A-Z\\\]^_]\|\x1B\[[0-9:;&lt;=&gt;?]*[-!&quot;#$%&amp;&#39;&quot;&#39;&quot;&#39;()*+,.\/]*[][\\@A-Z^_`a-z{|}~]//g&#39; \
  &gt;&gt;/tmp/release2.log
echo &#39;```&#39; &gt;&gt;/tmp/release2.log</code></pre></div>
<p>Finally we call the <strong>GitHub CLI to upload</strong> the Auto-Generated Release Notes appended with the Automated Test Log‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Upload the Test Log to the GitHub Release Notes
gh release edit \
  `cat /tmp/release.tag` \
  --notes-file /tmp/release2.log \
  --repo lupyuen/nuttx</code></pre></div>
<p><a href="https://cli.github.com/manual/gh_release_edit">(‚Äú<strong>gh release edit</strong>‚Äù is explained here)</a></p>
<p>That‚Äôs it for uploading the Automated Test Log to GitHub!</p>
<p><img src="https://lupyuen.github.io/images/auto2-connect.jpg" alt="PineDio Stack BL604 (top) and PineCone BL602 (bottom) connected to Single-Board Computer for Automated Testing" /></p>
<p><em>PineDio Stack BL604 (top) and PineCone BL602 (bottom) connected to Single-Board Computer for Automated Testing</em></p>
<h1 id="merge-updates-from-nuttx"><a href="#merge-updates-from-nuttx">10 Merge Updates From NuttX</a></h1>
<p><em>Is PineDio Stack fully supported by NuttX Mainline?</em></p>
<p>Not yet. Our fork of NuttX for PineDio Stack has <strong>Experimental Features</strong> that aren‚Äôt ready to be upstreamed into <a href="https://github.com/apache/nuttx"><strong>NuttX Mainline</strong></a>‚Ä¶</p>
<ul>
<li>
<p><a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/expander"><strong>GPIO Expander</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/touch"><strong>CST816S Touch Panel Driver</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/lorawan3"><strong>LoRa and LoRaWAN Libraries</strong></a></p>
</li>
</ul>
<p>Thus the onus is on us to <strong>pull the updates regularly</strong> from NuttX Mainline and make sure they work on PineDio Stack.</p>
<p><em>So PineDio Stack might not have the latest features from NuttX Mainline?</em></p>
<p>We‚Äôre merging updates from NuttX Mainline into the PineDio Stack repo roughly <strong>every 2 weeks</strong>. (Depends on my writing mood)</p>
<p>All NuttX Updates are tested on <strong>PineCone BL602</strong> first, then merged and tested on <strong>PineDio Stack BL604</strong>. (Because PineCone is way more popular than PineDio Stack right now)</p>
<p>That‚Äôs why we need the <strong>complicated setup</strong> for Automated Testing with PineCone and PineDio Stack. (Pic above)</p>
<p><a href="https://lupyuen.github.io/articles/auto2?23#appendix-select-usb-device">(More about the USB Ports for PineCone and PineDio Stack)</a></p>
<p><em>Which means we have 2 branches of NuttX: BL602 and BL604?</em></p>
<p>Yep. We‚Äôre now testing and maintaining two <strong>Stable Branches</strong> of NuttX for public consumption on BL602 and BL604‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/lupyuen/nuttx"><strong>PineCone (Release) Branch</strong></a> for PineCone BL602</p>
</li>
<li>
<p><a href="https://github.com/lupyuen/nuttx/tree/pinedio"><strong>PineDio Branch</strong></a> for PineDio Stack BL604</p>
</li>
</ul>
<p>(Same for NuttX Apps)</p>
<p><em>How do we keep NuttX Mainline in sync with PineCone and PineDio Stack?</em></p>
<p>Very carefully! And with lots of <strong>Automation</strong>. (GitHub Actions and Automated Testing)</p>
<p>Let‚Äôs watch how the <strong>updates from NuttX Mainline</strong> get merged into PineCone and PineDio Stack‚Ä¶</p>
<ul>
<li>NuttX Mainline ‚Üí PineCone Branch ‚Üí PineDio Branch</li>
</ul>
<p>And how <strong>updates from PineDio Stack</strong> get merged back into PineCone‚Ä¶</p>
<ul>
<li>PineDio Branch ‚Üí PineCone Branch</li>
</ul>
<p>Ultimately the PineCone and PineDio Branches will have the <strong>exact same code</strong>, tested OK on PineCone and PineDio Stack. (With different build settings)</p>
<p><img src="https://lupyuen.github.io/images/auto2-merge1.jpg" alt="Merge Updates From NuttX to PineDio Stack" /></p>
<h2 id="pinecone-to-pinedio-stack"><a href="#pinecone-to-pinedio-stack">10.1 PineCone to PineDio Stack</a></h2>
<p>The pic above shows how we <strong>merge the updates from NuttX Mainline</strong>  into the PineCone and PineDio Branches‚Ä¶</p>
<ol>
<li>
<p>Every day we build <strong>Mainline NuttX (Upstream)</strong> every day with GitHub Actions. <a href="https://lupyuen.github.io/articles/auto#appendix-build-nuttx-with-github-actions">(See this)</a></p>
<p>Also daily we run our <strong>Automated Testing</strong> to verify that the Upstream Build boots OK on PineCone BL602. <a href="https://github.com/lupyuen/nuttx/releases/tag/upstream-2022-05-22">(Like this)</a></p>
<p>(Upstream Build doesn‚Äôt include the LoRaWAN Stack)</p>
</li>
<li>
<p>Every 2 weeks (roughly), we merge Upstream NuttX into our <a href="https://github.com/lupyuen/nuttx/tree/downstream"><strong>Downstream Branch</strong></a>. <a href="https://github.com/lupyuen/nuttx/commit/70decce2bf2754e331648c24bcfbb7e377376f52">(Like this)</a></p>
<p>GitHub Actions triggers a build for the <strong>Downstream Branch</strong>. <a href="https://github.com/lupyuen/nuttx/blob/downstream/.github/workflows/bl602-downstream.yml#L7-L272">(See this)</a></p>
<p>Our <strong>Automated Testing</strong> verifies the Downstream Build with LoRaWAN on PineCone BL602. <a href="https://github.com/lupyuen/nuttx/releases/tag/downstream-2022-05-24">(Like this)</a></p>
</li>
<li>
<p>If the Downstream Branch has tested OK, we merge the Downstream Branch to the <strong>PineCone (Release) Branch</strong>. <a href="https://github.com/lupyuen/nuttx/pull/87">(Like this)</a></p>
<p>GitHub Actions triggers a build for the <strong>PineCone Branch</strong>. <a href="https://github.com/lupyuen/nuttx/blob/master/.github/workflows/bl602-commit.yml#L7-L272">(See this)</a></p>
<p>Our <strong>Automated Testing</strong> verifies the PineCone (Release) Build with LoRaWAN on PineCone BL602. <a href="https://github.com/lupyuen/nuttx/releases/tag/release-2022-05-24">(Like this)</a></p>
</li>
<li>
<p>If the PineCone Branch has tested OK, we <strong>merge the PineCone (Release) Branch</strong> to the PineDio Branch. <a href="https://github.com/lupyuen/nuttx/pull/88">(Like this)</a></p>
<p>GitHub Actions triggers a build for the <strong>PineDio Branch</strong>. <a href="https://github.com/lupyuen/nuttx/blob/master/.github/workflows/bl602-commit.yml#L7-L272">(See this)</a></p>
<p>We run our <strong>Automated Testing</strong> on PineDio Stack to verify that the PineDio Build works OK with LoRaWAN and Touch Panel. <a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-24">(Like this)</a></p>
</li>
</ol>
<p>That‚Äôs what we do today to keep PineCone and PineDio Branches in sync with NuttX Mainline.</p>
<p>(We do the same for <a href="https://github.com/lupyuen/nuttx-apps"><strong>NuttX Apps</strong></a>, just before every merge of NuttX OS)</p>
<p><img src="https://lupyuen.github.io/images/auto2-merge2.jpg" alt="Merge Updates From PineDio Stack to PineCone" /></p>
<h2 id="pinedio-stack-to-pinecone"><a href="#pinedio-stack-to-pinecone">10.2 PineDio Stack to PineCone</a></h2>
<p>Now Reverse Uno: The pic above shows how we <strong>merge the updates from PineDio Branch</strong> back to PineCone Branch (like when we add a new feature for PineDio Stack)‚Ä¶</p>
<ol>
<li>
<p>When we commit a change to the <strong>PineDio Branch</strong>, GitHub Actions triggers a build of the branch. <a href="https://github.com/lupyuen/nuttx/blob/pinedio/.github/workflows/pinedio.yml#L7-L77">(See this)</a></p>
<p>We run our <strong>Automated Testing</strong> on PineDio Stack to verify that the build works OK with LoRaWAN and Touch Panel. <a href="https://github.com/lupyuen/nuttx/releases/tag/pinedio-2022-05-23">(Like this)</a></p>
</li>
<li>
<p>If the PineDio Branch has tested OK, we merge the PineDio Branch to the <strong>PineCone (Release) Branch</strong>. <a href="https://github.com/lupyuen/nuttx/pull/85">(Like this)</a></p>
<p>GitHub Actions triggers a build for the <strong>PineCone Branch</strong>. <a href="https://github.com/lupyuen/nuttx/blob/master/.github/workflows/bl602-commit.yml#L7-L272">(See this)</a></p>
<p>Our <strong>Automated Testing</strong> verifies the PineCone (Release) Build with LoRaWAN on PineCone BL602. <a href="https://github.com/lupyuen/nuttx/releases/tag/release-2022-05-23">(Like this)</a></p>
</li>
<li>
<p>If the PineCone Branch has tested OK, we merge the PineCone (Release) Branch to the <strong>Downstream Branch</strong>. <a href="https://github.com/lupyuen/nuttx/pull/86">(Like this)</a></p>
<p>GitHub Actions triggers a build for the <strong>Downstream Branch</strong>. <a href="https://github.com/lupyuen/nuttx/blob/downstream/.github/workflows/bl602-downstream.yml#L7-L272">(See this)</a></p>
<p>For one last time, we run our <strong>Automated Testing</strong> on PineCone BL602 to verify that the Downstream Build works OK with LoRaWAN. <a href="https://github.com/lupyuen/nuttx/releases/tag/downstream-2022-05-23">(Like this)</a></p>
<p>Downstream Branch is now ready to <strong>accept new updates</strong> from NuttX Mainline. (Within the next 2 weeks)</p>
</li>
</ol>
<p>That‚Äôs what we do today to sync the PineDio and PineCone Branches.</p>
<p>(We do the same for <a href="https://github.com/lupyuen/nuttx-apps"><strong>NuttX Apps</strong></a>, just before every merge of NuttX OS)</p>
<p><img src="https://lupyuen.github.io/images/expander-title.jpg" alt="GPIO Expander for PineDio Stack" /></p>
<p><a href="https://lupyuen.github.io/articles/expander"><em>GPIO Expander for PineDio Stack</em></a></p>
<h2 id="merge-conflicts"><a href="#merge-conflicts">10.3 Merge Conflicts</a></h2>
<p><em>Hol‚Äô up‚Ä¶ PineCone Branch merges updates from NuttX Mainline AND PineDio Branch? Won‚Äôt they clash?</em></p>
<p>Yep maintaining the PineCone (Release) Branch is a delicate process‚Ä¶</p>
<p>We need to assure <strong>peaceful coexistence</strong> of the features from both NuttX Mainline and PineDio Stack.</p>
<p>Suppose NuttX Mainline implements a new feature: <a href="https://lupyuen.github.io/articles/pinedio2#spi-direct-memory-access"><strong>SPI DMA for BL602</strong></a>‚Ä¶</p>
<ul>
<li>
<p>We need to merge the SPI DMA changes into <strong>SPI Driver</strong> for the PineCone Branch: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c"><strong>bl602_spi.c</strong></a></p>
</li>
<li>
<p>But recall that the SPI Driver for the PineCone Branch also includes the <a href="https://lupyuen.github.io/articles/pinedio2#spi-device-table"><strong>SPI Device Table</strong></a> for PineDio Stack: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L1335-L1473"><strong>bl602_spi.c</strong></a></p>
</li>
<li>
<p>Thus we need to <strong>merge the SPI DMA</strong> changes very carefully into the SPI Driver. (Possibly changing the SPI Device Table too)</p>
</li>
<li>
<p>To make the merging easier, we have <strong>demarcated the SPI Device Table</strong> with the <strong>PINEDIO_STACK_BL604</strong> macro: <a href="https://github.com/lupyuen/nuttx/blob/master/arch/risc-v/src/bl602/bl602_spi.c#L1335-L1473"><strong>bl602_spi.c</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  If this is PineDio Stack...
#ifdef PINEDIO_STACK_BL604
//  Code for SPI Device Table goes here...
#endif  //  PINEDIO_STACK_BL604</code></pre></div></li>
<li>
<p><strong>PINEDIO_STACK_BL604</strong> is defined below, should probably be improved: <a href="https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/include/board.h#L147-L151"><strong>board.h</strong></a></p>
<div class="example-wrap"><pre class="language-c"><code>//  Identify as PineDio Stack if both ST7789 and CST816S are present
#if defined(CONFIG_LCD_ST7789) &amp;&amp; defined(CONFIG_INPUT_CST816S)
#define PINEDIO_STACK_BL604
#endif  //  CONFIG_LCD_ST7789 &amp;&amp; CONFIG_INPUT_CST816S</code></pre></div></li>
</ul>
<p><em>Is there a cleaner way to merge updates from NuttX Mainline?</em></p>
<p>The cleaner way to merge updates from NuttX Mainline might be to <strong>split the NuttX Drivers</strong> for PineCone and PineDio Stack.</p>
<p>We did this for the <strong>NuttX GPIO Driver</strong>‚Ä¶</p>
<ul>
<li>
<p>PineCone BL602 uses the <a href="https://lupyuen.github.io/articles/expander#bl602-evb-limitations"><strong>BL602 EVB GPIO Driver</strong></a></p>
</li>
<li>
<p>PineDio Stack BL604 uses the <a href="https://lupyuen.github.io/articles/expander"><strong>GPIO Expander Driver</strong></a></p>
</li>
</ul>
<p>We select the GPIO Driver through <a href="https://lupyuen.github.io/articles/expander#load-gpio-expander"><strong>Kconfig and Menuconfig</strong></a>. Or through the <strong>NuttX Build Configuration</strong>‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Configure build for PineCone BL602
./tools/configure.sh bl602evb:pinecone

# Configure build for PineDio Stack BL604
./tools/configure.sh bl602evb:pinedio</code></pre></div>
<p><a href="https://github.com/lupyuen/nuttx/blob/master/boards/risc-v/bl602/bl602evb/configs/pinecone/defconfig">(See the PineCone config)</a></p>
<p><a href="https://github.com/lupyuen/nuttx/blob/pinedio/boards/risc-v/bl602/bl602evb/configs/pinedio/defconfig">(See the PineDio Stack config)</a></p>
<p><a href="https://gist.github.com/lupyuen/a6396ccbe9427087e73e5f29bf570eda">(How we resolve Merge Conflicts between NuttX Mainline and our Downstream Branch)</a></p>
<p><img src="https://lupyuen.github.io/images/pinedio2-inside5.jpg" alt="Inside PineDio Stack BL604" /></p>
<p><a href="https://lupyuen.github.io/articles/pinedio2"><em>Inside PineDio Stack BL604</em></a></p>
<h1 id="why-nuttx"><a href="#why-nuttx">11 Why NuttX</a></h1>
<p><em>Wow looks like we‚Äôre doing Everything Everywhere All at Once / Daily / Fortnightly for NuttX on PineDio Stack! Why are we doing all this?</em></p>
<p>PineDio Stack is the <strong>most complex IoT gadget</strong> I‚Äôve seen‚Ä¶ <a href="https://lupyuen.github.io/articles/pinedio2#appendix-gpio-assignment"><strong>All 23 GPIOs</strong></a> in use, some multiplexed!</p>
<p>Thus we need a <strong>Common Framework</strong> to manage the complexity. And the framework shall be easily adopted by Alice, Bob, Chow and other devs worldwide to <strong>create Apps and Drivers</strong> for PineDio Stack.</p>
<p>The Common Framework that we have selected is <strong>Apache NuttX RTOS!</strong></p>
<p>NuttX <strong>looks like Linux</strong> (shrunk to a tiny footprint), so hopefully it appeals to coders familiar with Linux.</p>
<p><em>Isn‚Äôt it difficult to coordinate our devs everywhere?</em></p>
<p>That‚Äôs why we have <strong>automated everything</strong> as much as possible, from Automated Builds (GitHub Actions) to Automated Testing.</p>
<p>Updates are synced from <strong>NuttX Mainline</strong> every 2 weeks, so PineDio Stack Devs will experience the same features as other NuttX Devs worldwide.</p>
<p>With our grand plan, no dev gets left behind across the time zones!</p>
<p><em>Are there other options?</em></p>
<p>NuttX is the only <strong>Community-Supported RTOS</strong> for BL602 and BL604.</p>
<p>If community support is not required, we could consider these alternatives‚Ä¶</p>
<ul>
<li>
<p><a href="https://github.com/bouffalolab/bl_iot_sdk"><strong>BL IoT SDK</strong></a></p>
<p>(Supports WiFi and is based on FreeRTOS)</p>
</li>
<li>
<p><a href="https://github.com/bouffalolab/bl_mcu_sdk"><strong>BL MCU SDK</strong></a></p>
<p>(Doesn‚Äôt support WiFi, also based on FreeRTOS)</p>
</li>
</ul>
<p>But we might face serious challenges creating complex firmware for PineDio Stack.</p>
<h1 id="whats-next"><a href="#whats-next">12 What‚Äôs Next</a></h1>
<p>I hope Alice, Bob and Chow will have a great time creating NuttX Drivers and Apps on PineDio Stack‚Ä¶ And you too!</p>
<p>Lemme know what you‚Äôre building with PineDio Stack!</p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://www.reddit.com/r/RISCV/comments/uv2kzb/mostly_automated_testing_of_apache_nuttx_rtos_on/"><strong>Discuss this article on Reddit</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/articles/book"><strong>Read ‚ÄúThe RISC-V BL602 / BL604 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.github.io/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/auto2.md"><strong><code>lupyuen.github.io/src/auto2.md</code></strong></a></p>
<h1 id="notes"><a href="#notes">13 Notes</a></h1>
<ol>
<li>
<p>This article is the expanded version of <a href="https://twitter.com/MisterTechBlog/status/1519541046803271682"><strong>this Twitter Thread</strong></a></p>
</li>
<li>
<p>Automated Testing of <strong>PineCone BL602</strong> is explained here‚Ä¶</p>
<p><a href="https://lupyuen.github.io/articles/auto"><strong>‚ÄúAuto Flash and Test NuttX on RISC-V BL602‚Äù</strong></a></p>
</li>
<li>
<p>The ST7789 Display on our Spare PineDio Stack for Automated Testing is faulty. How will we know if the <strong>ST7789 Driver is working?</strong></p>
<p>Right now I‚Äôm manually running the LVGL Test App on my Main PineDio Stack (with a functioning display), to check if the ST7789 Driver is OK.</p>
<p>The test results are manually recorded in the Pull Request. <a href="https://github.com/lupyuen/nuttx/pull/88">(See this)</a></p>
</li>
<li>
<p>What if the Kconfig files in NuttX Mainline get updated? How do we sync the updates to the <strong>PineDio Stack Build Config</strong>?</p>
<p>Here‚Äôs how we sync the updates to the PineDio Stack Build Config, right after merging NuttX Mainline with PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Configure build for PineDio Stack BL604
./tools/configure.sh bl602evb:pinedio

# Copy the updated Build Config to our repo
cp .config boards/risc-v/bl602/bl602evb/configs/pinedio/defconfig

# So the next time we configure the build,
# we will use the updated Build Config...
# ./tools/configure.sh bl602evb:pinedio</code></pre></div></li>
</ol>
<p><img src="https://lupyuen.github.io/images/auto2-connect.jpg" alt="PineDio Stack BL604 (top) and PineCone BL602 (bottom) connected to Single-Board Computer for Automated Testing" /></p>
<p><em>PineDio Stack BL604 (top) and PineCone BL602 (bottom) connected to Single-Board Computer for Automated Testing</em></p>
<h1 id="appendix-select-usb-device"><a href="#appendix-select-usb-device">14 Appendix: Select USB Device</a></h1>
<p>When we connect both PineDio Stack BL604 and PineCone BL602 to our Single-Board Computer (pic above), we‚Äôll see two USB Devices: <strong>/dev/ttyUSB0</strong> and <strong>/dev/ttyUSB1</strong></p>
<p><em>How will we know which USB Device is for PineDio Stack and PineCone?</em></p>
<p>Do this‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code># Show /dev/ttyUSB0
lsusb -v -s 1:3 2&gt;&amp;1 | grep bcdDevice | colrm 1 23

# Show /dev/ttyUSB1
lsusb -v -s 1:4 2&gt;&amp;1 | grep bcdDevice | colrm 1 23

# Output for Pinedio Stack BL604:
# 2.64
# See https://gist.github.com/lupyuen/dc8c482f2b31b25d329cd93dc44f0044

# Output for PineCone BL602:
# 2.63
# See https://gist.github.com/lupyuen/3ba0dc0789fd282bbfcf9dd5c3ff8908</code></pre></div>
<p>Here‚Äôs how we <strong>override the Default USB Device</strong> for PineDio Stack‚Ä¶</p>
<div class="example-wrap"><pre class="language-bash"><code>#  Tell the script to use /dev/ttyUSB1
#  (Default is /dev/ttyUSB0)
export USB_DEVICE=/dev/ttyUSB1

#  Auto flash and test PineDio Stack BL604 at /dev/ttyUSB1
remote-bl602/scripts/pinedio.sh</code></pre></div>
<p><strong>TODO:</strong> We should automate this selection of USB Device in our Automated Testing Script.</p>

    
</body>
</html>